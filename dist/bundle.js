/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/cytoscape-dagre/cytoscape-dagre.js":
/*!*********************************************************!*\
  !*** ./node_modules/cytoscape-dagre/cytoscape-dagre.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! dagre */ "./node_modules/dagre/index.js"));
	else {}
})(this, function(__WEBPACK_EXTERNAL_MODULE__4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var impl = __webpack_require__(1); // registers the extension on a cytoscape lib ref


var register = function register(cytoscape) {
  if (!cytoscape) {
    return;
  } // can't register if cytoscape unspecified


  cytoscape('layout', 'dagre', impl); // register with cytoscape.js
};

if (typeof cytoscape !== 'undefined') {
  // expose to global cytoscape (i.e. window.cytoscape)
  register(cytoscape);
}

module.exports = register;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isFunction = function isFunction(o) {
  return typeof o === 'function';
};

var defaults = __webpack_require__(2);

var assign = __webpack_require__(3);

var dagre = __webpack_require__(4); // constructor
// options : object containing layout options


function DagreLayout(options) {
  this.options = assign({}, defaults, options);
} // runs the layout


DagreLayout.prototype.run = function () {
  var options = this.options;
  var layout = this;
  var cy = options.cy; // cy is automatically populated for us in the constructor

  var eles = options.eles;

  var getVal = function getVal(ele, val) {
    return isFunction(val) ? val.apply(ele, [ele]) : val;
  };

  var bb = options.boundingBox || {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  };

  if (bb.x2 === undefined) {
    bb.x2 = bb.x1 + bb.w;
  }

  if (bb.w === undefined) {
    bb.w = bb.x2 - bb.x1;
  }

  if (bb.y2 === undefined) {
    bb.y2 = bb.y1 + bb.h;
  }

  if (bb.h === undefined) {
    bb.h = bb.y2 - bb.y1;
  }

  var g = new dagre.graphlib.Graph({
    multigraph: true,
    compound: true
  });
  var gObj = {};

  var setGObj = function setGObj(name, val) {
    if (val != null) {
      gObj[name] = val;
    }
  };

  setGObj('nodesep', options.nodeSep);
  setGObj('edgesep', options.edgeSep);
  setGObj('ranksep', options.rankSep);
  setGObj('rankdir', options.rankDir);
  setGObj('align', options.align);
  setGObj('ranker', options.ranker);
  setGObj('acyclicer', options.acyclicer);
  g.setGraph(gObj);
  g.setDefaultEdgeLabel(function () {
    return {};
  });
  g.setDefaultNodeLabel(function () {
    return {};
  }); // add nodes to dagre

  var nodes = eles.nodes();

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var nbb = node.layoutDimensions(options);
    g.setNode(node.id(), {
      width: nbb.w,
      height: nbb.h,
      name: node.id()
    }); // console.log( g.node(node.id()) );
  } // set compound parents


  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];

    if (_node.isChild()) {
      g.setParent(_node.id(), _node.parent().id());
    }
  } // add edges to dagre


  var edges = eles.edges().stdFilter(function (edge) {
    return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes
  });

  for (var _i2 = 0; _i2 < edges.length; _i2++) {
    var edge = edges[_i2];
    g.setEdge(edge.source().id(), edge.target().id(), {
      minlen: getVal(edge, options.minLen),
      weight: getVal(edge, options.edgeWeight),
      name: edge.id()
    }, edge.id()); // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );
  }

  dagre.layout(g);
  var gNodeIds = g.nodes();

  for (var _i3 = 0; _i3 < gNodeIds.length; _i3++) {
    var id = gNodeIds[_i3];
    var n = g.node(id);
    cy.getElementById(id).scratch().dagre = n;
  }

  var dagreBB;

  if (options.boundingBox) {
    dagreBB = {
      x1: Infinity,
      x2: -Infinity,
      y1: Infinity,
      y2: -Infinity
    };
    nodes.forEach(function (node) {
      var dModel = node.scratch().dagre;
      dagreBB.x1 = Math.min(dagreBB.x1, dModel.x);
      dagreBB.x2 = Math.max(dagreBB.x2, dModel.x);
      dagreBB.y1 = Math.min(dagreBB.y1, dModel.y);
      dagreBB.y2 = Math.max(dagreBB.y2, dModel.y);
    });
    dagreBB.w = dagreBB.x2 - dagreBB.x1;
    dagreBB.h = dagreBB.y2 - dagreBB.y1;
  } else {
    dagreBB = bb;
  }

  var constrainPos = function constrainPos(p) {
    if (options.boundingBox) {
      var xPct = dagreBB.w === 0 ? 0 : (p.x - dagreBB.x1) / dagreBB.w;
      var yPct = dagreBB.h === 0 ? 0 : (p.y - dagreBB.y1) / dagreBB.h;
      return {
        x: bb.x1 + xPct * bb.w,
        y: bb.y1 + yPct * bb.h
      };
    } else {
      return p;
    }
  };

  nodes.layoutPositions(layout, options, function (ele) {
    ele = _typeof(ele) === "object" ? ele : this;
    var dModel = ele.scratch().dagre;
    return constrainPos({
      x: dModel.x,
      y: dModel.y
    });
  });
  return this; // chaining
};

module.exports = DagreLayout;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var defaults = {
  // dagre algo options, uses default value on undefined
  nodeSep: undefined,
  // the separation between adjacent nodes in the same rank
  edgeSep: undefined,
  // the separation between adjacent edges in the same rank
  rankSep: undefined,
  // the separation between adjacent nodes in the same rank
  rankDir: undefined,
  // alignment for rank nodes. Can be 'UL', 'UR', 'DL', or 'DR', where U = up, D = down, L = left, and R = right
  align: undefined,
  // 'TB' for top to bottom flow, 'LR' for left to right,
  ranker: undefined,
  // Type of algorithm to assigns a rank to each node in the input graph.
  // Possible values: network-simplex, tight-tree or longest-path
  minLen: function minLen(edge) {
    return 1;
  },
  // number of ranks to keep between the source and target of the edge
  edgeWeight: function edgeWeight(edge) {
    return 1;
  },
  // higher weight edges are generally made shorter and straighter than lower weight edges
  // general layout options
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  nodeDimensionsIncludeLabels: false,
  // whether labels should be included in determining the space used by a node
  animate: false,
  // whether to transition the node positions
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // whether to animate specific nodes when animation is on; non-animated nodes immediately go to their final positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  transform: function transform(node, pos) {
    return pos;
  },
  // a function that applies a transform to the final node position
  ready: function ready() {},
  // on layoutready
  stop: function stop() {} // on layoutstop

};
module.exports = defaults;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// Simple, internal Object.assign() polyfill for options objects etc.
module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  for (var _len = arguments.length, srcs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    srcs[_key - 1] = arguments[_key];
  }

  srcs.forEach(function (src) {
    Object.keys(src).forEach(function (k) {
      return tgt[k] = src[k];
    });
  });
  return tgt;
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4__;

/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/cytoscape-euler/cytoscape-euler.js":
/*!*********************************************************!*\
  !*** ./node_modules/cytoscape-euler/cytoscape-euler.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    srcs[_key - 1] = arguments[_key];
  }

  srcs.forEach(function (src) {
    Object.keys(src).forEach(function (k) {
      return tgt[k] = src[k];
    });
  });

  return tgt;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(0);

var defaults = Object.freeze({
  source: null,
  target: null,
  length: 80,
  coeff: 0.0002,
  weight: 1
});

function makeSpring(spring) {
  return assign({}, defaults, spring);
}

function applySpring(spring) {
  var body1 = spring.source,
      body2 = spring.target,
      length = spring.length < 0 ? defaults.length : spring.length,
      dx = body2.pos.x - body1.pos.x,
      dy = body2.pos.y - body1.pos.y,
      r = Math.sqrt(dx * dx + dy * dy);

  if (r === 0) {
    dx = (Math.random() - 0.5) / 50;
    dy = (Math.random() - 0.5) / 50;
    r = Math.sqrt(dx * dx + dy * dy);
  }

  var d = r - length;
  var coeff = (!spring.coeff || spring.coeff < 0 ? defaults.springCoeff : spring.coeff) * d / r * spring.weight;

  body1.force.x += coeff * dx;
  body1.force.y += coeff * dy;

  body2.force.x -= coeff * dx;
  body2.force.y -= coeff * dy;
}

module.exports = { makeSpring: makeSpring, applySpring: applySpring };

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
The implementation of the Euler layout algorithm
*/

var Layout = __webpack_require__(13);
var assign = __webpack_require__(0);
var defaults = __webpack_require__(4);

var _require = __webpack_require__(10),
    _tick = _require.tick;

var _require2 = __webpack_require__(7),
    makeQuadtree = _require2.makeQuadtree;

var _require3 = __webpack_require__(3),
    makeBody = _require3.makeBody;

var _require4 = __webpack_require__(1),
    makeSpring = _require4.makeSpring;

var isFn = function isFn(fn) {
  return typeof fn === 'function';
};
var isParent = function isParent(n) {
  return n.isParent();
};
var notIsParent = function notIsParent(n) {
  return !isParent(n);
};
var isLocked = function isLocked(n) {
  return n.locked();
};
var notIsLocked = function notIsLocked(n) {
  return !isLocked(n);
};
var isParentEdge = function isParentEdge(e) {
  return isParent(e.source()) || isParent(e.target());
};
var notIsParentEdge = function notIsParentEdge(e) {
  return !isParentEdge(e);
};
var getBody = function getBody(n) {
  return n.scratch('euler').body;
};
var getNonParentDescendants = function getNonParentDescendants(n) {
  return isParent(n) ? n.descendants().filter(notIsParent) : n;
};

var getScratch = function getScratch(el) {
  var scratch = el.scratch('euler');

  if (!scratch) {
    scratch = {};

    el.scratch('euler', scratch);
  }

  return scratch;
};

var optFn = function optFn(opt, ele) {
  if (isFn(opt)) {
    return opt(ele);
  } else {
    return opt;
  }
};

var Euler = function (_Layout) {
  _inherits(Euler, _Layout);

  function Euler(options) {
    _classCallCheck(this, Euler);

    return _possibleConstructorReturn(this, (Euler.__proto__ || Object.getPrototypeOf(Euler)).call(this, assign({}, defaults, options)));
  }

  _createClass(Euler, [{
    key: 'prerun',
    value: function prerun(state) {
      var s = state;

      s.quadtree = makeQuadtree();

      var bodies = s.bodies = [];

      // regular nodes
      s.nodes.filter(function (n) {
        return notIsParent(n);
      }).forEach(function (n) {
        var scratch = getScratch(n);

        var body = makeBody({
          pos: { x: scratch.x, y: scratch.y },
          mass: optFn(s.mass, n),
          locked: scratch.locked
        });

        body._cyNode = n;

        scratch.body = body;

        body._scratch = scratch;

        bodies.push(body);
      });

      var springs = s.springs = [];

      // regular edge springs
      s.edges.filter(notIsParentEdge).forEach(function (e) {
        var spring = makeSpring({
          source: getBody(e.source()),
          target: getBody(e.target()),
          length: optFn(s.springLength, e),
          coeff: optFn(s.springCoeff, e)
        });

        spring._cyEdge = e;

        var scratch = getScratch(e);

        spring._scratch = scratch;

        scratch.spring = spring;

        springs.push(spring);
      });

      // compound edge springs
      s.edges.filter(isParentEdge).forEach(function (e) {
        var sources = getNonParentDescendants(e.source());
        var targets = getNonParentDescendants(e.target());

        // just add one spring for perf
        sources = [sources[0]];
        targets = [targets[0]];

        sources.forEach(function (src) {
          targets.forEach(function (tgt) {
            springs.push(makeSpring({
              source: getBody(src),
              target: getBody(tgt),
              length: optFn(s.springLength, e),
              coeff: optFn(s.springCoeff, e)
            }));
          });
        });
      });
    }
  }, {
    key: 'tick',
    value: function tick(state) {
      var movement = _tick(state);

      var isDone = movement <= state.movementThreshold;

      return isDone;
    }
  }]);

  return Euler;
}(Layout);

module.exports = Euler;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = Object.freeze({
  pos: { x: 0, y: 0 },
  prevPos: { x: 0, y: 0 },
  force: { x: 0, y: 0 },
  velocity: { x: 0, y: 0 },
  mass: 1
});

var copyVec = function copyVec(v) {
  return { x: v.x, y: v.y };
};
var getValue = function getValue(val, def) {
  return val != null ? val : def;
};
var getVec = function getVec(vec, def) {
  return copyVec(getValue(vec, def));
};

function makeBody(opts) {
  var b = {};

  b.pos = getVec(opts.pos, defaults.pos);
  b.prevPos = getVec(opts.prevPos, b.pos);
  b.force = getVec(opts.force, defaults.force);
  b.velocity = getVec(opts.velocity, defaults.velocity);
  b.mass = opts.mass != null ? opts.mass : defaults.mass;
  b.locked = opts.locked;

  return b;
}

module.exports = { makeBody: makeBody };

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = Object.freeze({
  // The ideal legth of a spring
  // - This acts as a hint for the edge length
  // - The edge length can be longer or shorter if the forces are set to extreme values
  springLength: function springLength(edge) {
    return 80;
  },

  // Hooke's law coefficient
  // - The value ranges on [0, 1]
  // - Lower values give looser springs
  // - Higher values give tighter springs
  springCoeff: function springCoeff(edge) {
    return 0.0008;
  },

  // The mass of the node in the physics simulation
  // - The mass affects the gravity node repulsion/attraction
  mass: function mass(node) {
    return 4;
  },

  // Coulomb's law coefficient
  // - Makes the nodes repel each other for negative values
  // - Makes the nodes attract each other for positive values
  gravity: -1.2,

  // A force that pulls nodes towards the origin (0, 0)
  // Higher values keep the components less spread out
  pull: 0.001,

  // Theta coefficient from Barnes-Hut simulation
  // - Value ranges on [0, 1]
  // - Performance is better with smaller values
  // - Very small values may not create enough force to give a good result
  theta: 0.666,

  // Friction / drag coefficient to make the system stabilise over time
  dragCoeff: 0.02,

  // When the total of the squared position deltas is less than this value, the simulation ends
  movementThreshold: 1,

  // The amount of time passed per tick
  // - Larger values result in faster runtimes but might spread things out too far
  // - Smaller values produce more accurate results
  timeStep: 20
});

module.exports = defaults;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultCoeff = 0.02;

function applyDrag(body, manualDragCoeff) {
  var dragCoeff = void 0;

  if (manualDragCoeff != null) {
    dragCoeff = manualDragCoeff;
  } else if (body.dragCoeff != null) {
    dragCoeff = body.dragCoeff;
  } else {
    dragCoeff = defaultCoeff;
  }

  body.force.x -= dragCoeff * body.velocity.x;
  body.force.y -= dragCoeff * body.velocity.y;
}

module.exports = { applyDrag: applyDrag };

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// use euler method for force integration http://en.wikipedia.org/wiki/Euler_method
// return sum of squared position deltas
function integrate(bodies, timeStep) {
  var dx = 0,
      tx = 0,
      dy = 0,
      ty = 0,
      i,
      max = bodies.length;

  if (max === 0) {
    return 0;
  }

  for (i = 0; i < max; ++i) {
    var body = bodies[i],
        coeff = timeStep / body.mass;

    if (body.grabbed) {
      continue;
    }

    if (body.locked) {
      body.velocity.x = 0;
      body.velocity.y = 0;
    } else {
      body.velocity.x += coeff * body.force.x;
      body.velocity.y += coeff * body.force.y;
    }

    var vx = body.velocity.x,
        vy = body.velocity.y,
        v = Math.sqrt(vx * vx + vy * vy);

    if (v > 1) {
      body.velocity.x = vx / v;
      body.velocity.y = vy / v;
    }

    dx = timeStep * body.velocity.x;
    dy = timeStep * body.velocity.y;

    body.pos.x += dx;
    body.pos.y += dy;

    tx += Math.abs(dx);ty += Math.abs(dy);
  }

  return (tx * tx + ty * ty) / max;
}

module.exports = { integrate: integrate };

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// impl of barnes hut
// http://www.eecs.berkeley.edu/~demmel/cs267/lecture26/lecture26.html
// http://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation

var Node = __webpack_require__(9);
var InsertStack = __webpack_require__(8);

var resetVec = function resetVec(v) {
  v.x = 0;v.y = 0;
};

var isSamePosition = function isSamePosition(p1, p2) {
  var threshold = 1e-8;
  var dx = Math.abs(p1.x - p2.x);
  var dy = Math.abs(p1.y - p2.y);

  return dx < threshold && dy < threshold;
};

function makeQuadtree() {
  var updateQueue = [],
      insertStack = new InsertStack(),
      nodesCache = [],
      currentInCache = 0,
      root = newNode();

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
      node.quad0 = null;
      node.quad1 = null;
      node.quad2 = null;
      node.quad3 = null;
      node.body = null;
      node.mass = node.massX = node.massY = 0;
      node.left = node.right = node.top = node.bottom = 0;
    } else {
      node = new Node();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody, gravity, theta, pull) {
    var queue = updateQueue,
        v = void 0,
        dx = void 0,
        dy = void 0,
        r = void 0,
        fx = 0,
        fy = 0,
        queueLength = 1,
        shiftIdx = 0,
        pushIdx = 1;

    queue[0] = root;

    resetVec(sourceBody.force);

    var px = -sourceBody.pos.x;
    var py = -sourceBody.pos.y;
    var pr = Math.sqrt(px * px + py * py);
    var pv = sourceBody.mass * pull / pr;

    fx += pv * px;
    fy += pv * py;

    while (queueLength) {
      var node = queue[shiftIdx],
          body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = body !== sourceBody;
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        dx = body.pos.x - sourceBody.pos.x;
        dy = body.pos.y - sourceBody.pos.y;
        r = Math.sqrt(dx * dx + dy * dy);

        if (r === 0) {
          // Poor man's protection against zero distance.
          dx = (Math.random() - 0.5) / 50;
          dy = (Math.random() - 0.5) / 50;
          r = Math.sqrt(dx * dx + dy * dy);
        }

        // This is standard gravition force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        fx += v * dx;
        fy += v * dy;
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        dx = node.massX / node.mass - sourceBody.pos.x;
        dy = node.massY / node.mass - sourceBody.pos.y;
        r = Math.sqrt(dx * dx + dy * dy);

        if (r === 0) {
          // Sorry about code duplucation. I don't want to create many functions
          // right away. Just want to see performance first.
          dx = (Math.random() - 0.5) / 50;
          dy = (Math.random() - 0.5) / 50;
          r = Math.sqrt(dx * dx + dy * dy);
        }
        // If s / r < Î¸, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.right - node.left) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was squarified during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          fx += v * dx;
          fy += v * dy;
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
          if (node.quad0) {
            queue[pushIdx] = node.quad0;
            queueLength += 1;
            pushIdx += 1;
          }
          if (node.quad1) {
            queue[pushIdx] = node.quad1;
            queueLength += 1;
            pushIdx += 1;
          }
          if (node.quad2) {
            queue[pushIdx] = node.quad2;
            queueLength += 1;
            pushIdx += 1;
          }
          if (node.quad3) {
            queue[pushIdx] = node.quad3;
            queueLength += 1;
            pushIdx += 1;
          }
        }
      }
    }

    sourceBody.force.x += fx;
    sourceBody.force.y += fy;
  }

  function insertBodies(bodies) {
    if (bodies.length === 0) {
      return;
    }

    var x1 = Number.MAX_VALUE,
        y1 = Number.MAX_VALUE,
        x2 = Number.MIN_VALUE,
        y2 = Number.MIN_VALUE,
        i = void 0,
        max = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    i = max;
    while (i--) {
      var x = bodies[i].pos.x;
      var y = bodies[i].pos.y;
      if (x < x1) {
        x1 = x;
      }
      if (x > x2) {
        x2 = x;
      }
      if (y < y1) {
        y1 = y;
      }
      if (y > y2) {
        y2 = y;
      }
    }

    // Squarify the bounds.
    var dx = x2 - x1,
        dy = y2 - y1;
    if (dx > dy) {
      y2 = y1 + dx;
    } else {
      x2 = x1 + dy;
    }

    currentInCache = 0;
    root = newNode();
    root.left = x1;
    root.right = x2;
    root.top = y1;
    root.bottom = y2;

    i = max - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop(),
          node = stackItem.node,
          body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        var x = body.pos.x;
        var y = body.pos.y;
        node.mass = node.mass + body.mass;
        node.massX = node.massX + body.mass * x;
        node.massY = node.massY + body.mass * y;

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0,
            // Assume we are in the 0's quad.
        left = node.left,
            right = (node.right + left) / 2,
            top = node.top,
            bottom = (node.bottom + top) / 2;

        if (x > right) {
          // somewhere in the eastern part.
          quadIdx = quadIdx + 1;
          left = right;
          right = node.right;
        }
        if (y > bottom) {
          // and in south.
          quadIdx = quadIdx + 2;
          top = bottom;
          bottom = node.bottom;
        }

        var child = getChild(node, quadIdx);
        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          child.left = left;
          child.top = top;
          child.right = right;
          child.bottom = bottom;
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = Math.random();
            var dx = (node.right - node.left) * offset;
            var dy = (node.bottom - node.top) * offset;

            oldBody.pos.x = node.left + dx;
            oldBody.pos.y = node.top + dy;
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }

  return {
    insertBodies: insertBodies,
    updateBodyForce: update
  };
}

function getChild(node, idx) {
  if (idx === 0) return node.quad0;
  if (idx === 1) return node.quad1;
  if (idx === 2) return node.quad2;
  if (idx === 3) return node.quad3;
  return null;
}

function setChild(node, idx, child) {
  if (idx === 0) node.quad0 = child;else if (idx === 1) node.quad1 = child;else if (idx === 2) node.quad2 = child;else if (idx === 3) node.quad3 = child;
}

module.exports = { makeQuadtree: makeQuadtree };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = InsertStack;

/**
 * Our implmentation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack() {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function isEmpty() {
        return this.popIdx === 0;
    },
    push: function push(node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressue: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function pop() {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function reset() {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Internal data structure to represent 2D QuadTree node
 */
module.exports = function Node() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain boides:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
  this.quad0 = null;
  this.quad1 = null;
  this.quad2 = null;
  this.quad3 = null;

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  this.massX = 0;
  this.massY = 0;

  // bounding box coordinates
  this.left = 0;
  this.top = 0;
  this.bottom = 0;
  this.right = 0;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(6),
    integrate = _require.integrate;

var _require2 = __webpack_require__(5),
    applyDrag = _require2.applyDrag;

var _require3 = __webpack_require__(1),
    applySpring = _require3.applySpring;

function tick(_ref) {
  var bodies = _ref.bodies,
      springs = _ref.springs,
      quadtree = _ref.quadtree,
      timeStep = _ref.timeStep,
      gravity = _ref.gravity,
      theta = _ref.theta,
      dragCoeff = _ref.dragCoeff,
      pull = _ref.pull;

  // update body from scratch in case of any changes
  bodies.forEach(function (body) {
    var p = body._scratch;

    if (!p) {
      return;
    }

    body.locked = p.locked;
    body.grabbed = p.grabbed;
    body.pos.x = p.x;
    body.pos.y = p.y;
  });

  quadtree.insertBodies(bodies);

  for (var i = 0; i < bodies.length; i++) {
    var body = bodies[i];

    quadtree.updateBodyForce(body, gravity, theta, pull);
    applyDrag(body, dragCoeff);
  }

  for (var _i = 0; _i < springs.length; _i++) {
    var spring = springs[_i];

    applySpring(spring);
  }

  var movement = integrate(bodies, timeStep);

  // update scratch positions from body positions
  bodies.forEach(function (body) {
    var p = body._scratch;

    if (!p) {
      return;
    }

    p.x = body.pos.x;
    p.y = body.pos.y;
  });

  return movement;
}

module.exports = { tick: tick };

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Euler = __webpack_require__(2);

// registers the extension on a cytoscape lib ref
var register = function register(cytoscape) {
  if (!cytoscape) {
    return;
  } // can't register if cytoscape unspecified

  cytoscape('layout', 'euler', Euler); // register with cytoscape.js
};

if (typeof cytoscape !== 'undefined') {
  // expose to global cytoscape (i.e. window.cytoscape)
  register(cytoscape);
}

module.exports = register;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// general default options for force-directed layout

module.exports = Object.freeze({
  animate: true, // whether to show the layout as it's running; special 'end' value makes the layout animate like a discrete layout
  refresh: 10, // number of ticks per frame; higher is faster but more jerky
  maxIterations: 1000, // max iterations before the layout will bail out
  maxSimulationTime: 4000, // max length in ms to run the layout
  ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
  fit: true, // on every layout reposition of nodes, fit the viewport
  padding: 30, // padding around the simulation
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

  // layout event callbacks
  ready: function ready() {}, // on layoutready
  stop: function stop() {}, // on layoutstop

  // positioning options
  randomize: false, // use random node positions at beginning of layout

  // infinite layout options
  infinite: false // overrides all other options for a forces-all-the-time mode
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
A generic continuous layout class
*/

var assign = __webpack_require__(0);
var defaults = __webpack_require__(12);
var makeBoundingBox = __webpack_require__(14);

var _require = __webpack_require__(15),
    setInitialPositionState = _require.setInitialPositionState,
    refreshPositions = _require.refreshPositions,
    getNodePositionData = _require.getNodePositionData;

var _require2 = __webpack_require__(16),
    multitick = _require2.multitick;

var Layout = function () {
  function Layout(options) {
    _classCallCheck(this, Layout);

    var o = this.options = assign({}, defaults, options);

    var s = this.state = assign({}, o, {
      layout: this,
      nodes: o.eles.nodes(),
      edges: o.eles.edges(),
      tickIndex: 0,
      firstUpdate: true
    });

    s.animateEnd = o.animate && o.animate === 'end';
    s.animateContinuously = o.animate && !s.animateEnd;
  }

  _createClass(Layout, [{
    key: 'run',
    value: function run() {
      var l = this;
      var s = this.state;

      s.tickIndex = 0;
      s.firstUpdate = true;
      s.startTime = Date.now();
      s.running = true;

      s.currentBoundingBox = makeBoundingBox(s.boundingBox, s.cy);

      if (s.ready) {
        l.one('ready', s.ready);
      }
      if (s.stop) {
        l.one('stop', s.stop);
      }

      s.nodes.forEach(function (n) {
        return setInitialPositionState(n, s);
      });

      l.prerun(s);

      if (s.animateContinuously) {
        var ungrabify = function ungrabify(node) {
          if (!s.ungrabifyWhileSimulating) {
            return;
          }

          var grabbable = getNodePositionData(node, s).grabbable = node.grabbable();

          if (grabbable) {
            node.ungrabify();
          }
        };

        var regrabify = function regrabify(node) {
          if (!s.ungrabifyWhileSimulating) {
            return;
          }

          var grabbable = getNodePositionData(node, s).grabbable;

          if (grabbable) {
            node.grabify();
          }
        };

        var updateGrabState = function updateGrabState(node) {
          return getNodePositionData(node, s).grabbed = node.grabbed();
        };

        var onGrab = function onGrab(_ref) {
          var target = _ref.target;

          updateGrabState(target);
        };

        var onFree = onGrab;

        var onDrag = function onDrag(_ref2) {
          var target = _ref2.target;

          var p = getNodePositionData(target, s);
          var tp = target.position();

          p.x = tp.x;
          p.y = tp.y;
        };

        var listenToGrab = function listenToGrab(node) {
          node.on('grab', onGrab);
          node.on('free', onFree);
          node.on('drag', onDrag);
        };

        var unlistenToGrab = function unlistenToGrab(node) {
          node.removeListener('grab', onGrab);
          node.removeListener('free', onFree);
          node.removeListener('drag', onDrag);
        };

        var fit = function fit() {
          if (s.fit && s.animateContinuously) {
            s.cy.fit(s.padding);
          }
        };

        var onNotDone = function onNotDone() {
          refreshPositions(s.nodes, s);
          fit();

          requestAnimationFrame(_frame);
        };

        var _frame = function _frame() {
          multitick(s, onNotDone, _onDone);
        };

        var _onDone = function _onDone() {
          refreshPositions(s.nodes, s);
          fit();

          s.nodes.forEach(function (n) {
            regrabify(n);
            unlistenToGrab(n);
          });

          s.running = false;

          l.emit('layoutstop');
        };

        l.emit('layoutstart');

        s.nodes.forEach(function (n) {
          ungrabify(n);
          listenToGrab(n);
        });

        _frame(); // kick off
      } else {
        var done = false;
        var _onNotDone = function _onNotDone() {};
        var _onDone2 = function _onDone2() {
          return done = true;
        };

        while (!done) {
          multitick(s, _onNotDone, _onDone2);
        }

        s.eles.layoutPositions(this, s, function (node) {
          var pd = getNodePositionData(node, s);

          return { x: pd.x, y: pd.y };
        });
      }

      l.postrun(s);

      return this; // chaining
    }
  }, {
    key: 'prerun',
    value: function prerun() {}
  }, {
    key: 'postrun',
    value: function postrun() {}
  }, {
    key: 'tick',
    value: function tick() {}
  }, {
    key: 'stop',
    value: function stop() {
      this.state.running = false;

      return this; // chaining
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      return this; // chaining
    }
  }]);

  return Layout;
}();

module.exports = Layout;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bb, cy) {
  if (bb == null) {
    bb = { x1: 0, y1: 0, w: cy.width(), h: cy.height() };
  } else {
    // copy
    bb = { x1: bb.x1, x2: bb.x2, y1: bb.y1, y2: bb.y2, w: bb.w, h: bb.h };
  }

  if (bb.x2 == null) {
    bb.x2 = bb.x1 + bb.w;
  }
  if (bb.w == null) {
    bb.w = bb.x2 - bb.x1;
  }
  if (bb.y2 == null) {
    bb.y2 = bb.y1 + bb.h;
  }
  if (bb.h == null) {
    bb.h = bb.y2 - bb.y1;
  }

  return bb;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(0);

var setInitialPositionState = function setInitialPositionState(node, state) {
  var p = node.position();
  var bb = state.currentBoundingBox;
  var scratch = node.scratch(state.name);

  if (scratch == null) {
    scratch = {};

    node.scratch(state.name, scratch);
  }

  assign(scratch, state.randomize ? {
    x: bb.x1 + Math.random() * bb.w,
    y: bb.y1 + Math.random() * bb.h
  } : {
    x: p.x,
    y: p.y
  });

  scratch.locked = node.locked();
};

var getNodePositionData = function getNodePositionData(node, state) {
  return node.scratch(state.name);
};

var refreshPositions = function refreshPositions(nodes, state) {
  nodes.positions(function (node) {
    var scratch = node.scratch(state.name);

    return {
      x: scratch.x,
      y: scratch.y
    };
  });
};

module.exports = { setInitialPositionState: setInitialPositionState, getNodePositionData: getNodePositionData, refreshPositions: refreshPositions };

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nop = function nop() {};

var tick = function tick(state) {
  var s = state;
  var l = state.layout;

  var tickIndicatesDone = l.tick(s);

  if (s.firstUpdate) {
    if (s.animateContinuously) {
      // indicate the initial positions have been set
      s.layout.emit('layoutready');
    }
    s.firstUpdate = false;
  }

  s.tickIndex++;

  var duration = Date.now() - s.startTime;

  return !s.infinite && (tickIndicatesDone || s.tickIndex >= s.maxIterations || duration >= s.maxSimulationTime);
};

var multitick = function multitick(state) {
  var onNotDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nop;
  var onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : nop;

  var done = false;
  var s = state;

  for (var i = 0; i < s.refresh; i++) {
    done = !s.running || tick(s);

    if (done) {
      break;
    }
  }

  if (!done) {
    onNotDone();
  } else {
    onDone();
  }
};

module.exports = { tick: tick, multitick: multitick };

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2MGFhNzhlOTI4NDc1MThmZDBmMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzaWduLmpzIiwid2VicGFjazovLy8uL3NyYy9ldWxlci9zcHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V1bGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ldWxlci9ib2R5LmpzIiwid2VicGFjazovLy8uL3NyYy9ldWxlci9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXVsZXIvZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXVsZXIvaW50ZWdyYXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9ldWxlci9xdWFkdHJlZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXVsZXIvcXVhZHRyZWUvaW5zZXJ0U3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V1bGVyL3F1YWR0cmVlL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V1bGVyL3RpY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9sYXlvdXQvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGF5b3V0L21ha2UtYmIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dC9wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGF5b3V0L3RpY2suanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0Z3QiLCJzcmNzIiwiZm9yRWFjaCIsImtleXMiLCJzcmMiLCJrIiwicmVxdWlyZSIsImRlZmF1bHRzIiwiZnJlZXplIiwic291cmNlIiwidGFyZ2V0IiwibGVuZ3RoIiwiY29lZmYiLCJ3ZWlnaHQiLCJtYWtlU3ByaW5nIiwic3ByaW5nIiwiYXBwbHlTcHJpbmciLCJib2R5MSIsImJvZHkyIiwiZHgiLCJwb3MiLCJ4IiwiZHkiLCJ5IiwiciIsIk1hdGgiLCJzcXJ0IiwicmFuZG9tIiwiZCIsInNwcmluZ0NvZWZmIiwiZm9yY2UiLCJMYXlvdXQiLCJ0aWNrIiwibWFrZVF1YWR0cmVlIiwibWFrZUJvZHkiLCJpc0ZuIiwiZm4iLCJpc1BhcmVudCIsIm4iLCJub3RJc1BhcmVudCIsImlzTG9ja2VkIiwibG9ja2VkIiwibm90SXNMb2NrZWQiLCJpc1BhcmVudEVkZ2UiLCJlIiwibm90SXNQYXJlbnRFZGdlIiwiZ2V0Qm9keSIsInNjcmF0Y2giLCJib2R5IiwiZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMiLCJkZXNjZW5kYW50cyIsImZpbHRlciIsImdldFNjcmF0Y2giLCJlbCIsIm9wdEZuIiwib3B0IiwiZWxlIiwiRXVsZXIiLCJvcHRpb25zIiwic3RhdGUiLCJzIiwicXVhZHRyZWUiLCJib2RpZXMiLCJub2RlcyIsIm1hc3MiLCJfY3lOb2RlIiwiX3NjcmF0Y2giLCJwdXNoIiwic3ByaW5ncyIsImVkZ2VzIiwic3ByaW5nTGVuZ3RoIiwiX2N5RWRnZSIsInNvdXJjZXMiLCJ0YXJnZXRzIiwibW92ZW1lbnQiLCJpc0RvbmUiLCJtb3ZlbWVudFRocmVzaG9sZCIsInByZXZQb3MiLCJ2ZWxvY2l0eSIsImNvcHlWZWMiLCJ2IiwiZ2V0VmFsdWUiLCJ2YWwiLCJkZWYiLCJnZXRWZWMiLCJ2ZWMiLCJvcHRzIiwiYiIsImdyYXZpdHkiLCJwdWxsIiwidGhldGEiLCJkcmFnQ29lZmYiLCJ0aW1lU3RlcCIsImRlZmF1bHRDb2VmZiIsImFwcGx5RHJhZyIsIm1hbnVhbERyYWdDb2VmZiIsImludGVncmF0ZSIsInR4IiwidHkiLCJpIiwibWF4IiwiZ3JhYmJlZCIsInZ4IiwidnkiLCJhYnMiLCJOb2RlIiwiSW5zZXJ0U3RhY2siLCJyZXNldFZlYyIsImlzU2FtZVBvc2l0aW9uIiwicDEiLCJwMiIsInRocmVzaG9sZCIsInVwZGF0ZVF1ZXVlIiwiaW5zZXJ0U3RhY2siLCJub2Rlc0NhY2hlIiwiY3VycmVudEluQ2FjaGUiLCJyb290IiwibmV3Tm9kZSIsIm5vZGUiLCJxdWFkMCIsInF1YWQxIiwicXVhZDIiLCJxdWFkMyIsIm1hc3NYIiwibWFzc1kiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ1cGRhdGUiLCJzb3VyY2VCb2R5IiwicXVldWUiLCJmeCIsImZ5IiwicXVldWVMZW5ndGgiLCJzaGlmdElkeCIsInB1c2hJZHgiLCJweCIsInB5IiwicHIiLCJwdiIsImRpZmZlcmVudEJvZHkiLCJpbnNlcnRCb2RpZXMiLCJ4MSIsIk51bWJlciIsIk1BWF9WQUxVRSIsInkxIiwieDIiLCJNSU5fVkFMVUUiLCJ5MiIsImluc2VydCIsIm5ld0JvZHkiLCJyZXNldCIsImlzRW1wdHkiLCJzdGFja0l0ZW0iLCJwb3AiLCJxdWFkSWR4IiwiY2hpbGQiLCJnZXRDaGlsZCIsInNldENoaWxkIiwib2xkQm9keSIsInJldHJpZXNDb3VudCIsIm9mZnNldCIsInVwZGF0ZUJvZHlGb3JjZSIsImlkeCIsInN0YWNrIiwicG9wSWR4IiwicHJvdG90eXBlIiwiaXRlbSIsIkluc2VydFN0YWNrRWxlbWVudCIsInAiLCJyZWdpc3RlciIsImN5dG9zY2FwZSIsImFuaW1hdGUiLCJyZWZyZXNoIiwibWF4SXRlcmF0aW9ucyIsIm1heFNpbXVsYXRpb25UaW1lIiwidW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nIiwiZml0IiwicGFkZGluZyIsImJvdW5kaW5nQm94IiwidW5kZWZpbmVkIiwicmVhZHkiLCJzdG9wIiwicmFuZG9taXplIiwiaW5maW5pdGUiLCJtYWtlQm91bmRpbmdCb3giLCJzZXRJbml0aWFsUG9zaXRpb25TdGF0ZSIsInJlZnJlc2hQb3NpdGlvbnMiLCJnZXROb2RlUG9zaXRpb25EYXRhIiwibXVsdGl0aWNrIiwibyIsImxheW91dCIsImVsZXMiLCJ0aWNrSW5kZXgiLCJmaXJzdFVwZGF0ZSIsImFuaW1hdGVFbmQiLCJhbmltYXRlQ29udGludW91c2x5IiwibCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJydW5uaW5nIiwiY3VycmVudEJvdW5kaW5nQm94IiwiY3kiLCJvbmUiLCJwcmVydW4iLCJ1bmdyYWJpZnkiLCJncmFiYmFibGUiLCJyZWdyYWJpZnkiLCJncmFiaWZ5IiwidXBkYXRlR3JhYlN0YXRlIiwib25HcmFiIiwib25GcmVlIiwib25EcmFnIiwidHAiLCJwb3NpdGlvbiIsImxpc3RlblRvR3JhYiIsIm9uIiwidW5saXN0ZW5Ub0dyYWIiLCJyZW1vdmVMaXN0ZW5lciIsIm9uTm90RG9uZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImZyYW1lIiwib25Eb25lIiwiZW1pdCIsImRvbmUiLCJsYXlvdXRQb3NpdGlvbnMiLCJwZCIsInBvc3RydW4iLCJiYiIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJuYW1lIiwicG9zaXRpb25zIiwibm9wIiwidGlja0luZGljYXRlc0RvbmUiLCJkdXJhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7OztBQ2hFQUEsT0FBT0MsT0FBUCxHQUFpQkMsT0FBT0Ms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bkJnQixHQUFtQjtBQUFBLE1BQWRiLE1BQWMsdUVBQUxhLEdBQUs7O0FBQzlELE1BQUlYLE9BQU8sS0FBWDtBQUNBLE1BQUl0SyxJQUFJRCxLQUFSOztBQUVBLE9BQUssSUFBSXdDLElBQUksQ0FBYixFQUFnQkEsSUFBSXZDLEVBQUVrSCxPQUF0QixFQUErQjNFLEdBQS9CLEVBQW9DO0FBQ2xDK0gsV0FBTyxDQUFDdEssRUFBRThJLE9BQUgsSUFBYzFLLEtBQU00QixDQUFOLENBQXJCOztBQUVBLFFBQUlzSyxJQUFKLEVBQVU7QUFBRTtBQUFRO0FBQ3JCOztBQUVELE1BQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1RMO0FBQ0QsR0FGRCxNQUVPO0FBQ0xHO0FBQ0Q7QUFDRixDQWZEOztBQWlCQXJPLE9BQU9DLE9BQVAsR0FBaUIsRUFBRW9DLFVBQUYsRUFBUThKLG9CQUFSLEVBQWpCLEMiLCJmaWxlIjoiY3l0b3NjYXBlLWV1bGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlRXVsZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlRXVsZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNjBhYTc4ZTkyODQ3NTE4ZmQwZjMiLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZCggT2JqZWN0ICkgOiBmdW5jdGlvbiggdGd0LCAuLi5zcmNzICl7XG4gIHNyY3MuZm9yRWFjaCggc3JjID0+IHtcbiAgICBPYmplY3Qua2V5cyggc3JjICkuZm9yRWFjaCggayA9PiB0Z3Rba10gPSBzcmNba10gKTtcbiAgfSApO1xuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Fzc2lnbi5qcyIsImNvbnN0IGFzc2lnbiA9IHJlcXVpcmUoJy4uL2Fzc2lnbicpO1xuXG5jb25zdCBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICBzb3VyY2U6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgbGVuZ3RoOiA4MCxcbiAgY29lZmY6IDAuMDAwMixcbiAgd2VpZ2h0OiAxXG59KTtcblxuZnVuY3Rpb24gbWFrZVNwcmluZyggc3ByaW5nICl7XG4gIHJldHVybiBhc3NpZ24oIHt9LCBkZWZhdWx0cywgc3ByaW5nICk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3ByaW5nKCBzcHJpbmcgKXtcbiAgbGV0IGJvZHkxID0gc3ByaW5nLnNvdXJjZSxcbiAgICAgIGJvZHkyID0gc3ByaW5nLnRhcmdldCxcbiAgICAgIGxlbmd0aCA9IHNwcmluZy5sZW5ndGggPCAwID8gZGVmYXVsdHMubGVuZ3RoIDogc3ByaW5nLmxlbmd0aCxcbiAgICAgIGR4ID0gYm9keTIucG9zLnggLSBib2R5MS5wb3MueCxcbiAgICAgIGR5ID0gYm9keTIucG9zLnkgLSBib2R5MS5wb3MueSxcbiAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIGlmIChyID09PSAwKSB7XG4gICAgICBkeCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDUwO1xuICAgICAgZHkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA1MDtcbiAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9XG5cbiAgbGV0IGQgPSByIC0gbGVuZ3RoO1xuICBsZXQgY29lZmYgPSAoKCFzcHJpbmcuY29lZmYgfHwgc3ByaW5nLmNvZWZmIDwgMCkgPyBkZWZhdWx0cy5zcHJpbmdDb2VmZiA6IHNwcmluZy5jb2VmZikgKiBkIC8gciAqIHNwcmluZy53ZWlnaHQ7XG5cbiAgYm9keTEuZm9yY2UueCArPSBjb2VmZiAqIGR4O1xuICBib2R5MS5mb3JjZS55ICs9IGNvZWZmICogZHk7XG5cbiAgYm9keTIuZm9yY2UueCAtPSBjb2VmZiAqIGR4O1xuICBib2R5Mi5mb3JjZS55IC09IGNvZWZmICogZHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBtYWtlU3ByaW5nLCBhcHBseVNwcmluZyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL3NwcmluZy5qcyIsIi8qKlxuVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBFdWxlciBsYXlvdXQgYWxnb3JpdGhtXG4qL1xuXG5jb25zdCBMYXlvdXQgPSByZXF1aXJlKCcuLi9sYXlvdXQnKTtcbmNvbnN0IGFzc2lnbiA9IHJlcXVpcmUoJy4uL2Fzc2lnbicpO1xuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5jb25zdCB7IHRpY2sgfSA9IHJlcXVpcmUoJy4vdGljaycpO1xuY29uc3QgeyBtYWtlUXVhZHRyZWUgfSA9IHJlcXVpcmUoJy4vcXVhZHRyZWUnKTtcbmNvbnN0IHsgbWFrZUJvZHkgfSA9IHJlcXVpcmUoJy4vYm9keScpO1xuY29uc3QgeyBtYWtlU3ByaW5nIH0gPSByZXF1aXJlKCcuL3NwcmluZycpO1xuY29uc3QgaXNGbiA9IGZuID0+IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzUGFyZW50ID0gbiA9PiBuLmlzUGFyZW50KCk7XG5jb25zdCBub3RJc1BhcmVudCA9IG4gPT4gIWlzUGFyZW50KG4pO1xuY29uc3QgaXNMb2NrZWQgPSBuID0+IG4ubG9ja2VkKCk7XG5jb25zdCBub3RJc0xvY2tlZCA9IG4gPT4gIWlzTG9ja2VkKG4pO1xuY29uc3QgaXNQYXJlbnRFZGdlID0gZSA9PiBpc1BhcmVudCggZS5zb3VyY2UoKSApIHx8IGlzUGFyZW50KCBlLnRhcmdldCgpICk7XG5jb25zdCBub3RJc1BhcmVudEVkZ2UgPSBlID0+ICFpc1BhcmVudEVkZ2UoZSk7XG5jb25zdCBnZXRCb2R5ID0gbiA9PiBuLnNjcmF0Y2goJ2V1bGVyJykuYm9keTtcbmNvbnN0IGdldE5vblBhcmVudERlc2NlbmRhbnRzID0gbiA9PiBpc1BhcmVudChuKSA/IG4uZGVzY2VuZGFudHMoKS5maWx0ZXIoIG5vdElzUGFyZW50ICkgOiBuO1xuXG5jb25zdCBnZXRTY3JhdGNoID0gZWwgPT4ge1xuICBsZXQgc2NyYXRjaCA9IGVsLnNjcmF0Y2goJ2V1bGVyJyk7XG5cbiAgaWYoICFzY3JhdGNoICl7XG4gICAgc2NyYXRjaCA9IHt9O1xuXG4gICAgZWwuc2NyYXRjaCgnZXVsZXInLCBzY3JhdGNoKTtcbiAgfVxuXG4gIHJldHVybiBzY3JhdGNoO1xufTtcblxuY29uc3Qgb3B0Rm4gPSAoIG9wdCwgZWxlICkgPT4ge1xuICBpZiggaXNGbiggb3B0ICkgKXtcbiAgICByZXR1cm4gb3B0KCBlbGUgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb3B0O1xuICB9XG59O1xuXG5jbGFzcyBFdWxlciBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICl7XG4gICAgc3VwZXIoIGFzc2lnbigge30sIGRlZmF1bHRzLCBvcHRpb25zICkgKTtcbiAgfVxuXG4gIHByZXJ1biggc3RhdGUgKXtcbiAgICBsZXQgcyA9IHN0YXRlO1xuXG4gICAgcy5xdWFkdHJlZSA9IG1ha2VRdWFkdHJlZSgpO1xuXG4gICAgbGV0IGJvZGllcyA9IHMuYm9kaWVzID0gW107XG5cbiAgICAvLyByZWd1bGFyIG5vZGVzXG4gICAgcy5ub2Rlcy5maWx0ZXIoIG4gPT4gbm90SXNQYXJlbnQobikgKS5mb3JFYWNoKCBuID0+IHtcbiAgICAgIGxldCBzY3JhdGNoID0gZ2V0U2NyYXRjaCggbiApO1xuXG4gICAgICBsZXQgYm9keSA9IG1ha2VCb2R5KHtcbiAgICAgICAgcG9zOiB7IHg6IHNjcmF0Y2gueCwgeTogc2NyYXRjaC55IH0sXG4gICAgICAgIG1hc3M6IG9wdEZuKCBzLm1hc3MsIG4gKSxcbiAgICAgICAgbG9ja2VkOiBzY3JhdGNoLmxvY2tlZFxuICAgICAgfSk7XG5cbiAgICAgIGJvZHkuX2N5Tm9kZSA9IG47XG5cbiAgICAgIHNjcmF0Y2guYm9keSA9IGJvZHk7XG5cbiAgICAgIGJvZHkuX3NjcmF0Y2ggPSBzY3JhdGNoO1xuXG4gICAgICBib2RpZXMucHVzaCggYm9keSApO1xuICAgIH0gKTtcblxuICAgIGxldCBzcHJpbmdzID0gcy5zcHJpbmdzID0gW107XG5cbiAgICAvLyByZWd1bGFyIGVkZ2Ugc3ByaW5nc1xuICAgIHMuZWRnZXMuZmlsdGVyKCBub3RJc1BhcmVudEVkZ2UgKS5mb3JFYWNoKCBlID0+IHtcbiAgICAgIGxldCBzcHJpbmcgPSBtYWtlU3ByaW5nKHtcbiAgICAgICAgc291cmNlOiBnZXRCb2R5KCBlLnNvdXJjZSgpICksXG4gICAgICAgIHRhcmdldDogZ2V0Qm9keSggZS50YXJnZXQoKSApLFxuICAgICAgICBsZW5ndGg6IG9wdEZuKCBzLnNwcmluZ0xlbmd0aCwgZSApLFxuICAgICAgICBjb2VmZjogb3B0Rm4oIHMuc3ByaW5nQ29lZmYsIGUgKVxuICAgICAgfSk7XG5cbiAgICAgIHNwcmluZy5fY3lFZGdlID0gZTtcblxuICAgICAgbGV0IHNjcmF0Y2ggPSBnZXRTY3JhdGNoKCBlICk7XG5cbiAgICAgIHNwcmluZy5fc2NyYXRjaCA9IHNjcmF0Y2g7XG5cbiAgICAgIHNjcmF0Y2guc3ByaW5nID0gc3ByaW5nO1xuXG4gICAgICBzcHJpbmdzLnB1c2goIHNwcmluZyApO1xuICAgIH0gKTtcblxuICAgIC8vIGNvbXBvdW5kIGVkZ2Ugc3ByaW5nc1xuICAgIHMuZWRnZXMuZmlsdGVyKCBpc1BhcmVudEVkZ2UgKS5mb3JFYWNoKCBlID0+IHtcbiAgICAgIGxldCBzb3VyY2VzID0gZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMoIGUuc291cmNlKCkgKTtcbiAgICAgIGxldCB0YXJnZXRzID0gZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMoIGUudGFyZ2V0KCkgKTtcblxuICAgICAgLy8ganVzdCBhZGQgb25lIHNwcmluZyBmb3IgcGVyZlxuICAgICAgc291cmNlcyA9IFsgc291cmNlc1swXSBdO1xuICAgICAgdGFyZ2V0cyA9IFsgdGFyZ2V0c1swXSBdO1xuXG4gICAgICBzb3VyY2VzLmZvckVhY2goIHNyYyA9PiB7XG4gICAgICAgIHRhcmdldHMuZm9yRWFjaCggdGd0ID0+IHtcbiAgICAgICAgICBzcHJpbmdzLnB1c2goIG1ha2VTcHJpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBnZXRCb2R5KCBzcmMgKSxcbiAgICAgICAgICAgIHRhcmdldDogZ2V0Qm9keSggdGd0ICksXG4gICAgICAgICAgICBsZW5ndGg6IG9wdEZuKCBzLnNwcmluZ0xlbmd0aCwgZSApLFxuICAgICAgICAgICAgY29lZmY6IG9wdEZuKCBzLnNwcmluZ0NvZWZmLCBlIClcbiAgICAgICAgICB9KSApO1xuICAgICAgICB9ICk7XG4gICAgICB9ICk7XG4gICAgfSApO1xuICB9XG5cbiAgdGljayggc3RhdGUgKXtcbiAgICBsZXQgbW92ZW1lbnQgPSB0aWNrKCBzdGF0ZSApO1xuXG4gICAgbGV0IGlzRG9uZSA9IG1vdmVtZW50IDw9IHN0YXRlLm1vdmVtZW50VGhyZXNob2xkO1xuXG4gICAgcmV0dXJuIGlzRG9uZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV1bGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL2luZGV4LmpzIiwiY29uc3QgZGVmYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcbiAgcG9zOiB7IHg6IDAsIHk6IDAgfSxcbiAgcHJldlBvczogeyB4OiAwLCB5OiAwIH0sXG4gIGZvcmNlOiB7IHg6IDAsIHk6IDAgfSxcbiAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxuICBtYXNzOiAxXG59KTtcblxuY29uc3QgY29weVZlYyA9IHYgPT4gKHsgeDogdi54LCB5OiB2LnkgfSk7XG5jb25zdCBnZXRWYWx1ZSA9ICggdmFsLCBkZWYgKSA9PiB2YWwgIT0gbnVsbCA/IHZhbCA6IGRlZjtcbmNvbnN0IGdldFZlYyA9ICggdmVjLCBkZWYgKSA9PiBjb3B5VmVjKCBnZXRWYWx1ZSggdmVjLCBkZWYgKSApO1xuXG5mdW5jdGlvbiBtYWtlQm9keSggb3B0cyApe1xuICBsZXQgYiA9IHt9O1xuXG4gIGIucG9zID0gZ2V0VmVjKCBvcHRzLnBvcywgZGVmYXVsdHMucG9zICk7XG4gIGIucHJldlBvcyA9IGdldFZlYyggb3B0cy5wcmV2UG9zLCBiLnBvcyApO1xuICBiLmZvcmNlID0gZ2V0VmVjKCBvcHRzLmZvcmNlLCBkZWZhdWx0cy5mb3JjZSApO1xuICBiLnZlbG9jaXR5ID0gZ2V0VmVjKCBvcHRzLnZlbG9jaXR5LCBkZWZhdWx0cy52ZWxvY2l0eSApO1xuICBiLm1hc3MgPSBvcHRzLm1hc3MgIT0gbnVsbCA/IG9wdHMubWFzcyA6IGRlZmF1bHRzLm1hc3M7XG4gIGIubG9ja2VkID0gb3B0cy5sb2NrZWQ7XG5cbiAgcmV0dXJuIGI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBtYWtlQm9keSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL2JvZHkuanMiLCJjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBUaGUgaWRlYWwgbGVndGggb2YgYSBzcHJpbmdcbiAgLy8gLSBUaGlzIGFjdHMgYXMgYSBoaW50IGZvciB0aGUgZWRnZSBsZW5ndGhcbiAgLy8gLSBUaGUgZWRnZSBsZW5ndGggY2FuIGJlIGxvbmdlciBvciBzaG9ydGVyIGlmIHRoZSBmb3JjZXMgYXJlIHNldCB0byBleHRyZW1lIHZhbHVlc1xuICBzcHJpbmdMZW5ndGg6IGVkZ2UgPT4gODAsXG5cbiAgLy8gSG9va2UncyBsYXcgY29lZmZpY2llbnRcbiAgLy8gLSBUaGUgdmFsdWUgcmFuZ2VzIG9uIFswLCAxXVxuICAvLyAtIExvd2VyIHZhbHVlcyBnaXZlIGxvb3NlciBzcHJpbmdzXG4gIC8vIC0gSGlnaGVyIHZhbHVlcyBnaXZlIHRpZ2h0ZXIgc3ByaW5nc1xuICBzcHJpbmdDb2VmZjogZWRnZSA9PiAwLjAwMDgsXG5cbiAgLy8gVGhlIG1hc3Mgb2YgdGhlIG5vZGUgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAvLyAtIFRoZSBtYXNzIGFmZmVjdHMgdGhlIGdyYXZpdHkgbm9kZSByZXB1bHNpb24vYXR0cmFjdGlvblxuICBtYXNzOiBub2RlID0+IDQsXG5cbiAgLy8gQ291bG9tYidzIGxhdyBjb2VmZmljaWVudFxuICAvLyAtIE1ha2VzIHRoZSBub2RlcyByZXBlbCBlYWNoIG90aGVyIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgLy8gLSBNYWtlcyB0aGUgbm9kZXMgYXR0cmFjdCBlYWNoIG90aGVyIGZvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgZ3Jhdml0eTogLTEuMixcblxuICAvLyBBIGZvcmNlIHRoYXQgcHVsbHMgbm9kZXMgdG93YXJkcyB0aGUgb3JpZ2luICgwLCAwKVxuICAvLyBIaWdoZXIgdmFsdWVzIGtlZXAgdGhlIGNvbXBvbmVudHMgbGVzcyBzcHJlYWQgb3V0XG4gIHB1bGw6IDAuMDAxLFxuXG4gIC8vIFRoZXRhIGNvZWZmaWNpZW50IGZyb20gQmFybmVzLUh1dCBzaW11bGF0aW9uXG4gIC8vIC0gVmFsdWUgcmFuZ2VzIG9uIFswLCAxXVxuICAvLyAtIFBlcmZvcm1hbmNlIGlzIGJldHRlciB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIC8vIC0gVmVyeSBzbWFsbCB2YWx1ZXMgbWF5IG5vdCBjcmVhdGUgZW5vdWdoIGZvcmNlIHRvIGdpdmUgYSBnb29kIHJlc3VsdFxuICB0aGV0YTogMC42NjYsXG5cbiAgLy8gRnJpY3Rpb24gLyBkcmFnIGNvZWZmaWNpZW50IHRvIG1ha2UgdGhlIHN5c3RlbSBzdGFiaWxpc2Ugb3ZlciB0aW1lXG4gIGRyYWdDb2VmZjogMC4wMixcblxuICAvLyBXaGVuIHRoZSB0b3RhbCBvZiB0aGUgc3F1YXJlZCBwb3NpdGlvbiBkZWx0YXMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUsIHRoZSBzaW11bGF0aW9uIGVuZHNcbiAgbW92ZW1lbnRUaHJlc2hvbGQ6IDEsXG5cbiAgLy8gVGhlIGFtb3VudCBvZiB0aW1lIHBhc3NlZCBwZXIgdGlja1xuICAvLyAtIExhcmdlciB2YWx1ZXMgcmVzdWx0IGluIGZhc3RlciBydW50aW1lcyBidXQgbWlnaHQgc3ByZWFkIHRoaW5ncyBvdXQgdG9vIGZhclxuICAvLyAtIFNtYWxsZXIgdmFsdWVzIHByb2R1Y2UgbW9yZSBhY2N1cmF0ZSByZXN1bHRzXG4gIHRpbWVTdGVwOiAyMFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXVsZXIvZGVmYXVsdHMuanMiLCJjb25zdCBkZWZhdWx0Q29lZmYgPSAwLjAyO1xuXG5mdW5jdGlvbiBhcHBseURyYWcoIGJvZHksIG1hbnVhbERyYWdDb2VmZiApe1xuICBsZXQgZHJhZ0NvZWZmO1xuXG4gIGlmKCBtYW51YWxEcmFnQ29lZmYgIT0gbnVsbCApe1xuICAgIGRyYWdDb2VmZiA9IG1hbnVhbERyYWdDb2VmZjtcbiAgfSBlbHNlIGlmKCBib2R5LmRyYWdDb2VmZiAhPSBudWxsICl7XG4gICAgZHJhZ0NvZWZmID0gYm9keS5kcmFnQ29lZmY7XG4gIH0gZWxzZSB7XG4gICAgZHJhZ0NvZWZmID0gZGVmYXVsdENvZWZmO1xuICB9XG5cbiAgYm9keS5mb3JjZS54IC09IGRyYWdDb2VmZiAqIGJvZHkudmVsb2NpdHkueDtcbiAgYm9keS5mb3JjZS55IC09IGRyYWdDb2VmZiAqIGJvZHkudmVsb2NpdHkueTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGFwcGx5RHJhZyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL2RyYWcuanMiLCIvLyB1c2UgZXVsZXIgbWV0aG9kIGZvciBmb3JjZSBpbnRlZ3JhdGlvbiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX21ldGhvZFxuLy8gcmV0dXJuIHN1bSBvZiBzcXVhcmVkIHBvc2l0aW9uIGRlbHRhc1xuZnVuY3Rpb24gaW50ZWdyYXRlKCBib2RpZXMsIHRpbWVTdGVwICl7XG4gIHZhciBkeCA9IDAsIHR4ID0gMCxcbiAgICAgIGR5ID0gMCwgdHkgPSAwLFxuICAgICAgaSxcbiAgICAgIG1heCA9IGJvZGllcy5sZW5ndGg7XG5cbiAgaWYgKG1heCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgKytpKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgIGNvZWZmID0gdGltZVN0ZXAgLyBib2R5Lm1hc3M7XG5cbiAgICBpZiggYm9keS5ncmFiYmVkICl7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiggYm9keS5sb2NrZWQgKXtcbiAgICAgIGJvZHkudmVsb2NpdHkueCA9IDA7XG4gICAgICBib2R5LnZlbG9jaXR5LnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5LnZlbG9jaXR5LnggKz0gY29lZmYgKiBib2R5LmZvcmNlLng7XG4gICAgICBib2R5LnZlbG9jaXR5LnkgKz0gY29lZmYgKiBib2R5LmZvcmNlLnk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gYm9keS52ZWxvY2l0eS54LFxuICAgICAgICB2eSA9IGJvZHkudmVsb2NpdHkueSxcbiAgICAgICAgdiA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cbiAgICBpZiAodiA+IDEpIHtcbiAgICAgIGJvZHkudmVsb2NpdHkueCA9IHZ4IC8gdjtcbiAgICAgIGJvZHkudmVsb2NpdHkueSA9IHZ5IC8gdjtcbiAgICB9XG5cbiAgICBkeCA9IHRpbWVTdGVwICogYm9keS52ZWxvY2l0eS54O1xuICAgIGR5ID0gdGltZVN0ZXAgKiBib2R5LnZlbG9jaXR5Lnk7XG5cbiAgICBib2R5LnBvcy54ICs9IGR4O1xuICAgIGJvZHkucG9zLnkgKz0gZHk7XG5cbiAgICB0eCArPSBNYXRoLmFicyhkeCk7IHR5ICs9IE1hdGguYWJzKGR5KTtcbiAgfVxuXG4gIHJldHVybiAodHggKiB0eCArIHR5ICogdHkpL21heDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGludGVncmF0ZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL2ludGVncmF0ZS5qcyIsIi8vIGltcGwgb2YgYmFybmVzIGh1dFxuLy8gaHR0cDovL3d3dy5lZWNzLmJlcmtlbGV5LmVkdS9+ZGVtbWVsL2NzMjY3L2xlY3R1cmUyNi9sZWN0dXJlMjYuaHRtbFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXJuZXMlRTIlODAlOTNIdXRfc2ltdWxhdGlvblxuXG5jb25zdCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5jb25zdCBJbnNlcnRTdGFjayA9IHJlcXVpcmUoJy4vaW5zZXJ0U3RhY2snKTtcblxuY29uc3QgcmVzZXRWZWMgPSB2ID0+IHsgdi54ID0gMDsgdi55ID0gMDsgfTtcblxuY29uc3QgaXNTYW1lUG9zaXRpb24gPSAocDEsIHAyKSA9PiB7XG4gIGxldCB0aHJlc2hvbGQgPSAxZS04O1xuICBsZXQgZHggPSBNYXRoLmFicyhwMS54IC0gcDIueCk7XG4gIGxldCBkeSA9IE1hdGguYWJzKHAxLnkgLSBwMi55KTtcblxuICByZXR1cm4gZHggPCB0aHJlc2hvbGQgJiYgZHkgPCB0aHJlc2hvbGQ7XG59O1xuXG5mdW5jdGlvbiBtYWtlUXVhZHRyZWUoKXtcbiAgbGV0IHVwZGF0ZVF1ZXVlID0gW10sXG4gICAgaW5zZXJ0U3RhY2sgPSBuZXcgSW5zZXJ0U3RhY2soKSxcbiAgICBub2Rlc0NhY2hlID0gW10sXG4gICAgY3VycmVudEluQ2FjaGUgPSAwLFxuICAgIHJvb3QgPSBuZXdOb2RlKCk7XG5cbiAgZnVuY3Rpb24gbmV3Tm9kZSgpIHtcbiAgICAvLyBUbyBhdm9pZCBwcmVzc3VyZSBvbiBHQyB3ZSByZXVzZSBub2Rlcy5cbiAgICBsZXQgbm9kZSA9IG5vZGVzQ2FjaGVbY3VycmVudEluQ2FjaGVdO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLnF1YWQwID0gbnVsbDtcbiAgICAgIG5vZGUucXVhZDEgPSBudWxsO1xuICAgICAgbm9kZS5xdWFkMiA9IG51bGw7XG4gICAgICBub2RlLnF1YWQzID0gbnVsbDtcbiAgICAgIG5vZGUuYm9keSA9IG51bGw7XG4gICAgICBub2RlLm1hc3MgPSBub2RlLm1hc3NYID0gbm9kZS5tYXNzWSA9IDA7XG4gICAgICBub2RlLmxlZnQgPSBub2RlLnJpZ2h0ID0gbm9kZS50b3AgPSBub2RlLmJvdHRvbSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgbm9kZXNDYWNoZVtjdXJyZW50SW5DYWNoZV0gPSBub2RlO1xuICAgIH1cblxuICAgICsrY3VycmVudEluQ2FjaGU7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUoIHNvdXJjZUJvZHksIGdyYXZpdHksIHRoZXRhLCBwdWxsICkge1xuICAgIGxldCBxdWV1ZSA9IHVwZGF0ZVF1ZXVlLFxuICAgICAgdixcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICByLCBmeCA9IDAsXG4gICAgICBmeSA9IDAsXG4gICAgICBxdWV1ZUxlbmd0aCA9IDEsXG4gICAgICBzaGlmdElkeCA9IDAsXG4gICAgICBwdXNoSWR4ID0gMTtcblxuICAgIHF1ZXVlWzBdID0gcm9vdDtcblxuICAgIHJlc2V0VmVjKCBzb3VyY2VCb2R5LmZvcmNlICk7XG5cbiAgICBsZXQgcHggPSAtc291cmNlQm9keS5wb3MueDtcbiAgICBsZXQgcHkgPSAtc291cmNlQm9keS5wb3MueTtcbiAgICBsZXQgcHIgPSBNYXRoLnNxcnQocHggKiBweCArIHB5ICogcHkpO1xuICAgIGxldCBwdiA9IHNvdXJjZUJvZHkubWFzcyAqIHB1bGwgLyBwcjtcblxuICAgIGZ4ICs9IHB2ICogcHg7XG4gICAgZnkgKz0gcHYgKiBweTtcblxuICAgIHdoaWxlIChxdWV1ZUxlbmd0aCkge1xuICAgICAgbGV0IG5vZGUgPSBxdWV1ZVtzaGlmdElkeF0sXG4gICAgICAgIGJvZHkgPSBub2RlLmJvZHk7XG5cbiAgICAgIHF1ZXVlTGVuZ3RoIC09IDE7XG4gICAgICBzaGlmdElkeCArPSAxO1xuICAgICAgbGV0IGRpZmZlcmVudEJvZHkgPSAoYm9keSAhPT0gc291cmNlQm9keSk7XG4gICAgICBpZiAoYm9keSAmJiBkaWZmZXJlbnRCb2R5KSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBsZWFmIG5vZGUgKGFuZCBpdCBpcyBub3Qgc291cmNlIGJvZHkpLFxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGZvcmNlIGV4ZXJ0ZWQgYnkgdGhlIGN1cnJlbnQgbm9kZSBvbiBib2R5LCBhbmQgYWRkIHRoaXNcbiAgICAgICAgLy8gYW1vdW50IHRvIGJvZHkncyBuZXQgZm9yY2UuXG4gICAgICAgIGR4ID0gYm9keS5wb3MueCAtIHNvdXJjZUJvZHkucG9zLng7XG4gICAgICAgIGR5ID0gYm9keS5wb3MueSAtIHNvdXJjZUJvZHkucG9zLnk7XG4gICAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgLy8gUG9vciBtYW4ncyBwcm90ZWN0aW9uIGFnYWluc3QgemVybyBkaXN0YW5jZS5cbiAgICAgICAgICBkeCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDUwO1xuICAgICAgICAgIGR5ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNTA7XG4gICAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIHN0YW5kYXJkIGdyYXZpdGlvbiBmb3JjZSBjYWxjdWxhdGlvbiBidXQgd2UgZGl2aWRlXG4gICAgICAgIC8vIGJ5IHJeMyB0byBzYXZlIHR3byBvcGVyYXRpb25zIHdoZW4gbm9ybWFsaXppbmcgZm9yY2UgdmVjdG9yLlxuICAgICAgICB2ID0gZ3Jhdml0eSAqIGJvZHkubWFzcyAqIHNvdXJjZUJvZHkubWFzcyAvIChyICogciAqIHIpO1xuICAgICAgICBmeCArPSB2ICogZHg7XG4gICAgICAgIGZ5ICs9IHYgKiBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW50Qm9keSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGNhbGN1bGF0ZSB0aGUgcmF0aW8gcyAvIHIsICB3aGVyZSBzIGlzIHRoZSB3aWR0aCBvZiB0aGUgcmVnaW9uXG4gICAgICAgIC8vIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnRlcm5hbCBub2RlLCBhbmQgciBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9keVxuICAgICAgICAvLyBhbmQgdGhlIG5vZGUncyBjZW50ZXItb2YtbWFzc1xuICAgICAgICBkeCA9IG5vZGUubWFzc1ggLyBub2RlLm1hc3MgLSBzb3VyY2VCb2R5LnBvcy54O1xuICAgICAgICBkeSA9IG5vZGUubWFzc1kgLyBub2RlLm1hc3MgLSBzb3VyY2VCb2R5LnBvcy55O1xuICAgICAgICByID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgIC8vIFNvcnJ5IGFib3V0IGNvZGUgZHVwbHVjYXRpb24uIEkgZG9uJ3Qgd2FudCB0byBjcmVhdGUgbWFueSBmdW5jdGlvbnNcbiAgICAgICAgICAvLyByaWdodCBhd2F5LiBKdXN0IHdhbnQgdG8gc2VlIHBlcmZvcm1hbmNlIGZpcnN0LlxuICAgICAgICAgIGR4ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNTA7XG4gICAgICAgICAgZHkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA1MDtcbiAgICAgICAgICByID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzIC8gciA8IM64LCB0cmVhdCB0aGlzIGludGVybmFsIG5vZGUgYXMgYSBzaW5nbGUgYm9keSwgYW5kIGNhbGN1bGF0ZSB0aGVcbiAgICAgICAgLy8gZm9yY2UgaXQgZXhlcnRzIG9uIHNvdXJjZUJvZHksIGFuZCBhZGQgdGhpcyBhbW91bnQgdG8gc291cmNlQm9keSdzIG5ldCBmb3JjZS5cbiAgICAgICAgaWYgKChub2RlLnJpZ2h0IC0gbm9kZS5sZWZ0KSAvIHIgPCB0aGV0YSkge1xuICAgICAgICAgIC8vIGluIHRoZSBpZiBzdGF0ZW1lbnQgYWJvdmUgd2UgY29uc2lkZXIgbm9kZSdzIHdpZHRoIG9ubHlcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZSByZWdpb24gd2FzIHNxdWFyaWZpZWQgZHVyaW5nIHRyZWUgY3JlYXRpb24uXG4gICAgICAgICAgLy8gVGh1cyB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gdXNpbmcgd2lkdGggb3IgaGVpZ2h0LlxuICAgICAgICAgIHYgPSBncmF2aXR5ICogbm9kZS5tYXNzICogc291cmNlQm9keS5tYXNzIC8gKHIgKiByICogcik7XG4gICAgICAgICAgZnggKz0gdiAqIGR4O1xuICAgICAgICAgIGZ5ICs9IHYgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHJ1biB0aGUgcHJvY2VkdXJlIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlIGN1cnJlbnQgbm9kZSdzIGNoaWxkcmVuLlxuXG4gICAgICAgICAgLy8gSSBpbnRlbnRpb25hbGx5IHVuZm9sZGVkIHRoaXMgbG9vcCwgdG8gc2F2ZSBzZXZlcmFsIENQVSBjeWNsZXMuXG4gICAgICAgICAgaWYgKG5vZGUucXVhZDApIHtcbiAgICAgICAgICAgIHF1ZXVlW3B1c2hJZHhdID0gbm9kZS5xdWFkMDtcbiAgICAgICAgICAgIHF1ZXVlTGVuZ3RoICs9IDE7XG4gICAgICAgICAgICBwdXNoSWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnF1YWQxKSB7XG4gICAgICAgICAgICBxdWV1ZVtwdXNoSWR4XSA9IG5vZGUucXVhZDE7XG4gICAgICAgICAgICBxdWV1ZUxlbmd0aCArPSAxO1xuICAgICAgICAgICAgcHVzaElkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5xdWFkMikge1xuICAgICAgICAgICAgcXVldWVbcHVzaElkeF0gPSBub2RlLnF1YWQyO1xuICAgICAgICAgICAgcXVldWVMZW5ndGggKz0gMTtcbiAgICAgICAgICAgIHB1c2hJZHggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUucXVhZDMpIHtcbiAgICAgICAgICAgIHF1ZXVlW3B1c2hJZHhdID0gbm9kZS5xdWFkMztcbiAgICAgICAgICAgIHF1ZXVlTGVuZ3RoICs9IDE7XG4gICAgICAgICAgICBwdXNoSWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlQm9keS5mb3JjZS54ICs9IGZ4O1xuICAgIHNvdXJjZUJvZHkuZm9yY2UueSArPSBmeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEJvZGllcyhib2RpZXMpIHtcbiAgICBpZiggYm9kaWVzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgIGxldCB4MSA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB5MSA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB4MiA9IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICB5MiA9IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICBpLFxuICAgICAgbWF4ID0gYm9kaWVzLmxlbmd0aDtcblxuICAgIC8vIFRvIHJlZHVjZSBxdWFkIHRyZWUgZGVwdGggd2UgYXJlIGxvb2tpbmcgZm9yIGV4YWN0IGJvdW5kaW5nIGJveCBvZiBhbGwgcGFydGljbGVzLlxuICAgIGkgPSBtYXg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgbGV0IHggPSBib2RpZXNbaV0ucG9zLng7XG4gICAgICBsZXQgeSA9IGJvZGllc1tpXS5wb3MueTtcbiAgICAgIGlmICh4IDwgeDEpIHtcbiAgICAgICAgeDEgPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHggPiB4Mikge1xuICAgICAgICB4MiA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeSA8IHkxKSB7XG4gICAgICAgIHkxID0geTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID4geTIpIHtcbiAgICAgICAgeTIgPSB5O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNxdWFyaWZ5IHRoZSBib3VuZHMuXG4gICAgbGV0IGR4ID0geDIgLSB4MSxcbiAgICAgIGR5ID0geTIgLSB5MTtcbiAgICBpZiAoZHggPiBkeSkge1xuICAgICAgeTIgPSB5MSArIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHgxICsgZHk7XG4gICAgfVxuXG4gICAgY3VycmVudEluQ2FjaGUgPSAwO1xuICAgIHJvb3QgPSBuZXdOb2RlKCk7XG4gICAgcm9vdC5sZWZ0ID0geDE7XG4gICAgcm9vdC5yaWdodCA9IHgyO1xuICAgIHJvb3QudG9wID0geTE7XG4gICAgcm9vdC5ib3R0b20gPSB5MjtcblxuICAgIGkgPSBtYXggLSAxO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHJvb3QuYm9keSA9IGJvZGllc1tpXTtcbiAgICB9XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaW5zZXJ0KGJvZGllc1tpXSwgcm9vdCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0KG5ld0JvZHkpIHtcbiAgICBpbnNlcnRTdGFjay5yZXNldCgpO1xuICAgIGluc2VydFN0YWNrLnB1c2gocm9vdCwgbmV3Qm9keSk7XG5cbiAgICB3aGlsZSAoIWluc2VydFN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgbGV0IHN0YWNrSXRlbSA9IGluc2VydFN0YWNrLnBvcCgpLFxuICAgICAgICBub2RlID0gc3RhY2tJdGVtLm5vZGUsXG4gICAgICAgIGJvZHkgPSBzdGFja0l0ZW0uYm9keTtcblxuICAgICAgaWYgKCFub2RlLmJvZHkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlcm5hbCBub2RlLiBVcGRhdGUgdGhlIHRvdGFsIG1hc3Mgb2YgdGhlIG5vZGUgYW5kIGNlbnRlci1vZi1tYXNzLlxuICAgICAgICBsZXQgeCA9IGJvZHkucG9zLng7XG4gICAgICAgIGxldCB5ID0gYm9keS5wb3MueTtcbiAgICAgICAgbm9kZS5tYXNzID0gbm9kZS5tYXNzICsgYm9keS5tYXNzO1xuICAgICAgICBub2RlLm1hc3NYID0gbm9kZS5tYXNzWCArIGJvZHkubWFzcyAqIHg7XG4gICAgICAgIG5vZGUubWFzc1kgPSBub2RlLm1hc3NZICsgYm9keS5tYXNzICogeTtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgdGhlIGJvZHkgaW4gdGhlIGFwcHJvcHJpYXRlIHF1YWRyYW50LlxuICAgICAgICAvLyBCdXQgZmlyc3QgZmluZCB0aGUgYXBwcm9wcmlhdGUgcXVhZHJhbnQuXG4gICAgICAgIGxldCBxdWFkSWR4ID0gMCwgLy8gQXNzdW1lIHdlIGFyZSBpbiB0aGUgMCdzIHF1YWQuXG4gICAgICAgICAgbGVmdCA9IG5vZGUubGVmdCxcbiAgICAgICAgICByaWdodCA9IChub2RlLnJpZ2h0ICsgbGVmdCkgLyAyLFxuICAgICAgICAgIHRvcCA9IG5vZGUudG9wLFxuICAgICAgICAgIGJvdHRvbSA9IChub2RlLmJvdHRvbSArIHRvcCkgLyAyO1xuXG4gICAgICAgIGlmICh4ID4gcmlnaHQpIHsgLy8gc29tZXdoZXJlIGluIHRoZSBlYXN0ZXJuIHBhcnQuXG4gICAgICAgICAgcXVhZElkeCA9IHF1YWRJZHggKyAxO1xuICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiBib3R0b20pIHsgLy8gYW5kIGluIHNvdXRoLlxuICAgICAgICAgIHF1YWRJZHggPSBxdWFkSWR4ICsgMjtcbiAgICAgICAgICB0b3AgPSBib3R0b207XG4gICAgICAgICAgYm90dG9tID0gbm9kZS5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hpbGQgPSBnZXRDaGlsZChub2RlLCBxdWFkSWR4KTtcbiAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgIC8vIFRoZSBub2RlIGlzIGludGVybmFsIGJ1dCB0aGlzIHF1YWRyYW50IGlzIG5vdCB0YWtlbi4gQWRkXG4gICAgICAgICAgLy8gc3Vibm9kZSB0byBpdC5cbiAgICAgICAgICBjaGlsZCA9IG5ld05vZGUoKTtcbiAgICAgICAgICBjaGlsZC5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICBjaGlsZC50b3AgPSB0b3A7XG4gICAgICAgICAgY2hpbGQucmlnaHQgPSByaWdodDtcbiAgICAgICAgICBjaGlsZC5ib3R0b20gPSBib3R0b207XG4gICAgICAgICAgY2hpbGQuYm9keSA9IGJvZHk7XG5cbiAgICAgICAgICBzZXRDaGlsZChub2RlLCBxdWFkSWR4LCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29udGludWUgc2VhcmNoaW5nIGluIHRoaXMgcXVhZHJhbnQuXG4gICAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChjaGlsZCwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gYWRkIHRvIHRoZSBsZWFmIG5vZGUuXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gY29udmVydCBjdXJyZW50IGxlYWYgaW50byBpbnRlcm5hbCBub2RlXG4gICAgICAgIC8vIGFuZCBjb250aW51ZSBhZGRpbmcgdHdvIG5vZGVzLlxuICAgICAgICBsZXQgb2xkQm9keSA9IG5vZGUuYm9keTtcbiAgICAgICAgbm9kZS5ib2R5ID0gbnVsbDsgLy8gaW50ZXJuYWwgbm9kZXMgZG8gbm90IGNhcnkgYm9kaWVzXG5cbiAgICAgICAgaWYgKGlzU2FtZVBvc2l0aW9uKG9sZEJvZHkucG9zLCBib2R5LnBvcykpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIHN1YmRpdmlzaW9uIGJ5IGJ1bXBpbmcgb25lIG5vZGVcbiAgICAgICAgICAvLyBhbnl3aGVyZSBpbiB0aGlzIHF1YWRyYW50XG4gICAgICAgICAgbGV0IHJldHJpZXNDb3VudCA9IDM7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBsZXQgZHggPSAobm9kZS5yaWdodCAtIG5vZGUubGVmdCkgKiBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgZHkgPSAobm9kZS5ib3R0b20gLSBub2RlLnRvcCkgKiBvZmZzZXQ7XG5cbiAgICAgICAgICAgIG9sZEJvZHkucG9zLnggPSBub2RlLmxlZnQgKyBkeDtcbiAgICAgICAgICAgIG9sZEJvZHkucG9zLnkgPSBub2RlLnRvcCArIGR5O1xuICAgICAgICAgICAgcmV0cmllc0NvdW50IC09IDE7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgYnVtcCBpdCBvdXQgb2YgdGhlIGJveC4gSWYgd2UgZG8sIG5leHQgaXRlcmF0aW9uIHNob3VsZCBmaXggaXRcbiAgICAgICAgICB9IHdoaWxlIChyZXRyaWVzQ291bnQgPiAwICYmIGlzU2FtZVBvc2l0aW9uKG9sZEJvZHkucG9zLCBib2R5LnBvcykpO1xuXG4gICAgICAgICAgaWYgKHJldHJpZXNDb3VudCA9PT0gMCAmJiBpc1NhbWVQb3NpdGlvbihvbGRCb2R5LnBvcywgYm9keS5wb3MpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHZlcnkgYmFkLCB3ZSByYW4gb3V0IG9mIHByZWNpc2lvbi5cbiAgICAgICAgICAgIC8vIGlmIHdlIGRvIG5vdCByZXR1cm4gZnJvbSB0aGUgbWV0aG9kIHdlJ2xsIGdldCBpbnRvXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSBsb29wIGhlcmUuIFNvIHdlIHNhY3JpZmljZSBjb3JyZWN0bmVzcyBvZiBsYXlvdXQsIGFuZCBrZWVwIHRoZSBhcHAgcnVubmluZ1xuICAgICAgICAgICAgLy8gTmV4dCBsYXlvdXQgaXRlcmF0aW9uIHNob3VsZCBnZXQgbGFyZ2VyIGJvdW5kaW5nIGJveCBpbiB0aGUgZmlyc3Qgc3RlcCBhbmQgZml4IHRoaXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCBpdGVyYXRpb24gc2hvdWxkIHN1YmRpdmlkZSBub2RlIGZ1cnRoZXIuXG4gICAgICAgIGluc2VydFN0YWNrLnB1c2gobm9kZSwgb2xkQm9keSk7XG4gICAgICAgIGluc2VydFN0YWNrLnB1c2gobm9kZSwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRCb2RpZXM6IGluc2VydEJvZGllcyxcbiAgICB1cGRhdGVCb2R5Rm9yY2U6IHVwZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZChub2RlLCBpZHgpIHtcbiAgaWYgKGlkeCA9PT0gMCkgcmV0dXJuIG5vZGUucXVhZDA7XG4gIGlmIChpZHggPT09IDEpIHJldHVybiBub2RlLnF1YWQxO1xuICBpZiAoaWR4ID09PSAyKSByZXR1cm4gbm9kZS5xdWFkMjtcbiAgaWYgKGlkeCA9PT0gMykgcmV0dXJuIG5vZGUucXVhZDM7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDaGlsZChub2RlLCBpZHgsIGNoaWxkKSB7XG4gIGlmIChpZHggPT09IDApIG5vZGUucXVhZDAgPSBjaGlsZDtcbiAgZWxzZSBpZiAoaWR4ID09PSAxKSBub2RlLnF1YWQxID0gY2hpbGQ7XG4gIGVsc2UgaWYgKGlkeCA9PT0gMikgbm9kZS5xdWFkMiA9IGNoaWxkO1xuICBlbHNlIGlmIChpZHggPT09IDMpIG5vZGUucXVhZDMgPSBjaGlsZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IG1ha2VRdWFkdHJlZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V1bGVyL3F1YWR0cmVlL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBJbnNlcnRTdGFjaztcblxuLyoqXG4gKiBPdXIgaW1wbG1lbnRhdGlvbiBvZiBRdWFkVHJlZSBpcyBub24tcmVjdXJzaXZlIHRvIGF2b2lkIEdDIGhpdFxuICogVGhpcyBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnQgc3RhY2sgb2YgZWxlbWVudHNcbiAqIHdoaWNoIHdlIGFyZSB0cnlpbmcgdG8gaW5zZXJ0IGludG8gcXVhZCB0cmVlLlxuICovXG5mdW5jdGlvbiBJbnNlcnRTdGFjayAoKSB7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMucG9wSWR4ID0gMDtcbn1cblxuSW5zZXJ0U3RhY2sucHJvdG90eXBlID0ge1xuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3BJZHggPT09IDA7XG4gICAgfSxcbiAgICBwdXNoOiBmdW5jdGlvbiAobm9kZSwgYm9keSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuc3RhY2tbdGhpcy5wb3BJZHhdO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSB0cnlpbmcgdG8gYXZvaWQgbWVtb3J5IHByZXNzdWU6IGNyZWF0ZSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgLy8gb25seSB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMucG9wSWR4XSA9IG5ldyBJbnNlcnRTdGFja0VsZW1lbnQobm9kZSwgYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaXRlbS5ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMucG9wSWR4O1xuICAgIH0sXG4gICAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcElkeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrWy0tdGhpcy5wb3BJZHhdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvcElkeCA9IDA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gSW5zZXJ0U3RhY2tFbGVtZW50KG5vZGUsIGJvZHkpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlOyAvLyBRdWFkVHJlZSBub2RlXG4gICAgdGhpcy5ib2R5ID0gYm9keTsgLy8gcGh5c2ljYWwgYm9keSB3aGljaCBuZWVkcyB0byBiZSBpbnNlcnRlZCB0byBub2RlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXVsZXIvcXVhZHRyZWUvaW5zZXJ0U3RhY2suanMiLCIvKipcbiAqIEludGVybmFsIGRhdGEgc3RydWN0dXJlIHRvIHJlcHJlc2VudCAyRCBRdWFkVHJlZSBub2RlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gTm9kZSgpIHtcbiAgLy8gYm9keSBzdG9yZWQgaW5zaWRlIHRoaXMgbm9kZS4gSW4gcXVhZCB0cmVlIG9ubHkgbGVhZiBub2RlcyAoYnkgY29uc3RydWN0aW9uKVxuICAvLyBjb250YWluIGJvaWRlczpcbiAgdGhpcy5ib2R5ID0gbnVsbDtcblxuICAvLyBDaGlsZCBub2RlcyBhcmUgc3RvcmVkIGluIHF1YWRzLiBFYWNoIHF1YWQgaXMgcHJlc2VudGVkIGJ5IG51bWJlcjpcbiAgLy8gMCB8IDFcbiAgLy8gLS0tLS1cbiAgLy8gMiB8IDNcbiAgdGhpcy5xdWFkMCA9IG51bGw7XG4gIHRoaXMucXVhZDEgPSBudWxsO1xuICB0aGlzLnF1YWQyID0gbnVsbDtcbiAgdGhpcy5xdWFkMyA9IG51bGw7XG5cbiAgLy8gVG90YWwgbWFzcyBvZiBjdXJyZW50IG5vZGVcbiAgdGhpcy5tYXNzID0gMDtcblxuICAvLyBDZW50ZXIgb2YgbWFzcyBjb29yZGluYXRlc1xuICB0aGlzLm1hc3NYID0gMDtcbiAgdGhpcy5tYXNzWSA9IDA7XG5cbiAgLy8gYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzXG4gIHRoaXMubGVmdCA9IDA7XG4gIHRoaXMudG9wID0gMDtcbiAgdGhpcy5ib3R0b20gPSAwO1xuICB0aGlzLnJpZ2h0ID0gMDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXVsZXIvcXVhZHRyZWUvbm9kZS5qcyIsImNvbnN0IHsgaW50ZWdyYXRlIH0gPSByZXF1aXJlKCcuL2ludGVncmF0ZScpO1xuY29uc3QgeyBhcHBseURyYWcgfSA9IHJlcXVpcmUoJy4vZHJhZycpO1xuY29uc3QgeyBhcHBseVNwcmluZyB9ID0gcmVxdWlyZSgnLi9zcHJpbmcnKTtcblxuZnVuY3Rpb24gdGljayh7IGJvZGllcywgc3ByaW5ncywgcXVhZHRyZWUsIHRpbWVTdGVwLCBncmF2aXR5LCB0aGV0YSwgZHJhZ0NvZWZmLCBwdWxsIH0pe1xuICAvLyB1cGRhdGUgYm9keSBmcm9tIHNjcmF0Y2ggaW4gY2FzZSBvZiBhbnkgY2hhbmdlc1xuICBib2RpZXMuZm9yRWFjaCggYm9keSA9PiB7XG4gICAgbGV0IHAgPSBib2R5Ll9zY3JhdGNoO1xuXG4gICAgaWYoICFwICl7IHJldHVybjsgfVxuXG4gICAgYm9keS5sb2NrZWQgPSBwLmxvY2tlZDtcbiAgICBib2R5LmdyYWJiZWQgPSBwLmdyYWJiZWQ7XG4gICAgYm9keS5wb3MueCA9IHAueDtcbiAgICBib2R5LnBvcy55ID0gcC55O1xuICB9ICk7XG5cbiAgcXVhZHRyZWUuaW5zZXJ0Qm9kaWVzKCBib2RpZXMgKTtcblxuICBmb3IoIGxldCBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKyApe1xuICAgIGxldCBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgcXVhZHRyZWUudXBkYXRlQm9keUZvcmNlKCBib2R5LCBncmF2aXR5LCB0aGV0YSwgcHVsbCApO1xuICAgIGFwcGx5RHJhZyggYm9keSwgZHJhZ0NvZWZmICk7XG4gIH1cblxuICBmb3IoIGxldCBpID0gMDsgaSA8IHNwcmluZ3MubGVuZ3RoOyBpKysgKXtcbiAgICBsZXQgc3ByaW5nID0gc3ByaW5nc1tpXTtcblxuICAgIGFwcGx5U3ByaW5nKCBzcHJpbmcgKTtcbiAgfVxuXG4gIGxldCBtb3ZlbWVudCA9IGludGVncmF0ZSggYm9kaWVzLCB0aW1lU3RlcCApO1xuXG4gIC8vIHVwZGF0ZSBzY3JhdGNoIHBvc2l0aW9ucyBmcm9tIGJvZHkgcG9zaXRpb25zXG4gIGJvZGllcy5mb3JFYWNoKCBib2R5ID0+IHtcbiAgICBsZXQgcCA9IGJvZHkuX3NjcmF0Y2g7XG5cbiAgICBpZiggIXAgKXsgcmV0dXJuOyB9XG5cbiAgICBwLnggPSBib2R5LnBvcy54O1xuICAgIHAueSA9IGJvZHkucG9zLnk7XG4gIH0gKTtcblxuICByZXR1cm4gbW92ZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyB0aWNrIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXVsZXIvdGljay5qcyIsImNvbnN0IEV1bGVyID0gcmVxdWlyZSgnLi9ldWxlcicpO1xuXG4vLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG5sZXQgcmVnaXN0ZXIgPSBmdW5jdGlvbiggY3l0b3NjYXBlICl7XG4gIGlmKCAhY3l0b3NjYXBlICl7IHJldHVybjsgfSAvLyBjYW4ndCByZWdpc3RlciBpZiBjeXRvc2NhcGUgdW5zcGVjaWZpZWRcblxuICBjeXRvc2NhcGUoICdsYXlvdXQnLCAnZXVsZXInLCBFdWxlciApOyAvLyByZWdpc3RlciB3aXRoIGN5dG9zY2FwZS5qc1xufTtcblxuaWYoIHR5cGVvZiBjeXRvc2NhcGUgIT09ICd1bmRlZmluZWQnICl7IC8vIGV4cG9zZSB0byBnbG9iYWwgY3l0b3NjYXBlIChpLmUuIHdpbmRvdy5jeXRvc2NhcGUpXG4gIHJlZ2lzdGVyKCBjeXRvc2NhcGUgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIi8vIGdlbmVyYWwgZGVmYXVsdCBvcHRpb25zIGZvciBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nOyBzcGVjaWFsICdlbmQnIHZhbHVlIG1ha2VzIHRoZSBsYXlvdXQgYW5pbWF0ZSBsaWtlIGEgZGlzY3JldGUgbGF5b3V0XG4gIHJlZnJlc2g6IDEwLCAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gIG1heEl0ZXJhdGlvbnM6IDEwMDAsIC8vIG1heCBpdGVyYXRpb25zIGJlZm9yZSB0aGUgbGF5b3V0IHdpbGwgYmFpbCBvdXRcbiAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSwgLy8gc28geW91IGNhbid0IGRyYWcgbm9kZXMgZHVyaW5nIGxheW91dFxuICBmaXQ6IHRydWUsIC8vIG9uIGV2ZXJ5IGxheW91dCByZXBvc2l0aW9uIG9mIG5vZGVzLCBmaXQgdGhlIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIGFyb3VuZCB0aGUgc2ltdWxhdGlvblxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cblxuICAvLyBsYXlvdXQgZXZlbnQgY2FsbGJhY2tzXG4gIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0c3RvcFxuXG4gIC8vIHBvc2l0aW9uaW5nIG9wdGlvbnNcbiAgcmFuZG9taXplOiBmYWxzZSwgLy8gdXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG4gIFxuICAvLyBpbmZpbml0ZSBsYXlvdXQgb3B0aW9uc1xuICBpbmZpbml0ZTogZmFsc2UgLy8gb3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGZvciBhIGZvcmNlcy1hbGwtdGhlLXRpbWUgbW9kZVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5b3V0L2RlZmF1bHRzLmpzIiwiLyoqXG5BIGdlbmVyaWMgY29udGludW91cyBsYXlvdXQgY2xhc3NcbiovXG5cbmNvbnN0IGFzc2lnbiA9IHJlcXVpcmUoJy4uL2Fzc2lnbicpO1xuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5jb25zdCBtYWtlQm91bmRpbmdCb3ggPSByZXF1aXJlKCcuL21ha2UtYmInKTtcbmNvbnN0IHsgc2V0SW5pdGlhbFBvc2l0aW9uU3RhdGUsIHJlZnJlc2hQb3NpdGlvbnMsIGdldE5vZGVQb3NpdGlvbkRhdGEgfSA9IHJlcXVpcmUoJy4vcG9zaXRpb24nKTtcbmNvbnN0IHsgbXVsdGl0aWNrIH0gPSByZXF1aXJlKCcuL3RpY2snKTtcblxuY2xhc3MgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKXtcbiAgICBsZXQgbyA9IHRoaXMub3B0aW9ucyA9IGFzc2lnbigge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG5cbiAgICBsZXQgcyA9IHRoaXMuc3RhdGUgPSBhc3NpZ24oIHt9LCBvLCB7XG4gICAgICBsYXlvdXQ6IHRoaXMsXG4gICAgICBub2Rlczogby5lbGVzLm5vZGVzKCksXG4gICAgICBlZGdlczogby5lbGVzLmVkZ2VzKCksXG4gICAgICB0aWNrSW5kZXg6IDAsXG4gICAgICBmaXJzdFVwZGF0ZTogdHJ1ZVxuICAgIH0gKTtcblxuICAgIHMuYW5pbWF0ZUVuZCA9IG8uYW5pbWF0ZSAmJiBvLmFuaW1hdGUgPT09ICdlbmQnO1xuICAgIHMuYW5pbWF0ZUNvbnRpbnVvdXNseSA9IG8uYW5pbWF0ZSAmJiAhcy5hbmltYXRlRW5kO1xuICB9XG5cbiAgcnVuKCl7XG4gICAgbGV0IGwgPSB0aGlzO1xuICAgIGxldCBzID0gdGhpcy5zdGF0ZTtcblxuICAgIHMudGlja0luZGV4ID0gMDtcbiAgICBzLmZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHMuY3VycmVudEJvdW5kaW5nQm94ID0gbWFrZUJvdW5kaW5nQm94KCBzLmJvdW5kaW5nQm94LCBzLmN5ICk7XG5cbiAgICBpZiggcy5yZWFkeSApeyBsLm9uZSggJ3JlYWR5Jywgcy5yZWFkeSApOyB9XG4gICAgaWYoIHMuc3RvcCApeyBsLm9uZSggJ3N0b3AnLCBzLnN0b3AgKTsgfVxuXG4gICAgcy5ub2Rlcy5mb3JFYWNoKCBuID0+IHNldEluaXRpYWxQb3NpdGlvblN0YXRlKCBuLCBzICkgKTtcblxuICAgIGwucHJlcnVuKCBzICk7XG5cbiAgICBpZiggcy5hbmltYXRlQ29udGludW91c2x5ICl7XG4gICAgICBsZXQgdW5ncmFiaWZ5ID0gbm9kZSA9PiB7XG4gICAgICAgIGlmKCAhcy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgbGV0IGdyYWJiYWJsZSA9IGdldE5vZGVQb3NpdGlvbkRhdGEoIG5vZGUsIHMgKS5ncmFiYmFibGUgPSBub2RlLmdyYWJiYWJsZSgpO1xuXG4gICAgICAgIGlmKCBncmFiYmFibGUgKXtcbiAgICAgICAgICBub2RlLnVuZ3JhYmlmeSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsZXQgcmVncmFiaWZ5ID0gbm9kZSA9PiB7XG4gICAgICAgIGlmKCAhcy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgbGV0IGdyYWJiYWJsZSA9IGdldE5vZGVQb3NpdGlvbkRhdGEoIG5vZGUsIHMgKS5ncmFiYmFibGU7XG5cbiAgICAgICAgaWYoIGdyYWJiYWJsZSApe1xuICAgICAgICAgIG5vZGUuZ3JhYmlmeSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsZXQgdXBkYXRlR3JhYlN0YXRlID0gbm9kZSA9PiBnZXROb2RlUG9zaXRpb25EYXRhKCBub2RlLCBzICkuZ3JhYmJlZCA9IG5vZGUuZ3JhYmJlZCgpO1xuXG4gICAgICBsZXQgb25HcmFiID0gZnVuY3Rpb24oeyB0YXJnZXQgfSl7XG4gICAgICAgIHVwZGF0ZUdyYWJTdGF0ZSggdGFyZ2V0ICk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgb25GcmVlID0gb25HcmFiO1xuXG4gICAgICBsZXQgb25EcmFnID0gZnVuY3Rpb24oeyB0YXJnZXQgfSl7XG4gICAgICAgIGxldCBwID0gZ2V0Tm9kZVBvc2l0aW9uRGF0YSggdGFyZ2V0LCBzICk7XG4gICAgICAgIGxldCB0cCA9IHRhcmdldC5wb3NpdGlvbigpO1xuXG4gICAgICAgIHAueCA9IHRwLng7XG4gICAgICAgIHAueSA9IHRwLnk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgbGlzdGVuVG9HcmFiID0gbm9kZSA9PiB7XG4gICAgICAgIG5vZGUub24oJ2dyYWInLCBvbkdyYWIpO1xuICAgICAgICBub2RlLm9uKCdmcmVlJywgb25GcmVlKTtcbiAgICAgICAgbm9kZS5vbignZHJhZycsIG9uRHJhZyk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgdW5saXN0ZW5Ub0dyYWIgPSBub2RlID0+IHtcbiAgICAgICAgbm9kZS5yZW1vdmVMaXN0ZW5lcignZ3JhYicsIG9uR3JhYik7XG4gICAgICAgIG5vZGUucmVtb3ZlTGlzdGVuZXIoJ2ZyZWUnLCBvbkZyZWUpO1xuICAgICAgICBub2RlLnJlbW92ZUxpc3RlbmVyKCdkcmFnJywgb25EcmFnKTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBmaXQgPSAoKSA9PiB7XG4gICAgICAgIGlmKCBzLmZpdCAmJiBzLmFuaW1hdGVDb250aW51b3VzbHkgKXtcbiAgICAgICAgICBzLmN5LmZpdCggcy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGxldCBvbk5vdERvbmUgPSAoKSA9PiB7XG4gICAgICAgIHJlZnJlc2hQb3NpdGlvbnMoIHMubm9kZXMsIHMgKTtcbiAgICAgICAgZml0KCk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgfTtcblxuICAgICAgbGV0IGZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbXVsdGl0aWNrKCBzLCBvbk5vdERvbmUsIG9uRG9uZSApO1xuICAgICAgfTtcblxuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgICAgcmVmcmVzaFBvc2l0aW9ucyggcy5ub2RlcywgcyApO1xuICAgICAgICBmaXQoKTtcblxuICAgICAgICBzLm5vZGVzLmZvckVhY2goIG4gPT4ge1xuICAgICAgICAgIHJlZ3JhYmlmeSggbiApO1xuICAgICAgICAgIHVubGlzdGVuVG9HcmFiKCBuICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgICBzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICBsLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICAgIH07XG5cbiAgICAgIGwuZW1pdCgnbGF5b3V0c3RhcnQnKTtcblxuICAgICAgcy5ub2Rlcy5mb3JFYWNoKCBuID0+IHtcbiAgICAgICAgdW5ncmFiaWZ5KCBuICk7XG4gICAgICAgIGxpc3RlblRvR3JhYiggbiApO1xuICAgICAgfSApO1xuXG4gICAgICBmcmFtZSgpOyAvLyBraWNrIG9mZlxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IG9uTm90RG9uZSA9ICgpID0+IHt9O1xuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IGRvbmUgPSB0cnVlO1xuXG4gICAgICB3aGlsZSggIWRvbmUgKXtcbiAgICAgICAgbXVsdGl0aWNrKCBzLCBvbk5vdERvbmUsIG9uRG9uZSApO1xuICAgICAgfVxuXG4gICAgICBzLmVsZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBzLCBub2RlID0+IHtcbiAgICAgICAgbGV0IHBkID0gZ2V0Tm9kZVBvc2l0aW9uRGF0YSggbm9kZSwgcyApO1xuXG4gICAgICAgIHJldHVybiB7IHg6IHBkLngsIHk6IHBkLnkgfTtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICBsLnBvc3RydW4oIHMgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG5cbiAgcHJlcnVuKCl7fVxuICBwb3N0cnVuKCl7fVxuICB0aWNrKCl7fVxuXG4gIHN0b3AoKXtcbiAgICB0aGlzLnN0YXRlLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG5cbiAgZGVzdHJveSgpe1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheW91dC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIGJiLCBjeSApe1xuICBpZiggYmIgPT0gbnVsbCApe1xuICAgIGJiID0geyB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpIH07XG4gIH0gZWxzZSB7IC8vIGNvcHlcbiAgICBiYiA9IHsgeDE6IGJiLngxLCB4MjogYmIueDIsIHkxOiBiYi55MSwgeTI6IGJiLnkyLCB3OiBiYi53LCBoOiBiYi5oIH07XG4gIH1cblxuICBpZiggYmIueDIgPT0gbnVsbCApeyBiYi54MiA9IGJiLngxICsgYmIudzsgfVxuICBpZiggYmIudyA9PSBudWxsICl7IGJiLncgPSBiYi54MiAtIGJiLngxOyB9XG4gIGlmKCBiYi55MiA9PSBudWxsICl7IGJiLnkyID0gYmIueTEgKyBiYi5oOyB9XG4gIGlmKCBiYi5oID09IG51bGwgKXsgYmIuaCA9IGJiLnkyIC0gYmIueTE7IH1cblxuICByZXR1cm4gYmI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheW91dC9tYWtlLWJiLmpzIiwiY29uc3QgYXNzaWduID0gcmVxdWlyZSgnLi4vYXNzaWduJyk7XG5cbmxldCBzZXRJbml0aWFsUG9zaXRpb25TdGF0ZSA9IGZ1bmN0aW9uKCBub2RlLCBzdGF0ZSApe1xuICBsZXQgcCA9IG5vZGUucG9zaXRpb24oKTtcbiAgbGV0IGJiID0gc3RhdGUuY3VycmVudEJvdW5kaW5nQm94O1xuICBsZXQgc2NyYXRjaCA9IG5vZGUuc2NyYXRjaCggc3RhdGUubmFtZSApO1xuXG4gIGlmKCBzY3JhdGNoID09IG51bGwgKXtcbiAgICBzY3JhdGNoID0ge307XG5cbiAgICBub2RlLnNjcmF0Y2goIHN0YXRlLm5hbWUsIHNjcmF0Y2ggKTtcbiAgfVxuXG4gIGFzc2lnbiggc2NyYXRjaCwgc3RhdGUucmFuZG9taXplID8ge1xuICAgIHg6IGJiLngxICsgTWF0aC5yYW5kb20oKSAqIGJiLncsXG4gICAgeTogYmIueTEgKyBNYXRoLnJhbmRvbSgpICogYmIuaFxuICB9IDoge1xuICAgIHg6IHAueCxcbiAgICB5OiBwLnlcbiAgfSApO1xuXG4gIHNjcmF0Y2gubG9ja2VkID0gbm9kZS5sb2NrZWQoKTtcbn07XG5cbmxldCBnZXROb2RlUG9zaXRpb25EYXRhID0gZnVuY3Rpb24oIG5vZGUsIHN0YXRlICl7XG4gIHJldHVybiBub2RlLnNjcmF0Y2goIHN0YXRlLm5hbWUgKTtcbn07XG5cbmxldCByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24oIG5vZGVzLCBzdGF0ZSApe1xuICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24oIG5vZGUgKXtcbiAgICBsZXQgc2NyYXRjaCA9IG5vZGUuc2NyYXRjaCggc3RhdGUubmFtZSApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHNjcmF0Y2gueCxcbiAgICAgIHk6IHNjcmF0Y2gueVxuICAgIH07XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHNldEluaXRpYWxQb3NpdGlvblN0YXRlLCBnZXROb2RlUG9zaXRpb25EYXRhLCByZWZyZXNoUG9zaXRpb25zIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5b3V0L3Bvc2l0aW9uLmpzIiwiY29uc3Qgbm9wID0gZnVuY3Rpb24oKXt9O1xuXG5sZXQgdGljayA9IGZ1bmN0aW9uKCBzdGF0ZSApe1xuICBsZXQgcyA9IHN0YXRlO1xuICBsZXQgbCA9IHN0YXRlLmxheW91dDtcblxuICBsZXQgdGlja0luZGljYXRlc0RvbmUgPSBsLnRpY2soIHMgKTtcblxuICBpZiggcy5maXJzdFVwZGF0ZSApe1xuICAgIGlmKCBzLmFuaW1hdGVDb250aW51b3VzbHkgKXsgLy8gaW5kaWNhdGUgdGhlIGluaXRpYWwgcG9zaXRpb25zIGhhdmUgYmVlbiBzZXRcbiAgICAgIHMubGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7XG4gICAgfVxuICAgIHMuZmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHMudGlja0luZGV4Kys7XG5cbiAgbGV0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHMuc3RhcnRUaW1lO1xuXG4gIHJldHVybiAhcy5pbmZpbml0ZSAmJiAoIHRpY2tJbmRpY2F0ZXNEb25lIHx8IHMudGlja0luZGV4ID49IHMubWF4SXRlcmF0aW9ucyB8fCBkdXJhdGlvbiA+PSBzLm1heFNpbXVsYXRpb25UaW1lICk7XG59O1xuXG5sZXQgbXVsdGl0aWNrID0gZnVuY3Rpb24oIHN0YXRlLCBvbk5vdERvbmUgPSBub3AsIG9uRG9uZSA9IG5vcCApe1xuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBsZXQgcyA9IHN0YXRlO1xuXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgcy5yZWZyZXNoOyBpKysgKXtcbiAgICBkb25lID0gIXMucnVubmluZyB8fCB0aWNrKCBzICk7XG5cbiAgICBpZiggZG9uZSApeyBicmVhazsgfVxuICB9XG5cbiAgaWYoICFkb25lICl7XG4gICAgb25Ob3REb25lKCk7XG4gIH0gZWxzZSB7XG4gICAgb25Eb25lKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0aWNrLCBtdWx0aXRpY2sgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYXlvdXQvdGljay5qcyJdLCJzb3VyY2VSb290IjoiIn0=

/***/ }),

/***/ "./node_modules/cytoscape/dist/cytoscape.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.cjs.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/**
 * Copyright (c) 2016-2019, The Cytoscape Consortium.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the âSoftwareâ), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED âAS ISâ, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var util = _interopDefault(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
var Heap = _interopDefault(__webpack_require__(/*! heap */ "./node_modules/heap/index.js"));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

var navigator = window$1 ? window$1.navigator : null;
var document$1 = window$1 ? window$1.document : null;

var typeofstr = _typeof('');

var typeofobj = _typeof({});

var typeoffn = _typeof(function () {});

var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);

var instanceStr = function instanceStr(obj) {
  return obj && obj.instanceString && fn(obj.instanceString) ? obj.instanceString() : null;
};

var string = function string(obj) {
  return obj != null && _typeof(obj) == typeofstr;
};
var fn = function fn(obj) {
  return obj != null && _typeof(obj) === typeoffn;
};
var array = function array(obj) {
  return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
};
var plainObject = function plainObject(obj) {
  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
};
var object = function object(obj) {
  return obj != null && _typeof(obj) === typeofobj;
};
var number = function number(obj) {
  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
};
var integer = function integer(obj) {
  return number(obj) && Math.floor(obj) === obj;
};
var htmlElement = function htmlElement(obj) {
  if ('undefined' === typeofhtmlele) {
    return undefined;
  } else {
    return null != obj && obj instanceof HTMLElement;
  }
};
var elementOrCollection = function elementOrCollection(obj) {
  return element(obj) || collection(obj);
};
var element = function element(obj) {
  return instanceStr(obj) === 'collection' && obj._private.single;
};
var collection = function collection(obj) {
  return instanceStr(obj) === 'collection' && !obj._private.single;
};
var core = function core(obj) {
  return instanceStr(obj) === 'core';
};
var stylesheet = function stylesheet(obj) {
  return instanceStr(obj) === 'stylesheet';
};
var event = function event(obj) {
  return instanceStr(obj) === 'event';
};
var emptyString = function emptyString(obj) {
  if (obj === undefined || obj === null) {
    // null is empty
    return true;
  } else if (obj === '' || obj.match(/^\s+$/)) {
    return true; // empty string is empty
  }

  return false; // otherwise, we don't know what we've got
};
var domElement = function domElement(obj) {
  if (typeof HTMLElement === 'undefined') {
    return false; // we're not in a browser so it doesn't matter
  } else {
    return obj instanceof HTMLElement;
  }
};
var boundingBox = function boundingBox(obj) {
  return plainObject(obj) && number(obj.x1) && number(obj.x2) && number(obj.y1) && number(obj.y2);
};
var promise = function promise(obj) {
  return object(obj) && fn(obj.then);
};
var ms = function ms() {
  return navigator && navigator.userAgent.match(/msie|trident|edge/i);
}; // probably a better way to detect this...

var memoize = function memoize(fn, keyFn) {
  if (!keyFn) {
    keyFn = function keyFn() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return 'undefined';
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      return args.join('$');
    };
  }

  var memoizedFn = function memoizedFn() {
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply(self, args);
    var cache = memoizedFn.cache;

    if (!(ret = cache[k])) {
      ret = cache[k] = fn.apply(self, args);
    }

    return ret;
  };

  memoizedFn.cache = {};
  return memoizedFn;
};

var camel2dash = memoize(function (str) {
  return str.replace(/([A-Z])/g, function (v) {
    return '-' + v.toLowerCase();
  });
});
var dash2camel = memoize(function (str) {
  return str.replace(/(-\w)/g, function (v) {
    return v[1].toUpperCase();
  });
});
var prependCamel = memoize(function (prefix, str) {
  return prefix + str[0].toUpperCase() + str.substring(1);
}, function (prefix, str) {
  return prefix + '$' + str;
});
var capitalize = function capitalize(str) {
  if (emptyString(str)) {
    return str;
  }

  return str.charAt(0).toUpperCase() + str.substring(1);
};

var number$1 = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';
var rgba = 'rgb[a]?\\((' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)(?:\\s*,\\s*(' + number$1 + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hsla = 'hsl[a]?\\((' + number$1 + ')\\s*,\\s*(' + number$1 + '[%])\\s*,\\s*(' + number$1 + '[%])(?:\\s*,\\s*(' + number$1 + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number$1 + ')\\s*,\\s*(?:' + number$1 + '[%])\\s*,\\s*(?:' + number$1 + '[%])(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

var ascending = function ascending(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
};
var descending = function descending(a, b) {
  return -1 * ascending(a, b);
};

var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  var args = arguments;

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if (obj == null) {
      continue;
    }

    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];
      tgt[k] = obj[k];
    }
  }

  return tgt;
};

var hex2tuple = function hex2tuple(hex) {
  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
    return;
  }

  var shortHex = hex.length === 4;
  var r, g, b;
  var base = 16;

  if (shortHex) {
    r = parseInt(hex[1] + hex[1], base);
    g = parseInt(hex[2] + hex[2], base);
    b = parseInt(hex[3] + hex[3], base);
  } else {
    r = parseInt(hex[1] + hex[2], base);
    g = parseInt(hex[3] + hex[4], base);
    b = parseInt(hex[5] + hex[6], base);
  }

  return [r, g, b];
}; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)

var hsl2tuple = function hsl2tuple(hsl) {
  var ret;
  var h, s, l, a, r, g, b;

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  var m = new RegExp('^' + hsla + '$').exec(hsl);

  if (m) {
    // get hue
    h = parseInt(m[1]);

    if (h < 0) {
      h = (360 - -1 * h % 360) % 360;
    } else if (h > 360) {
      h = h % 360;
    }

    h /= 360; // normalise on [0, 1]

    s = parseFloat(m[2]);

    if (s < 0 || s > 100) {
      return;
    } // saturation is [0, 100]


    s = s / 100; // normalise on [0, 1]

    l = parseFloat(m[3]);

    if (l < 0 || l > 100) {
      return;
    } // lightness is [0, 100]


    l = l / 100; // normalise on [0, 1]

    a = m[4];

    if (a !== undefined) {
      a = parseFloat(a);

      if (a < 0 || a > 1) {
        return;
      } // alpha is [0, 1]

    } // now, convert to rgb
    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript


    if (s === 0) {
      r = g = b = Math.round(l * 255); // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
      g = Math.round(255 * hue2rgb(p, q, h));
      b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
    }

    ret = [r, g, b, a];
  }

  return ret;
}; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)

var rgb2tuple = function rgb2tuple(rgb) {
  var ret;
  var m = new RegExp('^' + rgba + '$').exec(rgb);

  if (m) {
    ret = [];
    var isPct = [];

    for (var i = 1; i <= 3; i++) {
      var channel = m[i];

      if (channel[channel.length - 1] === '%') {
        isPct[i] = true;
      }

      channel = parseFloat(channel);

      if (isPct[i]) {
        channel = channel / 100 * 255; // normalise to [0, 255]
      }

      if (channel < 0 || channel > 255) {
        return;
      } // invalid channel value


      ret.push(Math.floor(channel));
    }

    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
    var allArePct = isPct[1] && isPct[2] && isPct[3];

    if (atLeastOneIsPct && !allArePct) {
      return;
    } // must all be percent values if one is


    var alpha = m[4];

    if (alpha !== undefined) {
      alpha = parseFloat(alpha);

      if (alpha < 0 || alpha > 1) {
        return;
      } // invalid alpha value


      ret.push(alpha);
    }
  }

  return ret;
};
var colorname2tuple = function colorname2tuple(color) {
  return colors[color.toLowerCase()];
};
var color2tuple = function color2tuple(color) {
  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
};
var colors = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

var setMap = function setMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to set map with object key');
    }

    if (i < keys.length - 1) {
      // extend the map if necessary
      if (obj[key] == null) {
        obj[key] = {};
      }

      obj = obj[key];
    } else {
      // set the value
      obj[key] = options.value;
    }
  }
}; // gets the value in a map even if it's not built in places

var getMap = function getMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to get map with object key');
    }

    obj = obj[key];

    if (obj == null) {
      return obj;
    }
  }

  return obj;
}; // deletes the entry in the map

var performance = window$1 ? window$1.performance : null;
var pnow = performance && performance.now ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

var raf = function () {
  if (window$1) {
    if (window$1.requestAnimationFrame) {
      return function (fn) {
        window$1.requestAnimationFrame(fn);
      };
    } else if (window$1.mozRequestAnimationFrame) {
      return function (fn) {
        window$1.mozRequestAnimationFrame(fn);
      };
    } else if (window$1.webkitRequestAnimationFrame) {
      return function (fn) {
        window$1.webkitRequestAnimationFrame(fn);
      };
    } else if (window$1.msRequestAnimationFrame) {
      return function (fn) {
        window$1.msRequestAnimationFrame(fn);
      };
    }
  }

  return function (fn) {
    if (fn) {
      setTimeout(function () {
        fn(pnow());
      }, 1000 / 60);
    }
  };
}();

var requestAnimationFrame = function requestAnimationFrame(fn) {
  return raf(fn);
};
var performanceNow = pnow;

var DEFAULT_SEED = 5381;
var hashIterableInts = function hashIterableInts(iterator) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  var hash = seed;
  var entry;

  for (;;) {
    entry = iterator.next();

    if (entry.done) {
      break;
    }

    hash = (hash << 5) + hash + entry.value | 0;
  }

  return hash;
};
var hashInt = function hashInt(num) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  return (seed << 5) + seed + num | 0;
};
var hashIntsArray = function hashIntsArray(ints, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = ints.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = ints[i++];
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashString = function hashString(str, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = str.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = str.charCodeAt(i++);
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashStrings = function hashStrings() {
  return hashStringsArray(arguments);
};
var hashStringsArray = function hashStringsArray(strs) {
  var hash;

  for (var i = 0; i < strs.length; i++) {
    var str = strs[i];

    if (i === 0) {
      hash = hashString(str);
    } else {
      hash = hashString(str, hash);
    }
  }

  return hash;
};

/*global console */
var warningsEnabled = true;
var warnSupported = console.warn != null; // eslint-disable-line no-console

var traceSupported = console.trace != null; // eslint-disable-line no-console

var MAX_INT = Number.MAX_SAFE_INTEGER || 9007199254740991;
var trueify = function trueify() {
  return true;
};
var falsify = function falsify() {
  return false;
};
var zeroify = function zeroify() {
  return 0;
};
var noop = function noop() {};
var error = function error(msg) {
  throw new Error(msg);
};
var warnings = function warnings(enabled) {
  if (enabled !== undefined) {
    warningsEnabled = !!enabled;
  } else {
    return warningsEnabled;
  }
};
var warn = function warn(msg) {
  /* eslint-disable no-console */
  if (!warnings()) {
    return;
  }

  if (warnSupported) {
    console.warn(msg);
  } else {
    console.log(msg);

    if (traceSupported) {
      console.trace();
    }
  }
};
/* eslint-enable */

var clone = function clone(obj) {
  return extend({}, obj);
}; // gets a shallow copy of the argument

var copy = function copy(obj) {
  if (obj == null) {
    return obj;
  }

  if (array(obj)) {
    return obj.slice();
  } else if (plainObject(obj)) {
    return clone(obj);
  } else {
    return obj;
  }
};
var copyArray = function copyArray(arr) {
  return arr.slice();
};
var uuid = function uuid(a, b
/* placeholders */
) {
  for ( // loop :)
  b = a = ''; // b - result , a - numeric letiable
  a++ < 36; //
  b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
  ? //  return a random number or 4
  (a ^ 15 // if "a" is not 15
  ? // genetate a random number from 0 to 15
  8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
  : 4 //  otherwise 4
  ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
  ) {
  }

  return b;
};
var _staticEmptyObject = {};
var staticEmptyObject = function staticEmptyObject() {
  return _staticEmptyObject;
};
var defaults = function defaults(_defaults) {
  var keys = Object.keys(_defaults);
  return function (opts) {
    var filledOpts = {};

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var optVal = opts == null ? undefined : opts[key];
      filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
    }

    return filledOpts;
  };
};
var removeFromArray = function removeFromArray(arr, ele, manyCopies) {
  for (var i = arr.length; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);

      if (!manyCopies) {
        break;
      }
    }
  }
};
var clearArray = function clearArray(arr) {
  arr.splice(0, arr.length);
};
var push = function push(arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];
    arr.push(el);
  }
};
var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[propName];
};
var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[propName] = value;
};

/* global Map */
var ObjectMap =
/*#__PURE__*/
function () {
  function ObjectMap() {
    _classCallCheck(this, ObjectMap);

    this._obj = {};
  }

  _createClass(ObjectMap, [{
    key: "set",
    value: function set(key, val) {
      this._obj[key] = val;
      return this;
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this._obj[key] = undefined;
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._obj[key] !== undefined;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._obj[key];
    }
  }]);

  return ObjectMap;
}();

var Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;

/* global Set */
var undef =  "undefined" ;

var ObjectSet =
/*#__PURE__*/
function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);
    this.size = 0;

    if (arrayOrObjectSet != null) {
      var arr;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: "instanceString",
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: "add",
    value: function add(val) {
      var o = this._obj;

      if (o[val] !== 1) {
        o[val] = 1;
        this.size++;
      }
    }
  }, {
    key: "delete",
    value: function _delete(val) {
      var o = this._obj;

      if (o[val] === 1) {
        o[val] = 0;
        this.size--;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: "has",
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: "forEach",
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }]);

  return ObjectSet;
}();

var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;

var Element = function Element(cy, params, restore) {
  restore = restore === undefined || restore ? true : false;

  if (cy === undefined || params === undefined || !core(cy)) {
    error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group; // try to automatically infer the group if unspecified

  if (group == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group = 'edges';
    } else {
      group = 'nodes';
    }
  } // validate group


  if (group !== 'nodes' && group !== 'edges') {
    error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  } // make the element array-like, just like a collection


  this.length = 1;
  this[0] = this; // NOTE: when something is added here, add also to ele.json()

  var _p = this._private = {
    cy: cy,
    single: true,
    // indicates this is an element
    data: params.data || {},
    // data object
    position: params.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: undefined,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: group,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: true,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false,
    // whether it's selected
    selectable: params.selectable === undefined ? true : params.selectable ? true : false,
    // whether it's selectable
    locked: params.locked ? true : false,
    // whether the element is locked (cannot be moved)
    grabbed: false,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
    // whether the element can be grabbed
    pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,
    // whether the element has passthrough panning enabled
    active: false,
    // whether the element is active from user interaction
    classes: new Set$1(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: params.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: false,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      'mid-source': null,
      'mid-target': null
    }
  };

  if (_p.position.x == null) {
    _p.position.x = 0;
  }

  if (_p.position.y == null) {
    _p.position.y = 0;
  } // renderedPosition overrides if specified


  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();
    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  var classes = [];

  if (array(params.classes)) {
    classes = params.classes;
  } else if (string(params.classes)) {
    classes = params.classes.split(/\s+/);
  }

  for (var i = 0, l = classes.length; i < l; i++) {
    var cls = classes[i];

    if (!cls || cls === '') {
      continue;
    }

    _p.classes.add(cls);
  }

  this.createEmitter();
  var bypass = params.style || params.css;

  if (bypass) {
    warn('Setting a `style` bypass at element creation is deprecated');
    this.style(bypass);
  }

  if (restore === undefined || restore) {
    this.restore();
  }
};

var defineSearch = function defineSearch(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  }; // from pseudocode on wikipedia

  return function searchFn(roots, fn$1, directed) {
    var options;

    if (plainObject(roots) && !elementOrCollection(roots)) {
      options = roots;
      roots = options.roots || options.root;
      fn$1 = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !fn(fn$1) ? fn$1 : directed;
    fn$1 = fn(fn$1) ? fn$1 : function () {};
    var cy = this._private.cy;
    var v = roots = string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges; // enqueue v


    for (var i = 0; i < v.length; i++) {
      var vi = v[i];
      var viId = vi.id();

      if (vi.isNode()) {
        Q.unshift(vi);

        if (params.bfs) {
          V[viId] = true;
          connectedNodes.push(vi);
        }

        id2depth[viId] = 0;
      }
    }

    var _loop2 = function _loop2() {
      var v = params.bfs ? Q.shift() : Q.pop();
      var vId = v.id();

      if (params.dfs) {
        if (V[vId]) {
          return "continue";
        }

        V[vId] = true;
        connectedNodes.push(v);
      }

      var depth = id2depth[vId];
      var prevEdge = connectedBy[vId];
      var src = prevEdge != null ? prevEdge.source() : null;
      var tgt = prevEdge != null ? prevEdge.target() : null;
      var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
      var ret = void 0;
      ret = fn$1(v, prevEdge, prevNode, j++, depth);

      if (ret === true) {
        found = v;
        return "break";
      }

      if (ret === false) {
        return "break";
      }

      var vwEdges = v.connectedEdges().filter(function (e) {
        return (!directed || e.source().same(v)) && edges.has(e);
      });

      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
        var e = vwEdges[_i2];
        var w = e.connectedNodes().filter(function (n) {
          return !n.same(v) && nodes.has(n);
        });
        var wId = w.id();

        if (w.length !== 0 && !V[wId]) {
          w = w[0];
          Q.push(w);

          if (params.bfs) {
            V[wId] = true;
            connectedNodes.push(w);
          }

          connectedBy[wId] = e;
          id2depth[wId] = id2depth[vId] + 1;
        }
      }
    };

    _loop: while (Q.length !== 0) {
      var _ret = _loop2();

      switch (_ret) {
        case "continue":
          continue;

        case "break":
          break _loop;
      }
    }

    var connectedEles = cy.collection();

    for (var _i = 0; _i < connectedNodes.length; _i++) {
      var node = connectedNodes[_i];
      var edge = connectedBy[node.id()];

      if (edge != null) {
        connectedEles.merge(edge);
      }

      connectedEles.merge(node);
    }

    return {
      path: cy.collection(connectedEles),
      found: cy.collection(found)
    };
  };
}; // search, spanning trees, etc


var elesfn = {
  breadthFirstSearch: defineSearch({
    bfs: true
  }),
  depthFirstSearch: defineSearch({
    dfs: true
  })
}; // nice, short mathemathical alias

elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

var dijkstraDefaults = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$1 = {
  dijkstra: function dijkstra(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        weight: args[1],
        directed: args[2]
      };
    }

    var _dijkstraDefaults = dijkstraDefaults(options),
        root = _dijkstraDefaults.root,
        weight = _dijkstraDefaults.weight,
        directed = _dijkstraDefaults.directed;

    var eles = this;
    var weightFn = weight;
    var source = string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (ele) {
      return ele.isLoop();
    });

    var getDist = function getDist(node) {
      return dist[node.id()];
    };

    var setDist = function setDist(node, d) {
      dist[node.id()] = d;
      Q.updateItem(node);
    };

    var Q = new Heap(function (a, b) {
      return getDist(a) - getDist(b);
    });

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      dist[node.id()] = node.same(source) ? 0 : Infinity;
      Q.push(node);
    }

    var distBetween = function distBetween(u, v) {
      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for (var _i = 0; _i < uvs.length; _i++) {
        var edge = uvs[_i];

        var _weight = weightFn(edge);

        if (_weight < smallestDistance || !smallestEdge) {
          smallestDistance = _weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();
      knownDist[uid] = smalletsDist;

      if (smalletsDist === Infinity) {
        continue;
      }

      var neighbors = u.neighborhood().intersect(nodes);

      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
        var v = neighbors[_i2];
        var vid = v.id();
        var vDist = distBetween(u, v);
        var alt = smalletsDist + vDist.dist;

        if (alt < getDist(v)) {
          setDist(v, alt);
          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for

    } // while


    return {
      distanceTo: function distanceTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        return knownDist[target.id()];
      },
      pathTo: function pathTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;
        var uid = u.id();

        if (target.length > 0) {
          S.unshift(target);

          while (prev[uid]) {
            var p = prev[uid];
            S.unshift(p.edge);
            S.unshift(p.node);
            u = p.node;
            uid = u.id();
          }
        }

        return eles.spawn(S);
      }
    };
  }
};

var elesfn$2 = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function kruskal(weightFn) {
    weightFn = weightFn || function (edge) {
      return 1;
    };

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var forest = new Array(numNodes);
    var A = nodes; // assumes byGroup() creates new collections that can be safely mutated

    var findSetIndex = function findSetIndex(ele) {
      for (var i = 0; i < forest.length; i++) {
        var eles = forest[i];

        if (eles.has(ele)) {
          return i;
        }
      }
    }; // start with one forest per node


    for (var i = 0; i < numNodes; i++) {
      forest[i] = this.spawn(nodes[i]);
    }

    var S = edges.sort(function (a, b) {
      return weightFn(a) - weightFn(b);
    });

    for (var _i = 0; _i < S.length; _i++) {
      var edge = S[_i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setUIndex = findSetIndex(u);
      var setVIndex = findSetIndex(v);
      var setU = forest[setUIndex];
      var setV = forest[setVIndex];

      if (setUIndex !== setVIndex) {
        A.merge(edge); // combine forests for u and v

        setU.merge(setV);
        forest.splice(setVIndex, 1);
      }
    }

    return A;
  }
};

var aStarDefaults = defaults({
  root: null,
  goal: null,
  weight: function weight(edge) {
    return 1;
  },
  heuristic: function heuristic(edge) {
    return 0;
  },
  directed: false
});
var elesfn$3 = {
  // Implemented from pseudocode from wikipedia
  aStar: function aStar(options) {
    var cy = this.cy();

    var _aStarDefaults = aStarDefaults(options),
        root = _aStarDefaults.root,
        goal = _aStarDefaults.goal,
        heuristic = _aStarDefaults.heuristic,
        directed = _aStarDefaults.directed,
        weight = _aStarDefaults.weight;

    root = cy.collection(root)[0];
    goal = cy.collection(goal)[0];
    var sid = root.id();
    var tid = goal.id();
    var gScore = {};
    var fScore = {};
    var closedSetIds = {};
    var openSet = new Heap(function (a, b) {
      return fScore[a.id()] - fScore[b.id()];
    });
    var openSetIds = new Set$1();
    var cameFrom = {};
    var cameFromEdge = {};

    var addToOpenSet = function addToOpenSet(ele, id) {
      openSet.push(ele);
      openSetIds.add(id);
    };

    var cMin, cMinId;

    var popFromOpenSet = function popFromOpenSet() {
      cMin = openSet.pop();
      cMinId = cMin.id();
      openSetIds["delete"](cMinId);
    };

    var isInOpenSet = function isInOpenSet(id) {
      return openSetIds.has(id);
    };

    addToOpenSet(root, sid);
    gScore[sid] = 0;
    fScore[sid] = heuristic(root); // Counter

    var steps = 0; // Main loop

    while (openSet.size() > 0) {
      popFromOpenSet();
      steps++; // If we've found our goal, then we are done

      if (cMinId === tid) {
        var path = [];
        var pathNode = goal;
        var pathNodeId = tid;
        var pathEdge = cameFromEdge[pathNodeId];

        for (;;) {
          path.unshift(pathNode);

          if (pathEdge != null) {
            path.unshift(pathEdge);
          }

          pathNode = cameFrom[pathNodeId];

          if (pathNode == null) {
            break;
          }

          pathNodeId = pathNode.id();
          pathEdge = cameFromEdge[pathNodeId];
        }

        return {
          found: true,
          distance: gScore[cMinId],
          path: this.spawn(path),
          steps: steps
        };
      } // Add cMin to processed nodes


      closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
      // Take into account if graph is directed or not

      var vwEdges = cMin._private.edges;

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i]; // edge must be in set of calling eles

        if (!this.hasElementWithId(e.id())) {
          continue;
        } // cMin must be the source of edge if directed


        if (directed && e.data('source') !== cMinId) {
          continue;
        }

        var wSrc = e.source();
        var wTgt = e.target();
        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id(); // node must be in set of calling eles

        if (!this.hasElementWithId(wid)) {
          continue;
        } // if node is in closedSet, ignore it


        if (closedSetIds[wid]) {
          continue;
        } // New tentative score for node w


        var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value
        // w not in openSet

        if (!isInOpenSet(wid)) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          addToOpenSet(w, wid);
          cameFrom[wid] = cMin;
          cameFromEdge[wid] = e;
          continue;
        } // w already in openSet, but with greater gScore


        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          cameFrom[wid] = cMin;
        }
      } // End of neighbors update

    } // End of main loop
    // If we've reached here, then we've not reached our goal


    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }
}; // elesfn

var floydWarshallDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$4 = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function floydWarshall(options) {
    var cy = this.cy();

    var _floydWarshallDefault = floydWarshallDefaults(options),
        weight = _floydWarshallDefault.weight,
        directed = _floydWarshallDefault.directed;

    var weightFn = weight;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var N = nodes.length;
    var Nsq = N * N;

    var indexOf = function indexOf(node) {
      return nodes.indexOf(node);
    };

    var atIndex = function atIndex(i) {
      return nodes[i];
    }; // Initialize distance matrix


    var dist = new Array(Nsq);

    for (var n = 0; n < Nsq; n++) {
      var j = n % N;
      var i = (n - j) / N;

      if (i === j) {
        dist[n] = 0;
      } else {
        dist[n] = Infinity;
      }
    } // Initialize matrix used for path reconstruction
    // Initialize distance matrix


    var next = new Array(Nsq);
    var edgeNext = new Array(Nsq); // Process edges

    for (var _i = 0; _i < edges.length; _i++) {
      var edge = edges[_i];
      var src = edge.source()[0];
      var tgt = edge.target()[0];

      if (src === tgt) {
        continue;
      } // exclude loops


      var s = indexOf(src);
      var t = indexOf(tgt);
      var st = s * N + t; // source to target index

      var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes


      if (dist[st] > _weight) {
        dist[st] = _weight;
        next[st] = t;
        edgeNext[st] = edge;
      } // If undirected graph, process 'reversed' edge


      if (!directed) {
        var ts = t * N + s; // target to source index

        if (!directed && dist[ts] > _weight) {
          dist[ts] = _weight;
          next[ts] = s;
          edgeNext[ts] = edge;
        }
      }
    } // Main loop


    for (var k = 0; k < N; k++) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        var ik = _i2 * N + k;

        for (var _j = 0; _j < N; _j++) {
          var ij = _i2 * N + _j;
          var kj = k * N + _j;

          if (dist[ik] + dist[kj] < dist[ij]) {
            dist[ij] = dist[ik] + dist[kj];
            next[ij] = next[ik];
          }
        }
      }
    }

    var getArgEle = function getArgEle(ele) {
      return (string(ele) ? cy.filter(ele) : ele)[0];
    };

    var indexOfArgEle = function indexOfArgEle(ele) {
      return indexOf(getArgEle(ele));
    };

    var res = {
      distance: function distance(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        return dist[i * N + j];
      },
      path: function path(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        var fromNode = atIndex(i);

        if (i === j) {
          return fromNode.collection();
        }

        if (next[i * N + j] == null) {
          return cy.collection();
        }

        var path = cy.collection();
        var prev = i;
        var edge;
        path.merge(fromNode);

        while (i !== j) {
          prev = i;
          i = next[i * N + j];
          edge = edgeNext[prev * N + i];
          path.merge(edge);
          path.merge(atIndex(i));
        }

        return path;
      }
    };
    return res;
  } // floydWarshall

}; // elesfn

var bellmanFordDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$5 = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function bellmanFord(options) {
    var _this = this;

    var _bellmanFordDefaults = bellmanFordDefaults(options),
        weight = _bellmanFordDefaults.weight,
        directed = _bellmanFordDefaults.directed,
        root = _bellmanFordDefaults.root;

    var weightFn = weight;
    var eles = this;
    var cy = this.cy();

    var _this$byGroup = this.byGroup(),
        edges = _this$byGroup.edges,
        nodes = _this$byGroup.nodes;

    var numNodes = nodes.length;
    var infoMap = new Map$1();
    var hasNegativeWeightCycle = false;
    var negativeWeightCycles = [];
    root = cy.collection(root)[0]; // in case selector passed

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numEdges = edges.length;

    var getInfo = function getInfo(node) {
      var obj = infoMap.get(node.id());

      if (!obj) {
        obj = {};
        infoMap.set(node.id(), obj);
      }

      return obj;
    };

    var getNodeFromTo = function getNodeFromTo(to) {
      return (string(to) ? cy.$(to) : to)[0];
    };

    var distanceTo = function distanceTo(to) {
      return getInfo(getNodeFromTo(to)).dist;
    };

    var pathTo = function pathTo(to) {
      var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
      var end = getNodeFromTo(to);
      var path = [];
      var node = end;

      for (;;) {
        if (node == null) {
          return _this.spawn();
        }

        var _getInfo = getInfo(node),
            edge = _getInfo.edge,
            pred = _getInfo.pred;

        path.unshift(node[0]);

        if (node.same(thisStart) && path.length > 0) {
          break;
        }

        if (edge != null) {
          path.unshift(edge);
        }

        node = pred;
      }

      return eles.spawn(path);
    }; // Initializations { dist, pred, edge }


    for (var i = 0; i < numNodes; i++) {
      var node = nodes[i];
      var info = getInfo(node);

      if (node.same(root)) {
        info.dist = 0;
      } else {
        info.dist = Infinity;
      }

      info.pred = null;
      info.edge = null;
    } // Edges relaxation


    var replacedEdge = false;

    var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
      var dist = info1.dist + weight;

      if (dist < info2.dist && !edge.same(info1.edge)) {
        info2.dist = dist;
        info2.pred = node1;
        info2.edge = edge;
        replacedEdge = true;
      }
    };

    for (var _i = 1; _i < numNodes; _i++) {
      replacedEdge = false;

      for (var e = 0; e < numEdges; e++) {
        var edge = edges[e];
        var src = edge.source();
        var tgt = edge.target();

        var _weight = weightFn(edge);

        var srcInfo = getInfo(src);
        var tgtInfo = getInfo(tgt);
        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge

        if (!directed) {
          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
        }
      }

      if (!replacedEdge) {
        break;
      }
    }

    if (replacedEdge) {
      // Check for negative weight cycles
      for (var _e = 0; _e < numEdges; _e++) {
        var _edge = edges[_e];

        var _src = _edge.source();

        var _tgt = _edge.target();

        var _weight2 = weightFn(_edge);

        var srcDist = getInfo(_src).dist;
        var tgtDist = getInfo(_tgt).dist;

        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
          warn('Graph contains a negative weight cycle for Bellman-Ford');
          hasNegativeWeightCycle = true;
          break;
        }
      }
    }

    return {
      distanceTo: distanceTo,
      pathTo: pathTo,
      hasNegativeWeightCycle: hasNegativeWeightCycle,
      negativeWeightCycles: negativeWeightCycles
    };
  } // bellmanFord

}; // elesfn

var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse

var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
  if (remainingEdges.length === 0) {
    error("Karger-Stein must be run on a connected (sub)graph");
  }

  var edgeInfo = remainingEdges[edgeIndex];
  var sourceIn = edgeInfo[1];
  var targetIn = edgeInfo[2];
  var partition1 = nodeMap[sourceIn];
  var partition2 = nodeMap[targetIn];
  var newEdges = remainingEdges; // re-use array
  // Delete all edges between partition1 and partition2

  for (var i = newEdges.length - 1; i >= 0; i--) {
    var edge = newEdges[i];
    var src = edge[1];
    var tgt = edge[2];

    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
      newEdges.splice(i, 1);
    }
  } // All edges pointing to partition2 should now point to partition1


  for (var _i = 0; _i < newEdges.length; _i++) {
    var _edge = newEdges[_i];

    if (_edge[1] === partition2) {
      // Check source
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][1] = partition1;
    } else if (_edge[2] === partition2) {
      // Check target
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][2] = partition1;
    }
  } // Move all nodes from partition2 to partition1


  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
    if (nodeMap[_i2] === partition2) {
      nodeMap[_i2] = partition1;
    }
  }

  return newEdges;
}; // Contracts a graph until we reach a certain number of meta nodes


var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
  while (size > sizeLimit) {
    // Choose an edge randomly
    var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge

    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
    size--;
  }

  return remainingEdges;
};

var elesfn$6 = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function kargerStein() {
    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / sqrt2);

    if (numNodes < 2) {
      error('At least 2 nodes are required for Karger-Stein algorithm');
      return undefined;
    } // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)


    var edgeIndexes = [];

    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);
    } // We will store the best cut found here


    var minCutSize = Infinity;
    var minCutEdgeIndexes = [];
    var minCutNodeMap = new Array(numNodes); // Initial meta node partition

    var metaNodeMap = new Array(numNodes);
    var metaNodeMap2 = new Array(numNodes);

    var copyNodesMap = function copyNodesMap(from, to) {
      for (var _i3 = 0; _i3 < numNodes; _i3++) {
        to[_i3] = from[_i3];
      }
    }; // Main loop


    for (var iter = 0; iter <= numIter; iter++) {
      // Reset meta node partition
      for (var _i4 = 0; _i4 < numNodes; _i4++) {
        metaNodeMap[_i4] = _i4;
      } // Contract until stop point (stopSize nodes)


      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
      var edgesState2 = edgesState.slice(); // copy
      // Create a copy of the colapsed nodes state

      copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state

      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?

      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCutEdgeIndexes = res1;
        copyNodesMap(metaNodeMap, minCutNodeMap);
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCutEdgeIndexes = res2;
        copyNodesMap(metaNodeMap2, minCutNodeMap);
      }
    } // end of main loop
    // Construct result


    var cut = this.spawn(minCutEdgeIndexes.map(function (e) {
      return edges[e[0]];
    }));
    var partition1 = this.spawn();
    var partition2 = this.spawn(); // traverse metaNodeMap for best cut

    var witnessNodePartition = minCutNodeMap[0];

    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
      var partitionId = minCutNodeMap[_i5];
      var node = nodes[_i5];

      if (partitionId === witnessNodePartition) {
        partition1.merge(node);
      } else {
        partition2.merge(node);
      }
    }

    var ret = {
      cut: cut,
      partition1: partition1,
      partition2: partition2
    };
    return ret;
  }
}; // elesfn

var copyPosition = function copyPosition(p) {
  return {
    x: p.x,
    y: p.y
  };
};
var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
  return {
    x: p.x * zoom + pan.x,
    y: p.y * zoom + pan.y
  };
};
var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
  return {
    x: (p.x - pan.x) / zoom,
    y: (p.y - pan.y) / zoom
  };
};
var array2point = function array2point(arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
};
var min = function min(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var min = Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      min = Math.min(val, min);
    }
  }

  return min;
};
var max = function max(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var max = -Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      max = Math.max(val, max);
    }
  }

  return max;
};
var mean = function mean(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var total = 0;
  var n = 0;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      total += val;
      n++;
    }
  }

  return total / n;
};
var median = function median(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

  if (copy) {
    arr = arr.slice(begin, end);
  } else {
    if (end < arr.length) {
      arr.splice(end, arr.length - end);
    }

    if (begin > 0) {
      arr.splice(0, begin);
    }
  } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start


  var off = 0; // offset from non-finite values

  for (var i = arr.length - 1; i >= 0; i--) {
    var v = arr[i];

    if (includeHoles) {
      if (!isFinite(v)) {
        arr[i] = -Infinity;
        off++;
      }
    } else {
      // just remove it if we don't want to consider holes
      arr.splice(i, 1);
    }
  }

  if (sort) {
    arr.sort(function (a, b) {
      return a - b;
    }); // requires copy = true if you don't want to change the orig
  }

  var len = arr.length;
  var mid = Math.floor(len / 2);

  if (len % 2 !== 0) {
    return arr[mid + 1 + off];
  } else {
    return (arr[mid - 1 + off] + arr[mid + off]) / 2;
  }
};
var deg2rad = function deg2rad(deg) {
  return Math.PI * deg / 180;
};
var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
};
var log2 = Math.log2 || function (n) {
  return Math.log(n) / Math.log(2);
};
var signum = function signum(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var dist = function dist(p1, p2) {
  return Math.sqrt(sqdist(p1, p2));
};
var sqdist = function sqdist(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return dx * dx + dy * dy;
};
var inPlaceSumNormalize = function inPlaceSumNormalize(v) {
  var length = v.length; // First, get sum of all elements

  var total = 0;

  for (var i = 0; i < length; i++) {
    total += v[i];
  } // Now, divide each by the sum of all elements


  for (var _i = 0; _i < length; _i++) {
    v[_i] = v[_i] / total;
  }

  return v;
};

var qbezierAt = function qbezierAt(p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};
var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
  return {
    x: qbezierAt(p0.x, p1.x, p2.x, t),
    y: qbezierAt(p0.y, p1.y, p2.y, t)
  };
};
var lineAt = function lineAt(p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var vecDist = dist(p0, p1);
  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };
  t = t == null ? 0 : t;
  d = d != null ? d : t * vecDist;
  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};
var bound = function bound(min, val, max) {
  return Math.max(min, Math.min(max, val));
}; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params

var makeBoundingBox = function makeBoundingBox(bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};
var copyBoundingBox = function copyBoundingBox(bb) {
  return {
    x1: bb.x1,
    x2: bb.x2,
    w: bb.w,
    y1: bb.y1,
    y2: bb.y2,
    h: bb.h
  };
};
var clearBoundingBox = function clearBoundingBox(bb) {
  bb.x1 = Infinity;
  bb.y1 = Infinity;
  bb.x2 = -Infinity;
  bb.y2 = -Infinity;
  bb.w = 0;
  bb.h = 0;
};
var updateBoundingBox = function updateBoundingBox(bb1, bb2) {
  // update bb1 with bb2 bounds
  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;
  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
};
var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
  bb.x1 = Math.min(bb.x1, x);
  bb.x2 = Math.max(bb.x2, x);
  bb.w = bb.x2 - bb.x1;
  bb.y1 = Math.min(bb.y1, y);
  bb.y2 = Math.max(bb.y2, y);
  bb.h = bb.y2 - bb.y1;
};
var expandBoundingBox = function expandBoundingBox(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};
var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
  var top, right, bottom, left;

  if (padding.length === 1) {
    top = right = bottom = left = padding[0];
  } else if (padding.length === 2) {
    top = bottom = padding[0];
    left = right = padding[1];
  } else if (padding.length === 4) {
    var _padding = _slicedToArray(padding, 4);

    top = _padding[0];
    right = _padding[1];
    bottom = _padding[2];
    left = _padding[3];
  }

  bb.x1 -= left;
  bb.x2 += right;
  bb.y1 -= top;
  bb.y2 += bottom;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};

var assignBoundingBox = function assignBoundingBox(bb1, bb2) {
  bb1.x1 = bb2.x1;
  bb1.y1 = bb2.y1;
  bb1.x2 = bb2.x2;
  bb1.y2 = bb2.y2;
  bb1.w = bb1.x2 - bb1.x1;
  bb1.h = bb1.y2 - bb1.y1;
};
var assignShiftToBoundingBox = function assignShiftToBoundingBox(bb, delta) {
  bb.x1 += delta.x;
  bb.x2 += delta.x;
  bb.y1 += delta.y;
  bb.y2 += delta.y;
};
var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
  // case: one bb to right of other
  if (bb1.x1 > bb2.x2) {
    return false;
  }

  if (bb2.x1 > bb1.x2) {
    return false;
  } // case: one bb to left of other


  if (bb1.x2 < bb2.x1) {
    return false;
  }

  if (bb2.x2 < bb1.x1) {
    return false;
  } // case: one bb above other


  if (bb1.y2 < bb2.y1) {
    return false;
  }

  if (bb2.y2 < bb1.y1) {
    return false;
  } // case: one bb below other


  if (bb1.y1 > bb2.y2) {
    return false;
  }

  if (bb2.y1 > bb1.y2) {
    return false;
  } // otherwise, must have some overlap


  return true;
};
var inBoundingBox = function inBoundingBox(bb, x, y) {
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};
var pointInBoundingBox = function pointInBoundingBox(bb, pt) {
  return inBoundingBox(bb, pt.x, pt.y);
};
var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
};
var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
  var cornerRadius = getRoundRectangleRadius(width, height);
  var halfWidth = width / 2;
  var halfHeight = height / 2; // Check intersections with straight line segments

  var straightLineIntersections; // Top segment, left to right

  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Right segment, top to bottom

  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Bottom segment, left to right

  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Left segment, top to bottom

  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Check intersections with arc segments

  var arcIntersections; // Top Left

  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Top Right

  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Right

  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Left

  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  return []; // if nothing
};
var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;
  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);
  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};
var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
  var bb = {
    x1: Math.min(x1, x3, x2) - tolerance,
    x2: Math.max(x1, x3, x2) + tolerance,
    y1: Math.min(y1, y3, y2) - tolerance,
    y2: Math.max(y1, y3, y2) + tolerance
  }; // if outside the rough bounding box for the bezier, then it can't be a hit

  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }
};
var solveQuadratic = function solveQuadratic(a, b, c, val) {
  c -= val;
  var r = b * b - 4 * a * c;

  if (r < 0) {
    return [];
  }

  var sqrtR = Math.sqrt(r);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;
  return [root1, root2];
};
var solveCubic = function solveCubic(a, b, c, d, result) {
  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component
  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
  var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value

  if (a === 0) {
    a = epsilon;
  }

  b /= a;
  c /= a;
  d /= a;
  var discriminant, q, r, dum1, s, t, term1, r13;
  q = (3.0 * c - b * b) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;
  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = b / 3.0;

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
    t = r - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
  return;
};
var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve
  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)
  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = []; // Use the cubic solving algorithm

  solveCubic(a, b, c, d, roots);
  var zeroThreshold = 0.0000001;
  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);
  var minDistanceSquared = -1;
  var curX, curY, distSquared;

  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));

    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }

  return minDistanceSquared;
};
var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];
  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};
var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
  var x1, y1, x2, y2;
  var y3; // Intersect with vertical line through (x, y)

  var up = 0; // let down = 0;

  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      } // if( y3 < y ){
      // down++;
      // }

    } else {
      continue;
    }
  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};
var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
  var transformedPoints = new Array(basePoints.length); // Gives negative angle

  var angle;

  if (direction[0] != null) {
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle); //    console.log("base: " + basePoints);

  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = expandPolygon(transformedPoints, -padding);
    points = joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return pointInsidePolygonPoints(x, y, points);
};
var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
  var cutPolygonPoints = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);
  var squaredCornerRadius = cornerRadius * cornerRadius;

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];
    cutPolygonPoints[i * 4] = cp0x;
    cutPolygonPoints[i * 4 + 1] = cp0y;
    cutPolygonPoints[i * 4 + 2] = cp1x;
    cutPolygonPoints[i * 4 + 3] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);

    if (squaredDistance <= squaredCornerRadius) {
      return true;
    }
  }

  return pointInsidePolygonPoints(x, y, cutPolygonPoints);
};
var joinLines = function joinLines(lineSet) {
  var vertices = new Array(lineSet.length / 2);
  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};
var expandPolygon = function expandPolygon(points, pad) {
  var expandedLineSet = new Array(points.length * 2);
  var currentPointX, currentPointY, nextPointX, nextPointY;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
    // Assume CCW polygon winding


    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX); // Normalize

    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;
    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};
var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
  var dispX = centerX - x;
  var dispY = centerY - y;
  dispX /= ellipseWradius;
  dispY /= ellipseHradius;
  var len = Math.sqrt(dispX * dispX + dispY * dispY);
  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;
  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};
var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
  x -= centerX;
  y -= centerY;
  x /= width / 2 + padding;
  y /= height / 2 + padding;
  return x * x + y * y <= 1;
}; // Returns intersections of increasing distance from line's start point

var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line

  var f = [x1 - centerX, y1 - centerY];
  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
  var discriminant = b * b - 4 * a * c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {
    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {
      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;
      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
};
var midOfThree = function midOfThree(a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
}; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)

var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;
  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;
  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;
    var flptThreshold = 0.001;

    var _min = 0 - flptThreshold;

    var _max = 1 + flptThreshold;

    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {
      // Parallel, coincident lines. Check if overlap
      // Check endpoint of second line
      if (midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      } // Check start point of second line


      if (midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      } // Endpoint of first line


      if (midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }

      return [];
    } else {
      // Parallel, non-coincident
      return [];
    }
  }
}; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)

var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var transformedPoints = new Array(basePoints.length);
  var doTransform = true;

  if (width == null) {
    doTransform = false;
  }

  var points;

  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }

    if (padding > 0) {
      var expandedLineSet = expandPolygon(transformedPoints, -padding);
      points = joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX, currentY, nextX, nextY;

  for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
    currentX = points[_i2 * 2];
    currentY = points[_i2 * 2 + 1];

    if (_i2 < points.length / 2 - 1) {
      nextX = points[(_i2 + 1) * 2];
      nextY = points[(_i2 + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};
var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var lines = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];

    if (i === 0) {
      lines[basePoints.length - 2] = cp0x;
      lines[basePoints.length - 1] = cp0y;
    } else {
      lines[i * 4 - 2] = cp0x;
      lines[i * 4 - 1] = cp0y;
    }

    lines[i * 4] = cp1x;
    lines[i * 4 + 1] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {
    intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  if (intersections.length > 2) {
    var lowestIntersection = [intersections[0], intersections[1]];
    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);

    for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
      var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);

      if (squaredDistance <= lowestSquaredDistance) {
        lowestIntersection[0] = intersections[_i4 * 2];
        lowestIntersection[1] = intersections[_i4 * 2 + 1];
        lowestSquaredDistance = squaredDistance;
      }
    }

    return lowestIntersection;
  }

  return intersections;
};
var shortenIntersection = function shortenIntersection(intersection, offset, amount) {
  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};
var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
  var points = generateUnitNgonPoints(sides, rotationRadians);
  points = fitPolygonToSquare(points);
  return points;
};
var fitPolygonToSquare = function fitPolygonToSquare(points) {
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  } // stretch factors


  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var _i5 = 0; _i5 < sides; _i5++) {
    x = points[2 * _i5] = points[2 * _i5] * sx;
    y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  if (minY < -1) {
    for (var _i6 = 0; _i6 < sides; _i6++) {
      y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
    }
  }

  return points;
};
var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  startAngle += rotationRadians;
  var points = new Array(sides * 2);
  var currentAngle;

  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;
    points[2 * i] = Math.cos(currentAngle); // x

    points[2 * i + 1] = Math.sin(-currentAngle); // y
  }

  return points;
}; // Set the default radius, unless half of width or height is smaller than default

var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
  return Math.min(width / 4, height / 4, 8);
}; // Set the default radius

var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
  return Math.min(width / 10, height / 10, 8);
};
var getCutRectangleCornerLength = function getCutRectangleCornerLength() {
  return 8;
};
var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
}; // get curve width, height, and control point position offsets as a percentage of node height / width

var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
  return {
    heightOffset: Math.min(15, 0.05 * height),
    widthOffset: Math.min(100, 0.25 * width),
    ctrlPtOffsetPct: 0.05
  };
};

var pageRankDefaults = defaults({
  dampingFactor: 0.8,
  precision: 0.000001,
  iterations: 200,
  weight: function weight(edge) {
    return 1;
  }
});
var elesfn$7 = {
  pageRank: function pageRank(options) {
    var _pageRankDefaults = pageRankDefaults(options),
        dampingFactor = _pageRankDefaults.dampingFactor,
        precision = _pageRankDefaults.precision,
        iterations = _pageRankDefaults.iterations,
        weight = _pageRankDefaults.weight;

    var cy = this._private.cy;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var numNodesSqd = numNodes * numNodes;
    var numEdges = edges.length; // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column

    var matrix = new Array(numNodesSqd);
    var columnSum = new Array(numNodes);
    var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix

    for (var i = 0; i < numNodes; i++) {
      for (var j = 0; j < numNodes; j++) {
        var n = i * numNodes + j;
        matrix[n] = 0;
      }

      columnSum[i] = 0;
    } // Now, process edges


    for (var _i = 0; _i < numEdges; _i++) {
      var edge = edges[_i];
      var srcId = edge.data('source');
      var tgtId = edge.data('target'); // Don't include loops in the matrix

      if (srcId === tgtId) {
        continue;
      }

      var s = nodes.indexOfId(srcId);
      var t = nodes.indexOfId(tgtId);
      var w = weight(edge);

      var _n = t * numNodes + s; // Update matrix


      matrix[_n] += w; // Update column sum

      columnSum[s] += w;
    } // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0


    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column

    for (var _j = 0; _j < numNodes; _j++) {
      if (columnSum[_j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var _i2 = 0; _i2 < numNodes; _i2++) {
          var _n2 = _i2 * numNodes + _j;

          matrix[_n2] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var _i3 = 0; _i3 < numNodes; _i3++) {
          var _n3 = _i3 * numNodes + _j;

          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
        }
      }
    } // Compute dominant eigenvector using power method


    var eigenvector = new Array(numNodes);
    var temp = new Array(numNodes);
    var previous; // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand

    for (var _i4 = 0; _i4 < numNodes; _i4++) {
      eigenvector[_i4] = 1;
    }

    for (var iter = 0; iter < iterations; iter++) {
      // Temp array with all 0's
      for (var _i5 = 0; _i5 < numNodes; _i5++) {
        temp[_i5] = 0;
      } // Multiply matrix with previous result


      for (var _i6 = 0; _i6 < numNodes; _i6++) {
        for (var _j2 = 0; _j2 < numNodes; _j2++) {
          var _n4 = _i6 * numNodes + _j2;

          temp[_i6] += matrix[_n4] * eigenvector[_j2];
        }
      }

      inPlaceSumNormalize(temp);
      previous = eigenvector;
      eigenvector = temp;
      temp = previous;
      var diff = 0; // Compute difference (squared module) of both vectors

      for (var _i7 = 0; _i7 < numNodes; _i7++) {
        var delta = previous[_i7] - eigenvector[_i7];
        diff += delta * delta;
      } // If difference is less than the desired threshold, stop iterating


      if (diff < precision) {
        break;
      }
    } // Construct result


    var res = {
      rank: function rank(node) {
        node = cy.collection(node)[0];
        return eigenvector[nodes.indexOf(node)];
      }
    };
    return res;
  } // pageRank

}; // elesfn

var defaults$1 = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  alpha: 0
});
var elesfn$8 = {
  degreeCentralityNormalized: function degreeCentralityNormalized(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!options.directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i]; // add current node to the current options object and call degreeCentrality

        options.root = node;
        var currDegree = this.degreeCentrality(options);

        if (maxDegree < currDegree.degree) {
          maxDegree = currDegree.degree;
        }

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function degree(node) {
          if (maxDegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return degrees[node.id()] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var _i = 0; _i < numNodes; _i++) {
        var _node = nodes[_i];

        var id = _node.id(); // add current node to the current options object and call degreeCentrality


        options.root = _node;

        var _currDegree = this.degreeCentrality(options);

        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
        indegrees[id] = _currDegree.indegree;
        outdegrees[id] = _currDegree.outdegree;
      }

      return {
        indegree: function indegree(node) {
          if (maxIndegree == 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return indegrees[node.id()] / maxIndegree;
        },
        outdegree: function outdegree(node) {
          if (maxOutdegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return outdegrees[node.id()] / maxOutdegree;
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function degreeCentrality(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var callingEles = this;
    var _options = options,
        root = _options.root,
        weight = _options.weight,
        directed = _options.directed,
        alpha = _options.alpha;
    root = cy.collection(root)[0];

    if (!directed) {
      var connEdges = root.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0; // Now, sum edge weights

      for (var i = 0; i < connEdges.length; i++) {
        s += weight(connEdges[i]);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var edges = root.connectedEdges();
      var incoming = edges.filter(function (edge) {
        return edge.target().same(root) && callingEles.has(edge);
      });
      var outgoing = edges.filter(function (edge) {
        return edge.source().same(root) && callingEles.has(edge);
      });
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0; // Now, sum incoming edge weights

      for (var _i2 = 0; _i2 < incoming.length; _i2++) {
        s_in += weight(incoming[_i2]);
      } // Now, sum outgoing edge weights


      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
        s_out += weight(outgoing[_i3]);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$8.dc = elesfn$8.degreeCentrality;
elesfn$8.dcn = elesfn$8.degreeCentralityNormalised = elesfn$8.degreeCentralityNormalized;

var defaults$2 = defaults({
  harmonic: true,
  weight: function weight() {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$9 = {
  closenessCentralityNormalized: function closenessCentralityNormalized(options) {
    var _defaults = defaults$2(options),
        harmonic = _defaults.harmonic,
        weight = _defaults.weight,
        directed = _defaults.directed;

    var cy = this.cy();
    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({
      weight: weight,
      directed: directed
    }); // Compute closeness for every node and find the maximum closeness

    for (var i = 0; i < nodes.length; i++) {
      var currCloseness = 0;
      var node_i = nodes[i];

      for (var j = 0; j < nodes.length; j++) {
        if (i !== j) {
          var d = fw.distance(node_i, nodes[j]);

          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }

      closenesses[node_i.id()] = currCloseness;
    }

    return {
      closeness: function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }

        if (string(node)) {
          // from is a selector string
          node = cy.filter(node)[0].id();
        } else {
          // from is a node
          node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function closenessCentrality(options) {
    var _defaults2 = defaults$2(options),
        root = _defaults2.root,
        weight = _defaults2.weight,
        directed = _defaults2.directed,
        harmonic = _defaults2.harmonic;

    root = this.filter(root)[0]; // we need distance from this node to every other node

    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];

      if (!n.same(root)) {
        var d = dijkstra.distanceTo(n);

        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$9.cc = elesfn$9.closenessCentrality;
elesfn$9.ccn = elesfn$9.closenessCentralityNormalised = elesfn$9.closenessCentralityNormalized;

var defaults$3 = defaults({
  weight: null,
  directed: false
});
var elesfn$a = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function betweennessCentrality(options) {
    var _defaults = defaults$3(options),
        directed = _defaults.directed,
        weight = _defaults.weight;

    var weighted = weight != null;
    var cy = this.cy(); // starting

    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function set(key, val) {
        _C[key] = val;

        if (val > max) {
          max = val;
        }
      },
      get: function get(key) {
        return _C[key];
      }
    }; // A contains the neighborhoods of every node

    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();

      if (directed) {
        A[vid] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set(vid, 0);
    }

    var _loop = function _loop(s) {
      var sid = V[s].id();
      var S = []; // stack

      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function (a, b) {
        return d[a] - d[b];
      }); // queue
      // init dictionaries

      for (var _i = 0; _i < V.length; _i++) {
        var _vid = V[_i].id();

        P[_vid] = [];
        g[_vid] = 0;
        d[_vid] = Infinity;
      }

      g[sid] = 1; // sigma

      d[sid] = 0; // distance to s

      Q.push(sid);

      while (!Q.empty()) {
        var _v = Q.pop();

        S.push(_v);

        if (weighted) {
          for (var j = 0; j < A[_v].length; j++) {
            var w = A[_v][j];
            var vEle = cy.getElementById(_v);
            var edge = void 0;

            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }

            var edgeWeight = weight(edge);
            w = w.id();

            if (d[w] > d[_v] + edgeWeight) {
              d[w] = d[_v] + edgeWeight;

              if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                Q.push(w);
              } else {
                // update position if w is in Q
                Q.updateItem(w);
              }

              g[w] = 0;
              P[w] = [];
            }

            if (d[w] == d[_v] + edgeWeight) {
              g[w] = g[w] + g[_v];
              P[w].push(_v);
            }
          }
        } else {
          for (var _j = 0; _j < A[_v].length; _j++) {
            var _w = A[_v][_j].id();

            if (d[_w] == Infinity) {
              Q.push(_w);
              d[_w] = d[_v] + 1;
            }

            if (d[_w] == d[_v] + 1) {
              g[_w] = g[_w] + g[_v];

              P[_w].push(_v);
            }
          }
        }
      }

      var e = {};

      for (var _i2 = 0; _i2 < V.length; _i2++) {
        e[V[_i2].id()] = 0;
      }

      while (S.length > 0) {
        var _w2 = S.pop();

        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
          var _v2 = P[_w2][_j2];
          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);

          if (_w2 != V[s].id()) {
            C.set(_w2, C.get(_w2) + e[_w2]);
          }
        }
      }
    };

    for (var s = 0; s < V.length; s++) {
      _loop(s);
    }

    var ret = {
      betweenness: function betweenness(node) {
        var id = cy.collection(node).id();
        return C.get(id);
      },
      betweennessNormalized: function betweennessNormalized(node) {
        if (max == 0) {
          return 0;
        }

        var id = cy.collection(node).id();
        return C.get(id) / max;
      }
    }; // alias

    ret.betweennessNormalised = ret.betweennessNormalized;
    return ret;
  } // betweennessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$a.bc = elesfn$a.betweennessCentrality;

// Implemented by Zoe Xi @zoexi for GSOC 2016
/* eslint-disable no-unused-vars */

var defaults$4 = defaults({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [// attributes/features used to group nodes, ie. similarity values between nodes
  function (edge) {
    return 1;
  }]
});
/* eslint-enable */

var setOptions = function setOptions(options) {
  return defaults$4(options);
};
/* eslint-enable */


var getSimilarity = function getSimilarity(edge, attributes) {
  var total = 0;

  for (var i = 0; i < attributes.length; i++) {
    total += attributes[i](edge);
  }

  return total;
};

var addLoops = function addLoops(M, n, val) {
  for (var i = 0; i < n; i++) {
    M[i * n + i] = val;
  }
};

var normalize = function normalize(M, n) {
  var sum;

  for (var col = 0; col < n; col++) {
    sum = 0;

    for (var row = 0; row < n; row++) {
      sum += M[row * n + col];
    }

    for (var _row = 0; _row < n; _row++) {
      M[_row * n + col] = M[_row * n + col] / sum;
    }
  }
}; // TODO: blocked matrix multiplication?


var mmult = function mmult(A, B, n) {
  var C = new Array(n * n);

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      C[i * n + j] = 0;
    }

    for (var k = 0; k < n; k++) {
      for (var _j = 0; _j < n; _j++) {
        C[i * n + _j] += A[i * n + k] * B[k * n + _j];
      }
    }
  }

  return C;
};

var expand = function expand(M, n, expandFactor
/** power **/
) {
  var _M = M.slice(0);

  for (var p = 1; p < expandFactor; p++) {
    M = mmult(M, _M, n);
  }

  return M;
};

var inflate = function inflate(M, n, inflateFactor
/** r **/
) {
  var _M = new Array(n * n); // M(i,j) ^ inflatePower


  for (var i = 0; i < n * n; i++) {
    _M[i] = Math.pow(M[i], inflateFactor);
  }

  normalize(_M, n);
  return _M;
};

var hasConverged = function hasConverged(M, _M, n2, roundFactor) {
  // Check that both matrices have the same elements (i,j)
  for (var i = 0; i < n2; i++) {
    var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places

    var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);

    if (v1 !== v2) {
      return false;
    }
  }

  return true;
};

var assign = function assign(M, n, nodes, cy) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var cluster = [];

    for (var j = 0; j < n; j++) {
      // Row-wise attractors and elements that they attract belong in same cluster
      if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {
        cluster.push(nodes[j]);
      }
    }

    if (cluster.length !== 0) {
      clusters.push(cy.collection(cluster));
    }
  }

  return clusters;
};

var isDuplicate = function isDuplicate(c1, c2) {
  for (var i = 0; i < c1.length; i++) {
    if (!c2[i] || c1[i].id() !== c2[i].id()) {
      return false;
    }
  }

  return true;
};

var removeDuplicates = function removeDuplicates(clusters) {
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j < clusters.length; j++) {
      if (i != j && isDuplicate(clusters[i], clusters[j])) {
        clusters.splice(j, 1);
      }
    }
  }

  return clusters;
};

var markovClustering = function markovClustering(options) {
  var nodes = this.nodes();
  var edges = this.edges();
  var cy = this.cy(); // Set parameters of algorithm:

  var opts = setOptions(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)


  var n = nodes.length,
      n2 = n * n;

  var M = new Array(n2),
      _M;

  for (var _i = 0; _i < n2; _i++) {
    M[_i] = 0;
  }

  for (var e = 0; e < edges.length; e++) {
    var edge = edges[e];
    var _i2 = id2position[edge.source().id()];
    var j = id2position[edge.target().id()];
    var sim = getSimilarity(edge, opts.attributes);
    M[_i2 * n + j] += sim; // G should be symmetric and undirected

    M[j * n + _i2] += sim;
  } // Begin Markov cluster algorithm
  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal


  addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );

  normalize(M, n);
  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 3:

    _M = expand(M, n, opts.expandFactor); // Step 4:

    M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached

    if (!hasConverged(M, _M, n2, 4)) {
      isStillMoving = true;
    }

    iterations++;
  } // Build clusters from matrix


  var clusters = assign(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix

  clusters = removeDuplicates(clusters);
  return clusters;
};

var markovClustering$1 = {
  markovClustering: markovClustering,
  mcl: markovClustering
};

// Common distance metrics for clustering algorithms

var identity = function identity(x) {
  return x;
};

var absDiff = function absDiff(p, q) {
  return Math.abs(q - p);
};

var addAbsDiff = function addAbsDiff(total, p, q) {
  return total + absDiff(p, q);
};

var addSquaredDiff = function addSquaredDiff(total, p, q) {
  return total + Math.pow(q - p, 2);
};

var sqrt = function sqrt(x) {
  return Math.sqrt(x);
};

var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
  return Math.max(currentMax, absDiff(p, q));
};

var getDistance = function getDistance(length, getP, getQ, init, visit) {
  var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
  var ret = init;
  var p, q;

  for (var dim = 0; dim < length; dim++) {
    p = getP(dim);
    q = getQ(dim);
    ret = visit(ret, p, q);
  }

  return post(ret);
};

var distances = {
  euclidean: function euclidean(length, getP, getQ) {
    if (length >= 2) {
      return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
    } else {
      // for single attr case, more efficient to avoid sqrt
      return getDistance(length, getP, getQ, 0, addAbsDiff);
    }
  },
  squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addSquaredDiff);
  },
  manhattan: function manhattan(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addAbsDiff);
  },
  max: function max(length, getP, getQ) {
    return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
  }
}; // in case the user accidentally doesn't use camel case

distances['squared-euclidean'] = distances['squaredEuclidean'];
distances['squaredeuclidean'] = distances['squaredEuclidean'];
function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {
  var impl;

  if (fn(method)) {
    impl = method;
  } else {
    impl = distances[method] || distances.euclidean;
  }

  if (length === 0 && fn(method)) {
    return impl(nodeP, nodeQ);
  } else {
    return impl(length, getP, getQ, nodeP, nodeQ);
  }
}

var defaults$5 = defaults({
  k: 2,
  m: 2,
  sensitivityThreshold: 0.0001,
  distance: 'euclidean',
  maxIterations: 10,
  attributes: [],
  testMode: false,
  testCentroids: null
});

var setOptions$1 = function setOptions(options) {
  return defaults$5(options);
};
/* eslint-enable */


var getDist = function getDist(type, node, centroid, attributes, mode) {
  var noNodeP = mode !== 'kMedoids';
  var getP = noNodeP ? function (i) {
    return centroid[i];
  } : function (i) {
    return attributes[i](centroid);
  };

  var getQ = function getQ(i) {
    return attributes[i](node);
  };

  var nodeP = centroid;
  var nodeQ = node;
  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
};

var randomCentroids = function randomCentroids(nodes, k, attributes) {
  var ndim = attributes.length;
  var min = new Array(ndim);
  var max = new Array(ndim);
  var centroids = new Array(k);
  var centroid = null; // Find min, max values for each attribute dimension

  for (var i = 0; i < ndim; i++) {
    min[i] = nodes.min(attributes[i]).value;
    max[i] = nodes.max(attributes[i]).value;
  } // Build k centroids, each represented as an n-dim feature vector


  for (var c = 0; c < k; c++) {
    centroid = [];

    for (var _i = 0; _i < ndim; _i++) {
      centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
    }

    centroids[c] = centroid;
  }

  return centroids;
};

var classify = function classify(node, centroids, distance, attributes, type) {
  var min = Infinity;
  var index = 0;

  for (var i = 0; i < centroids.length; i++) {
    var dist = getDist(distance, node, centroids[i], attributes, type);

    if (dist < min) {
      min = dist;
      index = i;
    }
  }

  return index;
};

var buildCluster = function buildCluster(centroid, nodes, assignment) {
  var cluster = [];
  var node = null;

  for (var n = 0; n < nodes.length; n++) {
    node = nodes[n];

    if (assignment[node.id()] === centroid) {
      //console.log("Node " + node.id() + " is associated with medoid #: " + m);
      cluster.push(node);
    }
  }

  return cluster;
};

var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
  return Math.abs(v2 - v1) <= sensitivityThreshold;
};

var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
  for (var i = 0; i < v1.length; i++) {
    for (var j = 0; j < v1[i].length; j++) {
      var diff = Math.abs(v1[i][j] - v2[i][j]);

      if (diff > sensitivityThreshold) {
        return false;
      }
    }
  }

  return true;
};

var seenBefore = function seenBefore(node, medoids, n) {
  for (var i = 0; i < n; i++) {
    if (node === medoids[i]) return true;
  }

  return false;
};

var randomMedoids = function randomMedoids(nodes, k) {
  var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
  // so we need to check to see if we've already seen or chose this node before.

  if (nodes.length < 50) {
    // Randomly select k medoids from the n nodes
    for (var i = 0; i < k; i++) {
      var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
      // Instead choose a different random node.

      while (seenBefore(node, medoids, i)) {
        node = nodes[Math.floor(Math.random() * nodes.length)];
      }

      medoids[i] = node;
    }
  } else {
    // Relatively large data set, so pretty safe to not check and just select random nodes
    for (var _i2 = 0; _i2 < k; _i2++) {
      medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
    }
  }

  return medoids;
};

var findCost = function findCost(potentialNewMedoid, cluster, attributes) {
  var cost = 0;

  for (var n = 0; n < cluster.length; n++) {
    cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');
  }

  return cost;
};

var kMeans = function kMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.

  var opts = setOptions$1(options); // Begin k-means algorithm

  var clusters = new Array(opts.k);
  var assignment = {};
  var centroids; // Step 1: Initialize centroid positions

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    } else if (_typeof(opts.testCentroids) === 'object') {
      centroids = opts.testCentroids;
    } else {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    }
  } else {
    centroids = randomCentroids(nodes, opts.k, opts.attributes);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest centroid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');
    } // Step 3: For each of the k clusters, update its centroid


    isStillMoving = false;

    for (var c = 0; c < opts.k; c++) {
      // Get all nodes that belong to this cluster
      var cluster = buildCluster(c, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      } // Update centroids by calculating avg of all nodes within the cluster.


      var ndim = opts.attributes.length;
      var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]

      var newCentroid = new Array(ndim);
      var sum = new Array(ndim);

      for (var d = 0; d < ndim; d++) {
        sum[d] = 0.0;

        for (var i = 0; i < cluster.length; i++) {
          node = cluster[i];
          sum[d] += opts.attributes[d](node);
        }

        newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change

        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
          isStillMoving = true;
        }
      }

      centroids[c] = newCentroid;
      clusters[c] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var kMedoids = function kMedoids(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null;
  var opts = setOptions$1(options); // Begin k-medoids algorithm

  var clusters = new Array(opts.k);
  var medoids;
  var assignment = {};
  var curCost;
  var minCosts = new Array(opts.k); // minimum cost configuration for each cluster
  // Step 1: Initialize k medoids

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {
      medoids = opts.testCentroids;
    } else {
      medoids = randomMedoids(nodes, opts.k);
    }
  } else {
    medoids = randomMedoids(nodes, opts.k);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest medoid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');
    }

    isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
    // select the node with the lowest configuration cost as new medoid.

    for (var m = 0; m < medoids.length; m++) {
      // Get all nodes that belong to this medoid
      var cluster = buildCluster(m, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      }

      minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost
      // Select different medoid if its configuration has the lowest cost

      for (var _n = 0; _n < cluster.length; _n++) {
        curCost = findCost(cluster[_n], cluster, opts.attributes);

        if (curCost < minCosts[m]) {
          minCosts[m] = curCost;
          medoids[m] = cluster[_n];
          isStillMoving = true;
        }
      }

      clusters[m] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
  var numerator, denominator;

  for (var n = 0; n < nodes.length; n++) {
    for (var c = 0; c < centroids.length; c++) {
      weight[n][c] = Math.pow(U[n][c], opts.m);
    }
  }

  for (var _c = 0; _c < centroids.length; _c++) {
    for (var dim = 0; dim < opts.attributes.length; dim++) {
      numerator = 0;
      denominator = 0;

      for (var _n2 = 0; _n2 < nodes.length; _n2++) {
        numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
        denominator += weight[_n2][_c];
      }

      centroids[_c][dim] = numerator / denominator;
    }
  }
};

var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
  // Save previous step
  for (var i = 0; i < U.length; i++) {
    _U[i] = U[i].slice();
  }

  var sum, numerator, denominator;
  var pow = 2 / (opts.m - 1);

  for (var c = 0; c < centroids.length; c++) {
    for (var n = 0; n < nodes.length; n++) {
      sum = 0;

      for (var k = 0; k < centroids.length; k++) {
        // against all other centroids
        numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');
        denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');
        sum += Math.pow(numerator / denominator, pow);
      }

      U[n][c] = 1 / sum;
    }
  }
};

var assign$1 = function assign(nodes, U, opts, cy) {
  var clusters = new Array(opts.k);

  for (var c = 0; c < clusters.length; c++) {
    clusters[c] = [];
  }

  var max;
  var index;

  for (var n = 0; n < U.length; n++) {
    // for each node (U is N x C matrix)
    max = -Infinity;
    index = -1; // Determine which cluster the node is most likely to belong in

    for (var _c2 = 0; _c2 < U[0].length; _c2++) {
      if (U[n][_c2] > max) {
        max = U[n][_c2];
        index = _c2;
      }
    }

    clusters[index].push(nodes[n]);
  } // Turn every array into a collection of nodes


  for (var _c3 = 0; _c3 < clusters.length; _c3++) {
    clusters[_c3] = cy.collection(clusters[_c3]);
  }

  return clusters;
};

var fuzzyCMeans = function fuzzyCMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$1(options); // Begin fuzzy c-means algorithm

  var clusters;
  var centroids;
  var U;

  var _U;

  var weight; // Step 1: Initialize letiables.

  _U = new Array(nodes.length);

  for (var i = 0; i < nodes.length; i++) {
    // N x C matrix
    _U[i] = new Array(opts.k);
  }

  U = new Array(nodes.length);

  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // N x C matrix
    U[_i3] = new Array(opts.k);
  }

  for (var _i4 = 0; _i4 < nodes.length; _i4++) {
    var total = 0;

    for (var j = 0; j < opts.k; j++) {
      U[_i4][j] = Math.random();
      total += U[_i4][j];
    }

    for (var _j = 0; _j < opts.k; _j++) {
      U[_i4][_j] = U[_i4][_j] / total;
    }
  }

  centroids = new Array(opts.k);

  for (var _i5 = 0; _i5 < opts.k; _i5++) {
    centroids[_i5] = new Array(opts.attributes.length);
  }

  weight = new Array(nodes.length);

  for (var _i6 = 0; _i6 < nodes.length; _i6++) {
    // N x C matrix
    weight[_i6] = new Array(opts.k);
  } // end init FCM


  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 2: Calculate the centroids for each step.

    updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.

    updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.

    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
      isStillMoving = true;
    }

    iterations++;
  } // Assign nodes to clusters with highest probability.


  clusters = assign$1(nodes, U, opts, cy);
  return {
    clusters: clusters,
    degreeOfMembership: U
  };
};

var kClustering = {
  kMeans: kMeans,
  kMedoids: kMedoids,
  fuzzyCMeans: fuzzyCMeans,
  fcm: fuzzyCMeans
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$6 = defaults({
  distance: 'euclidean',
  // distance metric to compare nodes
  linkage: 'min',
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: 'threshold',
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: Infinity,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: false,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: [] // array of attr functions

});
var linkageAliases = {
  'single': 'min',
  'complete': 'max'
};

var setOptions$2 = function setOptions(options) {
  var opts = defaults$6(options);
  var preferredAlias = linkageAliases[opts.linkage];

  if (preferredAlias != null) {
    opts.linkage = preferredAlias;
  }

  return opts;
};

var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
  // Find two closest clusters from cached mins
  var minKey = 0;
  var min = Infinity;
  var dist;
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  };

  for (var i = 0; i < clusters.length; i++) {
    var key = clusters[i].key;
    var _dist = dists[key][mins[key]];

    if (_dist < min) {
      minKey = key;
      min = _dist;
    }
  }

  if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {
    return false;
  }

  var c1 = index[minKey];
  var c2 = index[mins[minKey]];
  var merged; // Merge two closest clusters

  if (opts.mode === 'dendrogram') {
    merged = {
      left: c1,
      right: c2,
      key: c1.key
    };
  } else {
    merged = {
      value: c1.value.concat(c2.value),
      key: c1.key
    };
  }

  clusters[c1.index] = merged;
  clusters.splice(c2.index, 1);
  index[c1.key] = merged; // Update distances with new merged cluster

  for (var _i = 0; _i < clusters.length; _i++) {
    var cur = clusters[_i];

    if (c1.key === cur.key) {
      dist = Infinity;
    } else if (opts.linkage === 'min') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'max') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'mean') {
      dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
    } else {
      if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);
    }

    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
  } // Update cached mins


  for (var _i2 = 0; _i2 < clusters.length; _i2++) {
    var key1 = clusters[_i2].key;

    if (mins[key1] === c1.key || mins[key1] === c2.key) {
      var _min = key1;

      for (var j = 0; j < clusters.length; j++) {
        var key2 = clusters[j].key;

        if (dists[key1][key2] < dists[key1][_min]) {
          _min = key2;
        }
      }

      mins[key1] = _min;
    }

    clusters[_i2].index = _i2;
  } // Clean up meta data used for clustering


  c1.key = c2.key = c1.index = c2.index = null;
  return true;
};

var getAllChildren = function getAllChildren(root, arr, cy) {
  if (!root) return;

  if (root.value) {
    arr.push(root.value);
  } else {
    if (root.left) getAllChildren(root.left, arr);
    if (root.right) getAllChildren(root.right, arr);
  }
};

var buildDendrogram = function buildDendrogram(root, cy) {
  if (!root) return '';

  if (root.left && root.right) {
    var leftStr = buildDendrogram(root.left, cy);
    var rightStr = buildDendrogram(root.right, cy);
    var node = cy.add({
      group: 'nodes',
      data: {
        id: leftStr + ',' + rightStr
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: leftStr,
        target: node.id()
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: rightStr,
        target: node.id()
      }
    });
    return node.id();
  } else if (root.value) {
    return root.value.id();
  }
};

var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
  if (!root) return [];
  var left = [],
      right = [],
      leaves = [];

  if (k === 0) {
    // don't cut tree, simply return all nodes as 1 single cluster
    if (root.left) getAllChildren(root.left, left);
    if (root.right) getAllChildren(root.right, right);
    leaves = left.concat(right);
    return [cy.collection(leaves)];
  } else if (k === 1) {
    // cut at root
    if (root.value) {
      // leaf node
      return [cy.collection(root.value)];
    } else {
      if (root.left) getAllChildren(root.left, left);
      if (root.right) getAllChildren(root.right, right);
      return [cy.collection(left), cy.collection(right)];
    }
  } else {
    if (root.value) {
      return [cy.collection(root.value)];
    } else {
      if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
      if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
      return left.concat(right);
    }
  }
};
/* eslint-enable */


var hierarchicalClustering = function hierarchicalClustering(options) {
  var cy = this.cy();
  var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.

  var opts = setOptions$2(options);
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  }; // Begin hierarchical algorithm


  var clusters = [];
  var dists = []; // distances between each pair of clusters

  var mins = []; // closest cluster for each cluster

  var index = []; // hash of all clusters by key
  // In agglomerative (bottom-up) clustering, each node starts as its own cluster

  for (var n = 0; n < nodes.length; n++) {
    var cluster = {
      value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],
      key: n,
      index: n
    };
    clusters[n] = cluster;
    index[n] = cluster;
    dists[n] = [];
    mins[n] = 0;
  } // Calculate the distance between each pair of clusters


  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j <= i; j++) {
      var dist = void 0;

      if (opts.mode === 'dendrogram') {
        // modes store cluster values differently
        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
      } else {
        dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
      }

      dists[i][j] = dist;
      dists[j][i] = dist;

      if (dist < dists[i][mins[i]]) {
        mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
      }
    }
  } // Find the closest pair of clusters and merge them into a single cluster.
  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.


  var merged = mergeClosest(clusters, index, dists, mins, opts);

  while (merged) {
    merged = mergeClosest(clusters, index, dists, mins, opts);
  }

  var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
  // in addition to returning the clusters.

  if (opts.mode === 'dendrogram') {
    retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
    if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
  } else {
    // Regular mode simply returns the clusters
    retClusters = new Array(clusters.length);
    clusters.forEach(function (cluster, i) {
      // Clean up meta data used for clustering
      cluster.key = cluster.index = null;
      retClusters[i] = cy.collection(cluster.value);
    });
  }

  return retClusters;
};

var hierarchicalClustering$1 = {
  hierarchicalClustering: hierarchicalClustering,
  hca: hierarchicalClustering
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$7 = defaults({
  distance: 'euclidean',
  // distance metric to compare attributes between two nodes
  preference: 'median',
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1000,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [// functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
});

var setOptions$3 = function setOptions(options) {
  var dmp = options.damping;
  var pref = options.preference;

  if (!(0.5 <= dmp && dmp < 1)) {
    error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
  }

  var validPrefs = ['median', 'mean', 'min', 'max'];

  if (!(validPrefs.some(function (v) {
    return v === pref;
  }) || number(pref))) {
    error("Preference must be one of [".concat(validPrefs.map(function (p) {
      return "'".concat(p, "'");
    }).join(', '), "] or a number.  Got: ").concat(pref));
  }

  return defaults$7(options);
};
/* eslint-enable */


var getSimilarity$1 = function getSimilarity(type, n1, n2, attributes) {
  var attr = function attr(n, i) {
    return attributes[i](n);
  }; // nb negative because similarity should have an inverse relationship to distance


  return -clusteringDistance(type, attributes.length, function (i) {
    return attr(n1, i);
  }, function (i) {
    return attr(n2, i);
  }, n1, n2);
};

var getPreference = function getPreference(S, preference) {
  // larger preference = greater # of clusters
  var p = null;

  if (preference === 'median') {
    p = median(S);
  } else if (preference === 'mean') {
    p = mean(S);
  } else if (preference === 'min') {
    p = min(S);
  } else if (preference === 'max') {
    p = max(S);
  } else {
    // Custom preference number, as set by user
    p = preference;
  }

  return p;
};

var findExemplars = function findExemplars(n, R, A) {
  var indices = [];

  for (var i = 0; i < n; i++) {
    if (R[i * n + i] + A[i * n + i] > 0) {
      indices.push(i);
    }
  }

  return indices;
};

var assignClusters = function assignClusters(n, S, exemplars) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var index = -1;
    var max = -Infinity;

    for (var ei = 0; ei < exemplars.length; ei++) {
      var e = exemplars[ei];

      if (S[i * n + e] > max) {
        index = e;
        max = S[i * n + e];
      }
    }

    if (index > 0) {
      clusters.push(index);
    }
  }

  for (var _ei = 0; _ei < exemplars.length; _ei++) {
    clusters[exemplars[_ei]] = exemplars[_ei];
  }

  return clusters;
};

var assign$2 = function assign(n, S, exemplars) {
  var clusters = assignClusters(n, S, exemplars);

  for (var ei = 0; ei < exemplars.length; ei++) {
    var ii = [];

    for (var c = 0; c < clusters.length; c++) {
      if (clusters[c] === exemplars[ei]) {
        ii.push(c);
      }
    }

    var maxI = -1;
    var maxSum = -Infinity;

    for (var i = 0; i < ii.length; i++) {
      var sum = 0;

      for (var j = 0; j < ii.length; j++) {
        sum += S[ii[j] * n + ii[i]];
      }

      if (sum > maxSum) {
        maxI = i;
        maxSum = sum;
      }
    }

    exemplars[ei] = ii[maxI];
  }

  clusters = assignClusters(n, S, exemplars);
  return clusters;
};

var affinityPropagation = function affinityPropagation(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$3(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Begin affinity propagation algorithm


  var n; // number of data points

  var n2; // size of matrices

  var S; // similarity matrix (1D array)

  var p; // preference/suitability of a data point to serve as an exemplar

  var R; // responsibility matrix (1D array)

  var A; // availability matrix (1D array)

  n = nodes.length;
  n2 = n * n; // Initialize and build S similarity matrix

  S = new Array(n2);

  for (var _i = 0; _i < n2; _i++) {
    S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
  }

  for (var _i2 = 0; _i2 < n; _i2++) {
    for (var j = 0; j < n; j++) {
      if (_i2 !== j) {
        S[_i2 * n + j] = getSimilarity$1(opts.distance, nodes[_i2], nodes[j], opts.attributes);
      }
    }
  } // Place preferences on the diagonal of S


  p = getPreference(S, opts.preference);

  for (var _i3 = 0; _i3 < n; _i3++) {
    S[_i3 * n + _i3] = p;
  } // Initialize R responsibility matrix


  R = new Array(n2);

  for (var _i4 = 0; _i4 < n2; _i4++) {
    R[_i4] = 0.0;
  } // Initialize A availability matrix


  A = new Array(n2);

  for (var _i5 = 0; _i5 < n2; _i5++) {
    A[_i5] = 0.0;
  }

  var old = new Array(n);
  var Rp = new Array(n);
  var se = new Array(n);

  for (var _i6 = 0; _i6 < n; _i6++) {
    old[_i6] = 0.0;
    Rp[_i6] = 0.0;
    se[_i6] = 0;
  }

  var e = new Array(n * opts.minIterations);

  for (var _i7 = 0; _i7 < e.length; _i7++) {
    e[_i7] = 0;
  }

  var iter;

  for (iter = 0; iter < opts.maxIterations; iter++) {
    // main algorithmic loop
    // Update R responsibility matrix
    for (var _i8 = 0; _i8 < n; _i8++) {
      var max = -Infinity,
          max2 = -Infinity,
          maxI = -1,
          AS = 0.0;

      for (var _j = 0; _j < n; _j++) {
        old[_j] = R[_i8 * n + _j];
        AS = A[_i8 * n + _j] + S[_i8 * n + _j];

        if (AS >= max) {
          max2 = max;
          max = AS;
          maxI = _j;
        } else if (AS > max2) {
          max2 = AS;
        }
      }

      for (var _j2 = 0; _j2 < n; _j2++) {
        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
      }

      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
    } // Update A availability matrix


    for (var _i9 = 0; _i9 < n; _i9++) {
      var sum = 0;

      for (var _j3 = 0; _j3 < n; _j3++) {
        old[_j3] = A[_j3 * n + _i9];
        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
        sum += Rp[_j3];
      }

      sum -= Rp[_i9];
      Rp[_i9] = R[_i9 * n + _i9];
      sum += Rp[_i9];

      for (var _j4 = 0; _j4 < n; _j4++) {
        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
      }

      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
    } // Check for convergence


    var K = 0;

    for (var _i10 = 0; _i10 < n; _i10++) {
      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
      e[iter % opts.minIterations * n + _i10] = E;
      K += E;
    }

    if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
      var _sum = 0;

      for (var _i11 = 0; _i11 < n; _i11++) {
        se[_i11] = 0;

        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
          se[_i11] += e[_j5 * n + _i11];
        }

        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
          _sum++;
        }
      }

      if (_sum === n) {
        // then we have convergence
        break;
      }
    }
  } // Identify exemplars (cluster centers)


  var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters

  var clusterIndices = assign$2(n, S, exemplarsIndices);
  var clusters = {};

  for (var c = 0; c < exemplarsIndices.length; c++) {
    clusters[exemplarsIndices[c]] = [];
  }

  for (var _i12 = 0; _i12 < nodes.length; _i12++) {
    var pos = id2position[nodes[_i12].id()];

    var clusterIndex = clusterIndices[pos];

    if (clusterIndex != null) {
      // the node may have not been assigned a cluster if no valid attributes were specified
      clusters[clusterIndex].push(nodes[_i12]);
    }
  }

  var retClusters = new Array(exemplarsIndices.length);

  for (var _c = 0; _c < exemplarsIndices.length; _c++) {
    retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
  }

  return retClusters;
};

var affinityPropagation$1 = {
  affinityPropagation: affinityPropagation,
  ap: affinityPropagation
};

var hierholzerDefaults = defaults({
  root: undefined,
  directed: false
});
var elesfn$b = {
  hierholzer: function hierholzer(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        directed: args[1]
      };
    }

    var _hierholzerDefaults = hierholzerDefaults(options),
        root = _hierholzerDefaults.root,
        directed = _hierholzerDefaults.directed;

    var eles = this;
    var dflag = false;
    var oddIn;
    var oddOut;
    var startVertex;
    if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
    var nodes = {};
    var edges = {};

    if (directed) {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var ind = ele.indegree(true);
          var outd = ele.outdegree(true);
          var d1 = ind - outd;
          var d2 = outd - ind;

          if (d1 == 1) {
            if (oddIn) dflag = true;else oddIn = id;
          } else if (d2 == 1) {
            if (oddOut) dflag = true;else oddOut = id;
          } else if (d2 > 1 || d1 > 1) {
            dflag = true;
          }

          nodes[id] = [];
          ele.outgoers().forEach(function (e) {
            if (e.isEdge()) nodes[id].push(e.id());
          });
        } else {
          edges[id] = [undefined, ele.target().id()];
        }
      });
    } else {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var d = ele.degree(true);

          if (d % 2) {
            if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;
          }

          nodes[id] = [];
          ele.connectedEdges().forEach(function (e) {
            return nodes[id].push(e.id());
          });
        } else {
          edges[id] = [ele.source().id(), ele.target().id()];
        }
      });
    }

    var result = {
      found: false,
      trail: undefined
    };
    if (dflag) return result;else if (oddOut && oddIn) {
      if (directed) {
        if (startVertex && oddOut != startVertex) {
          return result;
        }

        startVertex = oddOut;
      } else {
        if (startVertex && oddOut != startVertex && oddIn != startVertex) {
          return result;
        } else if (!startVertex) {
          startVertex = oddOut;
        }
      }
    } else {
      if (!startVertex) startVertex = eles[0].id();
    }

    var walk = function walk(v) {
      var currentNode = v;
      var subtour = [v];
      var adj, adjTail, adjHead;

      while (nodes[currentNode].length) {
        adj = nodes[currentNode].shift();
        adjTail = edges[adj][0];
        adjHead = edges[adj][1];

        if (currentNode != adjHead) {
          nodes[adjHead] = nodes[adjHead].filter(function (e) {
            return e != adj;
          });
          currentNode = adjHead;
        } else if (!directed && currentNode != adjTail) {
          nodes[adjTail] = nodes[adjTail].filter(function (e) {
            return e != adj;
          });
          currentNode = adjTail;
        }

        subtour.unshift(adj);
        subtour.unshift(currentNode);
      }

      return subtour;
    };

    var trail = [];
    var subtour = [];
    subtour = walk(startVertex);

    while (subtour.length != 1) {
      if (nodes[subtour[0]].length == 0) {
        trail.unshift(eles.getElementById(subtour.shift()));
        trail.unshift(eles.getElementById(subtour.shift()));
      } else {
        subtour = walk(subtour.shift()).concat(subtour);
      }
    }

    trail.unshift(eles.getElementById(subtour.shift())); // final node

    for (var d in nodes) {
      if (nodes[d].length) {
        return result;
      }
    }

    result.found = true;
    result.trail = this.spawn(trail);
    return result;
  }
};

var elesfn$c = {};
[elesfn, elesfn$1, elesfn$2, elesfn$3, elesfn$4, elesfn$5, elesfn$6, elesfn$7, elesfn$8, elesfn$9, elesfn$a, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$b].forEach(function (props) {
  extend(elesfn$c, props);
});

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING = 0;
/*  [Promises/A+ 2.1.1]  */

var STATE_FULFILLED = 1;
/*  [Promises/A+ 2.1.2]  */

var STATE_REJECTED = 2;
/*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */

var api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api)) return new api(executor);
  /*  initialize object  */

  this.id = 'Thenable/1.0.7';
  this.state = STATE_PENDING;
  /*  initial state  */

  this.fulfillValue = undefined;
  /*  initial value  */

  /*  [Promises/A+ 1.3, 2.1.2.2]  */

  this.rejectReason = undefined;
  /*  initial reason */

  /*  [Promises/A+ 1.5, 2.1.3.2]  */

  this.onFulfilled = [];
  /*  initial handlers  */

  this.onRejected = [];
  /*  initial handlers  */

  /*  provide optional information-hiding proxy  */

  this.proxy = {
    then: this.then.bind(this)
  };
  /*  support optional executor function  */

  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
/*  promise API methods  */


api.prototype = {
  /*  promise resolving methods  */
  fulfill: function fulfill(value) {
    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
  },
  reject: function reject(value) {
    return deliver(this, STATE_REJECTED, 'rejectReason', value);
  },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function then(onFulfilled, onRejected) {
    var curr = this;
    var next = new api();
    /*  [Promises/A+ 2.2.7]  */

    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));
    /*  [Promises/A+ 2.2.2/2.2.6]  */

    curr.onRejected.push(resolver(onRejected, next, 'reject'));
    /*  [Promises/A+ 2.2.3/2.2.6]  */

    execute(curr);
    return next.proxy;
    /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};
/*  deliver an action  */

var deliver = function deliver(curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state;
    /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */

    curr[name] = value;
    /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */

    execute(curr);
  }

  return curr;
};
/*  execute all handlers  */


var execute = function execute(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
};
/*  execute particular set of handlers  */


var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */

  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0) return;
  /*  iterate over all handlers, exactly once  */

  var handlers = curr[name];
  curr[name] = [];
  /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */

  var func = function func() {
    for (var i = 0; i < handlers.length; i++) {
      handlers[i](value);
    }
    /*  [Promises/A+ 2.2.5]  */

  };
  /*  execute procedure asynchronously  */

  /*  [Promises/A+ 2.2.4, 3.1]  */


  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
};
/*  generate a resolver function  */


var resolver = function resolver(cb, next, method) {
  return function (value) {
    if (typeof cb !== 'function')
      /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value);
      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
        var result;

        try {
          result = cb(value);
        }
        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);
          /*  [Promises/A+ 2.2.7.2]  */

          return;
        }

        resolve(next, result);
        /*  [Promises/A+ 2.2.7.1]  */
      }
  };
};
/*  "Promise Resolution Procedure"  */

/*  [Promises/A+ 2.3]  */


var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */

  /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError('cannot resolve promise with itself'));
    return;
  }
  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */


  var then;

  if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {
    try {
      then = x.then;
    }
    /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e);
      /*  [Promises/A+ 2.3.3.2]  */

      return;
    }
  }
  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */


  if (typeof then === 'function') {
    var resolved = false;

    try {
      /*  call retrieved "then" method */

      /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
      /*  resolvePromise  */

      /*  [Promises/A+ 2.3.3.3.1]  */
      function (y) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        if (y === x)
          /*  [Promises/A+ 3.6]  */
          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
      },
      /*  rejectPromise  */

      /*  [Promises/A+ 2.3.3.3.2]  */
      function (r) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        promise.reject(r);
      });
    } catch (e) {
      if (!resolved)
        /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e);
      /*  [Promises/A+ 2.3.3.3.4]  */
    }

    return;
  }
  /*  handle other values  */


  promise.fulfill(x);
  /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
}; // so we always have Promise.all()


api.all = function (ps) {
  return new api(function (resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;

    var fulfill = function fulfill(i, val) {
      vals[i] = val;
      doneCount++;

      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    };

    for (var i = 0; i < ps.length; i++) {
      (function (i) {
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if (isPromise) {
          p.then(function (val) {
            fulfill(i, val);
          }, function (err) {
            rejectAll(err);
          });
        } else {
          var val = p;
          fulfill(i, val);
        }
      })(i);
    }
  });
};

api.resolve = function (val) {
  return new api(function (resolve, reject) {
    resolve(val);
  });
};

api.reject = function (val) {
  return new api(function (resolve, reject) {
    reject(val);
  });
};

var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

var Animation = function Animation(target, opts, opts2) {
  var isCore = core(target);
  var isEle = !isCore;

  var _p = this._private = extend({
    duration: 1000
  }, opts, opts2);

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if (_p.complete && fn(_p.complete)) {
    _p.completes.push(_p.complete);
  }

  if (isEle) {
    var pos = target.position();
    _p.startPosition = _p.startPosition || {
      x: pos.x,
      y: pos.y
    };
    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
  }

  if (isCore) {
    var pan = target.pan();
    _p.startPan = {
      x: pan.x,
      y: pan.y
    };
    _p.startZoom = target.zoom();
  } // for future timeline/animations impl


  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;
extend(anifn, {
  instanceString: function instanceString() {
    return 'animation';
  },
  hook: function hook() {
    var _p = this._private;

    if (!_p.hooked) {
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;

      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }

      q.push(this); // add to the animation loop pool

      if (elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }

      _p.hooked = true;
    }

    return this;
  },
  play: function play() {
    var _p = this._private; // autorewind

    if (_p.progress === 1) {
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will start the animation...

    return this;
  },
  playing: function playing() {
    return this._private.playing;
  },
  apply: function apply() {
    var _p = this._private;
    _p.applying = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will apply the animation at this progress

    return this;
  },
  applying: function applying() {
    return this._private.applying;
  },
  pause: function pause() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    return this;
  },
  stop: function stop() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },
  rewind: function rewind() {
    return this.progress(0);
  },
  fastforward: function fastforward() {
    return this.progress(1);
  },
  time: function time(t) {
    var _p = this._private;

    if (t === undefined) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  },
  progress: function progress(p) {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (p === undefined) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if (wasPlaying) {
        this.play();
      }
    }

    return this;
  },
  completed: function completed() {
    return this._private.progress === 1;
  },
  reverse: function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (wasPlaying) {
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function swap(a, b) {
      var _pa = _p[a];

      if (_pa == null) {
        return;
      }

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap('zoom', 'startZoom');
    swap('pan', 'startPan');
    swap('position', 'startPosition'); // swap styles

    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop = _p.style[i];
        var name = prop.name;
        var startStyleProp = _p.startStyle[name];
        _p.startStyle[name] = prop;
        _p.style[i] = startStyleProp;
      }
    }

    if (wasPlaying) {
      this.play();
    }

    return this;
  },
  promise: function promise(type) {
    var _p = this._private;
    var arr;

    switch (type) {
      case 'frame':
        arr = _p.frames;
        break;

      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise$1(function (resolve, reject) {
      arr.push(function () {
        resolve();
      });
    });
  }
});
anifn.complete = anifn.completed;
anifn.run = anifn.play;
anifn.running = anifn.playing;

var define = {
  animated: function animated() {
    return function animatedImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return false;
      }

      var ele = all[0];

      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    };
  },
  // animated
  clearQueue: function clearQueue() {
    return function clearQueueImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  },
  // clearQueue
  delay: function delay() {
    return function delayImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  delayAnimation: function delayAnimation() {
    return function delayAnimationImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  animation: function animation() {
    return function animationImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if (!cy.styleEnabled()) {
        return this;
      }

      var style = cy.style();
      properties = extend({}, properties, params);
      var propertiesEmpty = Object.keys(properties).length === 0;

      if (propertiesEmpty) {
        return new Animation(all[0], properties); // nothing to animate
      }

      if (properties.duration === undefined) {
        properties.duration = 400;
      }

      switch (properties.duration) {
        case 'slow':
          properties.duration = 600;
          break;

        case 'fast':
          properties.duration = 200;
          break;
      }

      if (isEles) {
        properties.style = style.getPropsList(properties.style || properties.css);
        properties.css = undefined;
      }

      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();
        properties.position = renderedToModelPosition(rpos, zoom, pan);
      } // override pan w/ panBy if set


      if (isCore && properties.panBy != null) {
        var panBy = properties.panBy;
        var cyPan = cy.pan();
        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      } // override pan w/ center if set


      var center = properties.center || properties.centre;

      if (isCore && center != null) {
        var centerPan = cy.getCenterPan(center.eles, properties.zoom);

        if (centerPan != null) {
          properties.pan = centerPan;
        }
      } // override pan & zoom w/ fit if set


      if (isCore && properties.fit != null) {
        var fit = properties.fit;
        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      } // override zoom (& potentially pan) w/ zoom obj if set


      if (isCore && plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);

        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }

          if (vp.panned) {
            properties.pan = vp.pan;
          }
        }
      }

      return new Animation(all[0], properties);
    };
  },
  // animate
  animate: function animate() {
    return function animateImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      if (params) {
        properties = extend({}, properties, params);
      } // manually hook and run the animation


      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);
        var ani = ele.animation(properties, queue ? {
          queue: true
        } : undefined);
        ani.play();
      }

      return this; // chaining
    };
  },
  // animate
  stop: function stop() {
    return function stopImpl(clearQueue, jumpToEnd) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;

          if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        } // clear the queue of future animations


        if (clearQueue) {
          _p.animation.queue = [];
        }

        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      } // we have to notify (the animation loop doesn't do it for us on `stop`)


      cy.notify('draw');
      return this;
    };
  } // stop

}; // define

var define$1 = {
  // access data field
  data: function data(params) {
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {},
      // key => true if immutable
      updateStyle: false,
      beforeGet: function beforeGet(self) {},
      beforeSet: function beforeSet(self, obj) {},
      onSet: function onSet(self) {},
      canSet: function canSet(self) {
        return true;
      }
    };
    params = extend({}, defaults, params);
    return function dataImpl(name, value) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)

      if (string(name)) {
        // set or get property
        // .data('foo')
        if (p.allowGetting && value === undefined) {
          // get
          var ret;

          if (single) {
            p.beforeGet(single);
            ret = single._private[p.field][name];
          }

          return ret; // .data('foo', 'bar')
        } else if (p.allowSetting && value !== undefined) {
          // set
          var valid = !p.immutableKeys[name];

          if (valid) {
            var change = _defineProperty({}, name, value);

            p.beforeSet(self, change);

            for (var i = 0, l = all.length; i < l; i++) {
              var ele = all[i];

              if (p.canSet(ele)) {
                ele._private[p.field][name] = value;
              }
            } // update mappers if asked


            if (p.updateStyle) {
              self.updateStyle();
            } // call onSet callback


            p.onSet(self);

            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            }
          }
        } // .data({ 'foo': 'bar' })

      } else if (p.allowSetting && plainObject(name)) {
        // extend
        var obj = name;
        var k, v;
        var keys = Object.keys(obj);
        p.beforeSet(self, obj);

        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];

          var _valid = !p.immutableKeys[k];

          if (_valid) {
            for (var j = 0; j < all.length; j++) {
              var _ele = all[j];

              if (p.canSet(_ele)) {
                _ele._private[p.field][k] = v;
              }
            }
          }
        } // update mappers if asked


        if (p.updateStyle) {
          self.updateStyle();
        } // call onSet callback


        p.onSet(self);

        if (p.settingTriggersEvent) {
          self[p.triggerFnName](p.settingEvent);
        } // .data(function(){ ... })

      } else if (p.allowBinding && fn(name)) {
        // bind to event
        var fn$1 = name;
        self.on(p.bindingEvent, fn$1); // .data()
      } else if (p.allowGetting && name === undefined) {
        // get whole object
        var _ret;

        if (single) {
          p.beforeGet(single);
          _ret = single._private[p.field];
        }

        return _ret;
      }

      return self; // maintain chainability
    }; // function
  },
  // data
  // remove data field
  removeData: function removeData(params) {
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable

    };
    params = extend({}, defaults, params);
    return function removeDataImpl(names) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      // .removeData('foo bar')

      if (string(names)) {
        // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for (var i = 0; i < l; i++) {
          // delete each non-empty key
          var key = keys[i];

          if (emptyString(key)) {
            continue;
          }

          var valid = !p.immutableKeys[key]; // not valid if immutable

          if (valid) {
            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
              all[i_a]._private[p.field][key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        } // .removeData()

      } else if (names === undefined) {
        // then delete all keys
        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all[_i_a]._private[p.field];

          var _keys = Object.keys(_privateFields);

          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p.immutableKeys[_key];

            if (validKeyToDelete) {
              _privateFields[_key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }
      }

      return self; // maintain chaining
    }; // function
  } // removeData

}; // define

var define$2 = {
  eventAliasesOn: function eventAliasesOn(proto) {
    var p = proto;
    p.addListener = p.listen = p.bind = p.on;
    p.unlisten = p.unbind = p.off = p.removeListener;
    p.trigger = p.emit; // this is just a wrapper alias of .on()

    p.pon = p.promiseOn = function (events, selector) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      return new Promise$1(function (resolve, reject) {
        var callback = function callback(e) {
          self.off.apply(self, offArgs);
          resolve(e);
        };

        var onArgs = args.concat([callback]);
        var offArgs = onArgs.concat([]);
        self.on.apply(self, onArgs);
      });
    };
  }
}; // define

// use this module to cherry pick functions into your prototype
var define$3 = {};
[define, define$1, define$2].forEach(function (m) {
  extend(define$3, m);
});

var elesfn$d = {
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop()
};

var elesfn$e = {
  classes: function classes(_classes) {
    var self = this;

    if (_classes === undefined) {
      var ret = [];

      self[0]._private.classes.forEach(function (cls) {
        return ret.push(cls);
      });

      return ret;
    } else if (!array(_classes)) {
      // extract classes from string
      _classes = (_classes || '').match(/\S+/g) || [];
    }

    var changed = [];
    var classesSet = new Set$1(_classes); // check and update each ele

    for (var j = 0; j < self.length; j++) {
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false; // check if ele has all of the passed classes

      for (var i = 0; i < _classes.length; i++) {
        var cls = _classes[i];
        var eleHasClass = eleClasses.has(cls);

        if (!eleHasClass) {
          changedEle = true;
          break;
        }
      } // check if ele has classes outside of those passed


      if (!changedEle) {
        changedEle = eleClasses.size !== _classes.length;
      }

      if (changedEle) {
        _p.classes = classesSet;
        changed.push(ele);
      }
    } // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  addClass: function addClass(classes) {
    return this.toggleClass(classes, true);
  },
  hasClass: function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  },
  toggleClass: function toggleClass(classes, toggle) {
    if (!array(classes)) {
      // extract classes from string
      classes = classes.match(/\S+/g) || [];
    }

    var self = this;
    var toggleUndefd = toggle === undefined;
    var changed = []; // eles who had classes changed

    for (var i = 0, il = self.length; i < il; i++) {
      var ele = self[i];
      var eleClasses = ele._private.classes;
      var changedEle = false;

      for (var j = 0; j < classes.length; j++) {
        var cls = classes[j];
        var hasClass = eleClasses.has(cls);
        var changedNow = false;

        if (toggle || toggleUndefd && !hasClass) {
          eleClasses.add(cls);
          changedNow = true;
        } else if (!toggle || toggleUndefd && hasClass) {
          eleClasses["delete"](cls);
          changedNow = true;
        }

        if (!changedEle && changedNow) {
          changed.push(ele);
          changedEle = true;
        }
      } // for j classes

    } // for i eles
    // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  removeClass: function removeClass(classes) {
    return this.toggleClass(classes, false);
  },
  flashClass: function flashClass(classes, duration) {
    var self = this;

    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self; // nothing to do really
    }

    self.addClass(classes);
    setTimeout(function () {
      self.removeClass(classes);
    }, duration);
    return self;
  }
};
elesfn$e.className = elesfn$e.classNames = elesfn$e.classes;

var tokens = {
  metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]',
  // chars we need to escape in let names, etc
  comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=',
  // binary comparison op (used in data selectors)
  boolOp: '\\?|\\!|\\^',
  // boolean (unary) operators (used in data selectors)
  string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'",
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: number$1,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: 'degree|indegree|outdegree',
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: '\\s*,\\s*',
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: '\\s+',
  child: '\\s+>\\s+',
  subject: '\\$',
  group: 'node|edge|\\*',
  directedEdge: '\\s+->\\s+',
  undirectedEdge: '\\s+<->\\s+'
};
tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name

tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number

tokens.className = tokens.variable; // a class name (follows variable conventions)

tokens.id = tokens.variable; // an element id (follows variable conventions)

(function () {
  var ops, op, i; // add @ variants to comparatorOp

  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += '|@' + op;
  } // add ! variants to comparatorOp


  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];

    if (op.indexOf('!') >= 0) {
      continue;
    } // skip ops that explicitly contain !


    if (op === '=') {
      continue;
    } // skip = b/c != is explicitly defined


    tokens.comparatorOp += '|\\!' + op;
  }
})();

/**
 * Make a new query object
 *
 * @prop type {Type} The type enum (int) of the query
 * @prop checks List of checks to make against an ele to test for a match
 */
var newQuery = function newQuery() {
  return {
    checks: []
  };
};

/**
 * A check type enum-like object.  Uses integer values for fast match() lookup.
 * The ordering does not matter as long as the ints are unique.
 */
var Type = {
  /** E.g. node */
  GROUP: 0,

  /** A collection of elements */
  COLLECTION: 1,

  /** A filter(ele) function */
  FILTER: 2,

  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,

  /** E.g. [foo] */
  DATA_EXIST: 4,

  /** E.g. [?foo] */
  DATA_BOOL: 5,

  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,

  /** E.g. :selected */
  STATE: 7,

  /** E.g. #foo */
  ID: 8,

  /** E.g. .foo */
  CLASS: 9,

  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,

  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,

  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,

  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,

  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,

  /** E.g. #foo > #bar */
  CHILD: 15,

  /** E.g. #foo #bar */
  DESCENDANT: 16,

  /** E.g. $#foo > #bar */
  PARENT: 17,

  /** E.g. $#foo #bar */
  ANCESTOR: 18,

  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,

  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
};

var stateSelectors = [{
  selector: ':selected',
  matches: function matches(ele) {
    return ele.selected();
  }
}, {
  selector: ':unselected',
  matches: function matches(ele) {
    return !ele.selected();
  }
}, {
  selector: ':selectable',
  matches: function matches(ele) {
    return ele.selectable();
  }
}, {
  selector: ':unselectable',
  matches: function matches(ele) {
    return !ele.selectable();
  }
}, {
  selector: ':locked',
  matches: function matches(ele) {
    return ele.locked();
  }
}, {
  selector: ':unlocked',
  matches: function matches(ele) {
    return !ele.locked();
  }
}, {
  selector: ':visible',
  matches: function matches(ele) {
    return ele.visible();
  }
}, {
  selector: ':hidden',
  matches: function matches(ele) {
    return !ele.visible();
  }
}, {
  selector: ':transparent',
  matches: function matches(ele) {
    return ele.transparent();
  }
}, {
  selector: ':grabbed',
  matches: function matches(ele) {
    return ele.grabbed();
  }
}, {
  selector: ':free',
  matches: function matches(ele) {
    return !ele.grabbed();
  }
}, {
  selector: ':removed',
  matches: function matches(ele) {
    return ele.removed();
  }
}, {
  selector: ':inside',
  matches: function matches(ele) {
    return !ele.removed();
  }
}, {
  selector: ':grabbable',
  matches: function matches(ele) {
    return ele.grabbable();
  }
}, {
  selector: ':ungrabbable',
  matches: function matches(ele) {
    return !ele.grabbable();
  }
}, {
  selector: ':animated',
  matches: function matches(ele) {
    return ele.animated();
  }
}, {
  selector: ':unanimated',
  matches: function matches(ele) {
    return !ele.animated();
  }
}, {
  selector: ':parent',
  matches: function matches(ele) {
    return ele.isParent();
  }
}, {
  selector: ':childless',
  matches: function matches(ele) {
    return ele.isChildless();
  }
}, {
  selector: ':child',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':orphan',
  matches: function matches(ele) {
    return ele.isOrphan();
  }
}, {
  selector: ':nonorphan',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':compound',
  matches: function matches(ele) {
    if (ele.isNode()) {
      return ele.isParent();
    } else {
      return ele.source().isParent() || ele.target().isParent();
    }
  }
}, {
  selector: ':loop',
  matches: function matches(ele) {
    return ele.isLoop();
  }
}, {
  selector: ':simple',
  matches: function matches(ele) {
    return ele.isSimple();
  }
}, {
  selector: ':active',
  matches: function matches(ele) {
    return ele.active();
  }
}, {
  selector: ':inactive',
  matches: function matches(ele) {
    return !ele.active();
  }
}, {
  selector: ':backgrounding',
  matches: function matches(ele) {
    return ele.backgrounding();
  }
}, {
  selector: ':nonbackgrounding',
  matches: function matches(ele) {
    return !ele.backgrounding();
  }
}].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
  return descending(a.selector, b.selector);
});

var lookup = function () {
  var selToFn = {};
  var s;

  for (var i = 0; i < stateSelectors.length; i++) {
    s = stateSelectors[i];
    selToFn[s.selector] = s.matches;
  }

  return selToFn;
}();

var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
  return lookup[sel](ele);
};
var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
  return s.selector;
}).join('|') + ')';

// so that values get compared properly in Selector.filter()

var cleanMetaChars = function cleanMetaChars(str) {
  return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
    return $1;
  });
};

var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
  selector[selector.length - 1] = replacementQuery;
}; // NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i]
// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward


var exprs = [{
  name: 'group',
  // just used for identifying when debugging
  query: true,
  regex: '(' + tokens.group + ')',
  populate: function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        group = _ref2[0];

    query.checks.push({
      type: Type.GROUP,
      value: group === '*' ? group : group + 's'
    });
  }
}, {
  name: 'state',
  query: true,
  regex: stateSelectorRegex,
  populate: function populate(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        state = _ref4[0];

    query.checks.push({
      type: Type.STATE,
      value: state
    });
  }
}, {
  name: 'id',
  query: true,
  regex: '\\#(' + tokens.id + ')',
  populate: function populate(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        id = _ref6[0];

    query.checks.push({
      type: Type.ID,
      value: cleanMetaChars(id)
    });
  }
}, {
  name: 'className',
  query: true,
  regex: '\\.(' + tokens.className + ')',
  populate: function populate(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        className = _ref8[0];

    query.checks.push({
      type: Type.CLASS,
      value: cleanMetaChars(className)
    });
  }
}, {
  name: 'dataExists',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        variable = _ref10[0];

    query.checks.push({
      type: Type.DATA_EXIST,
      field: cleanMetaChars(variable)
    });
  }
}, {
  name: 'dataCompare',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
  populate: function populate(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3),
        variable = _ref12[0],
        comparatorOp = _ref12[1],
        value = _ref12[2];

    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

    if (valueIsString) {
      value = value.substring(1, value.length - 1);
    } else {
      value = parseFloat(value);
    }

    query.checks.push({
      type: Type.DATA_COMPARE,
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value
    });
  }
}, {
  name: 'dataBool',
  query: true,
  regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        boolOp = _ref14[0],
        variable = _ref14[1];

    query.checks.push({
      type: Type.DATA_BOOL,
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }
}, {
  name: 'metaCompare',
  query: true,
  regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
  populate: function populate(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3),
        meta = _ref16[0],
        comparatorOp = _ref16[1],
        number = _ref16[2];

    query.checks.push({
      type: Type.META_COMPARE,
      field: cleanMetaChars(meta),
      operator: comparatorOp,
      value: parseFloat(number)
    });
  }
}, {
  name: 'nextQuery',
  separator: true,
  regex: tokens.separator,
  populate: function populate(selector, query) {
    var currentSubject = selector.currentSubject;
    var edgeCount = selector.edgeCount;
    var compoundCount = selector.compoundCount;
    var lastQ = selector[selector.length - 1];

    if (currentSubject != null) {
      lastQ.subject = currentSubject;
      selector.currentSubject = null;
    }

    lastQ.edgeCount = edgeCount;
    lastQ.compoundCount = compoundCount;
    selector.edgeCount = 0;
    selector.compoundCount = 0; // go on to next query

    var nextQuery = selector[selector.length++] = newQuery();
    return nextQuery; // this is the new query to be filled by the following exprs
  }
}, {
  name: 'directedEdge',
  separator: true,
  regex: tokens.directedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.DIRECTED_EDGE,
        source: source,
        target: target
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // source/target
      var srcTgtQ = newQuery();
      var _source = query;

      var _target = newQuery();

      srcTgtQ.checks.push({
        type: Type.NODE_SOURCE,
        source: _source,
        target: _target
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, srcTgtQ);
      selector.edgeCount++;
      return _target; // now populating the target with the following expressions
    }
  }
}, {
  name: 'undirectedEdge',
  separator: true,
  regex: tokens.undirectedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.UNDIRECTED_EDGE,
        nodes: [source, target]
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // neighbourhood
      var nhoodQ = newQuery();
      var node = query;
      var neighbor = newQuery();
      nhoodQ.checks.push({
        type: Type.NODE_NEIGHBOR,
        node: node,
        neighbor: neighbor
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, nhoodQ);
      return neighbor; // now populating the neighbor with following expressions
    }
  }
}, {
  name: 'child',
  separator: true,
  regex: tokens.child,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: child query
      var parentChildQuery = newQuery();
      var child = newQuery();
      var parent = selector[selector.length - 1];
      parentChildQuery.checks.push({
        type: Type.CHILD,
        parent: parent,
        child: child
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, parentChildQuery);
      selector.compoundCount++; // we're now populating the child query with expressions that follow

      return child;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _child = newQuery();

      var _parent = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _parent.checks.push({
        type: Type.TRUE
      }); // parent implicitly refs the subject


      right.checks.push({
        type: Type.PARENT,
        // type is swapped on right side queries
        parent: _parent,
        child: _child // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _child; // now populating the right side's child
    } else {
      // parent query
      // info for parent query
      var _parent2 = newQuery();

      var _child2 = newQuery();

      var pcQChecks = [{
        type: Type.PARENT,
        parent: _parent2,
        child: _child2
      }]; // the parent-child query takes the place of the query previously being populated

      _parent2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = pcQChecks; // pc query takes over

      selector.compoundCount++;
      return _child2; // we're now populating the child
    }
  }
}, {
  name: 'descendant',
  separator: true,
  regex: tokens.descendant,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: descendant query
      var ancChQuery = newQuery();
      var descendant = newQuery();
      var ancestor = selector[selector.length - 1];
      ancChQuery.checks.push({
        type: Type.DESCENDANT,
        ancestor: ancestor,
        descendant: descendant
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, ancChQuery);
      selector.compoundCount++; // we're now populating the descendant query with expressions that follow

      return descendant;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _descendant = newQuery();

      var _ancestor = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _ancestor.checks.push({
        type: Type.TRUE
      }); // ancestor implicitly refs the subject


      right.checks.push({
        type: Type.ANCESTOR,
        // type is swapped on right side queries
        ancestor: _ancestor,
        descendant: _descendant // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _descendant; // now populating the right side's descendant
    } else {
      // ancestor query
      // info for parent query
      var _ancestor2 = newQuery();

      var _descendant2 = newQuery();

      var adQChecks = [{
        type: Type.ANCESTOR,
        ancestor: _ancestor2,
        descendant: _descendant2
      }]; // the parent-child query takes the place of the query previously being populated

      _ancestor2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = adQChecks; // pc query takes over

      selector.compoundCount++;
      return _descendant2; // we're now populating the child
    }
  }
}, {
  name: 'subject',
  modifier: true,
  regex: tokens.subject,
  populate: function populate(selector, query) {
    if (selector.currentSubject != null && selector.currentSubject !== query) {
      warn('Redefinition of subject in selector `' + selector.toString() + '`');
      return false;
    }

    selector.currentSubject = query;
    var topQ = selector[selector.length - 1];
    var topChk = topQ.checks[0];
    var topType = topChk == null ? null : topChk.type;

    if (topType === Type.DIRECTED_EDGE) {
      // directed edge with subject on the target
      // change to target node check
      topChk.type = Type.NODE_TARGET;
    } else if (topType === Type.UNDIRECTED_EDGE) {
      // undirected edge with subject on the second node
      // change to neighbor check
      topChk.type = Type.NODE_NEIGHBOR;
      topChk.node = topChk.nodes[1]; // second node is subject

      topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type

      topChk.nodes = null;
    }
  }
}];
exprs.forEach(function (e) {
  return e.regexObj = new RegExp('^' + e.regex);
});

/**
 * Of all the expressions, find the first match in the remaining text.
 * @param {string} remaining The remaining text to parse
 * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
 */

var consumeExpr = function consumeExpr(remaining) {
  var expr;
  var match;
  var name;

  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;
    var m = remaining.match(e.regexObj);

    if (m != null) {
      match = m;
      expr = e;
      name = n;
      var consumed = m[0];
      remaining = remaining.substring(consumed.length);
      break; // we've consumed one expr, so we can return now
    }
  }

  return {
    expr: expr,
    match: match,
    name: name,
    remaining: remaining
  };
};
/**
 * Consume all the leading whitespace
 * @param {string} remaining The text to consume
 * @returns The text with the leading whitespace removed
 */


var consumeWhitespace = function consumeWhitespace(remaining) {
  var match = remaining.match(/^\s+/);

  if (match) {
    var consumed = match[0];
    remaining = remaining.substring(consumed.length);
  }

  return remaining;
};
/**
 * Parse the string and store the parsed representation in the Selector.
 * @param {string} selector The selector string
 * @returns `true` if the selector was successfully parsed, `false` otherwise
 */


var parse = function parse(selector) {
  var self = this;
  var remaining = self.inputText = selector;
  var currentQuery = self[0] = newQuery();
  self.length = 1;
  remaining = consumeWhitespace(remaining); // get rid of leading whitespace

  for (;;) {
    var exprInfo = consumeExpr(remaining);

    if (exprInfo.expr == null) {
      warn('The selector `' + selector + '`is invalid');
      return false;
    } else {
      var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery

      var ret = exprInfo.expr.populate(self, currentQuery, args);

      if (ret === false) {
        return false; // exit if population failed
      } else if (ret != null) {
        currentQuery = ret; // change the current query to be filled if the expr specifies
      }
    }

    remaining = exprInfo.remaining; // we're done when there's nothing left to parse

    if (remaining.match(/^\s*$/)) {
      break;
    }
  }

  var lastQ = self[self.length - 1];

  if (self.currentSubject != null) {
    lastQ.subject = self.currentSubject;
  }

  lastQ.edgeCount = self.edgeCount;
  lastQ.compoundCount = self.compoundCount;

  for (var i = 0; i < self.length; i++) {
    var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations

    if (q.compoundCount > 0 && q.edgeCount > 0) {
      warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');
      return false;
    }

    if (q.edgeCount > 1) {
      warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');
      return false;
    } else if (q.edgeCount === 1) {
      warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');
    }
  }

  return true; // success
};
/**
 * Get the selector represented as a string.  This value uses default formatting,
 * so things like spacing may differ from the input text passed to the constructor.
 * @returns {string} The selector string
 */


var toString = function toString() {
  if (this.toStringCache != null) {
    return this.toStringCache;
  }

  var clean = function clean(obj) {
    if (obj == null) {
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function cleanVal(val) {
    if (string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  };

  var space = function space(val) {
    return ' ' + val + ' ';
  };

  var checkToString = function checkToString(check, subject) {
    var type = check.type,
        value = check.value;

    switch (type) {
      case Type.GROUP:
        {
          var group = clean(value);
          return group.substring(0, group.length - 1);
        }

      case Type.DATA_COMPARE:
        {
          var field = check.field,
              operator = check.operator;
          return '[' + field + space(clean(operator)) + cleanVal(value) + ']';
        }

      case Type.DATA_BOOL:
        {
          var _operator = check.operator,
              _field = check.field;
          return '[' + clean(_operator) + _field + ']';
        }

      case Type.DATA_EXIST:
        {
          var _field2 = check.field;
          return '[' + _field2 + ']';
        }

      case Type.META_COMPARE:
        {
          var _operator2 = check.operator,
              _field3 = check.field;
          return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';
        }

      case Type.STATE:
        {
          return value;
        }

      case Type.ID:
        {
          return '#' + value;
        }

      case Type.CLASS:
        {
          return '.' + value;
        }

      case Type.PARENT:
      case Type.CHILD:
        {
          return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);
        }

      case Type.ANCESTOR:
      case Type.DESCENDANT:
        {
          return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);
        }

      case Type.COMPOUND_SPLIT:
        {
          var lhs = queryToString(check.left, subject);
          var sub = queryToString(check.subject, subject);
          var rhs = queryToString(check.right, subject);
          return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;
        }

      case Type.TRUE:
        {
          return '';
        }
    }
  };

  var queryToString = function queryToString(query, subject) {
    return query.checks.reduce(function (str, chk, i) {
      return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);
    }, '');
  };

  var str = '';

  for (var i = 0; i < this.length; i++) {
    var query = this[i];
    str += queryToString(query, query.subject);

    if (this.length > 1 && i < this.length - 1) {
      str += ', ';
    }
  }

  this.toStringCache = str;
  return str;
};
var parse$1 = {
  parse: parse,
  toString: toString
};

var valCmp = function valCmp(fieldVal, operator, value) {
  var matches;
  var isFieldStr = string(fieldVal);
  var isFieldNum = number(fieldVal);
  var isValStr = string(value);
  var fieldStr, valStr;
  var caseInsensitive = false;
  var notExpr = false;
  var isIneqCmp = false;

  if (operator.indexOf('!') >= 0) {
    operator = operator.replace('!', '');
    notExpr = true;
  }

  if (operator.indexOf('@') >= 0) {
    operator = operator.replace('@', '');
    caseInsensitive = true;
  }

  if (isFieldStr || isValStr || caseInsensitive) {
    fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;
    valStr = '' + value;
  } // if we're doing a case insensitive comparison, then we're using a STRING comparison
  // even if we're comparing numbers


  if (caseInsensitive) {
    fieldVal = fieldStr = fieldStr.toLowerCase();
    value = valStr = valStr.toLowerCase();
  }

  switch (operator) {
    case '*=':
      matches = fieldStr.indexOf(valStr) >= 0;
      break;

    case '$=':
      matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
      break;

    case '^=':
      matches = fieldStr.indexOf(valStr) === 0;
      break;

    case '=':
      matches = fieldVal === value;
      break;

    case '>':
      isIneqCmp = true;
      matches = fieldVal > value;
      break;

    case '>=':
      isIneqCmp = true;
      matches = fieldVal >= value;
      break;

    case '<':
      isIneqCmp = true;
      matches = fieldVal < value;
      break;

    case '<=':
      isIneqCmp = true;
      matches = fieldVal <= value;
      break;

    default:
      matches = false;
      break;
  } // apply the not op, but null vals for inequalities should always stay non-matching


  if (notExpr && (fieldVal != null || !isIneqCmp)) {
    matches = !matches;
  }

  return matches;
};
var boolCmp = function boolCmp(fieldVal, operator) {
  switch (operator) {
    case '?':
      return fieldVal ? true : false;

    case '!':
      return fieldVal ? false : true;

    case '^':
      return fieldVal === undefined;
  }
};
var existCmp = function existCmp(fieldVal) {
  return fieldVal !== undefined;
};
var data = function data(ele, field) {
  return ele.data(field);
};
var meta = function meta(ele, field) {
  return ele[field]();
};

/** A lookup of `match(check, ele)` functions by `Type` int */

var match = [];
/**
 * Returns whether the query matches for the element
 * @param query The `{ type, value, ... }` query object
 * @param ele The element to compare against
*/

var matches = function matches(query, ele) {
  return query.checks.every(function (chk) {
    return match[chk.type](chk, ele);
  });
};

match[Type.GROUP] = function (check, ele) {
  var group = check.value;
  return group === '*' || group === ele.group();
};

match[Type.STATE] = function (check, ele) {
  var stateSelector = check.value;
  return stateSelectorMatches(stateSelector, ele);
};

match[Type.ID] = function (check, ele) {
  var id = check.value;
  return ele.id() === id;
};

match[Type.CLASS] = function (check, ele) {
  var cls = check.value;
  return ele.hasClass(cls);
};

match[Type.META_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(meta(ele, field), operator, value);
};

match[Type.DATA_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(data(ele, field), operator, value);
};

match[Type.DATA_BOOL] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return boolCmp(data(ele, field), operator);
};

match[Type.DATA_EXIST] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return existCmp(data(ele, field));
};

match[Type.UNDIRECTED_EDGE] = function (check, ele) {
  var qA = check.nodes[0];
  var qB = check.nodes[1];
  var src = ele.source();
  var tgt = ele.target();
  return matches(qA, src) && matches(qB, tgt) || matches(qB, src) && matches(qA, tgt);
};

match[Type.NODE_NEIGHBOR] = function (check, ele) {
  return matches(check.node, ele) && ele.neighborhood().some(function (n) {
    return n.isNode() && matches(check.neighbor, n);
  });
};

match[Type.DIRECTED_EDGE] = function (check, ele) {
  return matches(check.source, ele.source()) && matches(check.target, ele.target());
};

match[Type.NODE_SOURCE] = function (check, ele) {
  return matches(check.source, ele) && ele.outgoers().some(function (n) {
    return n.isNode() && matches(check.target, n);
  });
};

match[Type.NODE_TARGET] = function (check, ele) {
  return matches(check.target, ele) && ele.incomers().some(function (n) {
    return n.isNode() && matches(check.source, n);
  });
};

match[Type.CHILD] = function (check, ele) {
  return matches(check.child, ele) && matches(check.parent, ele.parent());
};

match[Type.PARENT] = function (check, ele) {
  return matches(check.parent, ele) && ele.children().some(function (c) {
    return matches(check.child, c);
  });
};

match[Type.DESCENDANT] = function (check, ele) {
  return matches(check.descendant, ele) && ele.ancestors().some(function (a) {
    return matches(check.ancestor, a);
  });
};

match[Type.ANCESTOR] = function (check, ele) {
  return matches(check.ancestor, ele) && ele.descendants().some(function (d) {
    return matches(check.descendant, d);
  });
};

match[Type.COMPOUND_SPLIT] = function (check, ele) {
  return matches(check.subject, ele) && matches(check.left, ele) && matches(check.right, ele);
};

match[Type.TRUE] = function () {
  return true;
};

match[Type.COLLECTION] = function (check, ele) {
  var collection = check.value;
  return collection.has(ele);
};

match[Type.FILTER] = function (check, ele) {
  var filter = check.value;
  return filter(ele);
};

var filter = function filter(collection) {
  var self = this; // for 1 id #foo queries, just get the element

  if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {
    return collection.getElementById(self[0].checks[0].value).collection();
  }

  var selectorFunction = function selectorFunction(element) {
    for (var j = 0; j < self.length; j++) {
      var query = self[j];

      if (matches(query, element)) {
        return true;
      }
    }

    return false;
  };

  if (self.text() == null) {
    selectorFunction = function selectorFunction() {
      return true;
    };
  }

  return collection.filter(selectorFunction);
}; // filter
// does selector match a single element?


var matches$1 = function matches$1(ele) {
  var self = this;

  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (matches(query, ele)) {
      return true;
    }
  }

  return false;
}; // matches


var matching = {
  matches: matches$1,
  filter: filter
};

var Selector = function Selector(selector) {
  this.inputText = selector;
  this.currentSubject = null;
  this.compoundCount = 0;
  this.edgeCount = 0;
  this.length = 0;

  if (selector == null || string(selector) && selector.match(/^\s*$/)) ; else if (elementOrCollection(selector)) {
    this.addQuery({
      checks: [{
        type: Type.COLLECTION,
        value: selector.collection()
      }]
    });
  } else if (fn(selector)) {
    this.addQuery({
      checks: [{
        type: Type.FILTER,
        value: selector
      }]
    });
  } else if (string(selector)) {
    if (!this.parse(selector)) {
      this.invalid = true;
    }
  } else {
    error('A selector must be created from a string; found ');
  }
};

var selfn = Selector.prototype;
[parse$1, matching].forEach(function (p) {
  return extend(selfn, p);
});

selfn.text = function () {
  return this.inputText;
};

selfn.size = function () {
  return this.length;
};

selfn.eq = function (i) {
  return this[i];
};

selfn.sameText = function (otherSel) {
  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
};

selfn.addQuery = function (q) {
  this[this.length++] = q;
};

selfn.selector = selfn.toString;

var elesfn$f = {
  allAre: function allAre(selector) {
    var selObj = new Selector(selector);
    return this.every(function (ele) {
      return selObj.matches(ele);
    });
  },
  is: function is(selector) {
    var selObj = new Selector(selector);
    return this.some(function (ele) {
      return selObj.matches(ele);
    });
  },
  some: function some(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (ret) {
        return true;
      }
    }

    return false;
  },
  every: function every(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (!ret) {
        return false;
      }
    }

    return true;
  },
  same: function same(collection) {
    // cheap collection ref check
    if (this === collection) {
      return true;
    }

    collection = this.cy().collection(collection);
    var thisLength = this.length;
    var collectionLength = collection.length; // cheap length check

    if (thisLength !== collectionLength) {
      return false;
    } // cheap element ref check


    if (thisLength === 1) {
      return this[0] === collection[0];
    }

    return this.every(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  anySame: function anySame(collection) {
    collection = this.cy().collection(collection);
    return this.some(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  allAreNeighbors: function allAreNeighbors(collection) {
    collection = this.cy().collection(collection);
    var nhood = this.neighborhood();
    return collection.every(function (ele) {
      return nhood.hasElementWithId(ele.id());
    });
  },
  contains: function contains(collection) {
    collection = this.cy().collection(collection);
    var self = this;
    return collection.every(function (ele) {
      return self.hasElementWithId(ele.id());
    });
  }
};
elesfn$f.allAreNeighbours = elesfn$f.allAreNeighbors;
elesfn$f.has = elesfn$f.contains;
elesfn$f.equal = elesfn$f.equals = elesfn$f.same;

var cache = function cache(fn, name) {
  return function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if (selectorOrEles == null) {
      key = '';
    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key = selectorOrEles.id();
    }

    if (eles.length === 1 && key) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || [];
      var hash = hashString(key);
      var cacheHit = ch[hash];

      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn.call(eles, arg1, arg2, arg3, arg4);
    }
  };
};

var elesfn$g = {
  parent: function parent(selector) {
    var parents = []; // optimisation for single ele call

    if (this.length === 1) {
      var parent = this[0]._private.parent;

      if (parent) {
        return parent;
      }
    }

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;

      if (_parent) {
        parents.push(_parent);
      }
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  parents: function parents(selector) {
    var parents = [];
    var eles = this.parent();

    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents.push(ele);
      }

      eles = eles.parent();
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  commonAncestors: function commonAncestors(selector) {
    var ancestors;

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents = ele.parents();
      ancestors = ancestors || parents;
      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
    }

    return ancestors.filter(selector);
  },
  orphans: function orphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isOrphan();
    }).filter(selector);
  },
  nonorphans: function nonorphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isChild();
    }).filter(selector);
  },
  children: cache(function (selector) {
    var children = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var eleChildren = ele._private.children;

      for (var j = 0; j < eleChildren.length; j++) {
        children.push(eleChildren[j]);
      }
    }

    return this.spawn(children, {
      unique: true
    }).filter(selector);
  }, 'children'),
  siblings: function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  },
  isParent: function isParent() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },
  isChildless: function isChildless() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  },
  isChild: function isChild() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  },
  isOrphan: function isOrphan() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  },
  descendants: function descendants(selector) {
    var elements = [];

    function add(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        elements.push(ele);

        if (ele.children().nonempty()) {
          add(ele.children());
        }
      }
    }

    add(this.children());
    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }
};

function forEachCompound(eles, fn, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set$1();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }

  while (q.length > 0) {
    var _ele = q.shift();

    fn(_ele);
    did.add(_ele.id());

    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }

  return eles;
}

function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (!did.has(child.id())) {
        q.push(child);
      }
    }
  }
} // very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use


elesfn$g.forEachDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addChildren);
};

function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent = ele._private.parent;

    if (!did.has(parent.id())) {
      q.push(parent);
    }
  }
}

elesfn$g.forEachUp = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParent);
};

function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}

elesfn$g.forEachUpAndDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParentAndChildren);
}; // aliases


elesfn$g.ancestors = elesfn$g.parents;

var fn$1, elesfn$h;
fn$1 = elesfn$h = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),
  rscratch: define$3.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),
  removeRscratch: define$3.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),
  id: function id() {
    var ele = this[0];

    if (ele) {
      return ele._private.data.id;
    }
  }
}; // aliases

fn$1.attr = fn$1.data;
fn$1.removeAttr = fn$1.removeData;
var data$1 = elesfn$h;

var elesfn$i = {};

function defineDegreeFunction(callback) {
  return function (includeLoops) {
    var self = this;

    if (includeLoops === undefined) {
      includeLoops = true;
    }

    if (self.length === 0) {
      return;
    }

    if (self.isNode() && !self.removed()) {
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];

        if (!includeLoops && edge.isLoop()) {
          continue;
        }

        degree += callback(node, edge);
      }

      return degree;
    } else {
      return;
    }
  };
}

extend(elesfn$i, {
  degree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),
  indegree: defineDegreeFunction(function (node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),
  outdegree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback) {
  return function (includeLoops) {
    var ret;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var ele = nodes[i];
      var degree = ele[degreeFn](includeLoops);

      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
        ret = degree;
      }
    }

    return ret;
  };
}

extend(elesfn$i, {
  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
    return degree < min;
  }),
  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
    return degree > max;
  }),
  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
    return degree < min;
  }),
  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
    return degree > max;
  }),
  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
    return degree < min;
  }),
  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
    return degree > max;
  })
});
extend(elesfn$i, {
  totalDegree: function totalDegree(includeLoops) {
    var total = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      total += nodes[i].degree(includeLoops);
    }

    return total;
  }
});

var fn$2, elesfn$j;

var beforePositionSet = function beforePositionSet(eles, newPos, silent) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x != null ? newPos.x - oldPos.x : 0,
        y: newPos.y != null ? newPos.y - oldPos.y : 0
      };

      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
        ele.children().shift(delta, silent);
      }

      ele.shiftCachedBoundingBox(delta);
    }
  }
};

var positionDef = {
  field: 'position',
  bindingEvent: 'position',
  allowBinding: true,
  allowSetting: true,
  settingEvent: 'position',
  settingTriggersEvent: true,
  triggerFnName: 'emitAndNotify',
  allowGetting: true,
  validKeys: ['x', 'y'],
  beforeGet: function beforeGet(ele) {
    ele.updateCompoundBounds();
  },
  beforeSet: function beforeSet(eles, newPos) {
    beforePositionSet(eles, newPos, false);
  },
  onSet: function onSet(eles) {
    eles.dirtyCompoundBoundsCache();
  },
  canSet: function canSet(ele) {
    return !ele.locked();
  }
};
fn$2 = elesfn$j = {
  position: define$3.data(positionDef),
  // position but no notification to renderer
  silentPosition: define$3.data(extend({}, positionDef, {
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: false,
    beforeSet: function beforeSet(eles, newPos) {
      beforePositionSet(eles, newPos, true);
    }
  })),
  positions: function positions(pos, silent) {
    if (plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (fn(pos)) {
      var _fn = pos;
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];

        var _pos = void 0;

        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }

      cy.endBatch();
    }

    return this; // chaining
  },
  silentPositions: function silentPositions(pos) {
    return this.positions(pos, true);
  },
  shift: function shift(dim, val, silent) {
    var delta;

    if (plainObject(dim)) {
      delta = {
        x: number(dim.x) ? dim.x : 0,
        y: number(dim.y) ? dim.y : 0
      };
      silent = val;
    } else if (string(dim) && number(val)) {
      delta = {
        x: 0,
        y: 0
      };
      delta[dim] = val;
    }

    if (delta != null) {
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var pos = ele.position();
        var newPos = {
          x: pos.x + delta.x,
          y: pos.y + delta.y
        };

        if (silent) {
          ele.silentPosition(newPos);
        } else {
          ele.position(newPos);
        }
      }

      cy.endBatch();
    }

    return this;
  },
  silentShift: function silentShift(dim, val) {
    if (plainObject(dim)) {
      this.shift(dim, true);
    } else if (string(dim) && number(val)) {
      this.shift(dim, val, true);
    }

    return this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = plainObject(dim) ? dim : undefined;
    var setting = rpos !== undefined || val !== undefined && string(dim);

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];

          if (val !== undefined) {
            // set one dimension
            _ele.position(dim, (val - pan[dim]) / zoom);
          } else if (rpos !== undefined) {
            // set whole position
            _ele.position(renderedToModelPosition(rpos, zoom, pan));
          }
        }
      } else {
        // getting
        var pos = ele.position();
        rpos = modelToRenderedPosition(pos, zoom, pan);

        if (dim === undefined) {
          // then return the whole rendered position
          return rpos;
        } else {
          // then return the specified dimension
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  },
  // get/set the position relative to the parent
  relativePosition: function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = plainObject(dim) ? dim : undefined;
    var setting = ppos !== undefined || val !== undefined && string(dim);
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent = hasCompoundNodes ? _ele2.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if (hasParent) {
            parent = parent[0];
          }

          var origin = relativeToParent ? parent.position() : {
            x: 0,
            y: 0
          };

          if (val !== undefined) {
            // set one dimension
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== undefined) {
            // set whole position
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        // getting
        var pos = ele.position();

        var _parent = hasCompoundNodes ? ele.parent() : null;

        var _hasParent = _parent && _parent.length > 0;

        var _relativeToParent = _hasParent;

        if (_hasParent) {
          _parent = _parent[0];
        }

        var _origin = _relativeToParent ? _parent.position() : {
          x: 0,
          y: 0
        };

        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };

        if (dim === undefined) {
          // then return the whole rendered position
          return ppos;
        } else {
          // then return the specified dimension
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  }
}; // aliases

fn$2.modelPosition = fn$2.point = fn$2.position;
fn$2.modelPositions = fn$2.points = fn$2.positions;
fn$2.renderedPoint = fn$2.renderedPosition;
fn$2.relativePoint = fn$2.relativePosition;
var position = elesfn$j;

var fn$3, elesfn$k;
fn$3 = elesfn$k = {};

elesfn$k.renderedBoundingBox = function (options) {
  var bb = this.boundingBox(options);
  var cy = this.cy();
  var zoom = cy.zoom();
  var pan = cy.pan();
  var x1 = bb.x1 * zoom + pan.x;
  var x2 = bb.x2 * zoom + pan.x;
  var y1 = bb.y1 * zoom + pan.y;
  var y2 = bb.y2 * zoom + pan.y;
  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    w: x2 - x1,
    h: y2 - y1
  };
};

elesfn$k.dirtyCompoundBoundsCache = function () {
  var cy = this.cy();

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  this.forEachUp(function (ele) {
    if (ele.isParent()) {
      var _p = ele._private;
      _p.compoundBoundsClean = false;
      _p.bbCache = null;
      ele.emitAndNotify('bounds');
    }
  });
  return this;
};

elesfn$k.updateCompoundBounds = function () {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  } // save cycles when batching -- but bounds will be stale (or not exist yet)


  if (!force && cy.batching()) {
    return this;
  }

  function update(parent) {
    if (!parent.isParent()) {
      return;
    }

    var _p = parent._private;
    var children = parent.children();
    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';
    var min = {
      width: {
        val: parent.pstyle('min-width').pfValue,
        left: parent.pstyle('min-width-bias-left'),
        right: parent.pstyle('min-width-bias-right')
      },
      height: {
        val: parent.pstyle('min-height').pfValue,
        top: parent.pstyle('min-height-bias-top'),
        bottom: parent.pstyle('min-height-bias-bottom')
      }
    };
    var bb = children.boundingBox({
      includeLabels: includeLabels,
      includeOverlays: false,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h

    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent.pstyle('width').pfValue,
        h: parent.pstyle('height').pfValue
      };
      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }

    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;

      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }

      return {
        biasDiff: biasDiff,
        biasComplementDiff: biasComplementDiff
      };
    }

    function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
      if (paddingObject.units === '%') {
        switch (relativeTo) {
          case 'width':
            return width > 0 ? paddingObject.pfValue * width : 0;

          case 'height':
            return height > 0 ? paddingObject.pfValue * height : 0;

          case 'average':
            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;

          case 'min':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;

          case 'max':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;

          default:
            return 0;
        }
      } else if (paddingObject.units === 'px') {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }

    var leftVal = min.width.left.value;

    if (min.width.left.units === 'px' && min.width.val > 0) {
      leftVal = leftVal * 100 / min.width.val;
    }

    var rightVal = min.width.right.value;

    if (min.width.right.units === 'px' && min.width.val > 0) {
      rightVal = rightVal * 100 / min.width.val;
    }

    var topVal = min.height.top.value;

    if (min.height.top.units === 'px' && min.height.val > 0) {
      topVal = topVal * 100 / min.height.val;
    }

    var bottomVal = min.height.bottom.value;

    if (min.height.bottom.units === 'px' && min.height.val > 0) {
      bottomVal = bottomVal * 100 / min.height.val;
    }

    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;
    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;
    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);
    _p.autoWidth = Math.max(bb.w, min.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
    _p.autoHeight = Math.max(bb.h, min.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
  }

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;

    if (!_p.compoundBoundsClean) {
      update(ele);

      if (!cy.batching()) {
        _p.compoundBoundsClean = true;
      }
    }
  }

  return this;
};

var noninf = function noninf(x) {
  if (x === Infinity || x === -Infinity) {
    return 0;
  }

  return x;
};

var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  } // don't update with null dim


  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
  b.w = b.x2 - b.x1;
  b.h = b.y2 - b.y1;
};

var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
  if (b2 == null) {
    return b;
  }

  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};

var prefixedProperty = function prefixedProperty(obj, field, prefix) {
  return getPrefixedProperty(obj, field, prefix);
};

var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
  var x;
  var y;

  if (arrowType !== 'none') {
    if (prefix === 'source') {
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if (prefix === 'target') {
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    } // always store the individual arrow bounds


    var bbs = _p.arrowBounds = _p.arrowBounds || {};
    var bb = bbs[prefix] = bbs[prefix] || {};
    bb.x1 = x - halfArW;
    bb.y1 = y - halfArW;
    bb.x2 = x + halfArW;
    bb.y2 = y + halfArW;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    expandBoundingBox(bb, 1);
    updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
  }
};

var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var prefixDash;

  if (prefix) {
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle(prefixDash + 'label').strValue;

  if (label) {
    var halign = ele.pstyle('text-halign');
    var valign = ele.pstyle('text-valign');
    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
    var labelX = prefixedProperty(rstyle, 'labelX', prefix);
    var labelY = prefixedProperty(rstyle, 'labelY', prefix);
    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + 'text-rotation');
    var outlineWidth = ele.pstyle('text-outline-width').pfValue;
    var borderWidth = ele.pstyle('text-border-width').pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle('text-background-padding').pfValue;
    var lh = labelHeight;
    var lw = labelWidth;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if (isEdge) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch (valign.value) {
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    } // shift by margin and expand by outline and border


    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding;
    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding;
    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding;
    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding; // always store the unrotated label bounds separately

    var bbPrefix = prefix || 'main';
    var bbs = _p.labelBounds;
    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
    bb.x1 = lx1;
    bb.y1 = ly1;
    bb.x2 = lx2;
    bb.y2 = ly2;
    bb.w = lx2 - lx1;
    bb.h = ly2 - ly1;
    expandBoundingBox(bb, 1); // expand to work around browser dimension inaccuracies

    var isAutorotate = isEdge && rotation.strValue === 'autorotate';
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
      var cos = Math.cos(theta);
      var sin = Math.sin(theta); // rotation point (default value for center-center)

      var xo = (lx1 + lx2) / 2;
      var yo = (ly1 + ly2) / 2;

      if (!isEdge) {
        switch (halign.value) {
          case 'left':
            xo = lx2;
            break;

          case 'right':
            xo = lx1;
            break;
        }

        switch (valign.value) {
          case 'top':
            yo = ly2;
            break;

          case 'bottom':
            yo = ly1;
            break;
        }
      }

      var rotate = function rotate(x, y) {
        x = x - xo;
        y = y - yo;
        return {
          x: x * cos - y * sin + xo,
          y: x * sin + y * cos + yo
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }

    var bbPrefixRot = bbPrefix + 'Rot';
    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
    bbRot.x1 = lx1;
    bbRot.y1 = ly1;
    bbRot.x2 = lx2;
    bbRot.y2 = ly2;
    bbRot.w = lx2 - lx1;
    bbRot.h = ly2 - ly1;
    updateBounds(bounds, lx1, ly1, lx2, ly2);
    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
  }

  return bounds;
}; // get the bounding box of the elements (in raw model position)


var boundingBoxImpl = function boundingBoxImpl(ele, options) {
  var cy = ele._private.cy;
  var styleEnabled = cy.styleEnabled();
  var headless = cy.headless();
  var bounds = makeBoundingBox();
  var _p = ele._private;
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2; // extrema of body / lines

  var x, y; // node pos

  var rstyle = _p.rstyle;
  var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion
  // (other factors like width values will be considered later in this function anyway)

  var isDisplayed = function isDisplayed(ele) {
    return ele.pstyle('display').value !== 'none';
  };

  var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));

  if (displayed) {
    // displayed suffices, since we will find zero area eles anyway
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if (styleEnabled && options.includeOverlays) {
      overlayOpacity = ele.pstyle('overlay-opacity').value;

      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle('overlay-padding').value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if (styleEnabled) {
      w = ele.pstyle('width').pfValue;
      wHalf = w / 2;
    }

    if (isNode && options.includeNodes) {
      var pos = ele.position();
      x = pos.x;
      y = pos.y;

      var _w = ele.outerWidth();

      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2; // handle node dimensions
      /////////////////////////

      ex1 = x - halfW;
      ex2 = x + halfW;
      ey1 = y - halfH;
      ey2 = y + halfH;
      updateBounds(bounds, ex1, ey1, ex2, ey2);
    } else if (isEdge && options.includeEdges) {
      if (styleEnabled && !headless) {
        var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width

        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
        ////////////////

        if (curveStyle === 'haystack') {
          var hpts = rstyle.haystackPts;

          if (hpts && hpts.length === 2) {
            ex1 = hpts[0].x;
            ey1 = hpts[0].y;
            ex2 = hpts[1].x;
            ey2 = hpts[1].y;

            if (ex1 > ex2) {
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if (ey1 > ey2) {
              var _temp = ey1;
              ey1 = ey2;
              ey2 = _temp;
            }

            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
          }
        } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {
          var pts;

          switch (curveStyle) {
            case 'bezier':
            case 'unbundled-bezier':
              pts = rstyle.bezierPts;
              break;

            case 'segments':
            case 'taxi':
              pts = rstyle.linePts;
              break;
          }

          if (pts != null) {
            for (var j = 0; j < pts.length; j++) {
              var pt = pts[j];
              ex1 = pt.x - wHalf;
              ex2 = pt.x + wHalf;
              ey1 = pt.y - wHalf;
              ey2 = pt.y + wHalf;
              updateBounds(bounds, ex1, ey1, ex2, ey2);
            }
          }
        } // bezier-like or segment-like edge

      } else {
        // headless or style disabled
        // fallback on source and target positions
        //////////////////////////////////////////
        var n1 = ele.source();
        var n1pos = n1.position();
        var n2 = ele.target();
        var n2pos = n2.position();
        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;

        if (ex1 > ex2) {
          var _temp2 = ex1;
          ex1 = ex2;
          ex2 = _temp2;
        }

        if (ey1 > ey2) {
          var _temp3 = ey1;
          ey1 = ey2;
          ey2 = _temp3;
        } // take into account edge width


        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2);
      } // headless or style disabled

    } // edges
    // handle edge arrow size
    /////////////////////////


    if (styleEnabled && options.includeEdges && isEdge) {
      updateBoundsFromArrow(bounds, ele, 'mid-source');
      updateBoundsFromArrow(bounds, ele, 'mid-target');
      updateBoundsFromArrow(bounds, ele, 'source');
      updateBoundsFromArrow(bounds, ele, 'target');
    } // ghost
    ////////


    if (styleEnabled) {
      var ghost = ele.pstyle('ghost').value === 'yes';

      if (ghost) {
        var gx = ele.pstyle('ghost-offset-x').pfValue;
        var gy = ele.pstyle('ghost-offset-y').pfValue;
        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
      }
    } // always store the body bounds separately from the labels


    var bbBody = _p.bodyBounds = _p.bodyBounds || {};
    assignBoundingBox(bbBody, bounds);
    expandBoundingBoxSides(bbBody, manualExpansion);
    expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
    // overlay
    //////////

    if (styleEnabled) {
      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;
      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
    } // always store the body bounds separately from the labels


    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
    assignBoundingBox(bbOverlay, bounds);
    expandBoundingBoxSides(bbOverlay, manualExpansion);
    expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
    // handle label dimensions
    //////////////////////////

    var bbLabels = _p.labelBounds = _p.labelBounds || {};

    if (bbLabels.all != null) {
      clearBoundingBox(bbLabels.all);
    } else {
      bbLabels.all = makeBoundingBox();
    }

    if (styleEnabled && options.includeLabels) {
      if (options.includeMainLabels) {
        updateBoundsFromLabel(bounds, ele, null);
      }

      if (isEdge) {
        if (options.includeSourceLabels) {
          updateBoundsFromLabel(bounds, ele, 'source');
        }

        if (options.includeTargetLabels) {
          updateBoundsFromLabel(bounds, ele, 'target');
        }
      }
    } // style enabled for labels

  } // if displayed


  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  if (bounds.w > 0 && bounds.h > 0 && displayed) {
    expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides

    expandBoundingBox(bounds, 1);
  }

  return bounds;
};

var getKey = function getKey(opts) {
  var i = 0;

  var tf = function tf(val) {
    return (val ? 1 : 0) << i++;
  };

  var key = 0;
  key += tf(opts.incudeNodes);
  key += tf(opts.includeEdges);
  key += tf(opts.includeLabels);
  key += tf(opts.includeMainLabels);
  key += tf(opts.includeSourceLabels);
  key += tf(opts.includeTargetLabels);
  key += tf(opts.includeOverlays);
  return key;
};

var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
  if (ele.isEdge()) {
    var p1 = ele.source().position();
    var p2 = ele.target().position();

    var r = function r(x) {
      return Math.round(x);
    };

    return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);
  } else {
    return 0;
  }
};

var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
  var _p = ele._private;
  var bb;
  var isEdge = ele.isEdge();
  var key = opts == null ? defBbOptsKey : getKey(opts);
  var usingDefOpts = key === defBbOptsKey;
  var currPosKey = getBoundingBoxPosKey(ele);
  var isPosKeySame = _p.bbCachePosKey === currPosKey;
  var useCache = opts.useCache && isPosKeySame;

  var isDirty = function isDirty(ele) {
    return ele._private.bbCache == null;
  };

  var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());

  if (needRecalc) {
    if (!isPosKeySame) {
      ele.recalculateRenderedStyle();
    }

    bb = boundingBoxImpl(ele, defBbOpts);
    _p.bbCache = bb;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = currPosKey;
  } else {
    bb = _p.bbCache;
  }

  if (!needRecalc && (_p.bbCacheShift.x !== 0 || _p.bbCacheShift.y !== 0)) {
    var shift = assignShiftToBoundingBox;
    var delta = _p.bbCacheShift;

    var safeShift = function safeShift(bb, delta) {
      if (bb != null) {
        shift(bb, delta);
      }
    };

    shift(bb, delta);
    var bodyBounds = _p.bodyBounds,
        overlayBounds = _p.overlayBounds,
        labelBounds = _p.labelBounds,
        arrowBounds = _p.arrowBounds;
    safeShift(bodyBounds, delta);
    safeShift(overlayBounds, delta);

    if (arrowBounds != null) {
      safeShift(arrowBounds.source, delta);
      safeShift(arrowBounds.target, delta);
      safeShift(arrowBounds['mid-source'], delta);
      safeShift(arrowBounds['mid-target'], delta);
    }

    if (labelBounds != null) {
      safeShift(labelBounds.main, delta);
      safeShift(labelBounds.all, delta);
      safeShift(labelBounds.source, delta);
      safeShift(labelBounds.target, delta);
    }
  } // always reset the shift, because we either applied the shift or cleared it by doing a fresh recalc


  _p.bbCacheShift.x = _p.bbCacheShift.y = 0; // not using def opts => need to build up bb from combination of sub bbs

  if (!usingDefOpts) {
    var isNode = ele.isNode();
    bb = makeBoundingBox();

    if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
      if (opts.includeOverlays) {
        updateBoundsFromBox(bb, _p.overlayBounds);
      } else {
        updateBoundsFromBox(bb, _p.bodyBounds);
      }
    }

    if (opts.includeLabels) {
      if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {
        updateBoundsFromBox(bb, _p.labelBounds.all);
      } else {
        if (opts.includeMainLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.mainRot);
        }

        if (opts.includeSourceLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
        }

        if (opts.includeTargetLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.targetRot);
        }
      }
    }

    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeMainLabels: true,
  includeSourceLabels: true,
  includeTargetLabels: true,
  includeOverlays: true,
  useCache: true
};
var defBbOptsKey = getKey(defBbOpts);
var filledBbOpts = defaults(defBbOpts);

elesfn$k.boundingBox = function (options) {
  var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function

  if (this.length === 1 && this[0]._private.bbCache != null && (options === undefined || options.useCache === undefined || options.useCache === true)) {
    if (options === undefined) {
      options = defBbOpts;
    } else {
      options = filledBbOpts(options);
    }

    bounds = cachedBoundingBoxImpl(this[0], options);
  } else {
    bounds = makeBoundingBox();
    options = options || defBbOpts;
    var opts = filledBbOpts(options);
    var eles = this;
    var cy = eles.cy();
    var styleEnabled = cy.styleEnabled();

    if (styleEnabled) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var currPosKey = getBoundingBoxPosKey(ele);
        var isPosKeySame = _p.bbCachePosKey === currPosKey;
        var useCache = opts.useCache && isPosKeySame;
        ele.recalculateRenderedStyle(useCache);
      }
    }

    this.updateCompoundBounds();

    for (var _i = 0; _i < eles.length; _i++) {
      var _ele = eles[_i];
      updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
    }
  }

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);
  return bounds;
};

elesfn$k.dirtyBoundingBoxCache = function () {
  for (var i = 0; i < this.length; i++) {
    var _p = this[i]._private;
    _p.bbCache = null;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = null;
    _p.bodyBounds = null;
    _p.overlayBounds = null;
    _p.labelBounds.all = null;
    _p.labelBounds.source = null;
    _p.labelBounds.target = null;
    _p.labelBounds.main = null;
    _p.labelBounds.sourceRot = null;
    _p.labelBounds.targetRot = null;
    _p.labelBounds.mainRot = null;
    _p.arrowBounds.source = null;
    _p.arrowBounds.target = null;
    _p.arrowBounds['mid-source'] = null;
    _p.arrowBounds['mid-target'] = null;
  }

  this.emitAndNotify('bounds');
  return this;
};

elesfn$k.shiftCachedBoundingBox = function (delta) {
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;
    var bb = _p.bbCache;

    if (bb != null) {
      _p.bbCacheShift.x += delta.x;
      _p.bbCacheShift.y += delta.y;
    }
  }

  this.emitAndNotify('bounds');
  return this;
}; // private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway


elesfn$k.boundingBoxAt = function (fn) {
  var nodes = this.nodes();
  var cy = this.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  if (hasCompoundNodes) {
    nodes = nodes.filter(function (node) {
      return !node.isParent();
    });
  }

  if (plainObject(fn)) {
    var obj = fn;

    fn = function fn() {
      return obj;
    };
  }

  var storeOldPos = function storeOldPos(node, i) {
    return node._private.bbAtOldPos = fn(node, i);
  };

  var getOldPos = function getOldPos(node) {
    return node._private.bbAtOldPos;
  };

  cy.startBatch();
  nodes.forEach(storeOldPos).silentPositions(fn);

  if (hasCompoundNodes) {
    this.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
  }

  var bb = copyBoundingBox(this.boundingBox({
    useCache: false
  }));
  nodes.silentPositions(getOldPos);
  cy.endBatch();
  return bb;
};

fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
var bounds = elesfn$k;

var fn$4, elesfn$l;
fn$4 = elesfn$l = {};

var defineDimFns = function defineDimFns(opts) {
  opts.uppercaseName = capitalize(opts.name);
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = capitalize(opts.outerName);

  fn$4[opts.name] = function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();
          return _p[opts.autoName] || 0;
        }

        var d = ele.pstyle(opts.name);

        switch (d.strValue) {
          case 'label':
            ele.recalculateRenderedStyle();
            return _p.rstyle[opts.labelName] || 0;

          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn$4['outer' + opts.uppercaseName] = function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        var dim = ele[opts.name]();
        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side

        var padding = 2 * ele.padding();
        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn$4['rendered' + opts.uppercaseName] = function renderedDimImpl() {
    var ele = this[0];

    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  };

  fn$4['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
    var ele = this[0];

    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width'
});
defineDimFns({
  name: 'height'
});

elesfn$l.padding = function () {
  var ele = this[0];
  var _p = ele._private;

  if (ele.isParent()) {
    ele.updateCompoundBounds();

    if (_p.autoPadding !== undefined) {
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
};

elesfn$l.paddedHeight = function () {
  var ele = this[0];
  return ele.height() + 2 * ele.padding();
};

elesfn$l.paddedWidth = function () {
  var ele = this[0];
  return ele.width() + 2 * ele.padding();
};

var widthHeight = elesfn$l;

var ifEdge = function ifEdge(ele, getValue) {
  if (ele.isEdge()) {
    return getValue(ele);
  }
};

var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
  }
};

var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    var pan = cy.pan();
    var zoom = cy.zoom();
    return getPoints(ele).map(function (p) {
      return modelToRenderedPosition(p, zoom, pan);
    });
  }
};

var controlPoints = function controlPoints(ele) {
  return ele.renderer().getControlPoints(ele);
};

var segmentPoints = function segmentPoints(ele) {
  return ele.renderer().getSegmentPoints(ele);
};

var sourceEndpoint = function sourceEndpoint(ele) {
  return ele.renderer().getSourceEndpoint(ele);
};

var targetEndpoint = function targetEndpoint(ele) {
  return ele.renderer().getTargetEndpoint(ele);
};

var midpoint = function midpoint(ele) {
  return ele.renderer().getEdgeMidpoint(ele);
};

var pts = {
  controlPoints: {
    get: controlPoints,
    mult: true
  },
  segmentPoints: {
    get: segmentPoints,
    mult: true
  },
  sourceEndpoint: {
    get: sourceEndpoint
  },
  targetEndpoint: {
    get: targetEndpoint
  },
  midpoint: {
    get: midpoint
  }
};

var renderedName = function renderedName(name) {
  return 'rendered' + name[0].toUpperCase() + name.substr(1);
};

var edgePoints = Object.keys(pts).reduce(function (obj, name) {
  var spec = pts[name];
  var rName = renderedName(name);

  obj[name] = function () {
    return ifEdge(this, spec.get);
  };

  if (spec.mult) {
    obj[rName] = function () {
      return ifEdgeRenderedPositions(this, spec.get);
    };
  } else {
    obj[rName] = function () {
      return ifEdgeRenderedPosition(this, spec.get);
    };
  }

  return obj;
}, {});

var dimensions = extend({}, position, bounds, widthHeight, edgePoints);

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
var Event = function Event(src, props) {
  this.recycle(src, props);
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
} // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


Event.prototype = {
  instanceString: function instanceString() {
    return 'event';
  },
  recycle: function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

    if (src != null && src.preventDefault) {
      // Browser Event object
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      // Plain object containing all event details
      props = src;
    } else {
      // Event string
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props != null) {
      // more efficient to manually copy fields we use
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }

    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
      var pos = this.position;
      var zoom = this.cy.zoom();
      var pan = this.cy.pan();
      this.renderedPosition = {
        x: pos.x * zoom + pan.x,
        y: pos.y * zoom + pan.y
      };
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now();
  },
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if preventDefault exists run it on the original event


    if (e.preventDefault) {
      e.preventDefault();
    }
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if stopPropagation exists run it on the original event


    if (e.stopPropagation) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")

var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

var defaults$8 = {
  qualifierCompare: function qualifierCompare(q1, q2) {
    return q1 === q2;
  },
  eventMatches: function eventMatches()
  /*context, listener, eventObj*/
  {
    return true;
  },
  addEventFields: function addEventFields()
  /*context, evt*/
  {},
  callbackContext: function callbackContext(context
  /*, listener, eventObj*/
  ) {
    return context;
  },
  beforeEmit: function beforeEmit()
  /* context, listener, eventObj */
  {},
  afterEmit: function afterEmit()
  /* context, listener, eventObj */
  {},
  bubble: function bubble()
  /*context*/
  {
    return false;
  },
  parent: function parent()
  /*context*/
  {
    return null;
  },
  context: null
};
var defaultsKeys = Object.keys(defaults$8);
var emptyOpts = {};

function Emitter() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
  var context = arguments.length > 1 ? arguments[1] : undefined;

  // micro-optimisation vs Object.assign() -- reduces Element instantiation time
  for (var i = 0; i < defaultsKeys.length; i++) {
    var key = defaultsKeys[i];
    this[key] = opts[key] || defaults$8[key];
  }

  this.context = context || this.context;
  this.listeners = [];
  this.emitting = 0;
}

var p = Emitter.prototype;

var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
  if (fn(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }

  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = extend({}, conf, confOverrides);
    }
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

      if (ret === false) {
        break;
      } // allow exiting early

    }
  }
};

var makeEventObj = function makeEventObj(self, obj) {
  self.addEventFields(self.context, obj);
  return new Event(obj.type, obj);
};

var forEachEventObj = function forEachEventObj(self, handler, events) {
  if (event(events)) {
    handler(self, events);
    return;
  } else if (plainObject(events)) {
    handler(self, makeEventObj(self, events));
    return;
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var eventObj = makeEventObj(self, {
        type: type,
        namespace: namespace,
        target: self.context
      });
      handler(self, eventObj);
    }
  }
};

p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
    if (fn(callback)) {
      self.listeners.push({
        event: event,
        // full event string
        callback: callback,
        // callback to run
        type: type,
        // the event type (e.g. 'click')
        namespace: namespace,
        // the event namespace (e.g. ".foo")
        qualifier: qualifier,
        // a restriction on whether to match this emitter
        conf: conf // additional configuration

      });
    }
  }, events, qualifier, callback, conf, confOverrides);
  return this;
};

p.one = function (events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, {
    one: true
  });
};

p.removeListener = p.off = function (events, qualifier, callback, conf) {
  var _this = this;

  if (this.emitting !== 0) {
    this.listeners = copyArray(this.listeners);
  }

  var listeners = this.listeners;

  var _loop = function _loop(i) {
    var listener = listeners[i];
    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback
    /*, conf*/
    ) {
      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
        listeners.splice(i, 1);
        return false;
      }
    }, events, qualifier, callback, conf);
  };

  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }

  return this;
};

p.removeAllListeners = function () {
  return this.removeListener('*');
};

p.emit = p.trigger = function (events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;
  this.emitting++;

  if (!array(extraParams)) {
    extraParams = [extraParams];
  }

  forEachEventObj(this, function (self, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];
      numListenersBeforeEmit = listeners.length;
    }

    var _loop2 = function _loop2(i) {
      var listener = listeners[i];

      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
        var args = [eventObj];

        if (extraParams != null) {
          push(args, extraParams);
        }

        self.beforeEmit(self.context, listener, eventObj);

        if (listener.conf && listener.conf.one) {
          self.listeners = self.listeners.filter(function (l) {
            return l !== listener;
          });
        }

        var context = self.callbackContext(self.context, listener, eventObj);
        var ret = listener.callback.apply(context, args);
        self.afterEmit(self.context, listener, eventObj);

        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      } // if listener matches

    };

    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2(i);
    } // for listener


    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
      self.parent(self.context).emit(eventObj, extraParams);
    }
  }, events);
  this.emitting--;
  return this;
};

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(ele, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(ele, evt) {
    evt.cy = ele.cy();
    evt.target = ele;
  },
  callbackContext: function callbackContext(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  },
  beforeEmit: function beforeEmit(context, listener
  /*, eventObj*/
  ) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  },
  bubble: function bubble() {
    return true;
  },
  parent: function parent(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }
};

var argSelector = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$m = {
  createEmitter: function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;

      if (!_p.emitter) {
        _p.emitter = new Emitter(emitterOptions, ele);
      }
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback);
    }

    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeListener(events, argSel, callback);
    }

    return this;
  },
  removeAllListeners: function removeAllListeners() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeAllListeners();
    }

    return this;
  },
  one: function one(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().one(events, argSel, callback);
    }

    return this;
  },
  once: function once(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback, {
        once: true,
        onceCollection: this
      });
    }
  },
  emit: function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().emit(events, extraParams);
    }

    return this;
  },
  emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
    if (this.length === 0) {
      return;
    } // empty collections don't need to notify anything
    // notify renderer


    this.cy().notify(event, this);
    this.emit(event, extraParams);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$m);

var elesfn$n = {
  nodes: function nodes(selector) {
    return this.filter(function (ele) {
      return ele.isNode();
    }).filter(selector);
  },
  edges: function edges(selector) {
    return this.filter(function (ele) {
      return ele.isEdge();
    }).filter(selector);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function byGroup() {
    var nodes = this.spawn();
    var edges = this.spawn();

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      if (ele.isNode()) {
        nodes.merge(ele);
      } else {
        edges.merge(ele);
      }
    }

    return {
      nodes: nodes,
      edges: edges
    };
  },
  filter: function filter(_filter, thisArg) {
    if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
      return this;
    } else if (string(_filter) || elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (fn(_filter)) {
      var filterEles = this.spawn();
      var eles = this;

      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

        if (include) {
          filterEles.merge(ele);
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },
  not: function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {
      if (string(toRemove)) {
        toRemove = this.filter(toRemove);
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for (var i = 0; i < this.length; i++) {
        var element = this[i];
        var remove = rMap.has(element.id());

        if (!remove) {
          elements.push(element);
        }
      }

      return this.spawn(elements);
    }
  },
  absoluteComplement: function absoluteComplement() {
    var cy = this.cy();
    return cy.mutableElements().not(this);
  },
  intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
    if (string(other)) {
      var selector = other;
      return this.filter(selector);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for (var i = 0; i < col.length; i++) {
      var id = col[i]._private.data.id;
      var entry = map2.get(id);

      if (entry) {
        elements.push(entry.ele);
      }
    }

    return this.spawn(elements);
  },
  xor: function xor(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (!inOther) {
          elements.push(ele);
        }
      }
    };

    add(col1, col2);
    add(col2, col1);
    return this.spawn(elements);
  },
  diff: function diff(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other, retEles) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (inOther) {
          both.push(ele);
        } else {
          retEles.push(ele);
        }
      }
    };

    add(col1, col2, left);
    add(col2, col1, right);
    return {
      left: this.spawn(left, {
        unique: true
      }),
      right: this.spawn(right, {
        unique: true
      }),
      both: this.spawn(both, {
        unique: true
      })
    };
  },
  add: function add(toAdd) {
    var cy = this._private.cy;

    if (!toAdd) {
      return this;
    }

    if (string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var elements = [];

    for (var i = 0; i < this.length; i++) {
      elements.push(this[i]);
    }

    var map = this._private.map;

    for (var _i = 0; _i < toAdd.length; _i++) {
      var add = !map.has(toAdd[_i].id());

      if (add) {
        elements.push(toAdd[_i]);
      }
    }

    return this.spawn(elements);
  },
  // in place merge on calling collection
  merge: function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;

    if (!toAdd) {
      return this;
    }

    if (toAdd && string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var map = _p.map;

    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id = toAddEle._private.data.id;
      var add = !map.has(id);

      if (add) {
        var index = this.length++;
        this[index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: index
        });
      } else {
        // replace
        var _index = map.get(id).index;
        this[_index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: _index
        });
      }
    }

    return this; // chaining
  },
  unmergeAt: function unmergeAt(i) {
    var ele = this[i];
    var id = ele.id();
    var _p = this._private;
    var map = _p.map; // remove ele

    this[i] = undefined;
    map["delete"](id);
    var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection

    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;
      this[lastEleI] = undefined;
      this[i] = lastEle;
      map.set(lastEleId, {
        ele: lastEle,
        index: i
      });
    } // the collection is now 1 ele smaller


    this.length--;
    return this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function unmergeOne(ele) {
    ele = ele[0];
    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry = map.get(id);

    if (!entry) {
      return this; // no need to remove
    }

    var i = entry.index;
    this.unmergeAt(i);
    return this;
  },
  // remove eles in place on calling collection
  unmerge: function unmerge(toRemove) {
    var cy = this._private.cy;

    if (!toRemove) {
      return this;
    }

    if (toRemove && string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }

    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }

    return this; // chaining
  },
  unmergeBy: function unmergeBy(toRmFn) {
    for (var i = this.length - 1; i >= 0; i--) {
      var ele = this[i];

      if (toRmFn(ele)) {
        this.unmergeAt(i);
      }
    }

    return this;
  },
  map: function map(mapFn, thisArg) {
    var arr = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
      arr.push(ret);
    }

    return arr;
  },
  reduce: function reduce(fn, initialValue) {
    var val = initialValue;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      val = fn(val, eles[i], i, eles);
    }

    return val;
  },
  max: function max(valFn, thisArg) {
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val > max) {
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },
  min: function min(valFn, thisArg) {
    var min = Infinity;
    var minEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val < min) {
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
}; // aliases

var fn$5 = elesfn$n;
fn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;
fn$5['\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;
fn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;
fn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;
fn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;
fn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;

var elesfn$o = {
  isNode: function isNode() {
    return this.group() === 'nodes';
  },
  isEdge: function isEdge() {
    return this.group() === 'edges';
  },
  isLoop: function isLoop() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function isSimple() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function group() {
    var ele = this[0];

    if (ele) {
      return ele._private.group;
    }
  }
};

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */

var zIndexSort = function zIndexSort(a, b) {
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele) {
    var style = ele.pstyle('z-compound-depth');

    if (style.value === 'auto') {
      return hasCompoundNodes ? ele.zDepth() : 0;
    } else if (style.value === 'bottom') {
      return -1;
    } else if (style.value === 'top') {
      return MAX_INT;
    } // 'orphan'


    return 0;
  }

  var depthDiff = getDepth(a) - getDepth(b);

  if (depthDiff !== 0) {
    return depthDiff;
  }

  function getEleDepth(ele) {
    var style = ele.pstyle('z-index-compare');

    if (style.value === 'auto') {
      return ele.isNode() ? 1 : 0;
    } // 'manual'


    return 0;
  }

  var eleDiff = getEleDepth(a) - getEleDepth(b);

  if (eleDiff !== 0) {
    return eleDiff;
  }

  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;

  if (zDiff !== 0) {
    return zDiff;
  } // compare indices in the core (order added to graph w/ last on top)


  return a.poolIndex() - b.poolIndex();
};

var elesfn$p = {
  forEach: function forEach(fn$1, thisArg) {
    if (fn(fn$1)) {
      var N = this.length;

      for (var i = 0; i < N; i++) {
        var ele = this[i];
        var ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);

        if (ret === false) {
          break;
        } // exit each early on return false

      }
    }

    return this;
  },
  toArray: function toArray() {
    var array = [];

    for (var i = 0; i < this.length; i++) {
      array.push(this[i]);
    }

    return array;
  },
  slice: function slice(start, end) {
    var array = [];
    var thisSize = this.length;

    if (end == null) {
      end = thisSize;
    }

    if (start == null) {
      start = 0;
    }

    if (start < 0) {
      start = thisSize + start;
    }

    if (end < 0) {
      end = thisSize + end;
    }

    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array.push(this[i]);
    }

    return this.spawn(array);
  },
  size: function size() {
    return this.length;
  },
  eq: function eq(i) {
    return this[i] || this.spawn();
  },
  first: function first() {
    return this[0] || this.spawn();
  },
  last: function last() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function empty() {
    return this.length === 0;
  },
  nonempty: function nonempty() {
    return !this.empty();
  },
  sort: function sort(sortFn) {
    if (!fn(sortFn)) {
      return this;
    }

    var sorted = this.toArray().sort(sortFn);
    return this.spawn(sorted);
  },
  sortByZIndex: function sortByZIndex() {
    return this.sort(zIndexSort);
  },
  zDepth: function zDepth() {
    var ele = this[0];

    if (!ele) {
      return undefined;
    } // let cy = ele.cy();


    var _p = ele._private;
    var group = _p.group;

    if (group === 'nodes') {
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if (!ele.isParent()) {
        return MAX_INT - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();
      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
    }
  }
};
elesfn$p.each = elesfn$p.forEach;

var getLayoutDimensionOptions = defaults({
  nodeDimensionsIncludeLabels: false
});
var elesfn$q = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function layoutDimensions(options) {
    options = getLayoutDimensionOptions(options);
    var dims;

    if (!this.takesUpSpace()) {
      dims = {
        w: 0,
        h: 0
      };
    } else if (options.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      dims = {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      dims = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    } // sanitise the dimensions for external layouts (avoid division by zero)


    if (dims.w === 0 || dims.h === 0) {
      dims.w = dims.h = 1;
    }

    return dims;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function layoutPositions(layout, options, fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges

    var getMemoizeKey = function getMemoizeKey(node) {
      return node.id();
    };

    var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function

    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
    layout.animations = [];

    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };
      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

    var spacingBb = function spacingBb() {
      if (!useSpacingFactor) {
        return null;
      }

      var bb = makeBoundingBox();

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = fnMem(node, i);
        expandBoundingBoxByPoint(bb, pos.x, pos.y);
      }

      return bb;
    };

    var bb = spacingBb();
    var getFinalPos = memoize(function (node, i) {
      var newPos = fnMem(node, i);

      if (useSpacingFactor) {
        var spacing = Math.abs(options.spacingFactor);
        newPos = calculateSpacing(spacing, bb, newPos);
      }

      if (options.transform != null) {
        newPos = options.transform(node, newPos);
      }

      return newPos;
    }, getMemoizeKey);

    if (options.animate) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options.animateFilter == null || options.animateFilter(node, i);

        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options.animationDuration,
            easing: options.animationEasing
          });
          layout.animations.push(ani);
        } else {
          node.position(newPos);
        }
      }

      if (options.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(fitAni);
      } else if (options.zoom !== undefined && options.pan !== undefined) {
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(zoomPanAni);
      }

      layout.animations.forEach(function (ani) {
        return ani.play();
      });
      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      Promise$1.all(layout.animations.map(function (ani) {
        return ani.promise();
      })).then(function () {
        layout.one('layoutstop', options.stop);
        layout.emit({
          type: 'layoutstop',
          layout: layout
        });
      });
    } else {
      nodes.positions(getFinalPos);

      if (options.fit) {
        cy.fit(options.eles, options.padding);
      }

      if (options.zoom != null) {
        cy.zoom(options.zoom);
      }

      if (options.pan) {
        cy.pan(options.pan);
      }

      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    }

    return this; // chaining
  },
  layout: function layout(options) {
    var cy = this.cy();
    return cy.makeLayout(extend({}, options, {
      eles: this
    }));
  }
}; // aliases:

elesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;

function styleCache(key, fn, ele) {
  var _p = ele._private;
  var cache = _p.styleCache = _p.styleCache || [];
  var val;

  if ((val = cache[key]) != null) {
    return val;
  } else {
    val = cache[key] = fn(ele);
    return val;
  }
}

function cacheStyleFunction(key, fn) {
  key = hashString(key);
  return function cachedStyleFunction(ele) {
    return styleCache(key, fn, ele);
  };
}

function cachePrototypeStyleFunction(key, fn) {
  key = hashString(key);

  var selfFn = function selfFn(ele) {
    return fn.call(ele);
  };

  return function cachedPrototypeStyleFunction() {
    var ele = this[0];

    if (ele) {
      return styleCache(key, selfFn, ele);
    }
  };
}

var elesfn$r = {
  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer = cy.renderer();
    var styleEnabled = cy.styleEnabled();

    if (renderer && styleEnabled) {
      renderer.recalculateRenderedStyle(this, useCache);
    }

    return this;
  },
  dirtyStyleCache: function dirtyStyleCache() {
    var cy = this.cy();

    var dirty = function dirty(ele) {
      return ele._private.styleCache = null;
    };

    if (cy.hasCompoundNodes()) {
      var eles;
      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
      eles.merge(eles.connectedEdges());
      eles.forEach(dirty);
    } else {
      this.forEach(function (ele) {
        dirty(ele);
        ele.connectedEdges().forEach(dirty);
      });
    }

    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function updateStyle(notifyRenderer) {
    var cy = this._private.cy;

    if (!cy.styleEnabled()) {
      return this;
    }

    if (cy.batching()) {
      var bEles = cy._private.batchStyleEles;
      bEles.merge(this);
      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (hasCompounds) {
      // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }

    var changedEles = style.apply(updatedEles);

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }

    return this; // chaining
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function parsedStyle(property) {
    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var ele = this[0];
    var cy = ele.cy();

    if (!cy.styleEnabled()) {
      return;
    }

    if (ele) {
      var overriddenStyle = ele._private.style[property];

      if (overriddenStyle != null) {
        return overriddenStyle;
      } else if (includeNonDefault) {
        return cy.style().getDefaultProperty(property);
      } else {
        return null;
      }
    }
  },
  numericStyle: function numericStyle(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      var pstyle = ele.pstyle(property);
      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },
  numericStyleUnits: function numericStyleUnits(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      return ele.pstyle(property).units;
    }
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function renderedStyle(property) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var ele = this[0];

    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function style(name, value) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();

    if (plainObject(name)) {
      // then extend the bypass
      var props = name;
      style.applyBypass(this, props, updateTransitions);
      this.emitAndNotify('style'); // let the renderer know we've updated style
    } else if (string(name)) {
      if (value === undefined) {
        // then get the property from the style
        var ele = this[0];

        if (ele) {
          return style.getStylePropertyValue(ele, name);
        } else {
          // empty collection => can't get any value
          return;
        }
      } else {
        // then set the bypass with the property value
        style.applyBypass(this, name, value, updateTransitions);
        this.emitAndNotify('style'); // let the renderer know we've updated style
      }
    } else if (name === undefined) {
      var _ele = this[0];

      if (_ele) {
        return style.getRawStyle(_ele);
      } else {
        // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },
  removeStyle: function removeStyle(names) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if (names === undefined) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        style.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);

      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];
        style.removeBypasses(_ele2, names, updateTransitions);
      }
    }

    this.emitAndNotify('style'); // let the renderer know we've updated style

    return this; // chaining
  },
  show: function show() {
    this.css('display', 'element');
    return this; // chaining
  },
  hide: function hide() {
    this.css('display', 'none');
    return this; // chaining
  },
  effectiveOpacity: function effectiveOpacity() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return 1;
    }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle('opacity').value;

      if (!hasCompoundNodes) {
        return parentOpacity;
      }

      var parents = !_p.data.parent ? null : ele.parents();

      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
          var opacity = parent.pstyle('opacity').value;
          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },
  transparent: function transparent() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if (ele) {
      if (!hasCompoundNodes) {
        return ele.pstyle('opacity').value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },
  backgrounding: function backgrounding() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    return ele._private.backgrounding ? true : false;
  }
};

function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents = _p.data.parent ? ele.parents() : null;

  if (parents) {
    for (var i = 0; i < parents.length; i++) {
      var parent = parents[i];

      if (!parentOk(parent)) {
        return false;
      }
    }
  }

  return true;
}

function defineDerivedStateFunction(specs) {
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;
  return function () {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return true;
    }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele) {
      var _p = ele._private;

      if (!ok(ele)) {
        return false;
      }

      if (ele.isNode()) {
        return !hasCompoundNodes || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;
        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}

var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});
elesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));
var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
});
var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
});
elesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));

elesfn$r.noninteractive = function () {
  var ele = this[0];

  if (ele) {
    return !ele.interactive();
  }
};

var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
});
var edgeVisibleViaNode = eleTakesUpSpace;
elesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));

elesfn$r.hidden = function () {
  var ele = this[0];

  if (ele) {
    return !ele.visible();
  }
};

elesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {
  if (!this.cy().styleEnabled()) {
    return false;
  }

  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();
});
elesfn$r.bypass = elesfn$r.css = elesfn$r.style;
elesfn$r.renderedCss = elesfn$r.renderedStyle;
elesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;
elesfn$r.pstyle = elesfn$r.parsedStyle;

var elesfn$s = {};

function defineSwitchFunction(params) {
  return function () {
    var args = arguments;
    var changedEles = []; // e.g. cy.nodes().select( data, handler )

    if (args.length === 2) {
      var data = args[0];
      var handler = args[1];
      this.on(params.event, data, handler);
    } // e.g. cy.nodes().select( handler )
    else if (args.length === 1 && fn(args[0])) {
        var _handler = args[0];
        this.on(params.event, _handler);
      } // e.g. cy.nodes().select()
      // e.g. (private) cy.nodes().select(['tapselect'])
      else if (args.length === 0 || args.length === 1 && array(args[0])) {
          var addlEvents = args.length === 1 ? args[0] : null;

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var able = !params.ableField || ele._private[params.ableField];
            var changed = ele._private[params.field] != params.value;

            if (params.overrideAble) {
              var overrideAble = params.overrideAble(ele);

              if (overrideAble !== undefined) {
                able = overrideAble;

                if (!overrideAble) {
                  return this;
                } // to save cycles assume not able for all on override

              }
            }

            if (able) {
              ele._private[params.field] = params.value;

              if (changed) {
                changedEles.push(ele);
              }
            }
          }

          var changedColl = this.spawn(changedEles);
          changedColl.updateStyle(); // change of state => possible change of style

          changedColl.emit(params.event);

          if (addlEvents) {
            changedColl.emit(addlEvents);
          }
        }

    return this;
  };
}

function defineSwitchSet(params) {
  elesfn$s[params.field] = function () {
    var ele = this[0];

    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);

        if (val !== undefined) {
          return val;
        }
      }

      return ele._private[params.field];
    }
  };

  elesfn$s[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });
  elesfn$s[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function overrideField(ele) {
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});
defineSwitchSet({
  field: 'grabbable',
  overrideField: function overrideField(ele) {
    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});
defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});
defineSwitchSet({
  field: 'selectable',
  overrideField: function overrideField(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});
elesfn$s.deselect = elesfn$s.unselect;

elesfn$s.grabbed = function () {
  var ele = this[0];

  if (ele) {
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});
defineSwitchSet({
  field: 'pannable',
  on: 'panify',
  off: 'unpanify'
});

elesfn$s.inactive = function () {
  var ele = this[0];

  if (ele) {
    return !ele._private.active;
  }
};

var elesfn$t = {}; // DAG functions
////////////////

var defineDagExtremity = function defineDagExtremity(params) {
  return function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }

      if (!disqualified) {
        ret.push(ele);
      }
    }

    return this.spawn(ret, {
      unique: true
    }).filter(selector);
  };
};

var defineDagOneHop = function defineDagOneHop(params) {
  return function (selector) {
    var eles = this;
    var oEles = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }

    return this.spawn(oEles, {
      unique: true
    }).filter(selector);
  };
};

var defineDagAllHops = function defineDagAllHops(params) {
  return function (selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for (;;) {
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if (next.length === 0) {
        break;
      } // done if none left


      var newNext = false;

      for (var i = 0; i < next.length; i++) {
        var n = next[i];
        var nid = n.id();

        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }

      if (!newNext) {
        break;
      } // done if touched all outgoers already


      eles = next;
    }

    return this.spawn(sEles, {
      unique: true
    }).filter(selector);
  };
};

elesfn$t.clearTraversalCache = function () {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};

extend(elesfn$t, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({
    noIncomingEdges: true
  }),
  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({
    noOutgoingEdges: true
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({
    outgoing: true
  }), 'outgoers'),
  // aka DAG descendants
  successors: defineDagAllHops({
    outgoing: true
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({
    incoming: true
  }), 'incomers'),
  // aka DAG ancestors
  predecessors: defineDagAllHops({
    incoming: true
  })
}); // Neighbourhood functions
//////////////////////////

extend(elesfn$t, {
  neighborhood: cache(function (selector) {
    var elements = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node

      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src; // need check in case of loop

        if (otherNode.length > 0) {
          elements.push(otherNode[0]); // add node 1 hop away
        } // add connected edge


        elements.push(edge[0]);
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }, 'neighborhood'),
  closedNeighborhood: function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  },
  openNeighborhood: function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }
}); // aliases

elesfn$t.neighbourhood = elesfn$t.neighborhood;
elesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;
elesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions
/////////////////

extend(elesfn$t, {
  source: cache(function sourceImpl(selector) {
    var ele = this[0];
    var src;

    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter(selector) : src;
  }, 'source'),
  target: cache(function targetImpl(selector) {
    var ele = this[0];
    var tgt;

    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter(selector) : tgt;
  }, 'target'),
  sources: defineSourceFunction({
    attr: 'source'
  }),
  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction(params) {
  return function sourceImpl(selector) {
    var sources = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];

      if (src) {
        sources.push(src);
      }
    }

    return this.spawn(sources, {
      unique: true
    }).filter(selector);
  };
}

extend(elesfn$t, {
  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),
  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), 'edgesTo')
});

function defineEdgesWithFunction(params) {
  return function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p = params || {}; // get elements if a selector is specified

    if (string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }

    for (var h = 0; h < otherNodes.length; h++) {
      var edges = otherNodes[h]._private.edges;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if (!edgeConnectsThisAndOther) {
          continue;
        }

        if (p.thisIsSrc || p.thisIsTgt) {
          if (p.thisIsSrc && !thisToOther) {
            continue;
          }

          if (p.thisIsTgt && !otherToThis) {
            continue;
          }
        }

        elements.push(edge);
      }
    }

    return this.spawn(elements, {
      unique: true
    });
  };
}

extend(elesfn$t, {
  connectedEdges: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];

      if (!node.isNode()) {
        continue;
      }

      var edges = node._private.edges;

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        retEles.push(edge);
      }
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedEdges'),
  connectedNodes: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];

      if (!edge.isEdge()) {
        continue;
      }

      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedNodes'),
  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),
  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), 'codirectedEdges')
});

function defineParallelEdgesFunction(params) {
  var defaults = {
    codirected: false
  };
  params = extend({}, defaults, params);
  return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params; // look at all the edges in the collection

    for (var i = 0; i < edges.length; i++) {
      var edge1 = edges[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge

      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;
        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  };
} // Misc functions
/////////////////


extend(elesfn$t, {
  components: function components(root) {
    var self = this;
    var cy = self.cy();
    var visited = cy.collection();
    var unvisited = root == null ? self.nodes() : root.nodes();
    var components = [];

    if (root != null && unvisited.empty()) {
      // root may contain only edges
      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
    }

    var visitInComponent = function visitInComponent(node, component) {
      visited.merge(node);
      unvisited.unmerge(node);
      component.merge(node);
    };

    if (unvisited.empty()) {
      return self.spawn();
    }

    var _loop = function _loop() {
      // each iteration yields a component
      var cmpt = cy.collection();
      components.push(cmpt);
      var root = unvisited[0];
      visitInComponent(root, cmpt);
      self.bfs({
        directed: false,
        roots: root,
        visit: function visit(v) {
          return visitInComponent(v, cmpt);
        }
      });
      cmpt.forEach(function (node) {
        node.connectedEdges().forEach(function (e) {
          // connectedEdges() usually cached
          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
            // has() is cheap
            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
          }
        });
      });
    };

    do {
      _loop();
    } while (unvisited.length > 0);

    return components;
  },
  component: function component() {
    var ele = this[0];
    return ele.cy().mutableElements().components(ele)[0];
  }
});
elesfn$t.componentsOf = elesfn$t.components;

var idFactory = {
  generate: function generate(cy, element, tryThisId) {
    var id = tryThisId != null ? tryThisId : uuid();

    while (cy.hasElementWithId(id)) {
      id = uuid();
    }

    return id;
  }
}; // represents a set of nodes, edges, or both together

var Collection = function Collection(cy, elements, options) {
  if (cy === undefined || !core(cy)) {
    error('A collection must have a reference to the core');
    return;
  }

  var map = new Map$1();
  var createdElements = false;

  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
    createdElements = true; // make elements from json and restore all at once later

    var eles = [];
    var elesIds = new Set$1();

    for (var i = 0, l = elements.length; i < l; i++) {
      var json = elements[i];

      if (json.data == null) {
        json.data = {};
      }

      var _data = json.data; // make sure newly created elements have valid ids

      if (_data.id == null) {
        _data.id = idFactory.generate(cy, json);
      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
        continue; // can't create element if prior id already exists
      }

      var ele = new Element(cy, json, false);
      eles.push(ele);
      elesIds.add(_data.id);
    }

    elements = eles;
  }

  this.length = 0;

  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements

    if (element$1 == null) {
      continue;
    }

    var id = element$1._private.data.id;

    if (options == null || options.unique && !map.has(id)) {
      map.set(id, {
        index: this.length,
        ele: element$1
      });
      this[this.length] = element$1;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  }; // restore the elements if we created them from json

  if (createdElements) {
    this.restore();
  }
}; // Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes


var elesfn$u = Element.prototype = Collection.prototype;

elesfn$u.instanceString = function () {
  return 'collection';
};

elesfn$u.spawn = function (cy, eles, opts) {
  if (!core(cy)) {
    // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection(cy, eles, opts);
};

elesfn$u.spawnSelf = function () {
  return this.spawn(this);
};

elesfn$u.cy = function () {
  return this._private.cy;
};

elesfn$u.renderer = function () {
  return this._private.cy.renderer();
};

elesfn$u.element = function () {
  return this[0];
};

elesfn$u.collection = function () {
  if (collection(this)) {
    return this;
  } else {
    // an element
    return new Collection(this._private.cy, [this]);
  }
};

elesfn$u.unique = function () {
  return new Collection(this._private.cy, this, {
    unique: true
  });
};

elesfn$u.hasElementWithId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.has(id);
};

elesfn$u.getElementById = function (id) {
  id = '' + id; // id must be string

  var cy = this._private.cy;

  var entry = this._private.map.get(id);

  return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};

elesfn$u.$id = elesfn$u.getElementById;

elesfn$u.poolIndex = function () {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this[0]._private.data.id;
  return eles._private.map.get(id).index;
};

elesfn$u.indexOf = function (ele) {
  var id = ele[0]._private.data.id;
  return this._private.map.get(id).index;
};

elesfn$u.indexOfId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.get(id).index;
};

elesfn$u.json = function (obj) {
  var ele = this.element();
  var cy = this.cy();

  if (ele == null && obj) {
    return this;
  } // can't set to no eles


  if (ele == null) {
    return undefined;
  } // can't get from no eles


  var p = ele._private;

  if (plainObject(obj)) {
    // set
    cy.startBatch();

    if (obj.data) {
      ele.data(obj.data);
      var _data2 = p.data;

      if (ele.isEdge()) {
        // source and target are immutable via data()
        var move = false;
        var spec = {};
        var src = obj.data.source;
        var tgt = obj.data.target;

        if (src != null && src != _data2.source) {
          spec.source = '' + src; // id must be string

          move = true;
        }

        if (tgt != null && tgt != _data2.target) {
          spec.target = '' + tgt; // id must be string

          move = true;
        }

        if (move) {
          ele = ele.move(spec);
        }
      } else {
        // parent is immutable via data()
        var parent = obj.data.parent;

        if ((parent != null || _data2.parent != null) && parent != _data2.parent) {
          if (parent === undefined) {
            // can't set undefined imperatively, so use null
            parent = null;
          }

          if (parent != null) {
            parent = '' + parent; // id must be string
          }

          ele = ele.move({
            parent: parent
          });
        }
      }
    }

    if (obj.position) {
      ele.position(obj.position);
    } // ignore group -- immutable


    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
      var obj_k = obj[k];

      if (obj_k != null && obj_k !== p[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    };

    checkSwitch('removed', 'remove', 'restore');
    checkSwitch('selected', 'select', 'unselect');
    checkSwitch('selectable', 'selectify', 'unselectify');
    checkSwitch('locked', 'lock', 'unlock');
    checkSwitch('grabbable', 'grabify', 'ungrabify');
    checkSwitch('pannable', 'panify', 'unpanify');

    if (obj.classes != null) {
      ele.classes(obj.classes);
    }

    cy.endBatch();
    return this;
  } else if (obj === undefined) {
    // get
    var json = {
      data: copy(p.data),
      position: copy(p.position),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      pannable: p.pannable,
      classes: null
    };
    json.classes = '';
    var i = 0;
    p.classes.forEach(function (cls) {
      return json.classes += i++ === 0 ? cls : ' ' + cls;
    });
    return json;
  }
};

elesfn$u.jsons = function () {
  var jsons = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    jsons.push(json);
  }

  return jsons;
};

elesfn$u.clone = function () {
  var cy = this.cy();
  var elesArr = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push(clone);
  }

  return new Collection(cy, elesArr);
};

elesfn$u.copy = elesfn$u.clone;

elesfn$u.restore = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private; // create arrays of nodes and edges, since we need to
  // restore the nodes first

  var nodes = [];
  var edges = [];
  var elements;

  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
    var ele = self[_i2];

    if (addToPool && !ele.removed()) {
      // don't need to handle this ele
      continue;
    } // keep nodes first in the array and edges after


    if (ele.isNode()) {
      // put to front of array if node
      nodes.push(ele);
    } else {
      // put to end of array if edge
      edges.push(ele);
    }
  }

  elements = nodes.concat(edges);
  var i;

  var removeFromElements = function removeFromElements() {
    elements.splice(i, 1);
    i--;
  }; // now, restore each element


  for (i = 0; i < elements.length; i++) {
    var _ele = elements[i];
    var _private = _ele._private;
    var _data3 = _private.data; // the traversal cache should start fresh when ele is added

    _ele.clearTraversalCache(); // set id and validate


    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {
      _data3.id = idFactory.generate(cy, _ele);
    } else if (number(_data3.id)) {
      _data3.id = '' + _data3.id; // now it's a string
    } else if (emptyString(_data3.id) || !string(_data3.id)) {
      error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id

      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(_data3.id)) {
      error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id

      removeFromElements();
      continue;
    }

    var id = _data3.id; // id is finalised, now let's keep a ref

    if (_ele.isNode()) {
      // extra checks for nodes
      var pos = _private.position; // make sure the nodes have a defined position

      if (pos.x == null) {
        pos.x = 0;
      }

      if (pos.y == null) {
        pos.y = 0;
      }
    }

    if (_ele.isEdge()) {
      // extra checks for edges
      var edge = _ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;

      for (var j = 0; j < fieldsLength; j++) {
        var field = fields[j];
        var val = _data3[field];

        if (number(val)) {
          val = _data3[field] = '' + _data3[field]; // now string
        }

        if (val == null || val === '') {
          // can't create if source or target is not defined properly
          error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if (badSourceOrTarget) {
        removeFromElements();
        continue;
      } // can't create this


      var src = cy.getElementById(_data3.source);
      var tgt = cy.getElementById(_data3.target); // only one edge in node if loop

      if (src.same(tgt)) {
        src._private.edges.push(edge);
      } else {
        src._private.edges.push(edge);

        tgt._private.edges.push(edge);
      }

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge
    // create mock ids / indexes maps for element so it can be used like collections


    _private.map = new Map$1();

    _private.map.set(id, {
      ele: _ele,
      index: 0
    });

    _private.removed = false;

    if (addToPool) {
      cy.addToPool(_ele);
    }
  } // for each element
  // do compound node sanity checks


  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // each node
    var node = nodes[_i3];
    var _data4 = node._private.data;

    if (number(_data4.parent)) {
      // then automake string
      _data4.parent = '' + _data4.parent;
    }

    var parentId = _data4.parent;
    var specifiedParent = parentId != null;

    if (specifiedParent) {
      var parent = cy.getElementById(parentId);

      if (parent.empty()) {
        // non-existant parent; just remove it
        _data4.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;

        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            // mark self as parent and remove from data
            selfAsParent = true;
            _data4.parent = undefined; // remove parent reference
            // exit or we loop forever

            break;
          }

          ancestor = ancestor.parent();
        }

        if (!selfAsParent) {
          // connect with children
          parent[0]._private.children.push(node);

          node._private.parent = parent[0]; // let the core know we have a compound graph

          cy_p.hasCompoundNodes = true;
        }
      } // else

    } // if specified parent

  } // for each node


  if (elements.length > 0) {
    var restored = new Collection(cy, elements);

    for (var _i4 = 0; _i4 < restored.length; _i4++) {
      var _ele2 = restored[_i4];

      if (_ele2.isNode()) {
        continue;
      } // adding an edge invalidates the traversal caches for the parallel edges


      _ele2.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes


      _ele2.source().clearTraversalCache();

      _ele2.target().clearTraversalCache();
    }

    var toUpdateStyle;

    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);

    if (notifyRenderer) {
      restored.emitAndNotify('add');
    } else if (addToPool) {
      restored.emit('add');
    }
  }

  return self; // chainability
};

elesfn$u.removed = function () {
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn$u.inside = function () {
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn$u.remove = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy; // add connected edges

  function addConnectedEdges(node) {
    var edges = node._private.edges;

    for (var i = 0; i < edges.length; i++) {
      add(edges[i]);
    }
  } // add descendant nodes


  function addChildren(node) {
    var children = node._private.children;

    for (var i = 0; i < children.length; i++) {
      add(children[i]);
    }
  }

  function add(ele) {
    var alreadyAdded = elesToRemoveIds[ele.id()];

    if (removeFromPool && ele.removed() || alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele.id()] = true;
    }

    if (ele.isNode()) {
      elesToRemove.push(ele); // nodes are removed last

      addConnectedEdges(ele);
      addChildren(ele);
    } else {
      elesToRemove.unshift(ele); // edges are removed first
    }
  } // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)


  for (var i = 0, l = self.length; i < l; i++) {
    var ele = self[i];
    add(ele);
  }

  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;
    removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes

    node.clearTraversalCache();
  }

  function removeParallelRef(pllEdge) {
    // removing an edge invalidates the traversal caches for the parallel edges
    pllEdge.clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef(parent, ele) {
    ele = ele[0];
    parent = parent[0];
    var children = parent._private.children;
    var pid = parent.id();
    removeFromArray(children, ele); // remove parent => child ref

    ele._private.parent = null; // remove child => parent ref

    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent);
    }
  }

  self.dirtyCompoundBoundsCache();

  if (removeFromPool) {
    cy.removeFromPool(elesToRemove); // remove from core pool
  }

  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
    var _ele3 = elesToRemove[_i5];

    if (_ele3.isEdge()) {
      // remove references to this edge in its connected nodes
      var src = _ele3.source()[0];

      var tgt = _ele3.target()[0];

      removeEdgeRef(src, _ele3);
      removeEdgeRef(tgt, _ele3);

      var pllEdges = _ele3.parallelEdges();

      for (var j = 0; j < pllEdges.length; j++) {
        var pllEdge = pllEdges[j];
        removeParallelRef(pllEdge);

        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      }
    } else {
      // remove reference to parent
      var parent = _ele3.parent();

      if (parent.length !== 0) {
        removeChildRef(parent, _ele3);
      }
    }

    if (removeFromPool) {
      // mark as removed
      _ele3._private.removed = true;
    }
  } // check to see if we have a compound graph or not


  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;

  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
    var _ele4 = elesStillInside[_i6];

    if (_ele4.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection(this.cy(), elesToRemove);

  if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed
    if (notifyRenderer) {
      removedElements.emitAndNotify('remove');
    } else if (removeFromPool) {
      removedElements.emit('remove');
    }
  } // the parents who were modified by the removal need their style updated


  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
    var _ele5 = alteredParents[_i7];

    if (!removeFromPool || !_ele5.removed()) {
      _ele5.updateStyle();
    }
  }

  return removedElements;
};

elesfn$u.move = function (struct) {
  var cy = this._private.cy;
  var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
  // (our calls to remove/restore do not remove from the graph or make events)

  var notifyRenderer = false;
  var modifyPool = false;

  var toString = function toString(id) {
    return id == null ? id : '' + id;
  }; // id must be string


  if (struct.source !== undefined || struct.target !== undefined) {
    var srcId = toString(struct.source);
    var tgtId = toString(struct.target);
    var srcExists = srcId != null && cy.hasElementWithId(srcId);
    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);

    if (srcExists || tgtExists) {
      cy.batch(function () {
        // avoid duplicate style updates
        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        eles.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data5 = ele._private.data;

          if (ele.isEdge()) {
            if (srcExists) {
              _data5.source = srcId;
            }

            if (tgtExists) {
              _data5.target = tgtId;
            }
          }
        }

        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  } else if (struct.parent !== undefined) {
    // move node to new parent
    var parentId = toString(struct.parent);
    var parentExists = parentId === null || cy.hasElementWithId(parentId);

    if (parentExists) {
      var pidToAssign = parentId === null ? undefined : parentId;
      cy.batch(function () {
        // avoid duplicate style updates
        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        updated.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data6 = ele._private.data;

          if (ele.isNode()) {
            _data6.parent = pidToAssign;
          }
        }

        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  }

  return this;
};

[elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {
  extend(elesfn$u, props);
});

var corefn = {
  add: function add(opts) {
    var elements;
    var cy = this; // add the elements

    if (elementOrCollection(opts)) {
      var eles = opts;

      if (eles._private.cy === cy) {
        // same instance => just restore
        elements = eles.restore();
      } else {
        // otherwise, copy from json
        var jsons = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }

        elements = new Collection(cy, jsons);
      }
    } // specify an array of options
    else if (array(opts)) {
        var _jsons = opts;
        elements = new Collection(cy, _jsons);
      } // specify via opts.nodes and opts.edges
      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
          var elesByGroup = opts;
          var _jsons2 = [];
          var grs = ['nodes', 'edges'];

          for (var _i = 0, il = grs.length; _i < il; _i++) {
            var group = grs[_i];
            var elesArray = elesByGroup[group];

            if (array(elesArray)) {
              for (var j = 0, jl = elesArray.length; j < jl; j++) {
                var json = extend({
                  group: group
                }, elesArray[j]);

                _jsons2.push(json);
              }
            }
          }

          elements = new Collection(cy, _jsons2);
        } // specify options for one element
        else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
          }

    return elements;
  },
  remove: function remove(collection) {
    if (elementOrCollection(collection)) ; else if (string(collection)) {
      var selector = collection;
      collection = this.$(selector);
    }

    return collection.remove();
  }
};

/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4,
      NEWTON_MIN_SLOPE = 0.001,
      SUBDIVISION_PRECISION = 0.0000001,
      SUBDIVISION_MAX_ITERATIONS = 10,
      kSplineTableSize = 11,
      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
      float32ArraySupported = typeof Float32Array !== 'undefined';
  /* Must contain four arguments. */

  if (arguments.length !== 4) {
    return false;
  }
  /* Arguments must be numbers. */


  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }
  /* X values must be in the [0, 1] range. */


  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);
  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }

  function binarySubdivide(aX, aA, aB) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function getTForX(aX) {
    var intervalStart = 0.0,
        currentSample = 1,
        lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
        guessForT = intervalStart + dist * kSampleStepSize,
        initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }

  var _precomputed = false;

  function precompute() {
    _precomputed = true;

    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }

  var f = function f(aX) {
    if (!_precomputed) {
      precompute();
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }

    if (aX === 0) {
      return 0;
    }

    if (aX === 1) {
      return 1;
    }

    return calcBezier(getTForX(aX), mY1, mY2);
  };

  f.getControlPoints = function () {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };

  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";

  f.toString = function () {
    return str;
  };

  return f;
}

/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */

/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
var generateSpringRK4 = function () {
  function springAccelerationForState(state) {
    return -state.tension * state.x - state.friction * state.v;
  }

  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };
    return {
      dx: state.v,
      dv: springAccelerationForState(state)
    };
  }

  function springIntegrateState(state, dt) {
    var a = {
      dx: state.v,
      dv: springAccelerationForState(state)
    },
        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
        d = springEvaluateStateWithDerivative(state, dt, c),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }

  return function springRK4Factory(tension, friction, duration) {
    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration,
        dt,
        last_state;
    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;
    initState.tension = tension;
    initState.friction = friction;
    have_duration = duration !== null;
    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */

    if (have_duration) {
      /* Run the simulation without a duration. */
      time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */

      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }

    for (;;) {
      /* Next/step function .*/
      last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */

      path.push(1 + last_state.x);
      time_lapsed += 16;
      /* If the change threshold is reached, break. */

      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }
    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */


    return !have_duration ? time_lapsed : function (percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  };
}();

var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);
  return function (start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
};

var easings = {
  'linear': function linear(start, end, percent) {
    return start + (end - start) * percent;
  },
  // default easings
  'ease': cubicBezier(0.25, 0.1, 0.25, 1),
  'ease-in': cubicBezier(0.42, 0, 1, 1),
  'ease-out': cubicBezier(0, 0, 0.58, 1),
  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
  // sine
  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),
  // quad
  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),
  // cubic
  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),
  // quart
  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),
  // quint
  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),
  // expo
  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),
  // circ
  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  'spring': function spring(tension, friction, duration) {
    if (duration === 0) {
      // can't get a spring w/ duration 0
      return easings.linear; // duration 0 => jump to end so impl doesn't matter
    }

    var spring = generateSpringRK4(tension, friction, duration);
    return function (start, end, percent) {
      return start + (end - start) * spring(percent);
    };
  },
  'cubic-bezier': cubicBezier
};

function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }

  var val = easingFn(start, end, percent);

  if (type == null) {
    return val;
  }

  if (type.roundValue || type.color) {
    val = Math.round(val);
  }

  if (type.min !== undefined) {
    val = Math.max(val, type.min);
  }

  if (type.max !== undefined) {
    val = Math.min(val, type.max);
  }

  return val;
}

function getValue(prop, spec) {
  if (prop.pfValue != null || prop.value != null) {
    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
      return prop.pfValue;
    } else {
      return prop.value;
    }
  } else {
    return prop;
  }
}

function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  var start = getValue(startProp, propSpec);
  var end = getValue(endProp, propSpec);

  if (number(start) && number(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (array(start) && array(end)) {
    var easedArr = [];

    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];

      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);
        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }

    return easedArr;
  }

  return undefined;
}

function step(self, ani, now, isCore) {
  var isEles = !isCore;
  var _p = self._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (!ani_p.easingImpl) {
    if (pEasing == null) {
      // use default
      ani_p.easingImpl = easings['linear'];
    } else {
      // then define w/ name
      var easingVals;

      if (string(pEasing)) {
        var easingProp = style.parse('transition-timing-function', pEasing);
        easingVals = easingProp.value;
      } else {
        // then assume preparsed array
        easingVals = pEasing;
      }

      var name, args;

      if (string(easingVals)) {
        name = easingVals;
        args = [];
      } else {
        name = easingVals[1];
        args = easingVals.slice(2).map(function (n) {
          return +n;
        });
      }

      if (args.length > 0) {
        // create with args
        if (name === 'spring') {
          args.push(ani_p.duration); // need duration to generate spring
        }

        ani_p.easingImpl = easings[name].apply(null, args);
      } else {
        // static impl by name
        ani_p.easingImpl = easings[name];
      }
    }
  }

  var easing = ani_p.easingImpl;
  var percent;

  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now - startTime) / ani_p.duration;
  }

  if (ani_p.applying) {
    percent = ani_p.progress;
  }

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  if (ani_p.delay == null) {
    // then update
    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;

    if (endPos && isEles && !self.locked()) {
      var newPos = {};

      if (valid(startPos.x, endPos.x)) {
        newPos.x = ease(startPos.x, endPos.x, percent, easing);
      }

      if (valid(startPos.y, endPos.y)) {
        newPos.y = ease(startPos.y, endPos.y, percent, easing);
      }

      self.position(newPos);
    }

    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan = _p.pan;
    var animatingPan = endPan != null && isCore;

    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan.x = ease(startPan.x, endPan.x, percent, easing);
      }

      if (valid(startPan.y, endPan.y)) {
        pan.y = ease(startPan.y, endPan.y, percent, easing);
      }

      self.emit('pan');
    }

    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;

    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
      }

      self.emit('zoom');
    }

    if (animatingPan || animatingZoom) {
      self.emit('viewport');
    }

    var props = ani_p.style;

    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var _name = prop.name;
        var end = prop;
        var start = ani_p.startStyle[_name];
        var propSpec = style.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);
        style.overrideBypass(self, _name, easedVal);
      } // for props


      self.emit('style');
    } // if

  }

  ani_p.progress = percent;
  return percent;
}

function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }

  if (number(start) && number(end)) {
    return true;
  } else if (start && end) {
    return true;
  }

  return false;
}

function startAnimation(self, ani, now, isCore) {
  var ani_p = ani._private;
  ani_p.started = true;
  ani_p.startTime = now - ani_p.progress * ani_p.duration;
}

function stepAll(now, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];

  function stepOne(ele, isCore) {
    var _p = ele._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false; // cancel all animations on display:none ele

    if (!isCore && ele.pstyle('display').value === 'none') {
      // put all current and queue animations in this tick's current list
      // and empty the lists for the element
      current = current.splice(0, current.length).concat(queue.splice(0, queue.length)); // stop all animations

      for (var i = 0; i < current.length; i++) {
        current[i].stop();
      }
    } // if nothing currently animating, get something from the queue


    if (current.length === 0) {
      var next = queue.shift();

      if (next) {
        current.push(next);
      }
    }

    var callbacks = function callbacks(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];
        cb();
      }

      _callbacks.splice(0, _callbacks.length);
    }; // step and remove if done


    for (var _i = current.length - 1; _i >= 0; _i--) {
      var ani = current[_i];
      var ani_p = ani._private;

      if (ani_p.stopped) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.frames);
        continue;
      }

      if (!ani_p.playing && !ani_p.applying) {
        continue;
      } // an apply() while playing shouldn't do anything


      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }

      if (!ani_p.started) {
        startAnimation(ele, ani, now);
      }

      step(ele, ani, now, isCore);

      if (ani_p.applying) {
        ani_p.applying = false;
      }

      callbacks(ani_p.frames);

      if (ani_p.step != null) {
        ani_p.step(now);
      }

      if (ani.completed()) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.completes);
      }

      ranAnis = true;
    }

    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele);
    }

    return ranAnis;
  } // stepElement
  // handle all eles


  var ranEleAni = false;

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);
    ranEleAni = ranEleAni || handledThisEle;
  } // each element


  var ranCoreAni = stepOne(cy, true); // notify renderer

  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      cy.notify('draw', eles);
    } else {
      cy.notify('draw');
    }
  } // remove elements from list of currently animating if its queues are empty


  eles.unmerge(doneEles);
  cy.emit('step');
} // stepAll

var corefn$1 = {
  // pull in animation functions
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop(),
  addToAnimationPool: function addToAnimationPool(eles) {
    var cy = this;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used


    cy._private.aniEles.merge(eles);
  },
  stopAnimationLoop: function stopAnimationLoop() {
    this._private.animationsRunning = false;
  },
  startAnimationLoop: function startAnimationLoop() {
    var cy = this;
    cy._private.animationsRunning = true;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used
    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop


    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }

      requestAnimationFrame(function animationStep(now) {
        stepAll(now, cy);
        headlessStep();
      });
    }

    var renderer = cy.renderer();

    if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
        stepAll(now, cy);
      }, renderer.beforeRenderPriorities.animations);
    } else {
      // manage the animation loop ourselves
      headlessStep(); // first call
    }
  }
};

var emitterOptions$1 = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(cy, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(cy, evt) {
    evt.cy = cy;
    evt.target = cy;
  },
  callbackContext: function callbackContext(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }
};

var argSelector$1 = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$v = {
  createEmitter: function createEmitter() {
    var _p = this._private;

    if (!_p.emitter) {
      _p.emitter = new Emitter(emitterOptions$1, this);
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    this.emitter().on(events, argSelector$1(selector), callback);
    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    this.emitter().removeListener(events, argSelector$1(selector), callback);
    return this;
  },
  removeAllListeners: function removeAllListeners() {
    this.emitter().removeAllListeners();
    return this;
  },
  one: function one(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  once: function once(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  emit: function emit(events, extraParams) {
    this.emitter().emit(events, extraParams);
    return this;
  },
  emitAndNotify: function emitAndNotify(event, eles) {
    this.emit(event);
    this.notify(event, eles);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$v);

var corefn$2 = {
  png: function png(options) {
    var renderer = this._private.renderer;
    options = options || {};
    return renderer.png(options);
  },
  jpg: function jpg(options) {
    var renderer = this._private.renderer;
    options = options || {};
    options.bg = options.bg || '#fff';
    return renderer.jpg(options);
  }
};
corefn$2.jpeg = corefn$2.jpg;

var corefn$3 = {
  layout: function layout(options) {
    var cy = this;

    if (options == null) {
      error('Layout options must be specified to make a layout');
      return;
    }

    if (options.name == null) {
      error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if (Layout == null) {
      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');
      return;
    }

    var eles;

    if (string(options.eles)) {
      eles = cy.$(options.eles);
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout(extend({}, options, {
      cy: cy,
      eles: eles
    }));
    return layout;
  }
};
corefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;

var corefn$4 = {
  notify: function notify(eventName, eventEles) {
    var _p = this._private;

    if (this.batching()) {
      _p.batchNotifications = _p.batchNotifications || {};
      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();

      if (eventEles != null) {
        eles.merge(eventEles);
      }

      return; // notifications are disabled during batching
    }

    if (!_p.notificationsEnabled) {
      return;
    } // exit on disabled


    var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528

    if (this.destroyed() || !renderer) {
      return;
    }

    renderer.notify(eventName, eventEles);
  },
  notifications: function notifications(bool) {
    var p = this._private;

    if (bool === undefined) {
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }

    return this;
  },
  noNotifications: function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  },
  batching: function batching() {
    return this._private.batchCount > 0;
  },
  startBatch: function startBatch() {
    var _p = this._private;

    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }

    if (_p.batchCount === 0) {
      _p.batchStyleEles = this.collection();
      _p.batchNotifications = {};
    }

    _p.batchCount++;
    return this;
  },
  endBatch: function endBatch() {
    var _p = this._private;

    if (_p.batchCount === 0) {
      return this;
    }

    _p.batchCount--;

    if (_p.batchCount === 0) {
      // update style for dirty eles
      _p.batchStyleEles.updateStyle();

      var renderer = this.renderer(); // notify the renderer of queued eles and event types

      Object.keys(_p.batchNotifications).forEach(function (eventName) {
        var eles = _p.batchNotifications[eventName];

        if (eles.empty()) {
          renderer.notify(eventName);
        } else {
          renderer.notify(eventName, eles);
        }
      });
    }

    return this;
  },
  batch: function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();
    return this;
  },
  // for backwards compatibility
  batchData: function batchData(map) {
    var cy = this;
    return this.batch(function () {
      var ids = Object.keys(map);

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = map[id];
        var ele = cy.getElementById(id);
        ele.data(data);
      }
    });
  }
};

var rendererDefaults = defaults({
  hideEdgesOnViewport: false,
  textureOnViewport: false,
  motionBlur: false,
  motionBlurOpacity: 0.05,
  pixelRatio: undefined,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: false,
  showFps: false
});
var corefn$5 = {
  renderTo: function renderTo(context, zoom, pan, pxRatio) {
    var r = this._private.renderer;
    r.renderTo(context, zoom, pan, pxRatio);
    return this;
  },
  renderer: function renderer() {
    return this._private.renderer;
  },
  forceRender: function forceRender() {
    this.notify('draw');
    return this;
  },
  resize: function resize() {
    this.invalidateSize();
    this.emitAndNotify('resize');
    return this;
  },
  initRenderer: function initRenderer(options) {
    var cy = this;
    var RendererProto = cy.extension('renderer', options.name);

    if (RendererProto == null) {
      error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }

    if (options.wheelSensitivity !== undefined) {
      warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    }

    var rOpts = rendererDefaults(options);
    rOpts.cy = cy;
    cy._private.renderer = new RendererProto(rOpts);
    this.notify('init');
  },
  destroyRenderer: function destroyRenderer() {
    var cy = this;
    cy.notify('destroy'); // destroy the renderer

    var domEle = cy.container();

    if (domEle) {
      domEle._cyreg = null;

      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref

    cy.mutableElements().forEach(function (ele) {
      var _p = ele._private;
      _p.rscratch = {};
      _p.rstyle = {};
      _p.animation.current = [];
      _p.animation.queue = [];
    });
  },
  onRender: function onRender(fn) {
    return this.on('render', fn);
  },
  offRender: function offRender(fn) {
    return this.off('render', fn);
  }
};
corefn$5.invalidateDimensions = corefn$5.resize;

var corefn$6 = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function collection(eles, opts) {
    if (string(eles)) {
      return this.$(eles);
    } else if (elementOrCollection(eles)) {
      return eles.collection();
    } else if (array(eles)) {
      return new Collection(this, eles, opts);
    }

    return new Collection(this);
  },
  nodes: function nodes(selector) {
    var nodes = this.$(function (ele) {
      return ele.isNode();
    });

    if (selector) {
      return nodes.filter(selector);
    }

    return nodes;
  },
  edges: function edges(selector) {
    var edges = this.$(function (ele) {
      return ele.isEdge();
    });

    if (selector) {
      return edges.filter(selector);
    }

    return edges;
  },
  // search the graph like jQuery
  $: function $(selector) {
    var eles = this._private.elements;

    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  },
  mutableElements: function mutableElements() {
    return this._private.elements;
  }
}; // aliases

corefn$6.elements = corefn$6.filter = corefn$6.$;

var styfn = {}; // keys for style blocks, e.g. ttfftt

var TRUE = 't';
var FALSE = 'f'; // (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it

styfn.apply = function (eles) {
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if (_p.newStyle) {
    // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};
    self.cleanElements(eles, true);
  }

  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];
    var cxtMeta = self.getContextMeta(ele);

    if (cxtMeta.empty) {
      continue;
    }

    var cxtStyle = self.getContextStyle(cxtMeta);
    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

    if (!_p.newStyle) {
      self.updateTransitions(ele, app.diffProps);
    }

    var hintsDiff = self.updateStyleHints(ele);

    if (hintsDiff) {
      updatedEles.merge(ele);
    }
  } // for elements


  _p.newStyle = false;
  return updatedEles;
};

styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if (cachedVal) {
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === TRUE;
    var newHasCxt = newCxtKey[i] === TRUE;
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
      var props = void 0;

      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if (cxtHasDiffed) {
        props = cxt.properties; // need to check them all
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties; // only need to check mapped
      }

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)

        var laterCxtOverrides = false;

        for (var k = i + 1; k < self.length; k++) {
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === TRUE;

          if (!hasLaterCxt) {
            continue;
          } // can't override unless the context is active


          laterCxtOverrides = laterCxt.properties[prop.name] != null;

          if (laterCxtOverrides) {
            break;
          } // exit early as long as one later context overrides

        }

        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      } // for props

    } // if

  } // for contexts


  cache[dualCxtKey] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function (ele) {
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if (self._private.newStyle) {
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  } // get the cxt key


  for (var i = 0; i < self.length; i++) {
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

    if (contextSelectorMatches) {
      cxtKey += TRUE;
    } else {
      cxtKey += FALSE;
    }
  } // for context


  diffProps = self.getPropertiesDiff(prevKey, cxtKey);
  ele._private.styleCxtKey = cxtKey;
  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
}; // gets a computed ele style object based on matched contexts


styfn.getContextStyle = function (cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy

  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var hasCxt = cxtKey[i] === TRUE;

    if (!hasCxt) {
      continue;
    }

    for (var j = 0; j < cxt.properties.length; j++) {
      var prop = cxt.properties[j];
      style[prop.name] = prop;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};
  var types = self.types;

  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);

    if (!cxtProp) {
      // no context prop means delete
      if (!eleProp) {
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if (eleProp.bypass) {
        cxtProp = {
          name: diffPropName,
          deleteBypassed: true
        };
      } else {
        cxtProp = {
          name: diffPropName,
          "delete": true
        };
      }
    } // save cycles when the context prop doesn't need to be applied


    if (eleProp === cxtProp) {
      continue;
    } // save cycles when a mapped context prop doesn't need to be applied


    if (cxtProp.mapped === types.fn // context prop is function mapper
    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
    && eleProp.mapping != null // ele prop is a concrete value from from a mapper
    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
    ) {
        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy

        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss

        if (fnValue === mapping.prevFnValue) {
          continue;
        }
      }

    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };
    self.applyParsedProperty(ele, cxtProp);
    retDiffProp.next = ele.pstyle(diffPropName);

    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function (ele) {
  var _p = ele._private;
  var self = this;
  var propNames = self.propertyGroupNames;
  var propGrKeys = self.propertyGroupKeys;

  var propHash = function propHash(ele, propNames, seedKey) {
    return self.getPropertiesHash(ele, propNames, seedKey);
  };

  var oldStyleKey = _p.styleKey;

  if (ele.removed()) {
    return false;
  }

  var isNode = _p.group === 'nodes'; // get the style key hashes per prop group
  // but lazily -- only use non-default prop values to reduce the number of hashes
  //

  var overriddenStyles = ele._private.style;
  propNames = Object.keys(overriddenStyles);

  for (var i = 0; i < propGrKeys.length; i++) {
    var grKey = propGrKeys[i];
    _p.styleKeys[grKey] = 0;
  }

  var updateGrKey = function updateGrKey(val, grKey) {
    return _p.styleKeys[grKey] = hashInt(val, _p.styleKeys[grKey]);
  };

  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
    for (var j = 0; j < strVal.length; j++) {
      updateGrKey(strVal.charCodeAt(j), grKey);
    }
  }; // - hashing works on 32 bit ints b/c we use bitwise ops
  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
  // - raise up small numbers so more significant digits are seen by hashing
  // - make small numbers larger than a normal value to avoid collisions
  // - works in practice and it's relatively cheap


  var N = 2000000000;

  var cleanNum = function cleanNum(val) {
    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
  };

  for (var _i = 0; _i < propNames.length; _i++) {
    var name = propNames[_i];
    var parsedProp = overriddenStyles[name];

    if (parsedProp == null) {
      continue;
    }

    var propInfo = this.properties[name];
    var type = propInfo.type;
    var _grKey = propInfo.groupKey;
    var normalizedNumberVal = void 0;

    if (propInfo.hashOverride != null) {
      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
    } else if (parsedProp.pfValue != null) {
      normalizedNumberVal = parsedProp.pfValue;
    } // might not be a number if it allows enums


    var numberVal = propInfo.enums == null ? parsedProp.value : null;
    var haveNormNum = normalizedNumberVal != null;
    var haveUnitedNum = numberVal != null;
    var haveNum = haveNormNum || haveUnitedNum;
    var units = parsedProp.units; // numbers are cheaper to hash than strings
    // 1 hash op vs n hash ops (for length n string)

    if (type.number && haveNum) {
      var v = haveNormNum ? normalizedNumberVal : numberVal;

      if (type.multiple) {
        for (var _i2 = 0; _i2 < v.length; _i2++) {
          updateGrKey(cleanNum(v[_i2]), _grKey);
        }
      } else {
        updateGrKey(cleanNum(v), _grKey);
      }

      if (!haveNormNum && units != null) {
        updateGrKeyWStr(units, _grKey);
      }
    } else {
      updateGrKeyWStr(parsedProp.strValue, _grKey);
    }
  } // overall style key
  //


  var hash = 0;

  for (var _i3 = 0; _i3 < propGrKeys.length; _i3++) {
    var _grKey2 = propGrKeys[_i3];
    var grHash = _p.styleKeys[_grKey2];
    hash = hashInt(grHash, hash);
  }

  _p.styleKey = hash; // label dims
  //

  var labelDimsKey = _p.labelDimsKey = _p.styleKeys.labelDimensions;
  _p.labelKey = propHash(ele, ['label'], labelDimsKey);
  _p.labelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.labelKey);

  if (!isNode) {
    _p.sourceLabelKey = propHash(ele, ['source-label'], labelDimsKey);
    _p.sourceLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.sourceLabelKey);
    _p.targetLabelKey = propHash(ele, ['target-label'], labelDimsKey);
    _p.targetLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.targetLabelKey);
  } // node
  //


  if (isNode) {
    var _p$styleKeys = _p.styleKeys,
        nodeBody = _p$styleKeys.nodeBody,
        nodeBorder = _p$styleKeys.nodeBorder,
        backgroundImage = _p$styleKeys.backgroundImage,
        compound = _p$styleKeys.compound,
        pie = _p$styleKeys.pie;
    _p.nodeKey = hashIntsArray([nodeBorder, backgroundImage, compound, pie], nodeBody);
    _p.hasPie = pie != 0;
  }

  return oldStyleKey !== _p.styleKey;
};

styfn.clearStyleHints = function (ele) {
  var _p = ele._private;
  _p.styleKeys = {};
  _p.styleKey = null;
  _p.labelKey = null;
  _p.labelStyleKey = null;
  _p.sourceLabelKey = null;
  _p.sourceLabelStyleKey = null;
  _p.targetLabelKey = null;
  _p.targetLabelStyleKey = null;
  _p.nodeKey = null;
  _p.hasPie = null;
}; // apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }


styfn.applyParsedProperty = function (ele, parsedProp) {
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var flatProp;
  var types = self.types;
  var type = self.properties[prop.name].type;
  var propIsBypass = prop.bypass;
  var origProp = style[prop.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  var getVal = function getVal(p) {
    if (p == null) {
      return null;
    } else if (p.pfValue != null) {
      return p.pfValue;
    } else {
      return p.value;
    }
  };

  var checkTriggers = function checkTriggers() {
    var fromVal = getVal(origProp);
    var toVal = getVal(prop);
    self.checkTriggers(ele, prop.name, fromVal, toVal);
  }; // edge sanity checks to prevent the client from making serious mistakes


  if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers
  parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks
  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {
    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
  }

  if (prop["delete"]) {
    // delete the property and use the default value on falsey value
    style[prop.name] = undefined;
    checkTriggers();
    return true;
  }

  if (prop.deleteBypassed) {
    // delete the property that the
    if (!origProp) {
      checkTriggers();
      return true; // can't delete if no prop
    } else if (origProp.bypass) {
      // delete bypassed
      origProp.bypassed = undefined;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  } // check if we need to delete the current bypass


  if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
    if (!origProp) {
      checkTriggers();
      return true; // property is already not defined
    } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[prop.name] = origProp.bypassed;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function printMappingErr() {
    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
  }; // put the property in the style objects


  switch (prop.mapped) {
    // flatten the property if mapped
    case types.mapData:
      {
        // flatten the field (e.g. data.foo.bar)
        var fields = prop.field.split('.');
        var fieldVal = _p.data;

        for (var i = 0; i < fields.length && fieldVal; i++) {
          var field = fields[i];
          fieldVal = fieldVal[field];
        }

        if (fieldVal == null) {
          printMappingErr();
          return false;
        }

        var percent;

        if (!number(fieldVal)) {
          // then don't apply and fall back on the existing style
          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');
          return false;
        } else {
          var fieldWidth = prop.fieldMax - prop.fieldMin;

          if (fieldWidth === 0) {
            // safety check -- not strictly necessary as no props of zero range should be passed here
            percent = 0;
          } else {
            percent = (fieldVal - prop.fieldMin) / fieldWidth;
          }
        } // make sure to bound percent value


        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (type.color) {
          var r1 = prop.valueMin[0];
          var r2 = prop.valueMax[0];
          var g1 = prop.valueMin[1];
          var g2 = prop.valueMax[1];
          var b1 = prop.valueMin[2];
          var b2 = prop.valueMax[2];
          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
          flatProp = {
            // colours are simple, so just create the flat property instead of expensive string parsing
            bypass: prop.bypass,
            // we're a bypass if the mapping property is a bypass
            name: prop.name,
            value: clr,
            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
          };
        } else if (type.number) {
          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
        } else {
          return false; // can only map to colours and numbers
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply the property and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }
    // direct mapping

    case types.data:
      {
        // flatten the field (e.g. data.foo.bar)
        var _fields = prop.field.split('.');

        var _fieldVal = _p.data;

        for (var _i4 = 0; _i4 < _fields.length && _fieldVal; _i4++) {
          var _field = _fields[_i4];
          _fieldVal = _fieldVal[_field];
        }

        if (_fieldVal != null) {
          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case types.fn:
      {
        var fn = prop.value;
        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function

        prop.prevFnValue = fnRetVal;

        if (fnRetVal == null) {
          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');
          return false;
        }

        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);

        if (!flatProp) {
          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');
          return false;
        }

        flatProp.mapping = copy(prop); // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case undefined:
      break;
    // just set the property

    default:
      return false;
    // not a valid mapping
  } // if the property is a bypass property, then link the resultant property to the original one


  if (propIsBypass) {
    if (origPropIsBypass) {
      // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else {
      // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[prop.name] = prop; // and set
  } else {
    // prop is not bypass
    if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else {
      // then just replace the old prop with the new one
      style[prop.name] = prop;
    }
  }

  checkTriggers();
  return true;
};

styfn.cleanElements = function (eles, keepBypasses) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    this.clearStyleHints(ele);
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache();

    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style = ele._private.style;
      var propNames = Object.keys(style);

      for (var j = 0; j < propNames.length; j++) {
        var propName = propNames[j];
        var eleProp = style[propName];

        if (eleProp != null) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style[propName] = null;
          }
        }
      }
    }
  }
}; // updates the visual style for all elements (useful for manual style modification after init)


styfn.update = function () {
  var cy = this._private.cy;
  var eles = cy.mutableElements();
  eles.updateStyle();
}; // diffProps : { name => { prev, next } }


styfn.updateTransitions = function (ele, diffProps) {
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle('transition-property').value;
  var duration = ele.pstyle('transition-duration').pfValue;
  var delay = ele.pstyle('transition-delay').pfValue;

  if (props.length > 0 && duration > 0) {
    var style = {}; // build up the style to animate towards

    var anyPrev = false;

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var styProp = ele.pstyle(prop);
      var diffProp = diffProps[prop];

      if (!diffProp) {
        continue;
      }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal = void 0;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if (!fromProp) {
        continue;
      } // consider px values


      if (number(fromProp.pfValue) && number(toProp.pfValue)) {
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy

        initVal = fromProp.pfValue + initDt * diff; // consider numerical values
      } else if (number(fromProp.value) && number(toProp.value)) {
        diff = toProp.value - fromProp.value; // nonzero is truthy

        initVal = fromProp.value + initDt * diff; // consider colour values
      } else if (array(fromProp.value) && array(toProp.value)) {
        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
        initVal = fromProp.strValue;
      } // the previous value is good for an animation only if it's different


      if (diff) {
        style[prop] = toProp.strValue; // to val

        this.applyBypass(ele, prop, initVal); // from val

        anyPrev = true;
      }
    } // end if props allow ani
    // can't transition if there's nothing previous to transition from


    if (!anyPrev) {
      return;
    }

    _p.transitioning = true;
    new Promise$1(function (resolve) {
      if (delay > 0) {
        ele.delayAnimation(delay).play().promise().then(resolve);
      } else {
        resolve();
      }
    }).then(function () {
      return ele.animation({
        style: style,
        duration: duration,
        easing: ele.pstyle('transition-timing-function').value,
        queue: false
      }).play().promise();
    }).then(function () {
      // if( !isBypass ){
      self.removeBypasses(ele, props);
      ele.emitAndNotify('style'); // }

      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify('style');
    _p.transitioning = false;
  }
};

styfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {
  var prop = this.properties[name];
  var triggerCheck = getTrigger(prop);

  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {
    onTrigger(prop);
  }
};

styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
  var _this = this;

  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersZOrder;
  }, function () {
    _this._private.cy.notify('zorder', ele);
  });
};

styfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersBounds;
  }, function (prop) {
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
    // then dirty the pll edge bb cache as well

    if ( // only for beziers -- so performance of other edges isn't affected
    (ele.pstyle('curve-style').value === 'bezier' // already a bezier
    // was just now changed to or from a bezier:
    || name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier')) && prop.triggersBoundsOfParallelBeziers) {
      ele.parallelEdges().forEach(function (pllEdge) {
        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      });
    }
  });
};

styfn.checkTriggers = function (ele, name, fromValue, toValue) {
  ele.dirtyStyleCache();
  this.checkZOrderTrigger(ele, name, fromValue, toValue);
  this.checkBoundsTrigger(ele, name, fromValue, toValue);
};

var styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property

styfn$1.applyBypass = function (eles, name, value, updateTransitions) {
  var self = this;
  var props = [];
  var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them

  if (name === '*' || name === '**') {
    // apply to all property names
    if (value !== undefined) {
      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var _name = prop.name;
        var parsedProp = this.parse(_name, value, true);

        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (string(name)) {
    // then parse the single property
    var _parsedProp = this.parse(name, value, true);

    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (plainObject(name)) {
    // then parse each property
    var specifiedProps = name;
    updateTransitions = value;
    var names = Object.keys(specifiedProps);

    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _value = specifiedProps[_name2];

      if (_value === undefined) {
        // try camel case name too
        _value = specifiedProps[dash2camel(_name2)];
      }

      if (_value !== undefined) {
        var _parsedProp2 = this.parse(_name2, _value, true);

        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    // can't do anything without well defined properties
    return false;
  } // we've failed if there are no valid properties


  if (props.length === 0) {
    return false;
  } // now, apply the bypass properties on the elements


  var ret = false; // return true if at least one succesful bypass applied

  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;

    for (var j = 0; j < props.length; j++) {
      // for each prop
      var _prop = props[j];

      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop.name);
        diffProp = diffProps[_prop.name] = {
          prev: prevProp
        };
      }

      ret = this.applyParsedProperty(ele, _prop) || ret;

      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop.name);
      }
    } // for props


    if (ret) {
      this.updateStyleHints(ele);
    }

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles


  return ret;
}; // only useful in specific cases like animation


styfn$1.overrideBypass = function (eles, name, value) {
  name = camel2dash(name);

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;
    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;

    if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
      this.applyBypass(ele, name, value);
    } else {
      prop.value = value;

      if (prop.pfValue != null) {
        prop.pfValue = value;
      }

      if (isColor) {
        prop.strValue = 'rgb(' + value.join(',') + ')';
      } else if (isMulti) {
        prop.strValue = value.join(' ');
      } else {
        prop.strValue = '' + value;
      }

      this.updateStyleHints(ele);
    }

    this.checkTriggers(ele, name, oldValue, value);
  }
};

styfn$1.removeAllBypasses = function (eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};

styfn$1.removeBypasses = function (eles, props, updateTransitions) {
  var isBypass = true;

  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};

    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop = this.properties[name];
      var prevProp = ele.pstyle(prop.name);

      if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass

      var parsedProp = this.parse(name, value, true);
      var diffProp = diffProps[prop.name] = {
        prev: prevProp
      };
      this.applyParsedProperty(ele, parsedProp);
      diffProp.next = ele.pstyle(prop.name);
    } // for props


    this.updateStyleHints(ele);

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles

};

var styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element

styfn$2.getEmSizeInPixels = function () {
  var px = this.containerCss('font-size');

  if (px != null) {
    return parseFloat(px);
  } else {
    return 1; // for headless
  }
}; // gets css property from the core container


styfn$2.containerCss = function (propName) {
  var cy = this._private.cy;
  var domElement = cy.container();

  if (window$1 && domElement && window$1.getComputedStyle) {
    return window$1.getComputedStyle(domElement).getPropertyValue(propName);
  }
};

var styfn$3 = {}; // gets the rendered style for an element

styfn$3.getRenderedStyle = function (ele, prop) {
  if (prop) {
    return this.getStylePropertyValue(ele, prop, true);
  } else {
    return this.getRawStyle(ele, true);
  }
}; // gets the raw style for an element


styfn$3.getRawStyle = function (ele, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var rstyle = {};

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

      if (val != null) {
        rstyle[prop.name] = val;
        rstyle[dash2camel(prop.name)] = val;
      }
    }

    return rstyle;
  }
};

styfn$3.getIndexedStyle = function (ele, property, subproperty, index) {
  var pstyle = ele.pstyle(property)[subproperty][index];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};

styfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var prop = self.properties[propName];

    if (prop.alias) {
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle(prop.name);

    if (styleProp) {
      var value = styleProp.value,
          units = styleProp.units,
          strValue = styleProp.strValue;

      if (isRenderedVal && type.number && value != null && number(value)) {
        var zoom = ele.cy().zoom();

        var getRenderedValue = function getRenderedValue(val) {
          return val * zoom;
        };

        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {
          return getRenderedValue(val) + units;
        };

        var isArrayValue = array(value);
        var haveUnits = isArrayValue ? units.every(function (u) {
          return u != null;
        }) : units != null;

        if (haveUnits) {
          if (isArrayValue) {
            return value.map(function (v, i) {
              return getValueStringWithUnits(v, units[i]);
            }).join(' ');
          } else {
            return getValueStringWithUnits(value, units);
          }
        } else {
          if (isArrayValue) {
            return value.map(function (v) {
              return string(v) ? v : '' + getRenderedValue(v);
            }).join(' ');
          } else {
            return '' + getRenderedValue(value);
          }
        }
      } else if (strValue != null) {
        return strValue;
      }
    }

    return null;
  }
};

styfn$3.getAnimationStartStyle = function (ele, aniProps) {
  var rstyle = {};

  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;
    var styleProp = ele.pstyle(name);

    if (styleProp !== undefined) {
      // then make a prop of it
      if (plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }

    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }

  return rstyle;
};

styfn$3.getPropsList = function (propsObj) {
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if (style) {
    var names = Object.keys(style);

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style[name];
      var prop = props[name] || props[camel2dash(name)];
      var styleProp = this.parse(prop.name, val);

      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }

  return rstyle;
};

styfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {
  var hash = seed;
  var name, val, strVal, chVal;
  var i, j;

  for (i = 0; i < propNames.length; i++) {
    name = propNames[i];
    val = ele.pstyle(name, false);

    if (val == null) {
      continue;
    } else if (val.pfValue != null) {
      hash = hashInt(chVal, hash);
    } else {
      strVal = val.strValue;

      for (j = 0; j < strVal.length; j++) {
        chVal = strVal.charCodeAt(j);
        hash = hashInt(chVal, hash);
      }
    }
  }

  return hash;
};

styfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;

var styfn$4 = {};

styfn$4.appendFromJson = function (json) {
  var style = this;

  for (var i = 0; i < json.length; i++) {
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);
    style.selector(selector); // apply selector

    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value = props[name];
      style.css(name, value); // apply property
    }
  }

  return style;
}; // accessible cy.style() function


styfn$4.fromJson = function (json) {
  var style = this;
  style.resetToDefault();
  style.appendFromJson(json);
  return style;
}; // get json from cy.style() api


styfn$4.json = function () {
  var json = [];

  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      css[prop.name] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

var styfn$5 = {};

styfn$5.appendFromString = function (string) {
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr; // remove comments from the style string

  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = '';
    }
  }

  for (;;) {
    var nothingLeftToParse = remaining.match(/^\s*$/);

    if (nothingLeftToParse) {
      break;
    }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if (!selAndBlock) {
      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0]; // parse the selector

    var selectorStr = selAndBlock[1];

    if (selectorStr !== 'core') {
      var selector = new Selector(selectorStr);

      if (selector.invalid) {
        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block

        removeSelAndBlockFromRemaining();
        continue;
      }
    } // parse the block of properties and values


    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    for (;;) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);

      if (_nothingLeftToParse) {
        break;
      }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if (!propAndVal) {
        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];
      var prop = self.properties[propStr];

      if (!prop) {
        warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse(propStr, valStr);

      if (!parsedProp) {
        warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    } // put the parsed block in the style


    style.selector(selectorStr);

    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style.css(_prop.name, _prop.val);
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn$5.fromString = function (string) {
  var style = this;
  style.resetToDefault();
  style.appendFromString(string);
  return style;
};

var styfn$6 = {};

(function () {
  var number = number$1;
  var rgba = rgbaNoBackRefs;
  var hsla = hslaNoBackRefs;
  var hex3$1 = hex3;
  var hex6$1 = hex6;

  var data = function data(prefix) {
    return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
  };

  var mapData = function mapData(prefix) {
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it

  styfn$6.types = {
    time: {
      number: true,
      min: 0,
      units: 's|ms',
      implicitUnits: 'ms'
    },
    percent: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%'
    },
    percentages: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%',
      multiple: true
    },
    zeroOneNumber: {
      number: true,
      min: 0,
      max: 1,
      unitless: true
    },
    zeroOneNumbers: {
      number: true,
      min: 0,
      max: 1,
      unitless: true,
      multiple: true
    },
    nOneOneNumber: {
      number: true,
      min: -1,
      max: 1,
      unitless: true
    },
    nonNegativeInt: {
      number: true,
      min: 0,
      integer: true,
      unitless: true
    },
    position: {
      enums: ['parent', 'origin']
    },
    nodeSize: {
      number: true,
      min: 0,
      enums: ['label']
    },
    number: {
      number: true,
      unitless: true
    },
    numbers: {
      number: true,
      unitless: true,
      multiple: true
    },
    positiveNumber: {
      number: true,
      unitless: true,
      min: 0,
      strictMin: true
    },
    size: {
      number: true,
      min: 0
    },
    bidirectionalSize: {
      number: true
    },
    // allows negative
    bidirectionalSizes: {
      number: true,
      multiple: true
    },
    // allows negative
    sizeMaybePercent: {
      number: true,
      min: 0,
      allowPercent: true
    },
    axisDirection: {
      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']
    },
    paddingRelativeTo: {
      enums: ['width', 'height', 'average', 'min', 'max']
    },
    bgWH: {
      number: true,
      min: 0,
      allowPercent: true,
      enums: ['auto'],
      multiple: true
    },
    bgPos: {
      number: true,
      allowPercent: true,
      multiple: true
    },
    bgRelativeTo: {
      enums: ['inner', 'include-padding'],
      multiple: true
    },
    bgRepeat: {
      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
      multiple: true
    },
    bgFit: {
      enums: ['none', 'contain', 'cover'],
      multiple: true
    },
    bgCrossOrigin: {
      enums: ['anonymous', 'use-credentials'],
      multiple: true
    },
    bgClip: {
      enums: ['none', 'node'],
      multiple: true
    },
    color: {
      color: true
    },
    colors: {
      color: true,
      multiple: true
    },
    fill: {
      enums: ['solid', 'linear-gradient', 'radial-gradient']
    },
    bool: {
      enums: ['yes', 'no']
    },
    lineStyle: {
      enums: ['solid', 'dotted', 'dashed']
    },
    lineCap: {
      enums: ['butt', 'round', 'square']
    },
    borderStyle: {
      enums: ['solid', 'dotted', 'dashed', 'double']
    },
    curveStyle: {
      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ['italic', 'normal', 'oblique']
    },
    fontWeight: {
      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ['none', 'underline', 'overline', 'line-through']
    },
    textTransform: {
      enums: ['none', 'uppercase', 'lowercase']
    },
    textWrap: {
      enums: ['none', 'wrap', 'ellipsis']
    },
    textOverflowWrap: {
      enums: ['whitespace', 'anywhere']
    },
    textBackgroundShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle']
    },
    nodeShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']
    },
    compoundIncludeLabels: {
      enums: ['include', 'exclude']
    },
    arrowShape: {
      enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']
    },
    arrowFill: {
      enums: ['filled', 'hollow']
    },
    display: {
      enums: ['element', 'none']
    },
    visibility: {
      enums: ['hidden', 'visible']
    },
    zCompoundDepth: {
      enums: ['bottom', 'orphan', 'auto', 'top']
    },
    zIndexCompare: {
      enums: ['auto', 'manual']
    },
    valign: {
      enums: ['top', 'center', 'bottom']
    },
    halign: {
      enums: ['left', 'center', 'right']
    },
    justification: {
      enums: ['left', 'center', 'right', 'auto']
    },
    text: {
      string: true
    },
    data: {
      mapping: true,
      regex: data('data')
    },
    layoutData: {
      mapping: true,
      regex: data('layoutData')
    },
    scratch: {
      mapping: true,
      regex: data('scratch')
    },
    mapData: {
      mapping: true,
      regex: mapData('mapData')
    },
    mapLayoutData: {
      mapping: true,
      regex: mapData('mapLayoutData')
    },
    mapScratch: {
      mapping: true,
      regex: mapData('mapScratch')
    },
    fn: {
      mapping: true,
      fn: true
    },
    url: {
      regexes: urlRegexes,
      singleRegexMatchValue: true
    },
    urls: {
      regexes: urlRegexes,
      singleRegexMatchValue: true,
      multiple: true
    },
    propList: {
      propList: true
    },
    angle: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad'
    },
    textRotation: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad',
      enums: ['none', 'autorotate']
    },
    polygonPointList: {
      number: true,
      multiple: true,
      evenMultiple: true,
      min: -1,
      max: 1,
      unitless: true
    },
    edgeDistances: {
      enums: ['intersection', 'node-position']
    },
    edgeEndpoint: {
      number: true,
      multiple: true,
      units: '%|px|em|deg|rad',
      implicitUnits: 'px',
      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],
      singleEnum: true,
      validate: function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';

          case 1:
            // can be enum, deg, or rad only
            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';

          default:
            return false;
        }
      }
    },
    easing: {
      regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
    },
    gradientDirection: {
      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']
    },
    boundsExpansion: {
      number: true,
      multiple: true,
      min: 0,
      validate: function validate(valArr) {
        var length = valArr.length;
        return length === 1 || length === 2 || length === 4;
      }
    }
  };
  var diff = {
    zeroNonZero: function zeroNonZero(val1, val2) {
      if ((val1 == null || val2 == null) && val1 !== val2) {
        return true; // null cases could represent any value
      }

      if (val1 == 0 && val2 != 0) {
        return true;
      } else if (val1 != 0 && val2 == 0) {
        return true;
      } else {
        return false;
      }
    },
    any: function any(val1, val2) {
      return val1 != val2;
    }
  }; // define visual style properties
  //
  // - n.b. adding a new group of props may require updates to updateStyleHints()
  // - adding new props to an existing group gets handled automatically

  var t = styfn$6.types;
  var mainLabel = [{
    name: 'label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }];
  var sourceLabel = [{
    name: 'source-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'source-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var targetLabel = [{
    name: 'target-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'target-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var labelDimensions = [{
    name: 'font-family',
    type: t.fontFamily,
    triggersBounds: diff.any
  }, {
    name: 'font-style',
    type: t.fontStyle,
    triggersBounds: diff.any
  }, {
    name: 'font-weight',
    type: t.fontWeight,
    triggersBounds: diff.any
  }, {
    name: 'font-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-transform',
    type: t.textTransform,
    triggersBounds: diff.any
  }, {
    name: 'text-wrap',
    type: t.textWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-overflow-wrap',
    type: t.textOverflowWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-max-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-outline-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'line-height',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }];
  var commonLabel = [{
    name: 'text-valign',
    type: t.valign,
    triggersBounds: diff.any
  }, {
    name: 'text-halign',
    type: t.halign,
    triggersBounds: diff.any
  }, {
    name: 'color',
    type: t.color
  }, {
    name: 'text-outline-color',
    type: t.color
  }, {
    name: 'text-outline-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-color',
    type: t.color
  }, {
    name: 'text-background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-border-color',
    type: t.color
  }, {
    name: 'text-border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-style',
    type: t.borderStyle,
    triggersBounds: diff.any
  }, {
    name: 'text-background-shape',
    type: t.textBackgroundShape,
    triggersBounds: diff.any
  }, {
    name: 'text-justification',
    type: t.justification
  }];
  var behavior = [{
    name: 'events',
    type: t.bool
  }, {
    name: 'text-events',
    type: t.bool
  }];
  var visibility = [{
    name: 'display',
    type: t.display,
    triggersZOrder: diff.any,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'visibility',
    type: t.visibility,
    triggersZOrder: diff.any
  }, {
    name: 'opacity',
    type: t.zeroOneNumber,
    triggersZOrder: diff.zeroNonZero
  }, {
    name: 'text-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'min-zoomed-font-size',
    type: t.size
  }, {
    name: 'z-compound-depth',
    type: t.zCompoundDepth,
    triggersZOrder: diff.any
  }, {
    name: 'z-index-compare',
    type: t.zIndexCompare,
    triggersZOrder: diff.any
  }, {
    name: 'z-index',
    type: t.nonNegativeInt,
    triggersZOrder: diff.any
  }];
  var overlay = [{
    name: 'overlay-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'overlay-color',
    type: t.color
  }, {
    name: 'overlay-opacity',
    type: t.zeroOneNumber,
    triggersBounds: diff.zeroNonZero
  }];
  var transition = [{
    name: 'transition-property',
    type: t.propList
  }, {
    name: 'transition-duration',
    type: t.time
  }, {
    name: 'transition-delay',
    type: t.time
  }, {
    name: 'transition-timing-function',
    type: t.easing
  }];

  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
    if (parsedProp.value === 'label') {
      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
    } else {
      return parsedProp.pfValue;
    }
  };

  var nodeBody = [{
    name: 'height',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'width',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'shape',
    type: t.nodeShape,
    triggersBounds: diff.any
  }, {
    name: 'shape-polygon-points',
    type: t.polygonPointList,
    triggersBounds: diff.any
  }, {
    name: 'background-color',
    type: t.color
  }, {
    name: 'background-fill',
    type: t.fill
  }, {
    name: 'background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'background-blacken',
    type: t.nOneOneNumber
  }, {
    name: 'background-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'background-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'background-gradient-direction',
    type: t.gradientDirection
  }, {
    name: 'padding',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'padding-relative-to',
    type: t.paddingRelativeTo,
    triggersBounds: diff.any
  }, {
    name: 'bounds-expansion',
    type: t.boundsExpansion,
    triggersBounds: diff.any
  }];
  var nodeBorder = [{
    name: 'border-color',
    type: t.color
  }, {
    name: 'border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'border-style',
    type: t.borderStyle
  }];
  var backgroundImage = [{
    name: 'background-image',
    type: t.urls
  }, {
    name: 'background-image-crossorigin',
    type: t.bgCrossOrigin
  }, {
    name: 'background-image-opacity',
    type: t.zeroOneNumbers
  }, {
    name: 'background-position-x',
    type: t.bgPos
  }, {
    name: 'background-position-y',
    type: t.bgPos
  }, {
    name: 'background-width-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-height-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-repeat',
    type: t.bgRepeat
  }, {
    name: 'background-fit',
    type: t.bgFit
  }, {
    name: 'background-clip',
    type: t.bgClip
  }, {
    name: 'background-width',
    type: t.bgWH
  }, {
    name: 'background-height',
    type: t.bgWH
  }, {
    name: 'background-offset-x',
    type: t.bgPos
  }, {
    name: 'background-offset-y',
    type: t.bgPos
  }];
  var compound = [{
    name: 'position',
    type: t.position,
    triggersBounds: diff.any
  }, {
    name: 'compound-sizing-wrt-labels',
    type: t.compoundIncludeLabels,
    triggersBounds: diff.any
  }, {
    name: 'min-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-left',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-right',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-top',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-bottom',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }];
  var edgeLine = [{
    name: 'line-style',
    type: t.lineStyle
  }, {
    name: 'line-color',
    type: t.color
  }, {
    name: 'line-fill',
    type: t.fill
  }, {
    name: 'line-cap',
    type: t.lineCap
  }, {
    name: 'line-dash-pattern',
    type: t.numbers
  }, {
    name: 'line-dash-offset',
    type: t.number
  }, {
    name: 'line-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'line-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'curve-style',
    type: t.curveStyle,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'haystack-radius',
    type: t.zeroOneNumber,
    triggersBounds: diff.any
  }, {
    name: 'source-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'target-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'control-point-step-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'control-point-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'control-point-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'segment-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'segment-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn-min-distance',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'taxi-direction',
    type: t.axisDirection,
    triggersBounds: diff.any
  }, {
    name: 'edge-distances',
    type: t.edgeDistances,
    triggersBounds: diff.any
  }, {
    name: 'arrow-scale',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }, {
    name: 'loop-direction',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'loop-sweep',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'source-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'target-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }];
  var ghost = [{
    name: 'ghost',
    type: t.bool,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-opacity',
    type: t.zeroOneNumber
  }];
  var core = [{
    name: 'selection-box-color',
    type: t.color
  }, {
    name: 'selection-box-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'selection-box-border-color',
    type: t.color
  }, {
    name: 'selection-box-border-width',
    type: t.size
  }, {
    name: 'active-bg-color',
    type: t.color
  }, {
    name: 'active-bg-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'active-bg-size',
    type: t.size
  }, {
    name: 'outside-texture-bg-color',
    type: t.color
  }, {
    name: 'outside-texture-bg-opacity',
    type: t.zeroOneNumber
  }]; // pie backgrounds for nodes

  var pie = [];
  styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)

  pie.push({
    name: 'pie-size',
    type: t.sizeMaybePercent
  });

  for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
    pie.push({
      name: 'pie-' + i + '-background-color',
      type: t.color
    });
    pie.push({
      name: 'pie-' + i + '-background-size',
      type: t.percent
    });
    pie.push({
      name: 'pie-' + i + '-background-opacity',
      type: t.zeroOneNumber
    });
  } // edge arrows


  var edgeArrow = [];
  var arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [{
    name: 'arrow-shape',
    type: t.arrowShape,
    triggersBounds: diff.any
  }, {
    name: 'arrow-color',
    type: t.color
  }, {
    name: 'arrow-fill',
    type: t.arrowFill
  }].forEach(function (prop) {
    arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var type = prop.type,
          triggersBounds = prop.triggersBounds;
      edgeArrow.push({
        name: name,
        type: type,
        triggersBounds: triggersBounds
      });
    });
  }, {});
  var props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
  var propGroups = styfn$6.propertyGroups = {
    // common to all eles
    behavior: behavior,
    transition: transition,
    visibility: visibility,
    overlay: overlay,
    ghost: ghost,
    // labels
    commonLabel: commonLabel,
    labelDimensions: labelDimensions,
    mainLabel: mainLabel,
    sourceLabel: sourceLabel,
    targetLabel: targetLabel,
    // node props
    nodeBody: nodeBody,
    nodeBorder: nodeBorder,
    backgroundImage: backgroundImage,
    pie: pie,
    compound: compound,
    // edge props
    edgeLine: edgeLine,
    edgeArrow: edgeArrow,
    core: core
  };
  var propGroupNames = styfn$6.propertyGroupNames = {};
  var propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);
  propGroupKeys.forEach(function (key) {
    propGroupNames[key] = propGroups[key].map(function (prop) {
      return prop.name;
    });
    propGroups[key].forEach(function (prop) {
      return prop.groupKey = key;
    });
  }); // define aliases

  var aliases = styfn$6.aliases = [{
    name: 'content',
    pointsTo: 'label'
  }, {
    name: 'control-point-distance',
    pointsTo: 'control-point-distances'
  }, {
    name: 'control-point-weight',
    pointsTo: 'control-point-weights'
  }, {
    name: 'edge-text-rotation',
    pointsTo: 'text-rotation'
  }, {
    name: 'padding-left',
    pointsTo: 'padding'
  }, {
    name: 'padding-right',
    pointsTo: 'padding'
  }, {
    name: 'padding-top',
    pointsTo: 'padding'
  }, {
    name: 'padding-bottom',
    pointsTo: 'padding'
  }]; // list of property names

  styfn$6.propertyNames = props.map(function (p) {
    return p.name;
  }); // allow access of properties by name ( e.g. style.properties.height )

  for (var _i = 0; _i < props.length; _i++) {
    var prop = props[_i];
    props[prop.name] = prop; // allow lookup by name
  } // map aliases


  for (var _i2 = 0; _i2 < aliases.length; _i2++) {
    var alias = aliases[_i2];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    }; // add alias prop for parsing

    props.push(aliasProp);
    props[alias.name] = aliasProp; // allow lookup by name
  }
})();

styfn$6.getDefaultProperty = function (name) {
  return this.getDefaultProperties()[name];
};

styfn$6.getDefaultProperties = function () {
  var _p = this._private;

  if (_p.defaultProperties != null) {
    return _p.defaultProperties;
  }

  var rawProps = extend({
    // core props
    'selection-box-color': '#ddd',
    'selection-box-opacity': 0.65,
    'selection-box-border-color': '#aaa',
    'selection-box-border-width': 1,
    'active-bg-color': 'black',
    'active-bg-opacity': 0.15,
    'active-bg-size': 30,
    'outside-texture-bg-color': '#000',
    'outside-texture-bg-opacity': 0.125,
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'text-justification': 'auto',
    'line-height': 1,
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-overflow-wrap': 'whitespace',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',
    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-fill': 'solid',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-offset-x': 0,
    'background-offset-y': 0,
    'background-width-relative-to': 'include-padding',
    'background-height-relative-to': 'include-padding',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
    'bounds-expansion': 0,
    // node gradient
    'background-gradient-direction': 'to-bottom',
    'background-gradient-stop-colors': '#999',
    'background-gradient-stop-positions': '0%',
    // ghost props
    'ghost': 'no',
    'ghost-offset-y': 0,
    'ghost-offset-x': 0,
    'ghost-opacity': 0,
    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [{
    name: 'pie-{{i}}-background-color',
    value: 'black'
  }, {
    name: 'pie-{{i}}-background-size',
    value: '0%'
  }, {
    name: 'pie-{{i}}-background-opacity',
    value: 1
  }].reduce(function (css, prop) {
    for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
      var name = prop.name.replace('{{i}}', i);
      var val = prop.value;
      css[name] = val;
    }

    return css;
  }, {}), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'line-fill': 'solid',
    'line-cap': 'butt',
    'line-gradient-stop-colors': '#999',
    'line-gradient-stop-positions': '0%',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'taxi-turn': '50%',
    'taxi-turn-min-distance': 10,
    'taxi-direction': 'auto',
    'edge-distances': 'intersection',
    'curve-style': 'haystack',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-45deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node',
    'line-dash-pattern': [6, 3],
    'line-dash-offset': 0
  }, [{
    name: 'arrow-shape',
    value: 'none'
  }, {
    name: 'arrow-color',
    value: '#999'
  }, {
    name: 'arrow-fill',
    value: 'filled'
  }].reduce(function (css, prop) {
    styfn$6.arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var val = prop.value;
      css[name] = val;
    });
    return css;
  }, {}));
  var parsedProps = {};

  for (var i = 0; i < this.properties.length; i++) {
    var prop = this.properties[i];

    if (prop.pointsTo) {
      continue;
    }

    var name = prop.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);
    parsedProps[name] = parsedProp;
  }

  _p.defaultProperties = parsedProps;
  return _p.defaultProperties;
};

styfn$6.addDefaultStylesheet = function () {
  this.selector(':parent').css({
    'shape': 'rectangle',
    'padding': 10,
    'background-color': '#eee',
    'border-color': '#ccc',
    'border-width': 1
  }).selector('edge').css({
    'width': 3
  }).selector(':loop').css({
    'curve-style': 'bezier'
  }).selector('edge:compound').css({
    'curve-style': 'bezier',
    'source-endpoint': 'outside-to-line',
    'target-endpoint': 'outside-to-line'
  }).selector(':selected').css({
    'background-color': '#0169D9',
    'line-color': '#0169D9',
    'source-arrow-color': '#0169D9',
    'target-arrow-color': '#0169D9',
    'mid-source-arrow-color': '#0169D9',
    'mid-target-arrow-color': '#0169D9'
  }).selector(':parent:selected').css({
    'background-color': '#CCE1F9',
    'border-color': '#aec8e5'
  }).selector(':active').css({
    'overlay-color': 'black',
    'overlay-padding': 10,
    'overlay-opacity': 0.25
  });
  this.defaultLength = this.length;
};

var styfn$7 = {}; // a caching layer for property parsing

styfn$7.parse = function (name, value, propIsBypass, propIsFlat) {
  var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway

  if (fn(value)) {
    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
  var bypassKey = propIsBypass ? 't' : 'f';
  var valueKey = '' + value;
  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
  var propCache = self.propCache = self.propCache || [];
  var ret;

  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element


  if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
    ret = copy(ret);

    if (ret) {
      ret.value = copy(ret.value); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

  if (!prop && value != null) {
    warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
  }

  return prop;
}; // parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property


styfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {
  var self = this;
  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[name];
  var passedValue = value;
  var types = self.types;

  if (!property) {
    return null;
  } // return null on property of unknown name


  if (value === undefined) {
    return null;
  } // can't assign undefined
  // the property may be an alias


  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = string(value);

  if (valueIsString) {
    // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;

  if (!type) {
    return null;
  } // no type, no luck
  // check if bypass is null or empty string (i.e. indication to delete bypass property)


  if (propIsBypass && (value === '' || value === null)) {
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  } // check if value is a function used as a mapper


  if (fn(value)) {
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  } // check if value is mapped


  var data, mapData;

  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    var mapped = types.data;
    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };
  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    if (type.multiple) {
      return false;
    } // impossible to map to num


    var _mapped = types.mapData; // we can map only if the type is a colour or a number

    if (!(type.color || type.number)) {
      return false;
    }

    var valueMin = this.parse(name, mapData[4]); // parse to validate

    if (!valueMin || valueMin.mapped) {
      return false;
    } // can't be invalid or mapped


    var valueMax = this.parse(name, mapData[5]); // parse to validate

    if (!valueMax || valueMax.mapped) {
      return false;
    } // can't be invalid or mapped
    // check if valueMin and valueMax are the same


    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');
      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;
      var same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
      c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
      c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

      if (same) {
        return false;
      } // can't make a mapper without a range

    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]),
      // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if (type.multiple && propIsFlat !== 'multiple') {
    var vals;

    if (valueIsString) {
      vals = value.split(/\s+/);
    } else if (array(value)) {
      vals = value;
    } else {
      vals = [value];
    }

    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var strVal = '';
    var hasEnum = false;

    for (var i = 0; i < vals.length; i++) {
      var p = self.parse(name, vals[i], propIsBypass, 'multiple');
      hasEnum = hasEnum || string(p.value);
      valArr.push(p.value);
      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
      unitsArr.push(p.units);
      strVal += (i > 0 ? ' ' : '') + p.strValue;
    }

    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }

    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && string(valArr[0])) {
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: strVal,
      bypass: propIsBypass,
      units: unitsArr
    };
  } // several types also allow enums


  var checkEnums = function checkEnums() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];

      if (en === value) {
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  }; // check the type and return the appropriate object


  if (type.number) {
    var units;
    var implicitUnits = 'px'; // not set => px

    if (type.units) {
      // use specified units if set
      units = type.units;
    }

    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }

    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');

        if (units) {
          unitsRegex = units;
        } // only allow explicit units if so set


        var match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');

        if (match) {
          value = match[1];
          units = match[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid

    if (isNaN(value) && type.enums === undefined) {
      return null;
    } // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)


    if (isNaN(value) && type.enums !== undefined) {
      value = passedValue;
      return checkEnums();
    } // check if value must be an integer


    if (type.integer && !integer(value)) {
      return null;
    } // check value is within range


    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    }; // normalise value in pixels

    if (type.unitless || units !== 'px' && units !== 'em') {
      ret.pfValue = value;
    } else {
      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
    } // normalise value in ms


    if (units === 'ms' || units === 's') {
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    } // normalise value in rad


    if (units === 'deg' || units === 'rad') {
      ret.pfValue = units === 'rad' ? value : deg2rad(value);
    } // normalize value in %


    if (units === '%') {
      ret.pfValue = value / 100;
    }

    return ret;
  } else if (type.propList) {
    var props = [];
    var propsStr = '' + value;

    if (propsStr === 'none') ; else {
      // go over each prop
      var propsSplit = propsStr.split(/\s*,\s*|\s+/);

      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();

        if (self.properties[propName]) {
          props.push(propName);
        } else {
          warn('`' + propName + '` is not a valid property name');
        }
      }

      if (props.length === 0) {
        return null;
      }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(' '),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple = color2tuple(value);

    if (!tuple) {
      return null;
    }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',
      // n.b. no spaces b/c of multiple support
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {
    // first check enums
    if (type.enums) {
      var enumProp = checkEnums();

      if (enumProp) {
        return enumProp;
      }
    }

    var regexes = type.regexes ? type.regexes : [type.regex];

    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex = new RegExp(regexes[_i3]); // make a regex from the type string

      var m = regex.exec(value);

      if (m) {
        // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null; // didn't match any
  } else if (type.string) {
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    // check enums last because it's a combo type in others
    return checkEnums();
  } else {
    return null; // not a type we can handle
  }
};

var Style = function Style(cy) {
  if (!(this instanceof Style)) {
    return new Style(cy);
  }

  if (!core(cy)) {
    error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };
  this.length = 0;
  this.resetToDefault();
};

var styfn$8 = Style.prototype;

styfn$8.instanceString = function () {
  return 'style';
}; // remove all contexts


styfn$8.clear = function () {
  for (var i = 0; i < this.length; i++) {
    this[i] = undefined;
  }

  this.length = 0;
  var _p = this._private;
  _p.newStyle = true;
  return this; // chaining
};

styfn$8.resetToDefault = function () {
  this.clear();
  this.addDefaultStylesheet();
  return this;
}; // builds a style object for the 'core' selector


styfn$8.core = function (propName) {
  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
}; // create a new context from the specified selector string and switch to that context


styfn$8.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);
  var i = this.length++; // new context means new index

  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };
  return this; // chaining
}; // add one or many css rules to the current context


styfn$8.css = function () {
  var self = this;
  var args = arguments;

  if (args.length === 1) {
    var map = args[0];

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var mapVal = map[prop.name];

      if (mapVal === undefined) {
        mapVal = map[dash2camel(prop.name)];
      }

      if (mapVal !== undefined) {
        this.cssRule(prop.name, mapVal);
      }
    }
  } else if (args.length === 2) {
    this.cssRule(args[0], args[1]);
  } // do nothing if args are invalid


  return this; // chaining
};

styfn$8.style = styfn$8.css; // add a single css rule to the current context

styfn$8.cssRule = function (name, value) {
  // name-value pair
  var property = this.parse(name, value); // add property to current context if valid

  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property; // allow access by name as well

    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }

    if (property.mapped) {
      this[i].mappedProperties.push(property);
    } // add to core style if necessary


    var currentSelectorIsCore = !this[i].selector;

    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }

  return this; // chaining
};

styfn$8.append = function (style) {
  if (stylesheet(style)) {
    style.appendToStyle(this);
  } else if (array(style)) {
    this.appendFromJson(style);
  } else if (string(style)) {
    this.appendFromString(style);
  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts


  return this;
}; // static function


Style.fromJson = function (cy, json) {
  var style = new Style(cy);
  style.fromJson(json);
  return style;
};

Style.fromString = function (cy, string) {
  return new Style(cy).fromString(string);
};

[styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {
  extend(styfn$8, props);
});
Style.types = styfn$8.types;
Style.properties = styfn$8.properties;
Style.propertyGroups = styfn$8.propertyGroups;
Style.propertyGroupNames = styfn$8.propertyGroupNames;
Style.propertyGroupKeys = styfn$8.propertyGroupKeys;

var corefn$7 = {
  style: function style(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);
      s.update();
    }

    return this._private.style;
  },
  setStyle: function setStyle(style) {
    var _p = this._private;

    if (stylesheet(style)) {
      _p.style = style.generateStyle(this);
    } else if (array(style)) {
      _p.style = Style.fromJson(this, style);
    } else if (string(style)) {
      _p.style = Style.fromString(this, style);
    } else {
      _p.style = Style(this);
    }

    return _p.style;
  }
};

var defaultSelectionType = 'single';
var corefn$8 = {
  autolock: function autolock(bool) {
    if (bool !== undefined) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },
  autoungrabify: function autoungrabify(bool) {
    if (bool !== undefined) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },
  autounselectify: function autounselectify(bool) {
    if (bool !== undefined) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },
  selectionType: function selectionType(selType) {
    var _p = this._private;

    if (_p.selectionType == null) {
      _p.selectionType = defaultSelectionType;
    }

    if (selType !== undefined) {
      if (selType === 'additive' || selType === 'single') {
        _p.selectionType = selType;
      }
    } else {
      return _p.selectionType;
    }

    return this;
  },
  panningEnabled: function panningEnabled(bool) {
    if (bool !== undefined) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },
  userPanningEnabled: function userPanningEnabled(bool) {
    if (bool !== undefined) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },
  zoomingEnabled: function zoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },
  userZoomingEnabled: function userZoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },
  boxSelectionEnabled: function boxSelectionEnabled(bool) {
    if (bool !== undefined) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },
  pan: function pan() {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch (args.length) {
      case 0:
        // .pan()
        return pan;

      case 1:
        if (string(args[0])) {
          // .pan('x')
          dim = args[0];
          return pan[dim];
        } else if (plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
          if (!this._private.panningEnabled) {
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x = x;
          }

          if (number(y)) {
            pan.y = y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .pan('x', 100)
        if (!this._private.panningEnabled) {
          return this;
        }

        dim = args[0];
        val = args[1];

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] = val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  panBy: function panBy(arg0, arg1) {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if (!this._private.panningEnabled) {
      return this;
    }

    switch (args.length) {
      case 1:
        if (plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x += x;
          }

          if (number(y)) {
            pan.y += y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .panBy('x', 100)
        dim = arg0;
        val = arg1;

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] += val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  fit: function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);

    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;
      this.emit('pan zoom viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getFitViewport: function getFitViewport(elements, padding) {
    if (number(elements) && padding === undefined) {
      // elements is optional
      padding = elements;
      elements = undefined;
    }

    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }

    var bb;

    if (string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (boundingBox(elements)) {
      // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elementOrCollection(elements) && elements.empty()) {
      return;
    } // can't fit to nothing


    bb = bb || elements.boundingBox();
    var w = this.width();
    var h = this.height();
    var zoom;
    padding = number(padding) ? padding : 0;

    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom

      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
      var pan = {
        // now pan to middle
        x: (w - zoom * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom * (bb.y1 + bb.y2)) / 2
      };
      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },
  zoomRange: function zoomRange(min, max) {
    var _p = this._private;

    if (max == null) {
      var opts = min;
      min = opts.min;
      max = opts.max;
    }

    if (number(min) && number(max) && min <= max) {
      _p.minZoom = min;
      _p.maxZoom = max;
    } else if (number(min) && max === undefined && min <= _p.maxZoom) {
      _p.minZoom = min;
    } else if (number(max) && min === undefined && max >= _p.minZoom) {
      _p.maxZoom = max;
    }

    return this;
  },
  minZoom: function minZoom(zoom) {
    if (zoom === undefined) {
      return this._private.minZoom;
    } else {
      return this.zoomRange({
        min: zoom
      });
    }
  },
  maxZoom: function maxZoom(zoom) {
    if (zoom === undefined) {
      return this._private.maxZoom;
    } else {
      return this.zoomRange({
        max: zoom
      });
    }
  },
  getZoomedViewport: function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos; // in rendered px

    var zoom;
    var bail = false;

    if (!_p.zoomingEnabled) {
      // zooming disabled
      bail = true;
    }

    if (number(params)) {
      // then set the zoom
      zoom = params;
    } else if (plainObject(params)) {
      // then zoom about a point
      zoom = params.level;

      if (params.position != null) {
        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }

      if (pos != null && !_p.panningEnabled) {
        // panning disabled
        bail = true;
      }
    } // crop zoom


    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
    zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params

    if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {
      return null;
    }

    if (pos != null) {
      // set zoom about position
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom2 = zoom;
      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };
      return {
        zoomed: true,
        panned: true,
        zoom: zoom2,
        pan: pan2
      };
    } else {
      // just set the zoom
      return {
        zoomed: true,
        panned: false,
        zoom: zoom,
        pan: currentPan
      };
    }
  },
  zoom: function zoom(params) {
    if (params === undefined) {
      // get
      return this._private.zoom;
    } else {
      // set
      var vp = this.getZoomedViewport(params);
      var _p = this._private;

      if (vp == null || !vp.zoomed) {
        return this;
      }

      _p.zoom = vp.zoom;

      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }

      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');
      this.notify('viewport');
      return this; // chaining
    }
  },
  viewport: function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger

    var zoomFailed = false;
    var panFailed = false;

    if (!opts) {
      return this;
    }

    if (!number(opts.zoom)) {
      zoomDefd = false;
    }

    if (!plainObject(opts.pan)) {
      panDefd = false;
    }

    if (!zoomDefd && !panDefd) {
      return this;
    }

    if (zoomDefd) {
      var z = opts.zoom;

      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;
        events.push('zoom');
      }
    }

    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p = opts.pan;

      if (number(p.x)) {
        _p.pan.x = p.x;
        panFailed = false;
      }

      if (number(p.y)) {
        _p.pan.y = p.y;
        panFailed = false;
      }

      if (!panFailed) {
        events.push('pan');
      }
    }

    if (events.length > 0) {
      events.push('viewport');
      this.emit(events.join(' '));
      this.notify('viewport');
    }

    return this; // chaining
  },
  center: function center(elements) {
    var pan = this.getCenterPan(elements);

    if (pan) {
      this._private.pan = pan;
      this.emit('pan viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getCenterPan: function getCenterPan(elements, zoom) {
    if (!this._private.panningEnabled) {
      return;
    }

    if (string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elements.length === 0) {
      return;
    } // can't centre pan to nothing


    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;
    var pan = {
      // middle
      x: (w - zoom * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom * (bb.y1 + bb.y2)) / 2
    };
    return pan;
  },
  reset: function reset() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }

    this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    });
    return this; // chaining
  },
  invalidateSize: function invalidateSize() {
    this._private.sizeCache = null;
  },
  size: function size() {
    var _p = this._private;
    var container = _p.container;
    return _p.sizeCache = _p.sizeCache || (container ? function () {
      var style = window$1.getComputedStyle(container);

      var val = function val(name) {
        return parseFloat(style.getPropertyValue(name));
      };

      return {
        width: container.clientWidth - val('padding-left') - val('padding-right'),
        height: container.clientHeight - val('padding-top') - val('padding-bottom')
      };
    }() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function width() {
    return this.size().width;
  },
  height: function height() {
    return this.size().height;
  },
  extent: function extent() {
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();
    var b = {
      x1: (rb.x1 - pan.x) / zoom,
      x2: (rb.x2 - pan.x) / zoom,
      y1: (rb.y1 - pan.y) / zoom,
      y2: (rb.y2 - pan.y) / zoom
    };
    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;
    return b;
  },
  renderedExtent: function renderedExtent() {
    var width = this.width();
    var height = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
}; // aliases

corefn$8.centre = corefn$8.center; // backwards compatibility

corefn$8.autolockNodes = corefn$8.autolock;
corefn$8.autoungrabifyNodes = corefn$8.autoungrabify;

var fn$6 = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })
}; // aliases

fn$6.attr = fn$6.data;
fn$6.removeAttr = fn$6.removeData;

var Core = function Core(opts) {
  var cy = this;
  opts = extend({}, opts);
  var container = opts.container; // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })

  if (container && !htmlElement(container) && htmlElement(container[0])) {
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery

  reg = reg || {};

  if (reg && reg.cy) {
    reg.cy.destroy();
    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if (container) {
    container._cyreg = reg;
  } // make sure container assoc'd reg points to this cy


  reg.cy = cy;
  var head = window$1 !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = extend({
    name: head ? 'grid' : 'null'
  }, options.layout);
  options.renderer = extend({
    name: head ? 'canvas' : 'null'
  }, options.renderer);

  var defVal = function defVal(def, val, altVal) {
    if (val !== undefined) {
      return val;
    } else if (altVal !== undefined) {
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container,
    // html dom ele container
    ready: false,
    // whether ready has been triggered
    options: options,
    // cached options
    elements: new Collection(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new Collection(this),
    // elements being animated
    data: {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false,
    // whether destroy was called
    notificationsEnabled: true,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: number(options.zoom) ? options.zoom : 1,
    pan: {
      x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,
      y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  this.createEmitter(); // set selection type

  this.selectionType(options.selectionType); // init zoom bounds

  this.zoomRange({
    min: options.minZoom,
    max: options.maxZoom
  });

  var loadExtData = function loadExtData(extData, next) {
    var anyIsPromise = extData.some(promise);

    if (anyIsPromise) {
      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
    } else {
      next(extData); // exec synchronously for convenience
    }
  }; // start with the default stylesheet so we have something before loading an external stylesheet


  if (_p.styleEnabled) {
    cy.setStyle([]);
  } // create the renderer


  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options

  cy.initRenderer(rendererOptions);

  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
    cy.notifications(false); // remove old elements

    var oldEles = cy.mutableElements();

    if (oldEles.length > 0) {
      oldEles.remove();
    }

    if (elements != null) {
      if (plainObject(elements) || array(elements)) {
        cy.add(elements);
      }
    }

    cy.one('layoutready', function (e) {
      cy.notifications(true);
      cy.emit(e); // we missed this event by turning notifications off, so pass it on

      cy.one('load', onload);
      cy.emitAndNotify('load');
    }).one('layoutstop', function () {
      cy.one('done', ondone);
      cy.emit('done');
    });
    var layoutOpts = extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();
    cy.layout(layoutOpts).run();
  };

  loadExtData([options.style, options.elements], function (thens) {
    var initStyle = thens[0];
    var initEles = thens[1]; // init style

    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    } // initial load


    setElesAndLayout(initEles, function () {
      // onready
      cy.startAnimationLoop();
      _p.ready = true; // if a ready callback is specified as an option, the bind it

      if (fn(options.ready)) {
        cy.on('ready', options.ready);
      } // bind all the ready handlers registered before creating this instance


      for (var i = 0; i < readies.length; i++) {
        var fn$1 = readies[i];
        cy.on('ready', fn$1);
      }

      if (reg) {
        reg.readies = [];
      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc


      cy.emit('ready');
    }, options.done);
  });
};

var corefn$9 = Core.prototype; // short alias

extend(corefn$9, {
  instanceString: function instanceString() {
    return 'core';
  },
  isReady: function isReady() {
    return this._private.ready;
  },
  destroyed: function destroyed() {
    return this._private.destroyed;
  },
  ready: function ready(fn) {
    if (this.isReady()) {
      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },
  destroy: function destroy() {
    var cy = this;
    if (cy.destroyed()) return;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    this.emit('destroy');
    cy._private.destroyed = true;
    return cy;
  },
  hasElementWithId: function hasElementWithId(id) {
    return this._private.elements.hasElementWithId(id);
  },
  getElementById: function getElementById(id) {
    return this._private.elements.getElementById(id);
  },
  hasCompoundNodes: function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  },
  headless: function headless() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function styleEnabled() {
    return this._private.styleEnabled;
  },
  addToPool: function addToPool(eles) {
    this._private.elements.merge(eles);

    return this; // chaining
  },
  removeFromPool: function removeFromPool(eles) {
    this._private.elements.unmerge(eles);

    return this;
  },
  container: function container() {
    return this._private.container || null;
  },
  mount: function mount(container) {
    if (container == null) {
      return;
    }

    var cy = this;
    var _p = cy._private;
    var options = _p.options;

    if (!htmlElement(container) && htmlElement(container[0])) {
      container = container[0];
    }

    cy.stopAnimationLoop();
    cy.destroyRenderer();
    _p.container = container;
    _p.styleEnabled = true;
    cy.invalidateSize();
    cy.initRenderer(extend({}, options, options.renderer, {
      // allow custom renderer name to be re-used, otherwise use canvas
      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name
    }));
    cy.startAnimationLoop();
    cy.style(options.style);
    cy.emit('mount');
    return cy;
  },
  unmount: function unmount() {
    var cy = this;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    cy.initRenderer({
      name: 'null'
    });
    cy.emit('unmount');
    return cy;
  },
  options: function options() {
    return copy(this._private.options);
  },
  json: function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    var getFreshRef = function getFreshRef(ele) {
      return cy.getElementById(ele.id());
    };

    if (plainObject(obj)) {
      // set
      cy.startBatch();

      if (obj.elements) {
        var idInJson = {};

        var updateEles = function updateEles(jsons, gr) {
          var toAdd = [];
          var toMod = [];

          for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            var id = '' + json.data.id; // id must be string

            var ele = cy.getElementById(id);
            idInJson[id] = true;

            if (ele.length !== 0) {
              // existing element should be updated
              toMod.push({
                ele: ele,
                json: json
              });
            } else {
              // otherwise should be added
              if (gr) {
                json.group = gr;
                toAdd.push(json);
              } else {
                toAdd.push(json);
              }
            }
          }

          cy.add(toAdd);

          for (var _i = 0; _i < toMod.length; _i++) {
            var _toMod$_i = toMod[_i],
                _ele = _toMod$_i.ele,
                _json = _toMod$_i.json;

            _ele.json(_json);
          }
        };

        if (array(obj.elements)) {
          // elements: []
          updateEles(obj.elements);
        } else {
          // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];

          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];

            if (array(elements)) {
              updateEles(elements, gr);
            }
          }
        }

        var parentsToRemove = cy.collection();
        eles.filter(function (ele) {
          return !idInJson[ele.id()];
        }).forEach(function (ele) {
          if (ele.isParent()) {
            parentsToRemove.merge(ele);
          } else {
            ele.remove();
          }
        }); // so that children are not removed w/parent

        parentsToRemove.forEach(function (ele) {
          return ele.children().move({
            parent: null
          });
        }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs

        parentsToRemove.forEach(function (ele) {
          return getFreshRef(ele).remove();
        });
      }

      if (obj.style) {
        cy.style(obj.style);
      }

      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }

      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }

      if (obj.data) {
        cy.data(obj.data);
      }

      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

      for (var _i2 = 0; _i2 < fields.length; _i2++) {
        var f = fields[_i2];

        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }

      cy.endBatch();
      return this; // chaining
    } else {
      // get
      var flat = !!obj;
      var json = {};

      if (flat) {
        json.elements = this.elements().map(function (ele) {
          return ele.json();
        });
      } else {
        json.elements = {};
        eles.forEach(function (ele) {
          var group = ele.group();

          if (!json.elements[group]) {
            json.elements[group] = [];
          }

          json.elements[group].push(ele.json());
        });
      }

      if (this._private.styleEnabled) {
        json.style = cy.style().json();
      }

      json.data = copy(cy.data());
      var options = _p.options;
      json.zoomingEnabled = _p.zoomingEnabled;
      json.userZoomingEnabled = _p.userZoomingEnabled;
      json.zoom = _p.zoom;
      json.minZoom = _p.minZoom;
      json.maxZoom = _p.maxZoom;
      json.panningEnabled = _p.panningEnabled;
      json.userPanningEnabled = _p.userPanningEnabled;
      json.pan = copy(_p.pan);
      json.boxSelectionEnabled = _p.boxSelectionEnabled;
      json.renderer = copy(options.renderer);
      json.hideEdgesOnViewport = options.hideEdgesOnViewport;
      json.textureOnViewport = options.textureOnViewport;
      json.wheelSensitivity = options.wheelSensitivity;
      json.motionBlur = options.motionBlur;
      return json;
    }
  }
});
corefn$9.$id = corefn$9.getElementById;
[corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {
  extend(corefn$9, props);
});

/* eslint-disable no-unused-vars */

var defaults$9 = {
  fit: true,
  // whether to fit the viewport to the graph
  directed: false,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30,
  // padding on fit
  circle: false,
  // put depths in concentric circles if true, put depths top down if false
  grid: false,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: undefined,
  // the roots of the trees
  maximal: false,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled,
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};
/* eslint-enable */

var getInfo = function getInfo(ele) {
  return ele.scratch('breadthfirst');
};

var setInfo = function setInfo(ele, obj) {
  return ele.scratch('breadthfirst', obj);
};

function BreadthFirstLayout(options) {
  this.options = extend({}, defaults$9, options);
}

BreadthFirstLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().filter(function (n) {
    return !n.isParent();
  });
  var graph = eles;
  var directed = options.directed;
  var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var roots;

  if (elementOrCollection(options.roots)) {
    roots = options.roots;
  } else if (array(options.roots)) {
    var rootsArray = [];

    for (var i = 0; i < options.roots.length; i++) {
      var id = options.roots[i];
      var ele = cy.getElementById(id);
      rootsArray.push(ele);
    }

    roots = cy.collection(rootsArray);
  } else if (string(options.roots)) {
    roots = cy.$(options.roots);
  } else {
    if (directed) {
      roots = nodes.roots();
    } else {
      var components = eles.components();
      roots = cy.collection();

      var _loop = function _loop(_i) {
        var comp = components[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function (ele) {
          return ele.degree(false) === maxDegree;
        });
        roots = roots.add(compRoots);
      };

      for (var _i = 0; _i < components.length; _i++) {
        _loop(_i);
      }
    }
  }

  var depths = [];
  var foundByBfs = {};

  var addToDepth = function addToDepth(ele, d) {
    if (depths[d] == null) {
      depths[d] = [];
    }

    var i = depths[d].length;
    depths[d].push(ele);
    setInfo(ele, {
      index: i,
      depth: d
    });
  };

  var changeDepth = function changeDepth(ele, newDepth) {
    var _getInfo = getInfo(ele),
        depth = _getInfo.depth,
        index = _getInfo.index;

    depths[depth][index] = null;
    addToDepth(ele, newDepth);
  }; // find the depths of the nodes


  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function visit(node, edge, pNode, i, depth) {
      var ele = node[0];
      var id = ele.id();
      addToDepth(ele, depth);
      foundByBfs[id] = true;
    }
  }); // check for nodes not found by bfs

  var orphanNodes = [];

  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _ele = nodes[_i2];

    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  } // assign the nodes a depth and index


  var assignDepthsAt = function assignDepthsAt(i) {
    var eles = depths[i];

    for (var j = 0; j < eles.length; j++) {
      var _ele2 = eles[j];

      if (_ele2 == null) {
        eles.splice(j, 1);
        j--;
        continue;
      }

      setInfo(_ele2, {
        depth: i,
        index: j
      });
    }
  };

  var assignDepths = function assignDepths() {
    for (var _i3 = 0; _i3 < depths.length; _i3++) {
      assignDepthsAt(_i3);
    }
  };

  var adjustMaximally = function adjustMaximally(ele, shifted) {
    var eInfo = getInfo(ele);
    var incomers = ele.incomers().filter(function (el) {
      return el.isNode() && eles.has(el);
    });
    var maxDepth = -1;
    var id = ele.id();

    for (var k = 0; k < incomers.length; k++) {
      var incmr = incomers[k];
      var iInfo = getInfo(incmr);
      maxDepth = Math.max(maxDepth, iInfo.depth);
    }

    if (eInfo.depth <= maxDepth) {
      if (shifted[id]) {
        return null;
      }

      changeDepth(ele, maxDepth + 1);
      shifted[id] = true;
      return true;
    }

    return false;
  }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)


  if (directed && maximal) {
    var Q = [];
    var shifted = {};

    var enqueue = function enqueue(n) {
      return Q.push(n);
    };

    var dequeue = function dequeue() {
      return Q.shift();
    };

    nodes.forEach(function (n) {
      return Q.push(n);
    });

    while (Q.length > 0) {
      var _ele3 = dequeue();

      var didShift = adjustMaximally(_ele3, shifted);

      if (didShift) {
        _ele3.outgoers().filter(function (el) {
          return el.isNode() && eles.has(el);
        }).forEach(enqueue);
      } else if (didShift === null) {
        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');
        break; // exit on failure
      }
    }
  }

  assignDepths(); // clear holes
  // find min distance we need to leave between nodes

  var minDistance = 0;

  if (options.avoidOverlap) {
    for (var _i4 = 0; _i4 < nodes.length; _i4++) {
      var n = nodes[_i4];
      var nbb = n.layoutDimensions(options);
      var w = nbb.w;
      var h = nbb.h;
      minDistance = Math.max(minDistance, w, h);
    }
  } // get the weighted percent for an element based on its connectivity to other levels


  var cachedWeightedPercent = {};

  var getWeightedPercent = function getWeightedPercent(ele) {
    if (cachedWeightedPercent[ele.id()]) {
      return cachedWeightedPercent[ele.id()];
    }

    var eleDepth = getInfo(ele).depth;
    var neighbors = ele.neighborhood();
    var percent = 0;
    var samples = 0;

    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {
      var neighbor = neighbors[_i5];

      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {
        continue;
      }

      var bf = getInfo(neighbor);
      var index = bf.index;
      var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering

      if (index == null || depth == null) {
        continue;
      }

      var nDepth = depths[depth].length;

      if (depth < eleDepth) {
        // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if (samples === 0) {
      // put lone nodes at the start
      percent = 0;
    }

    cachedWeightedPercent[ele.id()] = percent;
    return percent;
  }; // rearrange the indices in each depth level based on connectivity


  var sortFn = function sortFn(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);
    var diff = apct - bpct;

    if (diff === 0) {
      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
    } else {
      return diff;
    }
  }; // sort each level to make connected nodes closer


  for (var _i6 = 0; _i6 < depths.length; _i6++) {
    depths[_i6].sort(sortFn);

    assignDepthsAt(_i6);
  } // assign orphan nodes to a new top-level depth


  var orphanDepth = [];

  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {
    orphanDepth.push(orphanNodes[_i7]);
  }

  depths.unshift(orphanDepth);
  assignDepths();
  var biggestDepthSize = 0;

  for (var _i8 = 0; _i8 < depths.length; _i8++) {
    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };
  var maxDepthSize = depths.reduce(function (max, eles) {
    return Math.max(max, eles.length);
  }, 0);

  var getPosition = function getPosition(ele) {
    var _getInfo2 = getInfo(ele),
        depth = _getInfo2.depth,
        index = _getInfo2.index;

    var depthSize = depths[depth].length;
    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
    radiusStepSize = Math.max(radiusStepSize, minDistance);

    if (!options.circle) {
      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };
      return epos;
    } else {
      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
      var theta = 2 * Math.PI / depths[depth].length * index;

      if (depth === 0 && depths[0].length === 1) {
        radius = 1;
      }

      return {
        x: center.x + radius * Math.cos(theta),
        y: center.y + radius * Math.sin(theta)
      };
    }
  };

  nodes.layoutPositions(this, options, getPosition);
  return this; // chaining
};

var defaults$a = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function CircleLayout(options) {
  this.options = extend({}, defaults$a, options);
}

CircleLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
  var dTheta = sweep / Math.max(1, nodes.length - 1);
  var r;
  var minDistance = 0;

  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var w = nbb.w;
    var h = nbb.h;
    minDistance = Math.max(minDistance, w, h);
  }

  if (number(options.radius)) {
    r = options.radius;
  } else if (nodes.length <= 1) {
    r = 0;
  } else {
    r = Math.min(bb.h, bb.w) / 2 - minDistance;
  } // calculate the radius


  if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

    r = Math.max(rMin, r);
  }

  var getPos = function getPos(ele, i) {
    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
    var rx = r * Math.cos(theta);
    var ry = r * Math.sin(theta);
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };
    return pos;
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var defaults$b = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: undefined,
  // height of layout area (overrides container height)
  width: undefined,
  // width of layout area (overrides container width)
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function levelWidth(nodes) {
    // the letiation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function ConcentricLayout(options) {
  this.options = extend({}, defaults$b, options);
}

ConcentricLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var nodeValues = []; // { node, value }

  var maxNodeSize = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var value = void 0; // calculate the node value

    value = options.concentric(node);
    nodeValues.push({
      value: value,
      node: node
    }); // for style mapping

    node._private.scratch.concentric = value;
  } // in case we used the `concentric` in style


  nodes.updateStyle(); // calculate max size now based on potentially updated mappers

  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];

    var nbb = _node.layoutDimensions(options);

    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  } // sort node values in descreasing order


  nodeValues.sort(function (a, b) {
    return b.value - a.value;
  });
  var levelWidth = options.levelWidth(nodes); // put the values into levels

  var levels = [[]];
  var currentLevel = levels[0];

  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];

    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0].value - val.value);

      if (diff >= levelWidth) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(val);
  } // create positions from levels


  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if (!options.avoidOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
    minDist = Math.min(minDist, rStep);
  } // find the metrics for each level


  var r = 0;

  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius

    if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;
    r += minDist;
  }

  if (options.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;

    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;
      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    _r = 0;

    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];

      if (_i5 === 0) {
        _r = _level2.r;
      }

      _level2.r = _r;
      _r += rDeltaMax;
    }
  } // calculate the node positions


  var pos = {}; // id => position

  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;

    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
      var p = {
        x: center.x + _r2 * Math.cos(theta),
        y: center.y + _r2 * Math.sin(theta)
      };
      pos[_val.node.id()] = p;
    }
  } // position the nodes


  nodes.layoutPositions(this, options, function (ele) {
    var id = ele.id();
    return pos[id];
  });
  return this; // chaining
};

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/
var DEBUG;
/**
 * @brief :  default layout options
 */

var defaults$c = {
  // Called on `layoutready`
  ready: function ready() {},
  // Called on `layoutstop`
  stop: function stop() {},
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,
  // Easing of the animation for animate:'end'
  animationEasing: undefined,
  // The duration of the animation for animate:'end'
  animationDuration: undefined,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: true,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function nodeRepulsion(node) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function idealEdgeLength(edge) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function edgeElasticity(edge) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1000,
  // Initial temperature (maximum node displacement)
  initialTemp: 1000,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0
};
/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */

function CoseLayout(options) {
  this.options = extend({}, defaults$c, options);
  this.options.layout = this;
}
/**
 * @brief : runs the layout
 */


CoseLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var layout = this;
  layout.stopped = false;

  if (options.animate === true || options.animate === false) {
    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
  } // Set DEBUG - Global variable


  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  } // Initialize layout info


  var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging

  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  } // If required, randomize node positions


  if (options.randomize) {
    randomizePositions(layoutInfo);
  }

  var startTime = performanceNow();

  var refresh = function refresh() {
    refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary

    if (true === options.fit) {
      cy.fit(options.padding);
    }
  };

  var mainLoop = function mainLoop(i) {
    if (layout.stopped || i >= options.numIter) {
      // logDebug("Layout manually stopped. Stopping computation in step " + i);
      return false;
    } // Do one step in the phisical simulation


    step$1(layoutInfo, options); // Update temperature

    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);

    if (layoutInfo.temperature < options.minTemp) {
      // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
      return false;
    }

    return true;
  };

  var done = function done() {
    if (options.animate === true || options.animate === false) {
      refresh(); // Layout has finished

      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    } else {
      var nodes = options.eles.nodes();
      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
      nodes.layoutPositions(layout, options, getScaledPos);
    }
  };

  var i = 0;
  var loopRet = true;

  if (options.animate === true) {
    var frame = function frame() {
      var f = 0;

      while (loopRet && f < options.refresh) {
        loopRet = mainLoop(i);
        i++;
        f++;
      }

      if (!loopRet) {
        // it's done
        separateComponents(layoutInfo, options);
        done();
      } else {
        var now = performanceNow();

        if (now - startTime >= options.animationThreshold) {
          refresh();
        }

        requestAnimationFrame(frame);
      }
    };

    frame();
  } else {
    while (loopRet) {
      loopRet = mainLoop(i);
      i++;
    }

    separateComponents(layoutInfo, options);
    done();
  }

  return this; // chaining
};
/**
 * @brief : called on continuous layouts to stop them before they finish
 */


CoseLayout.prototype.stop = function () {
  this.stopped = true;

  if (this.thread) {
    this.thread.stop();
  }

  this.emit('layoutstop');
  return this; // chaining
};

CoseLayout.prototype.destroy = function () {
  if (this.thread) {
    this.thread.stop();
  }

  return this; // chaining
};
/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */


var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();
  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
      x1: 0,
      y1: 0,
      w: cy.width(),
      h: cy.height()
    })
  };
  var components = options.eles.components();
  var id2cmptId = {};

  for (var i = 0; i < components.length; i++) {
    var component = components[i];

    for (var j = 0; j < component.length; j++) {
      var node = component[j];
      id2cmptId[node.id()] = i;
    }
  } // Iterate over all nodes, creating layout nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data('id');
    tempNode.parentId = n.data('parent');
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position('x');
    tempNode.positionY = n.position('y');
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style('padding'));
    tempNode.padRight = parseFloat(n.style('padding'));
    tempNode.padTop = parseFloat(n.style('padding'));
    tempNode.padBottom = parseFloat(n.style('padding')); // forces

    tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node

    layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map

    layoutInfo.idToIndex[tempNode.id] = i;
  } // Inline implementation of a queue, used for traversing the graph in BFS order


  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue

  var tempGraph = []; // Second pass to add child information and
  // initialize queue for hierarchical traversal

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId; // Check if node n has a parent node

    if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  } // Add root graph to graphSet


  layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;

    if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children); // Add children to que queue to be visited

      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  } // Create indexToGraph map


  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];

    for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
    }
  } // Iterate over all edges, creating Layout Edges


  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target'); // Compute ideal length

    var idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge

    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph

      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0; // Source depth

      var tempNode = layoutInfo.layoutNodes[sourceIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // Target depth


      tempNode = layoutInfo.layoutNodes[targetIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);
      // Update idealLength


      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;
    layoutInfo.layoutEdges.push(tempEdge);
  } // Finally, return layoutInfo object


  return layoutInfo;
};
/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */


var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);

  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};
/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */


var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx

  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {
      count: 2,
      graph: graphIx
    };
  } // Make recursive calls for all subgraphs


  var c = 0;

  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it

    if (0 === children.length) {
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);

    if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;

      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {
    count: c,
    graph: graphIx
  };
};
/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */


if (false) { var printLayoutInfo; }
/**
 * @brief : Randomizes the position of all nodes
 */


var randomizePositions = function randomizePositions(layoutInfo, cy) {
  var width = layoutInfo.clientWidth;
  var height = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes

    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};

var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
  var bb = layoutInfo.boundingBox;
  var coseBB = {
    x1: Infinity,
    x2: -Infinity,
    y1: Infinity,
    y2: -Infinity
  };

  if (options.boundingBox) {
    nodes.forEach(function (node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });
    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  return function (ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];

    if (options.boundingBox) {
      // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  };
};
/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);
  var layout = options.layout;
  var nodes = options.eles.nodes();
  var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
  nodes.positions(getScaledPos); // Trigger layoutReady only on first call

  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.emit({
      type: 'layoutready',
      layout: this
    });
  }
};
/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

/**
 * @brief          : Performs one iteration of the physical simulation
 * @arg layoutInfo : LayoutInfo object already initialized
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var step$1 = function step(layoutInfo, options, _step) {
  // var s = "\n\n###############################";
  // s += "\nSTEP: " + step;
  // s += "\n###############################\n";
  // logDebug(s);
  // Calculate node repulsions
  calculateNodeForces(layoutInfo, options); // Calculate edge forces

  calculateEdgeForces(layoutInfo); // Calculate gravity forces

  calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child

  propagateForces(layoutInfo); // Update positions based on calculated forces

  updatePositions(layoutInfo);
};
/**
 * @brief : Computes the node repulsion forces
 */


var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
  // Go through each of the graphs in graphSet
  // Nodes only repel each other if they belong to the same graph
  // var s = 'calculateNodeForces';
  // logDebug(s);
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Now get all the pairs of nodes
    // Only get each pair once, (A, B) = (B, A)

    for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, options);
      }
    }
  }
};

var randomDistance = function randomDistance(max) {
  return -max + 2 * max * Math.random();
};
/**
 * @brief : Compute the node repulsion forces between a pair of nodes
 */


var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
  // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
  var cmptId1 = node1.cmptId;
  var cmptId2 = node2.cmptId;

  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
    return;
  } // Get direction of line connecting both node centers


  var directionX = node2.positionX - node1.positionX;
  var directionY = node2.positionY - node1.positionY;
  var maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
  // If both centers are the same, apply a random force

  if (0 === directionX && 0 === directionY) {
    directionX = randomDistance(maxRandDist);
    directionY = randomDistance(maxRandDist);
  }

  var overlap = nodesOverlap(node1, node2, directionX, directionY);

  if (overlap > 0) {
    // s += "\nNodes DO overlap.";
    // s += "\nOverlap: " + overlap;
    // If nodes overlap, repulsion force is proportional
    // to the overlap
    var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector

    var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;

    var forceX = force * directionX / distance;
    var forceY = force * directionY / distance;
  } else {
    // s += "\nNodes do NOT overlap.";
    // If there's no overlap, force is inversely proportional
    // to squared distance
    // Get clipping points for both nodes
    var point1 = findClippingPoint(node1, directionX, directionY);
    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance

    var distanceX = point2.x - point1.x;
    var distanceY = point2.y - point1.y;
    var distanceSqr = distanceX * distanceX + distanceY * distanceY;
    var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
    // Compute the module and components of the force vector

    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
    var forceX = force * distanceX / distance;
    var forceY = force * distanceY / distance;
  } // Apply force


  if (!node1.isLocked) {
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
  }

  if (!node2.isLocked) {
    node2.offsetX += forceX;
    node2.offsetY += forceY;
  } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
  // logDebug(s);


  return;
};
/**
 * @brief  : Determines whether two nodes overlap or not
 * @return : Amount of overlapping (0 => no overlap)
 */


var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
  if (dX > 0) {
    var overlapX = node1.maxX - node2.minX;
  } else {
    var overlapX = node2.maxX - node1.minX;
  }

  if (dY > 0) {
    var overlapY = node1.maxY - node2.minY;
  } else {
    var overlapY = node2.maxY - node1.minY;
  }

  if (overlapX >= 0 && overlapY >= 0) {
    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
  } else {
    return 0;
  }
};
/**
 * @brief : Finds the point in which an edge (direction dX, dY) intersects
 *          the rectangular bounding box of it's source/target node
 */


var findClippingPoint = function findClippingPoint(node, dX, dY) {
  // Shorcuts
  var X = node.positionX;
  var Y = node.positionY;
  var H = node.height || 1;
  var W = node.width || 1;
  var dirSlope = dY / dX;
  var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
  //   " . Height:  " + H + ", Width: " + W +
  //   "\nDirection " + dX + ", " + dY;
  //
  // Compute intersection

  var res = {}; // Case: Vertical direction (up)

  if (0 === dX && 0 < dY) {
    res.x = X; // s += "\nUp direction";

    res.y = Y + H / 2;
    return res;
  } // Case: Vertical direction (down)


  if (0 === dX && 0 > dY) {
    res.x = X;
    res.y = Y + H / 2; // s += "\nDown direction";

    return res;
  } // Case: Intersects the right border


  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X + W / 2;
    res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";

    return res;
  } // Case: Intersects the left border


  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X - W / 2;
    res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";

    return res;
  } // Case: Intersects the top border


  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X + H * dX / 2 / dY;
    res.y = Y + H / 2; // s += "\nTop border";

    return res;
  } // Case: Intersects the bottom border


  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X - H * dX / 2 / dY;
    res.y = Y - H / 2; // s += "\nBottom border";

    return res;
  } // s += "\nClipping point found at " + res.x + ", " + res.y;
  // logDebug(s);


  return res;
};
/**
 * @brief : Calculates all edge forces
 */


var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
  // Iterate over all edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    // Get edge, source & target nodes
    var edge = layoutInfo.layoutEdges[i];
    var sourceIx = layoutInfo.idToIndex[edge.sourceId];
    var source = layoutInfo.layoutNodes[sourceIx];
    var targetIx = layoutInfo.idToIndex[edge.targetId];
    var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers

    var directionX = target.positionX - source.positionX;
    var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
    // A random force has already been applied as node repulsion

    if (0 === directionX && 0 === directionY) {
      continue;
    } // Get clipping points for both nodes


    var point1 = findClippingPoint(source, directionX, directionY);
    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
    var lx = point2.x - point1.x;
    var ly = point2.y - point1.y;
    var l = Math.sqrt(lx * lx + ly * ly);
    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

    if (0 !== l) {
      var forceX = force * lx / l;
      var forceY = force * ly / l;
    } else {
      var forceX = 0;
      var forceY = 0;
    } // Add this force to target and source nodes


    if (!source.isLocked) {
      source.offsetX += forceX;
      source.offsetY += forceY;
    }

    if (!target.isLocked) {
      target.offsetX -= forceX;
      target.offsetY -= forceY;
    } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
    // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
    // logDebug(s);

  }
};
/**
 * @brief : Computes gravity forces for all nodes
 */


var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
  var distThreshold = 1; // var s = 'calculateGravityForces';
  // logDebug(s);

  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Compute graph center

    if (0 === i) {
      var centerX = layoutInfo.clientHeight / 2;
      var centerY = layoutInfo.clientWidth / 2;
    } else {
      // Get Parent node for this graph, and use its position as center
      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
      var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
      var centerX = parent.positionX;
      var centerY = parent.positionY;
    } // s = "Center found at: " + centerX + ", " + centerY;
    // logDebug(s);
    // Apply force to all nodes in graph


    for (var j = 0; j < numNodes; j++) {
      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;

      if (node.isLocked) {
        continue;
      }

      var dx = centerX - node.positionX;
      var dy = centerY - node.positionY;
      var d = Math.sqrt(dx * dx + dy * dy);

      if (d > distThreshold) {
        var fx = options.gravity * dx / d;
        var fy = options.gravity * dy / d;
        node.offsetX += fx;
        node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
      } // s += ": skypped since it's too close to center";
        // logDebug(s);

    }
  }
};
/**
 * @brief          : This function propagates the existing offsets from
 *                   parent nodes to its descendents.
 * @arg layoutInfo : layoutInfo Object
 * @arg cy         : cytoscape Object
 * @arg options    : Layout options
 */


var propagateForces = function propagateForces(layoutInfo, options) {
  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue
  // logDebug('propagateForces');
  // Start by visiting the nodes in the root graph

  queue.push.apply(queue, layoutInfo.graphSet[0]);
  end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var nodeId = queue[start++];
    var nodeIndex = layoutInfo.idToIndex[nodeId];
    var node = layoutInfo.layoutNodes[nodeIndex];
    var children = node.children; // We only need to process the node if it's compound

    if (0 < children.length && !node.isLocked) {
      var offX = node.offsetX;
      var offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);

      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset

        childNode.offsetX += offX;
        childNode.offsetY += offY; // Add children to queue to be visited

        queue[++end] = children[i];
      } // Reset parent offsets


      node.offsetX = 0;
      node.offsetY = 0;
    }
  }
};
/**
 * @brief : Updates the layout model positions, based on
 *          the accumulated forces
 */


var updatePositions = function updatePositions(layoutInfo, options) {
  // var s = 'Updating positions';
  // logDebug(s);
  // Reset boundaries for compound nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length) {
      // logDebug("Resetting boundaries of compound node: " + n.id);
      n.maxX = undefined;
      n.minX = undefined;
      n.maxY = undefined;
      n.minY = undefined;
    }
  }

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length || n.isLocked) {
      // No need to set compound or locked node position
      // logDebug("Skipping position update of node: " + n.id);
      continue;
    } // s = "Node: " + n.id + " Previous position: (" +
    // n.positionX + ", " + n.positionY + ").";
    // Limit displacement in order to improve stability


    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
    n.positionX += tempForce.x;
    n.positionY += tempForce.y;
    n.offsetX = 0;
    n.offsetY = 0;
    n.minX = n.positionX - n.width;
    n.maxX = n.positionX + n.width;
    n.minY = n.positionY - n.height;
    n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
    // logDebug(s);
    // Update ancestry boudaries

    updateAncestryBoundaries(n, layoutInfo);
  } // Update size, position of compund nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length && !n.isLocked) {
      n.positionX = (n.maxX + n.minX) / 2;
      n.positionY = (n.maxY + n.minY) / 2;
      n.width = n.maxX - n.minX;
      n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
      // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
      // s += "\nWidth: " + n.width + ", Height: " + n.height;
      // logDebug(s);
    }
  }
};
/**
 * @brief : Limits a force (forceX, forceY) to be not
 *          greater (in modulo) than max.
 8          Preserves force direction.
  */


var limitForce = function limitForce(forceX, forceY, max) {
  // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
  var force = Math.sqrt(forceX * forceX + forceY * forceY);

  if (force > max) {
    var res = {
      x: max * forceX / force,
      y: max * forceY / force
    };
  } else {
    var res = {
      x: forceX,
      y: forceY
    };
  } // s += ".\nResult: (" + res.x + ", " + res.y + ")";
  // logDebug(s);


  return res;
};
/**
 * @brief : Function used for keeping track of compound node
 *          sizes, since they should bound all their subnodes.
 */


var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
  // var s = "Propagating new position/size of node " + node.id;
  var parentId = node.parentId;

  if (null == parentId) {
    // If there's no parent, we are done
    // s += ". No parent node.";
    // logDebug(s);
    return;
  } // Get Parent Node


  var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
  var flag = false; // MaxX

  if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
    p.maxX = node.maxX + p.padRight;
    flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
  } // MinX


  if (null == p.minX || node.minX - p.padLeft < p.minX) {
    p.minX = node.minX - p.padLeft;
    flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
  } // MaxY


  if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
    p.maxY = node.maxY + p.padBottom;
    flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
  } // MinY


  if (null == p.minY || node.minY - p.padTop < p.minY) {
    p.minY = node.minY - p.padTop;
    flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
  } // If updated boundaries, propagate changes upward


  if (flag) {
    // logDebug(s);
    return updateAncestryBoundaries(p, layoutInfo);
  } // s += ". No changes in boundaries/position of parent node " + p.id;
  // logDebug(s);


  return;
};

var separateComponents = function separateComponents(layoutInfo, options) {
  var nodes = layoutInfo.layoutNodes;
  var components = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var cid = node.cmptId;
    var component = components[cid] = components[cid] || [];
    component.push(node);
  }

  var totalA = 0;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    c.x1 = Infinity;
    c.x2 = -Infinity;
    c.y1 = Infinity;
    c.y2 = -Infinity;

    for (var j = 0; j < c.length; j++) {
      var n = c[j];
      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
    }

    c.w = c.x2 - c.x1;
    c.h = c.y2 - c.y1;
    totalA += c.w * c.h;
  }

  components.sort(function (c1, c2) {
    return c2.w * c2.h - c1.w * c1.h;
  });
  var x = 0;
  var y = 0;
  var usedW = 0;
  var rowH = 0;
  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    for (var j = 0; j < c.length; j++) {
      var n = c[j];

      if (!n.isLocked) {
        n.positionX += x - c.x1;
        n.positionY += y - c.y1;
      }
    }

    x += c.w + options.componentSpacing;
    usedW += c.w + options.componentSpacing;
    rowH = Math.max(rowH, c.h);

    if (usedW > maxRowW) {
      y += rowH + options.componentSpacing;
      x = 0;
      usedW = 0;
      rowH = 0;
    }
  }
};

var defaults$d = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false,
  // uses all available space on false, uses minimal space on true
  rows: undefined,
  // force num of rows in the grid
  cols: undefined,
  // force num of columns in the grid
  position: function position(node) {},
  // returns { row, col } for element
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function GridLayout(options) {
  this.options = extend({}, defaults$d, options);
}

GridLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  if (bb.h === 0 || bb.w === 0) {
    nodes.layoutPositions(this, options, function (ele) {
      return {
        x: bb.x1,
        y: bb.y1
      };
    });
  } else {
    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);

    var small = function small(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);

        if (min == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function large(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);

        if (max == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values

    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    } // otherwise use the automatic values and adjust accordingly
    // if rounding was up, see if we can reduce rows or columns
    else if (cols * rows > cells) {
        var sm = small();
        var lg = large(); // reducing the small side takes away the most cells, so try it first

        if ((sm - 1) * lg >= cells) {
          small(sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(lg - 1);
        }
      } else {
        // if rounding was too low, add rows or columns
        while (cols * rows < cells) {
          var _sm = small();

          var _lg = large(); // try to add to larger side first (adds less in multiplication)


          if ((_lg + 1) * _sm >= cells) {
            large(_lg + 1);
          } else {
            small(_sm + 1);
          }
        }
      }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if (options.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }

    if (options.avoidOverlap) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = node._private.position;

        if (pos.x == null || pos.y == null) {
          // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.layoutDimensions(options);
        var p = options.avoidOverlapPadding;
        var w = nbb.w + p;
        var h = nbb.h + p;
        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function used(row, col) {
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function use(row, col) {
      cellUsed['c-' + row + '-' + col] = true;
    }; // to keep track of current cell position


    var row = 0;
    var col = 0;

    var moveToNextCell = function moveToNextCell() {
      col++;

      if (col >= cols) {
        col = 0;
        row++;
      }
    }; // get a cache of all the manual positions


    var id2manPos = {};

    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
      var rcPos = options.position(_node);

      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if (_pos.col === undefined) {
          // find unused col
          _pos.col = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === undefined) {
          // find unused row
          _pos.row = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }

        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }

    var getPos = function getPos(element, i) {
      var x, y;

      if (element.locked() || element.isParent()) {
        return false;
      } // see if we have a manual position set


      var rcPos = id2manPos[element.id()];

      if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        // otherwise set automatically
        while (used(row, col)) {
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);
        moveToNextCell();
      }

      return {
        x: x,
        y: y
      };
    };

    nodes.layoutPositions(this, options, getPos);
  }

  return this; // chaining
};

var defaults$e = {
  ready: function ready() {},
  // on layoutready
  stop: function stop() {} // on layoutstop

}; // constructor
// options : object containing layout options

function NullLayout(options) {
  this.options = extend({}, defaults$e, options);
} // runs the layout


NullLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout

  var layout = this; // cy is automatically populated for us in the constructor
  // (disable eslint for next line as this serves as example layout code to external developers)
  // eslint-disable-next-line no-unused-vars

  var cy = options.cy;
  layout.emit('layoutstart'); // puts all nodes at (0, 0)
  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events

  eles.nodes().positions(function () {
    return {
      x: 0,
      y: 0
    };
  }); // trigger layoutready when each node has had its position set at least once

  layout.one('layoutready', options.ready);
  layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)

  layout.one('layoutstop', options.stop);
  layout.emit('layoutstop');
  return this; // chaining
}; // called on continuous layouts to stop them before they finish


NullLayout.prototype.stop = function () {
  return this; // chaining
};

var defaults$f = {
  positions: undefined,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined,
  // the zoom level to set (prob want fit = false if set)
  pan: undefined,
  // the pan level to set (prob want fit = false if set)
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function PresetLayout(options) {
  this.options = extend({}, defaults$f, options);
}

PresetLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles;
  var nodes = eles.nodes();
  var posIsFn = fn(options.positions);

  function getPosition(node) {
    if (options.positions == null) {
      return copyPosition(node.position());
    }

    if (posIsFn) {
      return options.positions(node);
    }

    var pos = options.positions[node._private.data.id];

    if (pos == null) {
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function (node, i) {
    var position = getPosition(node);

    if (node.locked() || position == null) {
      return false;
    }

    return position;
  });
  return this; // chaining
};

var defaults$g = {
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function RandomLayout(options) {
  this.options = extend({}, defaults$g, options);
}

RandomLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  var getPos = function getPos(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var layout = [{
  name: 'breadthfirst',
  impl: BreadthFirstLayout
}, {
  name: 'circle',
  impl: CircleLayout
}, {
  name: 'concentric',
  impl: ConcentricLayout
}, {
  name: 'cose',
  impl: CoseLayout
}, {
  name: 'grid',
  impl: GridLayout
}, {
  name: 'null',
  impl: NullLayout
}, {
  name: 'preset',
  impl: PresetLayout
}, {
  name: 'random',
  impl: RandomLayout
}];

function NullRenderer(options) {
  this.options = options;
  this.notifications = 0; // for testing
}

var noop$1 = function noop() {};

var throwImgErr = function throwImgErr() {
  throw new Error('A headless instance can not render images');
};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop$1,
  notify: function notify() {
    this.notifications++;
  },
  init: noop$1,
  isHeadless: function isHeadless() {
    return true;
  },
  png: throwImgErr,
  jpg: throwImgErr
};

var BRp = {};
BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function () {
  var arrowShapes = this.arrowShapes = {};
  var renderer = this; // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;
    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
    return inside;
  };

  var transform = function transform(x, y, size, angle, translation) {
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;
    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function transformPoints(pts, size, angle, translation) {
    var retPts = [];

    for (var i = 0; i < pts.length; i += 2) {
      var x = pts[i];
      var y = pts[i + 1];
      retPts.push(transform(x, y, size, angle, translation));
    }

    return retPts;
  };

  var pointsToArr = function pointsToArr(pts) {
    var ret = [];

    for (var i = 0; i < pts.length; i++) {
      var p = pts[i];
      ret.push(p.x, p.y);
    }

    return ret;
  };

  var standardGap = function standardGap(edge) {
    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
  };

  var defineArrowShape = function defineArrowShape(name, defn) {
    if (string(defn)) {
      defn = arrowShapes[defn];
    }

    arrowShapes[name] = extend({
      name: name,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function collide(x, y, size, angle, translation, padding) {
        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
        var inside = pointInsidePolygonPoints(x, y, points);
        return inside;
      },
      roughCollide: bbCollide,
      draw: function draw(context, size, angle, translation) {
        var points = transformPoints(this.points, size, angle, translation);
        renderer.arrowShapeImpl('polygon')(context, points);
      },
      spacing: function spacing(edge) {
        return 0;
      },
      gap: standardGap
    }, defn);
  };

  defineArrowShape('none', {
    collide: falsify,
    roughCollide: falsify,
    draw: noop,
    spacing: zeroify,
    gap: zeroify
  });
  defineArrowShape('triangle', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });
  defineArrowShape('arrow', 'triangle');
  defineArrowShape('triangle-backcurve', {
    points: arrowShapes['triangle'].points,
    controlPoint: [0, -0.15],
    roughCollide: bbCollide,
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var ptsTrans = transformPoints(this.points, size, angle, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    },
    gap: function gap(edge) {
      return standardGap(edge) * 0.8;
    }
  });
  defineArrowShape('triangle-tee', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var teePts = transformPoints(this.pointsTee, size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
    }
  });
  defineArrowShape('triangle-cross', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
    0.15, -0.4],
    crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
      var p = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size;
      var y0 = 3;
      var y1 = 5;
      p[y0] = p[y0] - shiftFactor;
      p[y1] = p[y1] - shiftFactor;
      return p;
    },
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }
  });
  defineArrowShape('vee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function gap(edge) {
      return standardGap(edge) * 0.525;
    }
  });
  defineArrowShape('circle', {
    radius: 0.15,
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
    },
    spacing: function spacing(edge) {
      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
    }
  });
  defineArrowShape('tee', {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function spacing(edge) {
      return 1;
    },
    gap: function gap(edge) {
      return 1;
    }
  });
  defineArrowShape('square', {
    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
  });
  defineArrowShape('diamond', {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function gap(edge) {
      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
  defineArrowShape('chevron', {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function gap(edge) {
      return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
};

var BRp$1 = {}; // Project mouse

BRp$1.projectIntoViewport = function (clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale = offsets[4];
  var pan = cy.pan();
  var zoom = cy.zoom();
  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;
  return [x, y];
};

BRp$1.findContainerClientCoords = function () {
  if (this.containerBB) {
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window$1.getComputedStyle(container);

  var styleValue = function styleValue(name) {
    return parseFloat(style.getPropertyValue(name));
  };

  var padding = {
    left: styleValue('padding-left'),
    right: styleValue('padding-right'),
    top: styleValue('padding-top'),
    bottom: styleValue('padding-bottom')
  };
  var border = {
    left: styleValue('border-left-width'),
    right: styleValue('border-right-width'),
    top: styleValue('border-top-width'),
    bottom: styleValue('border-bottom-width')
  };
  var clientWidth = container.clientWidth;
  var clientHeight = container.clientHeight;
  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;
  var borderHor = border.left + border.right;
  var scale = rect.width / (clientWidth + borderHor);
  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;
  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;
  return this.containerBB = [left, top, unscaledW, unscaledH, scale];
};

BRp$1.invalidateContainerClientCoordsCache = function () {
  this.containerBB = null;
};

BRp$1.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};

BRp$1.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max

  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }

  function addEle(ele, sqDist) {
    if (ele.isNode()) {
      if (nearNode) {
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push(ele);
      }
    }

    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
          for (var i = 0; i < near.length; i++) {
            if (near[i].isEdge()) {
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele);
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode(node) {
    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = node.position();

    if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
    ) {
        var shape = r.nodeShapes[self.getNodeShape(node)];

        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
          addEle(node, 0);
          return true;
        }
      }
  }

  function checkEdge(edge) {
    var _p = edge._private;
    var rs = _p.rscratch;
    var styleWidth = edge.pstyle('width').pfValue;
    var scale = edge.pstyle('arrow-scale').value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre

    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var sqDist;

    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
      var pts = rs.allpts;

      for (var i = 0; i + 3 < pts.length; i += 2) {
        if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
      var pts = rs.allpts;

      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
        if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } // if we're close to the edge but didn't hit it, maybe we hit its arrows


    var src = src || _p.source;
    var tgt = tgt || _p.target;
    var arSize = self.getArrowWidth(styleWidth, scale);
    var arrows = [{
      name: 'source',
      x: rs.arrowStartX,
      y: rs.arrowStartY,
      angle: rs.srcArrowAngle
    }, {
      name: 'target',
      x: rs.arrowEndX,
      y: rs.arrowEndY,
      angle: rs.tgtArrowAngle
    }, {
      name: 'mid-source',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midsrcArrowAngle
    }, {
      name: 'mid-target',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midtgtArrowAngle
    }];

    for (var i = 0; i < arrows.length; i++) {
      var ar = arrows[i];
      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
      var edgeWidth = edge.pstyle('width').pfValue;

      if (shape.roughCollide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)


    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }

  function preprop(obj, name, pre) {
    return getPrefixedProperty(obj, name, pre);
  }

  function checkLabel(ele, prefix) {
    var _p = ele._private;
    var th = labelThreshold;
    var prefixDash;

    if (prefix) {
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    ele.boundingBox();
    var bb = _p.labelBounds[prefix || 'main'];
    var text = ele.pstyle(prefixDash + 'label').value;
    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

    if (!eventsEnabled || !text) {
      return;
    }

    var rstyle = _p.rstyle;
    var lx = preprop(rstyle, 'labelX', prefix);
    var ly = preprop(rstyle, 'labelY', prefix);
    var theta = preprop(_p.rscratch, 'labelAngle', prefix);
    var lx1 = bb.x1 - th;
    var lx2 = bb.x2 + th;
    var ly1 = bb.y1 - th;
    var ly2 = bb.y2 + th;

    if (theta) {
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - lx;
        y = y - ly;
        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

      if (pointInsidePolygonPoints(x, y, points)) {
        addEle(ele);
        return true;
      }
    } else {
      // do a cheaper bb check
      if (inBoundingBox(bb, x, y)) {
        addEle(ele);
        return true;
      }
    }
  }

  for (var i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
    var ele = eles[i];

    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      // then edge
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
    }
  }

  return near;
}; // 'Give me everything from this box'


BRp$1.getAllInBox = function (x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];
  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);
  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;
  var boxBb = makeBoundingBox({
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  });

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];

    if (ele.isNode()) {
      var node = ele;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      });

      if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {
        box.push(node);
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
        continue;
      }

      if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
        continue;
      }

      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {
        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for (var i = 0; i < pts.length; i++) {
          if (!pointInBoundingBox(boxBb, pts[i])) {
            allInside = false;
            break;
          }
        }

        if (allInside) {
          box.push(edge);
        }
      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
        box.push(edge);
      }
    }
  }

  return box;
};

var BRp$2 = {};

BRp$2.calculateArrowAngles = function (edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation

  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  if (isHaystack) {
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY; // source
  //

  if (isSegments) {
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
    var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if (isHaystack) {
    midX = (startX + endX) / 2;
    midY = (startY + endY) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      var i2 = pts.length / 2;
      var i1 = i2 - 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts.length / 2 - 1; // startpt

      var ic = p0 + 2;
      var p1 = ic + 2;
      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
    } else {
      var ic = pts.length / 2 - 1; // ctrpt

      var p0 = ic - 2; // startpt

      var p1 = ic + 2; // endpt

      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
    }

    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }

  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
  rs.midDispX = dispX;
  rs.midDispY = dispY; // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) ; else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;
      dispX = -(pts[i3] - pts[i2]);
      dispY = -(pts[i3 + 1] - pts[i2 + 1]);
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
  //

  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var l = pts.length;
    var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
    var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
};

BRp$2.getArrowWidth = BRp$2.getArrowHeight = function (edgeWidth, scale) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};
  var cachedVal = cache[edgeWidth + ', ' + scale];

  if (cachedVal) {
    return cachedVal;
  }

  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
  cache[edgeWidth + ', ' + scale] = cachedVal;
  return cachedVal;
};

var BRp$3 = {};

BRp$3.findHaystackPoints = function (edges) {
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var rs = _p.rscratch;

    if (!rs.haystack) {
      var angle = Math.random() * 2 * Math.PI;
      rs.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
      angle = Math.random() * 2 * Math.PI;
      rs.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle('haystack-radius').value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously

    rs.edgeType = 'haystack';
    rs.haystack = true;
    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};

BRp$3.findSegmentsPoints = function (edge, pairInfo) {
  // Segments (multiple straight lines)
  var rs = edge._private.rscratch;
  var posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts,
      vectorNormInverse = pairInfo.vectorNormInverse;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var segmentWs = edge.pstyle('segment-weights');
  var segmentDs = edge.pstyle('segment-distances');
  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
  rs.edgeType = 'segments';
  rs.segpts = [];

  for (var s = 0; s < segmentsN; s++) {
    var w = segmentWs.pfValue[s];
    var d = segmentDs.pfValue[s];
    var w1 = 1 - w;
    var w2 = w;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
  }
};

BRp$3.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Self-edge
  var rs = edge._private.rscratch;
  var dirCounts = pairInfo.dirCounts,
      srcPos = pairInfo.srcPos;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var loopDir = edge.pstyle('loop-direction').pfValue;
  var loopSwp = edge.pstyle('loop-sweep').pfValue;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  rs.edgeType = 'self';
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopAngle = loopDir - Math.PI / 2;
  var outAngle = loopAngle - loopSwp / 2;
  var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values

  var dc = String(loopDir + '_' + loopSwp);
  j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
};

BRp$3.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Compound edge
  var rs = edge._private.rscratch;
  rs.edgeType = 'compound';
  var srcPos = pairInfo.srcPos,
      tgtPos = pairInfo.tgtPos,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopW = 50;
  var loopaPos = {
    x: srcPos.x - srcW / 2,
    y: srcPos.y - srcH / 2
  };
  var loopbPos = {
    x: tgtPos.x - tgtW / 2,
    y: tgtPos.y - tgtH / 2
  };
  var loopPos = {
    x: Math.min(loopaPos.x, loopbPos.x),
    y: Math.min(loopaPos.y, loopbPos.y)
  }; // avoids cases with impossible beziers

  var minCompoundStretch = 0.5;
  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
};

BRp$3.findStraightEdgePoints = function (edge) {
  // Straight edge within bundle
  edge._private.rscratch.edgeType = 'straight';
};

BRp$3.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
  var rs = edge._private.rscratch;
  var vectorNormInverse = pairInfo.vectorNormInverse,
      posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptWs = edge.pstyle('control-point-weights');
  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier

  var multi = edgeIsUnbundled;
  rs.edgeType = multi ? 'multibezier' : 'bezier';
  rs.ctrlpts = [];

  for (var b = 0; b < bezierN; b++) {
    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
    var manctrlptDist = void 0;
    var sign = signum(normctrlptDist);

    if (multi) {
      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size

      ctrlptWeight = ctrlptWs.value[b];
    }

    if (edgeIsUnbundled) {
      // multi or single unbundled
      manctrlptDist = ctrlptDist;
    } else {
      manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
    }

    var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
    var w1 = 1 - ctrlptWeight;
    var w2 = ctrlptWeight;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
  }
};

BRp$3.findTaxiPoints = function (edge, pairInfo) {
  // Taxicab geometry with two turns maximum
  var rs = edge._private.rscratch;
  rs.edgeType = 'segments';
  var VERTICAL = 'vertical';
  var HORIZONTAL = 'horizontal';
  var LEFTWARD = 'leftward';
  var RIGHTWARD = 'rightward';
  var DOWNWARD = 'downward';
  var UPWARD = 'upward';
  var AUTO = 'auto';
  var posPts = pairInfo.posPts,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var dIncludesNodeBody = edgeDistances !== 'node-position';
  var taxiDir = edge.pstyle('taxi-direction').value;
  var rawTaxiDir = taxiDir; // unprocessed value

  var taxiTurn = edge.pstyle('taxi-turn');
  var taxiTurnPfVal = taxiTurn.pfValue;
  var minD = edge.pstyle('taxi-turn-min-distance').pfValue;
  var turnIsPercent = taxiTurn.units === '%';
  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
  var pdx = posPts.x2 - posPts.x1;
  var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value

  var subDWH = function subDWH(dxy, dwh) {
    if (dxy > 0) {
      return Math.max(dxy - dwh, 0);
    } else {
      return Math.min(dxy + dwh, 0);
    }
  };

  var dx = subDWH(pdx, dw);
  var dy = subDWH(pdy, dh);
  var isExplicitDir = false;

  if (taxiDir === AUTO) {
    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
  } else if (taxiDir === UPWARD || taxiDir === DOWNWARD) {
    taxiDir = VERTICAL;
    isExplicitDir = true;
  } else if (taxiDir === LEFTWARD || taxiDir === RIGHTWARD) {
    taxiDir = HORIZONTAL;
    isExplicitDir = true;
  }

  var isVert = taxiDir === VERTICAL;
  var l = isVert ? dy : dx;
  var pl = isVert ? pdy : pdx;
  var sgnL = signum(pl);
  var forcedDir = false;

  if (!(isExplicitDir && turnIsPercent) // forcing in this case would cause weird growing in the opposite direction
  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
    sgnL *= -1;
    l = sgnL * Math.abs(l);
    forcedDir = true;
  }

  var d = turnIsPercent ? taxiTurnPfVal * l : taxiTurnPfVal * sgnL;

  var getIsTooClose = function getIsTooClose(d) {
    return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
  };

  var isTooCloseSrc = getIsTooClose(d);
  var isTooCloseTgt = getIsTooClose(l - d);
  var isTooClose = isTooCloseSrc || isTooCloseTgt;

  if (isTooClose && !forcedDir) {
    // non-ideal routing
    if (isVert) {
      // vertical fallbacks
      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;

      if (lShapeInsideSrc) {
        // horizontal Z-shape (direction not respected)
        var x = (posPts.x1 + posPts.x2) / 2;
        var y1 = posPts.y1,
            y2 = posPts.y2;
        rs.segpts = [x, y1, x, y2];
      } else if (lShapeInsideTgt) {
        // vertical Z-shape (distance not respected)
        var y = (posPts.y1 + posPts.y2) / 2;
        var x1 = posPts.x1,
            x2 = posPts.x2;
        rs.segpts = [x1, y, x2, y];
      } else {
        // L-shape fallback (turn distance not respected, but works well with tree siblings)
        rs.segpts = [posPts.x1, posPts.y2];
      }
    } else {
      // horizontal fallbacks
      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;

      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;

      if (_lShapeInsideSrc) {
        // vertical Z-shape (direction not respected)
        var _y = (posPts.y1 + posPts.y2) / 2;

        var _x = posPts.x1,
            _x2 = posPts.x2;
        rs.segpts = [_x, _y, _x2, _y];
      } else if (_lShapeInsideTgt) {
        // horizontal Z-shape (turn distance not respected)
        var _x3 = (posPts.x1 + posPts.x2) / 2;

        var _y2 = posPts.y1,
            _y3 = posPts.y2;
        rs.segpts = [_x3, _y2, _x3, _y3];
      } else {
        // L-shape (turn distance not respected, but works well for tree siblings)
        rs.segpts = [posPts.x2, posPts.y1];
      }
    }
  } else {
    // ideal routing
    if (isVert) {
      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);

      var _x4 = posPts.x1,
          _x5 = posPts.x2;
      rs.segpts = [_x4, _y4, _x5, _y4];
    } else {
      // horizontal
      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);

      var _y5 = posPts.y1,
          _y6 = posPts.y2;
      rs.segpts = [_x6, _y5, _x6, _y6];
    }
  }
};

BRp$3.tryToCorrectInvalidPoints = function (edge, pairInfo) {
  var rs = edge._private.rscratch; // can only correct beziers for now...

  if (rs.edgeType === 'bezier') {
    var srcPos = pairInfo.srcPos,
        tgtPos = pairInfo.tgtPos,
        srcW = pairInfo.srcW,
        srcH = pairInfo.srcH,
        tgtW = pairInfo.tgtW,
        tgtH = pairInfo.tgtH,
        srcShape = pairInfo.srcShape,
        tgtShape = pairInfo.tgtShape;
    var badStart = !number(rs.startX) || !number(rs.startY);
    var badAStart = !number(rs.arrowStartX) || !number(rs.arrowStartY);
    var badEnd = !number(rs.endX) || !number(rs.endY);
    var badAEnd = !number(rs.arrowEndX) || !number(rs.arrowEndY);
    var minCpADistFactor = 3;
    var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
    var minCpADist = minCpADistFactor * arrowW;
    var startACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.startX,
      y: rs.startY
    });
    var closeStartACp = startACpDist < minCpADist;
    var endACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.endX,
      y: rs.endY
    });
    var closeEndACp = endACpDist < minCpADist;
    var overlapping = false;

    if (badStart || badAStart || closeStartACp) {
      overlapping = true; // project control point along line from src centre to outside the src shape
      // (otherwise intersection will yield nothing)

      var cpD = {
        // delta
        x: rs.ctrlpts[0] - srcPos.x,
        y: rs.ctrlpts[1] - srcPos.y
      };
      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line

      var cpM = {
        // normalised delta
        x: cpD.x / cpL,
        y: cpD.y / cpL
      };
      var radius = Math.max(srcW, srcH);
      var cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + cpM.x * 2 * radius,
        y: rs.ctrlpts[1] + cpM.y * 2 * radius
      };
      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

      if (closeStartACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
      } else {
        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
      }
    }

    if (badEnd || badAEnd || closeEndACp) {
      overlapping = true; // project control point along line from tgt centre to outside the tgt shape
      // (otherwise intersection will yield nothing)

      var _cpD = {
        // delta
        x: rs.ctrlpts[0] - tgtPos.x,
        y: rs.ctrlpts[1] - tgtPos.y
      };

      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line


      var _cpM = {
        // normalised delta
        x: _cpD.x / _cpL,
        y: _cpD.y / _cpL
      };

      var _radius = Math.max(srcW, srcH);

      var _cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
      };
      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);

      if (closeEndACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
      } else {
        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
      }
    }

    if (overlapping) {
      // recalc endpts
      this.findEndpoints(edge);
    }
  }
};

BRp$3.storeAllpts = function (edge) {
  var rs = edge._private.rscratch;

  if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);

    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
      // ctrl pt itself
      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts

      if (b + 3 < rs.ctrlpts.length) {
        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
      }
    }

    rs.allpts.push(rs.endX, rs.endY);
    var m, mt;

    if (rs.ctrlpts.length / 2 % 2 === 0) {
      m = rs.allpts.length / 2 - 1;
      rs.midX = rs.allpts[m];
      rs.midY = rs.allpts[m + 1];
    } else {
      m = rs.allpts.length / 2 - 3;
      mt = 0.5;
      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
    }
  } else if (rs.edgeType === 'straight') {
    // need to calc these after endpts
    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc

    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
  } else if (rs.edgeType === 'segments') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);
    rs.allpts.push.apply(rs.allpts, rs.segpts);
    rs.allpts.push(rs.endX, rs.endY);

    if (rs.segpts.length % 4 === 0) {
      var i2 = rs.segpts.length / 2;
      var i1 = i2 - 2;
      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
    } else {
      var _i = rs.segpts.length / 2 - 1;

      rs.midX = rs.segpts[_i];
      rs.midY = rs.segpts[_i + 1];
    }
  }
};

BRp$3.checkForInvalidEdgeWarning = function (edge) {
  var rs = edge[0]._private.rscratch;

  if (rs.nodesOverlap || number(rs.startX) && number(rs.startY) && number(rs.endX) && number(rs.endY)) {
    rs.loggedErr = false;
  } else {
    if (!rs.loggedErr) {
      rs.loggedErr = true;
      warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');
    }
  }
};

BRp$3.findEdgeControlPoints = function (edges) {
  var _this = this;

  if (!edges || edges.length === 0) {
    return;
  }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {
    map: new Map$1(),
    get: function get(pairId) {
      var map2 = this.map.get(pairId[0]);

      if (map2 != null) {
        return map2.get(pairId[1]);
      } else {
        return null;
      }
    },
    set: function set(pairId, val) {
      var map2 = this.map.get(pairId[0]);

      if (map2 == null) {
        map2 = new Map$1();
        this.map.set(pairId[0], map2);
      }

      map2.set(pairId[1], val);
    }
  };
  var pairIds = [];
  var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed
    // they shouldn't take up space

    if (edge.removed() || !edge.takesUpSpace()) {
      continue;
    }

    if (curveStyle === 'haystack') {
      haystackEdges.push(edge);
      continue;
    }

    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'taxi';
    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';
    var src = _p.source;
    var tgt = _p.target;
    var srcIndex = src.poolIndex();
    var tgtIndex = tgt.poolIndex();
    var pairId = [srcIndex, tgtIndex].sort();
    var tableEntry = hashTable.get(pairId);

    if (tableEntry == null) {
      tableEntry = {
        eles: []
      };
      hashTable.set(pairId, tableEntry);
      pairIds.push(pairId);
    }

    tableEntry.eles.push(edge);

    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }

    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  } // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount


  var _loop = function _loop(p) {
    var pairId = pairIds[p];
    var pairInfo = hashTable.get(pairId);
    var swappedpairInfo = void 0;

    if (!pairInfo.hasUnbundled) {
      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {
        return e.isBundledBezier();
      });
      clearArray(pairInfo.eles);
      pllEdges.forEach(function (edge) {
        return pairInfo.eles.push(edge);
      }); // for each pair id, the edges should be sorted by index

      pairInfo.eles.sort(function (edge1, edge2) {
        return edge1.poolIndex() - edge2.poolIndex();
      });
    }

    var firstEdge = pairInfo.eles[0];
    var src = firstEdge.source();
    var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId

    if (src.poolIndex() > tgt.poolIndex()) {
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    var srcPos = pairInfo.srcPos = src.position();
    var tgtPos = pairInfo.tgtPos = tgt.position();
    var srcW = pairInfo.srcW = src.outerWidth();
    var srcH = pairInfo.srcH = src.outerHeight();
    var tgtW = pairInfo.tgtW = tgt.outerWidth();
    var tgtH = pairInfo.tgtH = tgt.outerHeight();

    var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];

    var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];

    pairInfo.dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
      var _edge = pairInfo.eles[_i2];
      var rs = _edge[0]._private.rscratch;

      var _curveStyle = _edge.pstyle('curve-style').value;

      var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order


      var edgeIsSwapped = !src.same(_edge.source());

      if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
        pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt

        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
        var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt

        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
        var tgtIntn = pairInfo.tgtIntn = tgtOutside;
        var intersectionPts = pairInfo.intersectionPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };
        var posPts = pairInfo.posPts = {
          x1: srcPos.x,
          x2: tgtPos.x,
          y1: srcPos.y,
          y2: tgtPos.y
        };
        var dy = tgtOutside[1] - srcOutside[1];
        var dx = tgtOutside[0] - srcOutside[0];
        var l = Math.sqrt(dx * dx + dy * dy);
        var vector = pairInfo.vector = {
          x: dx,
          y: dy
        };
        var vectorNorm = pairInfo.vectorNorm = {
          x: vector.x / l,
          y: vector.y / l
        };
        var vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        }; // if node shapes overlap, then no ctrl pts to draw

        pairInfo.nodesOverlap = !number(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
        pairInfo.vectorNormInverse = vectorNormInverse;
        swappedpairInfo = {
          nodesOverlap: pairInfo.nodesOverlap,
          dirCounts: pairInfo.dirCounts,
          calculatedIntersection: true,
          hasBezier: pairInfo.hasBezier,
          hasUnbundled: pairInfo.hasUnbundled,
          eles: pairInfo.eles,
          srcPos: tgtPos,
          tgtPos: srcPos,
          srcW: tgtW,
          srcH: tgtH,
          tgtW: srcW,
          tgtH: srcH,
          srcIntn: tgtIntn,
          tgtIntn: srcIntn,
          srcShape: tgtShape,
          tgtShape: srcShape,
          posPts: {
            x1: posPts.x2,
            y1: posPts.y2,
            x2: posPts.x1,
            y2: posPts.y1
          },
          intersectionPts: {
            x1: intersectionPts.x2,
            y1: intersectionPts.y2,
            x2: intersectionPts.x1,
            y2: intersectionPts.y1
          },
          vector: {
            x: -vector.x,
            y: -vector.y
          },
          vectorNorm: {
            x: -vectorNorm.x,
            y: -vectorNorm.y
          },
          vectorNormInverse: {
            x: -vectorNormInverse.x,
            y: -vectorNormInverse.y
          }
        };
      }

      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
      rs.nodesOverlap = passedPairInfo.nodesOverlap;
      rs.srcIntn = passedPairInfo.srcIntn;
      rs.tgtIntn = passedPairInfo.tgtIntn;

      if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {
        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (src === tgt) {
        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (_curveStyle === 'segments') {
        _this.findSegmentsPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'taxi') {
        _this.findTaxiPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
        _this.findStraightEdgePoints(_edge);
      } else {
        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
      }

      _this.findEndpoints(_edge);

      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);

      _this.checkForInvalidEdgeWarning(_edge);

      _this.storeAllpts(_edge);

      _this.storeEdgeProjections(_edge);

      _this.calculateArrowAngles(_edge);

      _this.recalculateEdgeLabelProjections(_edge);

      _this.calculateLabelAngles(_edge);
    } // for pair edges

  };

  for (var p = 0; p < pairIds.length; p++) {
    _loop(p);
  } // for pair ids
  // haystacks avoid the expense of pairInfo stuff (intersections etc.)


  this.findHaystackPoints(haystackEdges);
};

function getPts(pts) {
  var retPts = [];

  if (pts == null) {
    return;
  }

  for (var i = 0; i < pts.length; i += 2) {
    var x = pts[i];
    var y = pts[i + 1];
    retPts.push({
      x: x,
      y: y
    });
  }

  return retPts;
}

BRp$3.getSegmentPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'segments') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.segpts);
  }
};

BRp$3.getControlPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.ctrlpts);
  }
};

BRp$3.getEdgeMidpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  return {
    x: rs.midX,
    y: rs.midY
  };
};

var BRp$4 = {};

BRp$4.manualEndptToPx = function (node, prop) {
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if (prop.value.length === 2) {
    var p = [prop.pfValue[0], prop.pfValue[1]];

    if (prop.units[0] === '%') {
      p[0] = p[0] * w;
    }

    if (prop.units[1] === '%') {
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;
    return p;
  } else {
    var angle = prop.pfValue[0];
    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max(w, h);
    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];
    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
  }
};

BRp$4.findEndpoints = function (edge) {
  var r = this;
  var intersect;
  var source = edge.source()[0];
  var target = edge.target()[0];
  var srcPos = source.position();
  var tgtPos = target.position();
  var tgtArShape = edge.pstyle('target-arrow-shape').value;
  var srcArShape = edge.pstyle('source-arrow-shape').value;
  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
  var srcDist = edge.pstyle('source-distance-from-node').pfValue;
  var curveStyle = edge.pstyle('curve-style').value;
  var rs = edge._private.rscratch;
  var et = rs.edgeType;
  var taxi = curveStyle === 'taxi';
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var overrideEndpts = self || taxi;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;
  var tgtManEndpt = edge.pstyle('target-endpoint');
  var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;
  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;
  var p1; // last known point of edge on target side

  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape

  var p2_i; // point to intersect with source shape

  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);
    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if (tgtManEndptVal === 'inside-to-node') {
    intersect = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === 'outside-to-line') {
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {
      p1_i = p1;
    } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {
      p1_i = [srcPos.x, srcPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);

    if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {
      var trs = target._private.rscratch;
      var lw = trs.labelWidth;
      var lh = trs.labelHeight;
      var lx = trs.labelX;
      var ly = trs.labelY;
      var va = target.pstyle('text-valign').value;

      if (va === 'top') {
        ly -= lh / 2;
      } else if (va === 'bottom') {
        ly += lh / 2;
      }

      var ha = target.pstyle('text-halign').value;

      if (ha === 'left') {
        lx -= lw / 2;
      } else if (ha === 'right') {
        lx += lw / 2;
      }

      var labelIntersect = r.nodeShapes['rectangle'].intersectLine(lx, ly, lw, lh, p1_i[0], p1_i[1], 0);
      var refPt = srcPos;
      var intSqdist = sqdist(refPt, array2point(intersect));
      var labIntSqdist = sqdist(refPt, array2point(labelIntersect));

      if (labIntSqdist < intSqdist) {
        intersect = labelIntersect;
      }
    }
  }

  var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];
  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if (srcManEndptVal === 'inside-to-node') {
    intersect = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect = this.manualEndptToPx(source, srcManEndpt);
  } else if (srcManEndptVal === 'outside-to-line') {
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {
      p2_i = p2;
    } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {
      p2_i = [tgtPos.x, tgtPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);

    if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {
      var srs = source._private.rscratch;
      var _lw = srs.labelWidth;
      var _lh = srs.labelHeight;
      var _lx = srs.labelX;
      var _ly = srs.labelY;
      var _va = source.pstyle('text-valign').value;

      if (_va === 'top') {
        _ly -= _lh / 2;
      } else if (_va === 'bottom') {
        _ly += _lh / 2;
      }

      var _ha = source.pstyle('text-halign').value;

      if (_ha === 'left') {
        _lx -= _lw / 2;
      } else if (_ha === 'right') {
        _lx += _lw / 2;
      }

      var _labelIntersect = r.nodeShapes['rectangle'].intersectLine(_lx, _ly, _lw, _lh, p2_i[0], p2_i[1], 0);

      var _refPt = tgtPos;

      var _intSqdist = sqdist(_refPt, array2point(intersect));

      var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));

      if (_labIntSqdist < _intSqdist) {
        intersect = _labelIntersect;
      }
    }
  }

  var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];
  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if (hasEndpts) {
    if (!number(rs.startX) || !number(rs.startY) || !number(rs.endX) || !number(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp$4.getSourceEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };

    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};

BRp$4.getTargetEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };

    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};

var BRp$5 = {};

function pushBezierPts(r, edge, pts) {
  var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
    return qbezierAt(p1, p2, p3, t);
  };

  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for (var i = 0; i < r.bezierProjPcts.length; i++) {
    var p = r.bezierProjPcts[i];
    bpts.push({
      x: qbezierAt$1(pts[0], pts[2], pts[4], p),
      y: qbezierAt$1(pts[1], pts[3], pts[5], p)
    });
  }
}

BRp$5.storeEdgeProjections = function (edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType; // clear the cached points state

  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
    _p.rstyle.bezierPts = [];

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === 'segments') {
    var lpts = _p.rstyle.linePts = [];

    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === 'haystack') {
    var hpts = rs.haystackPts;
    _p.rstyle.haystackPts = [{
      x: hpts[0],
      y: hpts[1]
    }, {
      x: hpts[2],
      y: hpts[3]
    }];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
};

BRp$5.recalculateEdgeProjections = function (edges) {
  this.findEdgeControlPoints(edges);
};

var BRp$6 = {};

BRp$6.recalculateNodeLabelProjection = function (node) {
  var content = node.pstyle('label').strValue;

  if (emptyString(content)) {
    return;
  }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle('text-halign').strValue;
  var textValign = node.pstyle('text-valign').strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch (textHalign) {
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default:
      // e.g. center
      textX = nodePos.x;
  }

  switch (textValign) {
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default:
      // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;
  this.applyLabelDimensions(node);
};

var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
  var angle = Math.atan(dy / dx);

  if (dx === 0 && angle < 0) {
    angle = angle * -1;
  }

  return angle;
};

var lineAngle = function lineAngle(p0, p1) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  return lineAngleFromDelta(dx, dy);
};

var bezierAngle = function bezierAngle(p0, p1, p2, t) {
  var t0 = bound(0, t - 0.001, 1);
  var t1 = bound(0, t + 0.001, 1);
  var lp0 = qbezierPtAt(p0, p1, p2, t0);
  var lp1 = qbezierPtAt(p0, p1, p2, t1);
  return lineAngle(lp0, lp1);
};

BRp$6.recalculateEdgeLabelProjections = function (edge) {
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if (content.mid || content.source || content.target) ; else {
      return; // no labels => no calcs
    } // add center point to style so bounding box calculations can use it
  //


  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function setRs(propName, prefix, value) {
    setPrefixedProperty(_p.rscratch, propName, prefix, value);
    setPrefixedProperty(_p.rstyle, propName, prefix, value);
  };

  setRs('labelX', null, p.x);
  setRs('labelY', null, p.y);
  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
  setRs('labelAutoAngle', null, midAngle);

  var createControlPointInfo = function createControlPointInfo() {
    if (createControlPointInfo.cache) {
      return createControlPointInfo.cache;
    } // use cache so only 1x per edge


    var ctrlpts = []; // store each ctrlpt info init

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = {
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      };
      var p1 = {
        x: rs.allpts[i + 2],
        y: rs.allpts[i + 3]
      }; // ctrlpt

      var p2 = {
        x: rs.allpts[i + 4],
        y: rs.allpts[i + 5]
      };
      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment(cp, p0, p1, t0, t1) {
      var length = dist(p0, p1);
      var prevSegment = cp.segments[cp.segments.length - 1];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };
      cp.segments.push(segment);
      cp.length += length;
    } // update each ctrlpt with segment info


    for (var _i = 0; _i < ctrlpts.length; _i++) {
      var cp = ctrlpts[_i];
      var prevCp = ctrlpts[_i - 1];

      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first

      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
      }

      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
    }

    return createControlPointInfo.cache = ctrlpts;
  };

  var calculateEndProjection = function calculateEndProjection(prefix) {
    var angle;
    var isSrc = prefix === 'source';

    if (!content[prefix]) {
      return;
    }

    var offset = edge.pstyle(prefix + '-text-offset').pfValue;

    switch (rs.edgeType) {
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        {
          var cps = createControlPointInfo();
          var selected;
          var startDist = 0;
          var totalDist = 0; // find the segment we're on

          for (var i = 0; i < cps.length; i++) {
            var _cp = cps[isSrc ? i : cps.length - 1 - i];

            for (var j = 0; j < _cp.segments.length; j++) {
              var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
              var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
              startDist = totalDist;
              totalDist += _seg.length;

              if (totalDist >= offset || lastSeg) {
                selected = {
                  cp: _cp,
                  segment: _seg
                };
                break;
              }
            }

            if (selected) {
              break;
            }
          }

          var cp = selected.cp;
          var seg = selected.segment;
          var tSegment = (offset - startDist) / seg.length;
          var segDt = seg.t1 - seg.t0;
          var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
          t = bound(0, t, 1);
          p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
          angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
          break;
        }

      case 'straight':
      case 'segments':
      case 'haystack':
        {
          var d = 0,
              di,
              d0;
          var p0, p1;
          var l = rs.allpts.length;

          for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {
            if (isSrc) {
              p0 = {
                x: rs.allpts[_i2],
                y: rs.allpts[_i2 + 1]
              };
              p1 = {
                x: rs.allpts[_i2 + 2],
                y: rs.allpts[_i2 + 3]
              };
            } else {
              p0 = {
                x: rs.allpts[l - 2 - _i2],
                y: rs.allpts[l - 1 - _i2]
              };
              p1 = {
                x: rs.allpts[l - 4 - _i2],
                y: rs.allpts[l - 3 - _i2]
              };
            }

            di = dist(p0, p1);
            d0 = d;
            d += di;

            if (d >= offset) {
              break;
            }
          }

          var pD = offset - d0;

          var _t = pD / di;

          _t = bound(0, _t, 1);
          p = lineAt(p0, p1, _t);
          angle = lineAngle(p0, p1);
          break;
        }
    }

    setRs('labelX', prefix, p.x);
    setRs('labelY', prefix, p.y);
    setRs('labelAutoAngle', prefix, angle);
  };

  calculateEndProjection('source');
  calculateEndProjection('target');
  this.applyLabelDimensions(edge);
};

BRp$6.applyLabelDimensions = function (ele) {
  this.applyPrefixedLabelDimensions(ele);

  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, 'source');
    this.applyPrefixedLabelDimensions(ele, 'target');
  }
};

BRp$6.applyPrefixedLabelDimensions = function (ele, prefix) {
  var _p = ele._private;
  var text = this.getLabelText(ele, prefix);
  var labelDims = this.calculateLabelDimensions(ele, text);
  var lineHeight = ele.pstyle('line-height').pfValue;
  var textWrap = ele.pstyle('text-wrap').strValue;
  var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];
  var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);
  var normPerLineHeight = labelDims.height / numLines;
  var labelLineHeight = normPerLineHeight * lineHeight;
  var width = labelDims.width;
  var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
  setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);
};

BRp$6.getLabelText = function (ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle(pfd + 'label').strValue;
  var textTransform = ele.pstyle('text-transform').value;

  var rscratch = function rscratch(propName, value) {
    if (value) {
      setPrefixedProperty(_p.rscratch, propName, prefix, value);
      return value;
    } else {
      return getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  }; // for empty text, skip all processing


  if (!text) {
    return '';
  }

  if (textTransform == 'none') ; else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle('text-wrap').value;

  if (wrapStyle === 'wrap') {
    var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before

    if (labelKey != null && rscratch('labelWrapKey') === labelKey) {
      return rscratch('labelWrapCachedText');
    }

    var zwsp = "\u200B";
    var lines = text.split('\n');
    var maxW = ele.pstyle('text-max-width').pfValue;
    var overflow = ele.pstyle('text-overflow-wrap').value;
    var overflowAny = overflow === 'anywhere';
    var wrappedLines = [];
    var wordsRegex = /[\s\u200b]+/;
    var wordSeparator = overflowAny ? '' : ' ';

    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line);
      var lineW = lineDims.width;

      if (overflowAny) {
        var processedLine = line.split('').join(zwsp);
        line = processedLine;
      }

      if (lineW > maxW) {
        // line is too long
        var words = line.split(wordsRegex);
        var subline = '';

        for (var w = 0; w < words.length; w++) {
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + wordSeparator + word;
          var testDims = this.calculateLabelDimensions(ele, testLine);
          var testW = testDims.width;

          if (testW <= maxW) {
            // word fits on current line
            subline += word + wordSeparator;
          } else {
            // word starts new line
            if (subline) {
              wrappedLines.push(subline);
            }

            subline = word + wordSeparator;
          }
        } // if there's remaining text, put it in a wrapped line


        if (!subline.match(/^[\s\u200b]+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        // line is already short enough
        wrappedLines.push(line);
      }
    } // for


    rscratch('labelWrapCachedLines', wrappedLines);
    text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
    rscratch('labelWrapKey', labelKey);
  } else if (wrapStyle === 'ellipsis') {
    var _maxW = ele.pstyle('text-max-width').pfValue;
    var ellipsized = '';
    var ellipsis = "\u2026";
    var incLastCh = false;

    for (var i = 0; i < text.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

      if (widthWithNextCh > _maxW) {
        break;
      }

      ellipsized += text[i];

      if (i === text.length - 1) {
        incLastCh = true;
      }
    }

    if (!incLastCh) {
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize


  return text;
};

BRp$6.getLabelJustification = function (ele) {
  var justification = ele.pstyle('text-justification').strValue;
  var textHalign = ele.pstyle('text-halign').strValue;

  if (justification === 'auto') {
    if (ele.isNode()) {
      switch (textHalign) {
        case 'left':
          return 'right';

        case 'right':
          return 'left';

        default:
          return 'center';
      }
    } else {
      return 'center';
    }
  } else {
    return justification;
  }
};

BRp$6.calculateLabelDimensions = function (ele, text) {
  var r = this;
  var cacheKey = hashString(text, ele._private.labelDimsKey);
  var cache = r.labelDimCache || (r.labelDimCache = []);
  var existingVal = cache[cacheKey];

  if (existingVal != null) {
    return existingVal;
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text

  var fStyle = ele.pstyle('font-style').strValue;
  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  var weight = ele.pstyle('font-weight').strValue;
  var div = this.labelCalcDiv;

  if (!div) {
    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef

    document.body.appendChild(div); // eslint-disable-line no-undef
  }

  var ds = div.style; // from ele style

  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight; // forced style

  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if (ele.pstyle('text-wrap').value === 'wrap') {
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  } // put label content in div


  div.textContent = text;
  return cache[cacheKey] = {
    width: Math.ceil(div.clientWidth / sizeMult),
    height: Math.ceil(div.clientHeight / sizeMult)
  };
};

BRp$6.calculateLabelAngle = function (ele, prefix) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var prefixDash = prefix ? prefix + '-' : '';
  var rot = ele.pstyle(prefixDash + 'text-rotation');
  var rotStr = rot.strValue;

  if (rotStr === 'none') {
    return 0;
  } else if (isEdge && rotStr === 'autorotate') {
    return rs.labelAutoAngle;
  } else if (rotStr === 'autorotate') {
    return 0;
  } else {
    return rot.pfValue;
  }
};

BRp$6.calculateLabelAngles = function (ele) {
  var r = this;
  var isEdge = ele.isEdge();
  var _p = ele._private;
  var rs = _p.rscratch;
  rs.labelAngle = r.calculateLabelAngle(ele);

  if (isEdge) {
    rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');
    rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');
  }
};

var BRp$7 = {};
var TOO_SMALL_CUT_RECT = 28;
var warnedCutRect = false;

BRp$7.getNodeShape = function (node) {
  var r = this;
  var shape = node.pstyle('shape').value;

  if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
    if (!warnedCutRect) {
      warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');
      warnedCutRect = true;
    }

    return 'rectangle';
  }

  if (node.isParent()) {
    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if (shape === 'polygon') {
    var points = node.pstyle('shape-polygon-points').value;
    return r.nodeShapes.makePolygon(points).name;
  }

  return shape;
};

var BRp$8 = {};

BRp$8.registerCalculationListeners = function () {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function enqueue(eles) {
    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    elesToUpdate.merge(eles);

    if (dirtyStyleCaches) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle;
        rstyle.clean = false;
        rstyle.cleanConnected = false;
      }
    }
  };

  r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {
    var ele = e.target;
    enqueue(ele);
  }).on('style.* background.*', function onDirtyStyle(e) {
    var ele = e.target;
    enqueue(ele, false);
  });

  var updateEleCalcs = function updateEleCalcs(willDraw) {
    if (willDraw) {
      var fns = r.onUpdateEleCalcsFns;

      for (var i = 0; i < elesToUpdate.length; i++) {
        var ele = elesToUpdate[i];
        var rstyle = ele._private.rstyle;

        if (ele.isNode() && !rstyle.cleanConnected) {
          enqueue(ele.connectedEdges());
          rstyle.cleanConnected = true;
        }
      }

      if (fns) {
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];
          fn(willDraw, elesToUpdate);
        }
      }

      r.recalculateRenderedStyle(elesToUpdate);
      elesToUpdate = cy.collection();
    }
  };

  r.flushRenderedStyleQueue = function () {
    updateEleCalcs(true);
  };

  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};

BRp$8.onUpdateEleCalcs = function (fn) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  fns.push(fn);
};

BRp$8.recalculateRenderedStyle = function (eles, useCache) {
  var edges = [];
  var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()

  if (this.destroyed) {
    return;
  } // use cache by default for perf


  if (useCache === undefined) {
    useCache = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle; // only update if dirty and in graph

    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    } // only update if not display: none


    if (ele.pstyle('display').value === 'none') {
      continue;
    }

    if (_p.group === 'nodes') {
      nodes.push(ele);
    } else {
      // edges
      edges.push(ele);
    }

    rstyle.clean = true;
  } // update node data from projections


  for (var i = 0; i < nodes.length; i++) {
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = ele.position();
    this.recalculateNodeLabelProjection(ele);
    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle('width').pfValue;
    rstyle.nodeH = ele.pstyle('height').pfValue;
  }

  this.recalculateEdgeProjections(edges); // update edge data from projections

  for (var i = 0; i < edges.length; i++) {
    var ele = edges[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch; // update rstyle positions

    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

var BRp$9 = {};

BRp$9.updateCachedGrabbedEles = function () {
  var eles = this.cachedZSortedEles;

  if (!eles) {
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];
  var grabTargets = [];

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  } // put the grab target nodes last so it's on top of its neighbourhood


  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];
    eles.drag.push(ele);
  }
};

BRp$9.invalidateCachedZSortedEles = function () {
  this.cachedZSortedEles = null;
};

BRp$9.getCachedZSortedEles = function (forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    var eles = this.cy.mutableElements().toArray();
    eles.sort(zIndexSort);
    eles.interactive = eles.filter(function (ele) {
      return ele.interactive();
    });
    this.cachedZSortedEles = eles;
    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

var BRp$a = {};
[BRp$1, BRp$2, BRp$3, BRp$4, BRp$5, BRp$6, BRp$7, BRp$8, BRp$9].forEach(function (props) {
  extend(BRp$a, props);
});

var BRp$b = {};

BRp$b.getCachedImage = function (url, crossOrigin, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[url];

  if (cache) {
    if (!cache.image.complete) {
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[url] = imageCache[url] || {};
    var image = cache.image = new Image(); // eslint-disable-line no-undef

    image.addEventListener('load', onLoad);
    image.addEventListener('error', function () {
      image.error = true;
    }); // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978

    var dataUriPrefix = 'data:';
    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;

    if (!isDataUri) {
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;
    return image;
  }
};

var BRp$c = {};
/* global document, window, ResizeObserver, MutationObserver */

BRp$c.registerBinding = function (target, event, handler, useCapture) {
  // eslint-disable-line no-unused-vars
  var args = Array.prototype.slice.apply(arguments, [1]); // copy

  var b = this.binder(target);
  return b.on.apply(b, args);
};

BRp$c.binder = function (tgt) {
  var r = this;
  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);

  if (r.supportsPassiveEvents == null) {
    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
          return true;
        }
      });
      window.addEventListener('test', null, opts);
    } catch (err) {// not supported
    }

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function on(event, handler, useCapture) {
    var args = Array.prototype.slice.call(arguments);

    if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });
    (tgt.addEventListener || tgt.on).apply(tgt, args);
    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp$c.nodeIsDraggable = function (node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};

BRp$c.nodeIsGrabbable = function (node) {
  return this.nodeIsDraggable(node) && node.interactive();
};

BRp$c.load = function () {
  var r = this;

  var isSelected = function isSelected(ele) {
    return ele.selected();
  };

  var triggerEvents = function triggerEvents(target, names, e, position) {
    if (target == null) {
      target = r.cy;
    }

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      target.emit({
        originalEvent: e,
        type: name,
        position: position
      });
    }
  };

  var isMultSelKeyDown = function isMultSelKeyDown(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
    var allowPassthrough = true;

    if (r.cy.hasCompoundNodes() && down && down.pannable()) {
      // a grabbable compound node below the ele => no passthrough panning
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];

        if (down.isNode() && down.isParent()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var setGrabbed = function setGrabbed(ele) {
    ele[0]._private.grabbed = true;
  };

  var setFreed = function setFreed(ele) {
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function setInDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function setOutDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function setGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function removeGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function addToDragList(ele, opts) {
    var list = opts.addToList;
    var listHasEle = list.has(ele);

    if (!listHasEle) {
      list.merge(ele);
      setGrabbed(ele);
    }
  }; // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes


  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    var innerNodes = node.descendants();

    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }

    if (opts.addToList) {
      opts.addToList.unmerge(innerNodes);
    }
  }; // adds the given nodes and its neighbourhood to the drag layer


  var addNodesToDrag = function addNodesToDrag(nodes, opts) {
    opts = opts || {};
    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if (opts.inDragLayer) {
      nodes.forEach(setInDragLayer);
      nodes.neighborhood().stdFilter(function (ele) {
        return !hasCompoundNodes || ele.isEdge();
      }).forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }

    addDescendantsToDrag(nodes, opts); // always add to drag
    // also add nodes and edges related to the topmost ancestor

    updateAncestorsInDragLayer(nodes, {
      inDragLayer: opts.inDragLayer
    });
    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function freeDraggedElements(grabbedEles) {
    if (!grabbedEles) {
      return;
    } // just go over all elements rather than doing a bunch of (possibly expensive) traversals


    r.getCachedZSortedEles().forEach(function (ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });
    r.updateCachedGrabbedEles();
  }; // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).


  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    if (!node.cy().hasCompoundNodes()) {
      return;
    } // find top-level parent


    var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer

    if (parent.same(node)) {
      return;
    }

    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
    var edges = nodes.connectedEdges();

    if (opts.inDragLayer) {
      edges.forEach(setInDragLayer);
      nodes.forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  var blurActiveDomElement = function blurActiveDomElement() {
    if (document.activeElement != null && document.activeElement.blur != null) {
      document.activeElement.blur();
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';
  var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom

  if (haveMutationsApi) {
    r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];

            if (rNode === r.container) {
              r.destroy();
              break;
            }
          }
        }
      }
    });

    if (r.container.parentNode) {
      r.removeObserver.observe(r.container.parentNode, {
        childList: true
      });
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      // eslint-disable-line no-unused-vars
      r.destroy();
    });
  }

  var onResize = util(function () {
    r.cy.resize();
  }, 100);

  if (haveMutationsApi) {
    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

    r.styleObserver.observe(r.container, {
      attributes: true
    });
  } // auto resize


  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

  if (haveResizeObserverApi) {
    r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef

    r.resizeObserver.observe(r.container);
  }

  var forEachUp = function forEachUp(domEle, fn) {
    while (domEle != null) {
      fn(domEle);
      domEle = domEle.parentNode;
    }
  };

  var invalidateCoords = function invalidateCoords() {
    r.invalidateContainerClientCoordsCache();
  };

  forEachUp(r.container, function (domEle) {
    r.registerBinding(domEle, 'transitionend', invalidateCoords);
    r.registerBinding(domEle, 'animationend', invalidateCoords);
    r.registerBinding(domEle, 'scroll', invalidateCoords);
  }); // stop right click menu from appearing on cy

  r.registerBinding(r.container, 'contextmenu', function (e) {
    e.preventDefault();
  });

  var inBoxSelection = function inBoxSelection() {
    return r.selection[4] !== 0;
  };

  var eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];
    var positions = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];

      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
        atLeastOnePosInside = true;
        break;
      }
    }

    if (!atLeastOnePosInside) {
      return false;
    }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while (tParent) {
      if (tParent === container) {
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if (!containerIsTarget) {
      return false;
    } // if target is outisde cy container, then this event is not for us


    return true;
  }; // Primary key


  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    e.preventDefault();
    blurActiveDomElement();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;
    var cy = r.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var select = r.selection;
    var nears = r.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;
    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function checkForTaphold() {
      r.hoverData.tapholdCancelled = false;
      clearTimeout(r.hoverData.tapholdTimeout);
      r.hoverData.tapholdTimeout = setTimeout(function () {
        if (r.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r.hoverData.down;

          if (ele) {
            ele.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          } else {
            cy.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      }, r.tapholdDuration);
    }; // Right click button


    if (e.which == 3) {
      r.hoverData.cxtStarted = true;
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapstart',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (near) {
        near.activate();
        near.emit(cxtEvt);
        r.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }

      r.hoverData.downTime = new Date().getTime();
      r.hoverData.cxtDragged = false; // Primary button
    } else if (e.which == 1) {
      if (near) {
        near.activate();
      } // Element dragging


      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {
          if (r.nodeIsGrabbable(near)) {
            var makeEvent = function makeEvent(type) {
              return {
                originalEvent: e,
                type: type,
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              };
            };

            var triggerGrab = function triggerGrab(ele) {
              ele.emit(makeEvent('grab'));
            };

            setGrabTarget(near);

            if (!near.selected()) {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              addNodeToDrag(near, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
            } else {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              var selectedNodes = cy.$(function (ele) {
                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
              });
              addNodesToDrag(selectedNodes, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon'));
              selectedNodes.forEach(triggerGrab);
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }
        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = new Date().getTime();
      }
      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (near == null) {
        select[4] = 1;
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } else if (near.pannable()) {
        select[4] = 1; // for future pan
      }

      checkForTaphold();
    } // Initialize selection box coordinates


    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, false);
  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;
    var near = null;

    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }

    var last = r.hoverData.last;
    var down = r.hoverData.down;
    var disp = [pos[0] - select[2], pos[1] - select[3]];
    var draggedElements = r.dragData.possibleDragElements;
    var isOverThresholdDrag;

    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown(e);

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function updateDragDelta() {
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if (dragDelta.length === 0) {
        dragDelta.push(disp[0]);
        dragDelta.push(disp[1]);
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };

    preventDefault = true;
    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      x: pos[0],
      y: pos[1]
    });

    var goIntoBoxMode = function goIntoBoxMode() {
      r.data.bgActivePosistion = undefined;

      if (!r.hoverData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: pos[0],
            y: pos[1]
          }
        });
      }

      select[4] = 1;
      r.hoverData.selecting = true;
      r.redrawHint('select', true);
      r.redraw();
    }; // trigger context drag if rmouse down


    if (r.hoverData.which === 3) {
      // but only if over threshold
      if (isOverThresholdDrag) {
        var cxtEvt = {
          originalEvent: e,
          type: 'cxtdrag',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }

        r.hoverData.cxtDragged = true;

        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
          if (r.hoverData.cxtOver) {
            r.hoverData.cxtOver.emit({
              originalEvent: e,
              type: 'cxtdragout',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }

          r.hoverData.cxtOver = near;

          if (near) {
            near.emit({
              originalEvent: e,
              type: 'cxtdragover',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      } // Check if we are drag panning the entire graph

    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;

        if (r.hoverData.justStartedPan) {
          var mdPos = r.hoverData.mdownPos;
          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom,
            y: (pos[1] - mdPos[1]) * zoom
          };
          r.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };
        }

        cy.panBy(deltaP);
        r.hoverData.dragged = true;
      } // Needs reproject due to pan changing viewport


      pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
    } else if (select[4] == 1 && (down == null || down.pannable())) {
      if (isOverThresholdDrag) {
        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

          if (allowPassthrough) {
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;
            r.data.bgActivePosistion = array2point(mdownPos);
            r.redrawHint('select', true);
            r.redraw();
          }
        }

        if (down && down.pannable() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.pannable() && down.active()) {
        down.unactivate();
      }

      if ((!down || !down.grabbed()) && near != last) {
        if (last) {
          triggerEvents(last, ['mouseout', 'tapdragout'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        if (near) {
          triggerEvents(near, ['mouseover', 'tapdragover'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        r.hoverData.last = near;
      }

      if (down) {
        if (isOverThresholdDrag) {
          // then we can take action
          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);
              down.emit('freeon');
              draggedElements.emit('free');

              if (r.dragData.didDrag) {
                down.emit('dragfreeon');
                draggedElements.emit('dragfree');
              }
            }

            goIntoBoxMode();
          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              r.redrawHint('eles', true);
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = cy.collection(); // now, add the elements to the drag layer if not done already

            if (!r.hoverData.draggingEles) {
              addNodesToDrag(draggedElements, {
                inDragLayer: true
              });
            }

            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                var dragDelta = r.hoverData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            for (var i = 0; i < draggedElements.length; i++) {
              var dEle = draggedElements[i];

              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                toTrigger.merge(dEle);
              }
            }

            r.hoverData.draggingEles = true;
            toTrigger.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);
            r.redraw();
          }
        } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      } // prevent the dragging from triggering text selection on the page


      preventDefault = true;
    }

    select[2] = pos[0];
    select[3] = pos[1];

    if (preventDefault) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, false);
  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture) {
      return;
    }

    r.hoverData.capture = false;
    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;
    var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);

    if (r.data.bgActivePosistion) {
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;
    r.data.bgActivePosistion = undefined; // not active bg now

    if (down) {
      down.unactivate();
    }

    if (r.hoverData.which === 3) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (!r.hoverData.cxtDragged) {
        var cxtTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;
    } else if (r.hoverData.which === 1) {
      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
      ) {
          triggerEvents(down, ['click', 'tap', 'vclick'], e, {
            x: pos[0],
            y: pos[1]
          });
        } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something


      if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {
        cy.$(isSelected).unselect(['tapunselect']);

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = cy.collection();
      } // Single selection


      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
        if (near != null && near._private.selectable) {
          if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {
            if (near.selected()) {
              near.unselect(['tapunselect']);
            } else {
              near.select(['tapselect']);
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(isSelected).unmerge(near).unselect(['tapunselect']);
              near.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if (r.hoverData.selecting) {
        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
        r.redrawHint('select', true);

        if (box.length > 0) {
          r.redrawHint('eles', true);
        }

        cy.emit({
          type: 'boxend',
          originalEvent: e,
          position: {
            x: pos[0],
            y: pos[1]
          }
        });

        var eleWouldBeSelected = function eleWouldBeSelected(ele) {
          return ele.selectable() && !ele.selected();
        };

        if (cy.selectionType() === 'additive') {
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } else {
          if (!multSelKeyDown) {
            cy.$(isSelected).unmerge(box).unselect();
          }

          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } // always need redraw in case eles unselectable


        r.redraw();
      } // Cancel drag pan


      if (r.hoverData.dragging) {
        r.hoverData.dragging = false;
        r.redrawHint('select', true);
        r.redrawHint('eles', true);
        r.redraw();
      }

      if (!select[4]) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);
        var downWasGrabbed = down && down.grabbed();
        freeDraggedElements(draggedElements);

        if (downWasGrabbed) {
          down.emit('freeon');
          draggedElements.emit('free');

          if (r.dragData.didDrag) {
            down.emit('dragfreeon');
            draggedElements.emit('dragfree');
          }
        }
      }
    } // else not right mouse


    select[4] = 0;
    r.hoverData.down = null;
    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.hoverData.isOverThresholdDrag = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;
  }, false);

  var wheelHandler = function wheelHandler(e) {
    if (r.scrollingPage) {
      return;
    } // while scrolling, ignore wheel-to-zoom


    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();
      r.data.wheelZooming = true;
      clearTimeout(r.data.wheelTimeout);
      r.data.wheelTimeout = setTimeout(function () {
        r.data.wheelZooming = false;
        r.redrawHint('eles', true);
        r.redraw();
      }, 150);
      var diff;

      if (e.deltaY != null) {
        diff = e.deltaY / -250;
      } else if (e.wheelDeltaY != null) {
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;
      var needsWheelFix = e.deltaMode === 1;

      if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: {
          x: rpos[0],
          y: rpos[1]
        }
      });
    }
  }; // Functions to help with whether mouse wheel should trigger zooming
  // --


  r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-unused-vars
    r.scrollingPage = true;
    clearTimeout(r.scrollingPageTimeout);
    r.scrollingPageTimeout = setTimeout(function () {
      r.scrollingPage = false;
    }, 250);
  }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container

  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseout',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseover',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom

  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom

  var center1, modelCenter1; // center point on start pinch to zoom

  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  var distanceSq = function distanceSq(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    blurActiveDomElement();
    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    } // record starting points for pinch-to-zoom


    if (e.touches[1]) {
      r.touchData.singleTouchMoved = true;
      freeDraggedElements(r.dragData.touchDragEles);
      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];
      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;
      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;
      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
      var pan = cy.pan();
      var zoom = cy.zoom();
      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap

      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;

      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if (near1 && near1.isNode()) {
          near1.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near2;
        } else {
          cy.emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        if (r.touchData.start) {
          r.touchData.start._private.grabbed = false;
        }

        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;
        r.redraw();
        return;
      }
    }

    if (e.touches[2]) {
      // ignore
      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
      if (cy.boxSelectionEnabled()) {
        e.preventDefault();
      }
    } else if (e.touches[1]) ; else if (e.touches[0]) {
      var nears = r.findNearestElements(now[0], now[1], true, true);
      var near = nears[0];

      if (near != null) {
        near.activate();
        r.touchData.start = near;
        r.touchData.starts = nears;

        if (r.nodeIsGrabbable(near)) {
          var draggedEles = r.dragData.touchDragEles = cy.collection();
          var selectedNodes = null;
          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if (near.selected()) {
            // reset drag elements, since near will be added again
            selectedNodes = cy.$(function (ele) {
              return ele.selected() && r.nodeIsGrabbable(ele);
            });
            addNodesToDrag(selectedNodes, {
              addToList: draggedEles
            });
          } else {
            addNodeToDrag(near, {
              addToList: draggedEles
            });
          }

          setGrabTarget(near);

          var makeEvent = function makeEvent(type) {
            return {
              originalEvent: e,
              type: type,
              position: {
                x: now[0],
                y: now[1]
              }
            };
          };

          near.emit(makeEvent('grabon'));

          if (selectedNodes) {
            selectedNodes.forEach(function (n) {
              n.emit(makeEvent('grab'));
            });
          } else {
            near.emit(makeEvent('grab'));
          }
        }
      }

      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        x: now[0],
        y: now[1]
      });

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } // Tap, taphold
      // -----


      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();
      clearTimeout(r.touchData.tapholdTimeout);
      r.touchData.tapholdTimeout = setTimeout(function () {
        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
        ) {
            triggerEvents(r.touchData.start, ['taphold'], e, {
              x: now[0],
              y: now[1]
            });
          }
      }, r.tapholdDuration);
    }

    if (e.touches.length >= 1) {
      var sPos = r.touchData.startPosition = [];

      for (var i = 0; i < now.length; i++) {
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];
      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, false);
  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if (capture && e.touches[0] && startGPos) {
      var disp = [];

      for (var j = 0; j < now.length; j++) {
        disp[j] = now[j] - earlier[j];
      }

      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    } // context swipe cancelling


    if (capture && r.touchData.cxt) {
      e.preventDefault();
      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );

      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;
      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases

      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r.touchData.cxt = false;
        r.data.bgActivePosistion = undefined;
        r.redrawHint('select', true);
        var cxtEvt = {
          originalEvent: e,
          type: 'cxttapend',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (r.touchData.start) {
          r.touchData.start.unactivate().emit(cxtEvt);
          r.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    } // context swipe


    if (capture && r.touchData.cxt) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxtdrag',
        position: {
          x: now[0],
          y: now[1]
        }
      };
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if (r.touchData.start) {
        r.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxtDragged = true;
      var near = r.findNearestElement(now[0], now[1], true, true);

      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
        if (r.touchData.cxtOver) {
          r.touchData.cxtOver.emit({
            originalEvent: e,
            type: 'cxtdragout',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        r.touchData.cxtOver = near;

        if (near) {
          near.emit({
            originalEvent: e,
            type: 'cxtdragover',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }
      } // box selection

    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      this.lastThreeTouch = +new Date();

      if (!r.touchData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: now[0],
            y: now[1]
          }
        });
      }

      r.touchData.selecting = true;
      r.touchData.didSelect = true;
      select[4] = 1;

      if (!select || select.length === 0 || select[0] === undefined) {
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      r.redrawHint('select', true);
      r.redraw(); // pinch to zoom
    } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (draggedEles) {
        r.redrawHint('drag', true);

        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;
          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2

      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;
      var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );

      var factor = distance2 / distance1;

      if (twoFingersStartInside) {
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1; // delta finger 2

        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans

        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2; // now calculate the zoom

        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan(); // the model center point converted to the current rendered pos

        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;
        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        }; // remove dragged eles

        if (_start && _start.active()) {
          var draggedEles = r.dragData.touchDragEles;
          freeDraggedElements(draggedEles);
          r.redrawHint('drag', true);
          r.redrawHint('eles', true);

          _start.unactivate().emit('freeon');

          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            _start.emit('dragfreeon');

            draggedEles.emit('dragfree');
          }
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });
        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;
        r.pinching = true;
      } // Re-project


      if (e.touches[0]) {
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0];
        now[1] = pos[1];
      }

      if (e.touches[1]) {
        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
        now[2] = pos[0];
        now[3] = pos[1];
      }

      if (e.touches[2]) {
        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
        now[4] = pos[0];
        now[5] = pos[1];
      }
    } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
    ) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near;

        if (!r.hoverData.draggingEles && !r.swipePanning) {
          near = r.findNearestElement(now[0], now[1], true, true);
        }

        if (capture && start != null) {
          e.preventDefault();
        } // dragging nodes


        if (capture && start != null && r.nodeIsDraggable(start)) {
          if (isOverThresholdDrag) {
            // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              addNodesToDrag(draggedEles, {
                inDragLayer: true
              });
            }

            r.dragData.didDrag = true;
            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                r.redrawHint('eles', true);
                var dragDelta = r.touchData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            r.hoverData.draggingEles = true;
            draggedEles.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);

            if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          } else {
            // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        } // touchmove


        {
          triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
            x: now[0],
            y: now[1]
          });

          if ((!start || !start.grabbed()) && near != last) {
            if (last) {
              last.emit({
                originalEvent: e,
                type: 'tapdragout',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }

            if (near) {
              near.emit({
                originalEvent: e,
                type: 'tapdragover',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
          }

          r.touchData.last = near;
        } // check to cancel taphold

        if (capture) {
          for (var i = 0; i < now.length; i++) {
            if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {
              r.touchData.singleTouchMoved = true;
            }
          }
        } // panning


        if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

          if (allowPassthrough) {
            e.preventDefault();

            if (!r.data.bgActivePosistion) {
              r.data.bgActivePosistion = array2point(r.touchData.startPosition);
            }

            if (r.swipePanning) {
              cy.panBy({
                x: disp[0] * zoom,
                y: disp[1] * zoom
              });
            } else if (isOverThresholdDrag) {
              r.swipePanning = true;
              cy.panBy({
                x: dx * zoom,
                y: dy * zoom
              });

              if (start) {
                start.unactivate();
                r.redrawHint('select', true);
                r.touchData.start = null;
              }
            }
          } // Re-project


          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
      }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning


    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      r.redraw();
    }
  }, false);
  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    r.touchData.capture = false;

    if (start) {
      start.unactivate();
    }
  });
  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    var capture = r.touchData.capture;

    if (capture) {
      if (e.touches.length === 0) {
        r.touchData.capture = false;
      }

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;
    r.swipePanning = false;
    r.hoverData.draggingEles = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    if (start) {
      start.unactivate();
    }

    var ctxTapend;

    if (r.touchData.cxt) {
      ctxTapend = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: now[0],
          y: now[1]
        }
      };

      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }

      if (!r.touchData.cxtDragged) {
        var ctxTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxt = false;
      r.touchData.start = null;
      r.redraw();
      return;
    } // no more box selection if we don't have three fingers


    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
      r.touchData.selecting = false;
      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;
      r.redrawHint('select', true);
      cy.emit({
        type: 'boxend',
        originalEvent: e,
        position: {
          x: now[0],
          y: now[1]
        }
      });

      var eleWouldBeSelected = function eleWouldBeSelected(ele) {
        return ele.selectable() && !ele.selected();
      };

      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

      if (box.nonempty()) {
        r.redrawHint('eles', true);
      }

      r.redraw();
    }

    if (start != null) {
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (start != null) {
        var startWasGrabbed = start._private.grabbed;
        freeDraggedElements(draggedEles);
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if (startWasGrabbed) {
          start.emit('freeon');
          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            start.emit('dragfreeon');
            draggedEles.emit('dragfree');
          }
        }

        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
        start.unactivate();
        r.touchData.start = null;
      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);
        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch

      if (!r.touchData.singleTouchMoved) {
        if (!start) {
          cy.$(':selected').unselect(['tapunselect']);
        }

        triggerEvents(start, ['tap', 'vclick'], e, {
          x: now[0],
          y: now[1]
        });
      } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance


      if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
      ) {
          if (cy.selectionType() === 'single') {
            cy.$(isSelected).unmerge(start).unselect(['tapunselect']);
            start.select(['tapselect']);
          } else {
            if (start.selected()) {
              start.unselect(['tapunselect']);
            } else {
              start.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }

      r.touchData.singleTouchMoved = true;
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }

    r.dragData.didDrag = false; // reset for next touchstart

    if (e.touches.length === 0) {
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
      r.touchData.didSelect = false;
    }

    if (e.touches.length < 2) {
      if (e.touches.length === 1) {
        // the old start global pos'n may not be the same finger that remains
        r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
      }

      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    } //r.redraw();

  }, false); // fallback compatibility layer for ms pointer events

  if (typeof TouchEvent === 'undefined') {
    var pointers = [];

    var makeTouch = function makeTouch(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function makePointer(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function addPointer(e) {
      pointers.push(makePointer(e));
    };

    var removePointer = function removePointer(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p = pointers[i];

        if (p.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    };

    var updatePointer = function updatePointer(e) {
      var p = pointers.filter(function (p) {
        return p.event.pointerId === e.pointerId;
      })[0];
      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function addTouchesToEvent(e) {
      e.touches = pointers.map(function (p) {
        return p.touch;
      });
    };

    var pointerIsMouse = function pointerIsMouse(e) {
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      addPointer(e);
      addTouchesToEvent(e);
      touchstartHandler(e);
    });
    r.registerBinding(r.container, 'pointerup', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchendHandler(e);
    });
    r.registerBinding(r.container, 'pointercancel', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchcancelHandler(e);
    });
    r.registerBinding(r.container, 'pointermove', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      updatePointer(e);
      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};

var BRp$d = {};

BRp$d.generatePolygon = function (name, points) {
  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: points,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
    }
  };
};

BRp$d.generateEllipse = function () {
  return this.nodeShapes['ellipse'] = {
    renderer: this,
    name: 'ellipse',
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return checkInEllipse(x, y, width, height, centerX, centerY, padding);
    }
  };
};

BRp$d.generateRoundPolygon = function (name, points) {
  // Pre-compute control points
  // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
  // the unit vectors.
  // For simplicity the layout will be:
  // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
  var allPoints = new Array(points.length * 2);

  for (var i = 0; i < points.length / 2; i++) {
    var sourceIndex = i * 2;
    var destIndex = void 0;

    if (i < points.length / 2 - 1) {
      destIndex = (i + 1) * 2;
    } else {
      destIndex = 0;
    }

    allPoints[i * 4] = points[sourceIndex];
    allPoints[i * 4 + 1] = points[sourceIndex + 1];
    var xDest = points[destIndex] - points[sourceIndex];
    var yDest = points[destIndex + 1] - points[sourceIndex + 1];
    var norm = Math.sqrt(xDest * xDest + yDest * yDest);
    allPoints[i * 4 + 2] = xDest / norm;
    allPoints[i * 4 + 3] = yDest / norm;
  }

  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: allPoints,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
    }
  };
};

BRp$d.generateRoundRectangle = function () {
  return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {
    renderer: this,
    name: 'round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = cornerRadius * 2; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // Check top left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check top right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.generateCutRectangle = function () {
  return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {
    renderer: this,
    name: 'cut-rectangle',
    cornerLength: getCutRectangleCornerLength(),
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]

      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
        return true;
      }

      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
    }
  };
};

BRp$d.generateBarrel = function () {
  return this.nodeShapes['barrel'] = {
    renderer: this,
    name: 'barrel',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      // use two fixed t values for the bezier curve approximation
      var t0 = 0.15;
      var t1 = 0.5;
      var t2 = 0.85;
      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
        // approximate curve pts based on the two t values
        var m0 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t0);
        var m1 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t1);
        var m2 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t2);
        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
      };

      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]

      var pts = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };
      pts.topLeft.isTop = true;
      pts.topRight.isTop = true;
      pts.bottomLeft.isBottom = true;
      pts.bottomRight.isBottom = true;
      return pts;
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
        return true;
      }

      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

      var getCurveT = function getCurveT(x, y, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x2 = curvePts[0];
        var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];

        var y2 = curvePts[1];
        var xMin = Math.min(x0, x2);
        var xMax = Math.max(x0, x2);
        var yMin = Math.min(y0, y2);
        var yMax = Math.max(y0, y2);

        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
          var coeff = bezierPtsToQuadCoeff(x0, x1, x2);
          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
          var validRoots = roots.filter(function (r) {
            return 0 <= r && r <= 1;
          });

          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }

        return null;
      };

      var curveRegions = Object.keys(barrelCurvePts);

      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x, y, cornerPts);

        if (t == null) {
          continue;
        }

        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y2 = cornerPts[1];
        var bezY = qbezierAt(y0, y1, y2, t);

        if (cornerPts.isTop && bezY <= y) {
          return true;
        }

        if (cornerPts.isBottom && y <= bezY) {
          return true;
        }
      }

      return false;
    }
  };
};

BRp$d.generateBottomRoundrectangle = function () {
  return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {
    renderer: this,
    name: 'bottom-round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var topStartX = nodeX - (width / 2 + padding);
      var topStartY = nodeY - (height / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width / 2 + padding);
      var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

      if (topIntersections.length > 0) {
        return topIntersections;
      }

      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = 2 * cornerRadius; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // check non-rounded top side


      var outerWidth = width / 2 + 2 * padding;
      var outerHeight = height / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];

      if (pointInsidePolygonPoints(x, y, points)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.registerNodeShapes = function () {
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;
  this.generateEllipse();
  this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes['square'] = nodeShapes['rectangle'];
  this.generateRoundRectangle();
  this.generateCutRectangle();
  this.generateBarrel();
  this.generateBottomRoundrectangle();
  {
    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon('diamond', diamondPoints);
    this.generateRoundPolygon('round-diamond', diamondPoints);
  }
  this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));
  this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));
  var star5Points = new Array(20);
  {
    var outerPoints = generateUnitNgonPoints(5, 0);
    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller

    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }

    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }
  star5Points = fitPolygonToSquare(star5Points);
  this.generatePolygon('star', star5Points);
  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);
  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
  this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon('tag', tagPoints);
    this.generateRoundPolygon('round-tag', tagPoints);
  }

  nodeShapes.makePolygon = function (points) {
    // use caching on user-specified polygons so they are as fast as native shapes
    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if (shape = this[name]) {
      // got cached shape
      return shape;
    } // create and cache new shape


    return renderer.generatePolygon(name, points);
  };
};

var BRp$e = {};

BRp$e.timeToRender = function () {
  return this.redrawTotalTime / this.redrawCount;
};

BRp$e.redraw = function (options) {
  options = options || staticEmptyObject();
  var r = this;

  if (r.averageRedrawTime === undefined) {
    r.averageRedrawTime = 0;
  }

  if (r.lastRedrawTime === undefined) {
    r.lastRedrawTime = 0;
  }

  if (r.lastDrawTime === undefined) {
    r.lastDrawTime = 0;
  }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp$e.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
  if (this.destroyed) {
    return;
  }

  if (priority == null) {
    error('Priority is not optional for beforeRender');
  }

  var cbs = this.beforeRenderCallbacks;
  cbs.push({
    fn: fn,
    priority: priority
  }); // higher priority callbacks executed first

  cbs.sort(function (a, b) {
    return b.priority - a.priority;
  });
};

var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
  var cbs = r.beforeRenderCallbacks;

  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
};

BRp$e.startRenderLoop = function () {
  var r = this;
  var cy = r.cy;

  if (r.renderLoopStarted) {
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function renderFn(requestTime) {
    if (r.destroyed) {
      return;
    }

    if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {
      beforeRenderCallbacks(r, true, requestTime);
      var startTime = performanceNow();
      r.render(r.renderOptions);
      var endTime = r.lastDrawTime = performanceNow();

      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = endTime - startTime;
      }

      if (r.redrawCount === undefined) {
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if (r.redrawTotalTime === undefined) {
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;
      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily

      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r, false, requestTime);
    }

    r.skipFrame = false;
    requestAnimationFrame(renderFn);
  };

  requestAnimationFrame(renderFn);
};

var BaseRenderer = function BaseRenderer(options) {
  this.init(options);
};

var BR = BaseRenderer;
var BRp$f = BR.prototype;
BRp$f.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

BRp$f.init = function (options) {
  var r = this;
  r.options = options;
  r.cy = options.cy;
  var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that

  if (window$1) {
    var document = window$1.document;
    var head = document.head;
    var stylesheetId = '__________cytoscape_stylesheet';
    var className = '__________cytoscape_container';
    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || '') + ' ' + className;
    }

    if (!stylesheetAlreadyExists) {
      var stylesheet = document.createElement('style');
      stylesheet.id = stylesheetId;
      stylesheet.innerHTML = '.' + className + ' { position: relative; }';
      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
    }

    var computedStyle = window$1.getComputedStyle(ctr);
    var position = computedStyle.getPropertyValue('position');

    if (position === 'static') {
      warn('A Cytoscape container has style position:static and so can not use UI extensions properly');
    }
  }

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data

  r.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: false,
    initialPan: [null, null],
    capture: false
  };
  r.dragData = {
    possibleDragElements: []
  };
  r.touchData = {
    start: null,
    capture: false,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };
  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;
  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default

  r.forcedPixelRatio = number(options.pixelRatio) ? options.pixelRatio : null;
  r.motionBlur = options.motionBlur; // for initial kick off

  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;

  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;
  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  };
  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
};

BRp$f.notify = function (eventName, eles) {
  var r = this;
  var cy = r.cy; // the renderer can't be notified after it's destroyed

  if (this.destroyed) {
    return;
  }

  if (eventName === 'init') {
    r.load();
    return;
  }

  if (eventName === 'destroy') {
    r.destroy();
    return;
  }

  if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {
    r.invalidateCachedZSortedEles();
  }

  if (eventName === 'viewport') {
    r.redrawHint('select', true);
  }

  if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize(r.container);
  }

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  this.startRenderLoop();
  this.redraw();
};

BRp$f.destroy = function () {
  var r = this;
  r.destroyed = true;
  r.cy.stopAnimationLoop();

  for (var i = 0; i < r.bindings.length; i++) {
    var binding = r.bindings[i];
    var b = binding;
    var tgt = b.target;
    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if (r.removeObserver) {
    r.removeObserver.disconnect();
  }

  if (r.styleObserver) {
    r.styleObserver.disconnect();
  }

  if (r.resizeObserver) {
    r.resizeObserver.disconnect();
  }

  if (r.labelCalcDiv) {
    try {
      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {// ie10 issue #1014
    }
  }
};

BRp$f.isHeadless = function () {
  return false;
};

[BRp, BRp$a, BRp$b, BRp$c, BRp$d, BRp$e].forEach(function (props) {
  extend(BRp$f, props);
});

var fullFpsTime = 1000 / 60; // assume 60 frames per second

var defs = {
  setupDequeueing: function setupDequeueing(opts) {
    return function setupDequeueingImpl() {
      var self = this;
      var r = this.renderer;

      if (self.dequeueingSetup) {
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util(function () {
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, opts.deqRedrawThreshold);

      var dequeue = function dequeue(willDraw, frameStartTime) {
        var startTime = performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
        // queue won't automatically be flushed before dequeueing starts

        if (!willDraw) {
          r.flushRenderedStyleQueue();
        }

        while (true) {
          // eslint-disable-line no-constant-condition
          var now = performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time
            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }

          var thisDeqd = opts.deq(self, pixelRatio, extent);

          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        } // callbacks on dequeue


        if (deqd.length > 0) {
          opts.onDeqd(self, deqd);

          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || noop;
      r.beforeRender(dequeue, priority(self));
    };
  }
};

// Uses keys so elements may share the same cache.

var ElementTextureCacheLookup =
/*#__PURE__*/
function () {
  function ElementTextureCacheLookup(getKey) {
    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;

    _classCallCheck(this, ElementTextureCacheLookup);

    this.idsByKey = new Map$1();
    this.keyForId = new Map$1();
    this.cachesByLvl = new Map$1();
    this.lvls = [];
    this.getKey = getKey;
    this.doesEleInvalidateKey = doesEleInvalidateKey;
  }

  _createClass(ElementTextureCacheLookup, [{
    key: "getIdsFor",
    value: function getIdsFor(key) {
      if (key == null) {
        error("Can not get id list for null key");
      }

      var idsByKey = this.idsByKey;
      var ids = this.idsByKey.get(key);

      if (!ids) {
        ids = new Set$1();
        idsByKey.set(key, ids);
      }

      return ids;
    }
  }, {
    key: "addIdForKey",
    value: function addIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key).add(id);
      }
    }
  }, {
    key: "deleteIdForKey",
    value: function deleteIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key)["delete"](id);
      }
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function getNumberOfIdsForKey(key) {
      if (key == null) {
        return 0;
      } else {
        return this.getIdsFor(key).size;
      }
    }
  }, {
    key: "updateKeyMappingFor",
    value: function updateKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var currKey = this.getKey(ele);
      this.deleteIdForKey(prevKey, id);
      this.addIdForKey(currKey, id);
      this.keyForId.set(id, currKey);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function deleteKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      this.deleteIdForKey(prevKey, id);
      this.keyForId["delete"](id);
    }
  }, {
    key: "keyHasChangedFor",
    value: function keyHasChangedFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var newKey = this.getKey(ele);
      return prevKey !== newKey;
    }
  }, {
    key: "isInvalid",
    value: function isInvalid(ele) {
      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
    }
  }, {
    key: "getCachesAt",
    value: function getCachesAt(lvl) {
      var cachesByLvl = this.cachesByLvl,
          lvls = this.lvls;
      var caches = cachesByLvl.get(lvl);

      if (!caches) {
        caches = new Map$1();
        cachesByLvl.set(lvl, caches);
        lvls.push(lvl);
      }

      return caches;
    }
  }, {
    key: "getCache",
    value: function getCache(key, lvl) {
      return this.getCachesAt(lvl).get(key);
    }
  }, {
    key: "get",
    value: function get(ele, lvl) {
      var key = this.getKey(ele);
      var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys

      if (cache != null) {
        this.updateKeyMappingFor(ele);
      }

      return cache;
    }
  }, {
    key: "getForCachedKey",
    value: function getForCachedKey(ele, lvl) {
      var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key

      var cache = this.getCache(key, lvl);
      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(key, lvl) {
      return this.getCachesAt(lvl).has(key);
    }
  }, {
    key: "has",
    value: function has(ele, lvl) {
      var key = this.getKey(ele);
      return this.hasCache(key, lvl);
    }
  }, {
    key: "setCache",
    value: function setCache(key, lvl, cache) {
      cache.key = key;
      this.getCachesAt(lvl).set(key, cache);
    }
  }, {
    key: "set",
    value: function set(ele, lvl, cache) {
      var key = this.getKey(ele);
      this.setCache(key, lvl, cache);
      this.updateKeyMappingFor(ele);
    }
  }, {
    key: "deleteCache",
    value: function deleteCache(key, lvl) {
      this.getCachesAt(lvl)["delete"](key);
    }
  }, {
    key: "delete",
    value: function _delete(ele, lvl) {
      var key = this.getKey(ele);
      this.deleteCache(key, lvl);
    }
  }, {
    key: "invalidateKey",
    value: function invalidateKey(key) {
      var _this = this;

      this.lvls.forEach(function (lvl) {
        return _this.deleteCache(key, lvl);
      });
    } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)

  }, {
    key: "invalidate",
    value: function invalidate(ele) {
      var id = ele.id();
      var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)

      this.deleteKeyMappingFor(ele);
      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);

      if (entireKeyInvalidated) {
        // clear mapping for current key
        this.invalidateKey(key);
      }

      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
    }
  }]);

  return ElementTextureCacheLookup;
}();

var minTxrH = 25; // the size of the texture cache for small height eles (special case)

var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up

var minLvl = -4; // when scaling smaller than that we don't need to re-render

var maxLvl = 3; // when larger than this scale just render directly (caching is not helpful)

var maxZoom = 7.99; // beyond this zoom level, layered textures are not used

var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps

var defTxrWidth = 1024; // default/minimum texture width

var maxTxrW = 1024; // the maximum width of a texture

var maxTxrH = 1024; // the maximum height of a texture

var minUtility = 0.2; // if usage of texture is less than this, it is retired

var maxFullness = 0.8; // fullness of texture after which queue removal is checked

var maxFullnessChecks = 10; // dequeued after this many checks

var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost = 0.9; // % of frame time to be used when >60fps

var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};
var initDefaults = defaults({
  getKey: null,
  doesEleInvalidateKey: falsify,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: trueify,
  allowEdgeTxrCaching: true,
  allowParentTxrCaching: true
});

var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
  var self = this;
  self.renderer = renderer;
  self.onDequeues = [];
  var opts = initDefaults(initOptions);
  extend(self, opts);
  self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;
ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed

ETCp.getTextureQueue = function (txrH) {
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};
  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
}; // the list of usused textures which can be recycled (in use in texture queue)


ETCp.getRetiredTextureQueue = function (txrH) {
  var self = this;
  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
  return rtxtrQ;
}; // queue of element draw requests at different scale levels


ETCp.getElementQueue = function () {
  var self = this;
  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
    return b.reqs - a.reqs;
  });
  return q;
}; // queue of element draw requests at different scale levels (element id lookup)


ETCp.getElementKeyToQueue = function () {
  var self = this;
  var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
  return k2q;
};

ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
  var self = this;
  var r = this.renderer;
  var zoom = r.cy.zoom();
  var lookup = this.lookup;

  if (bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible()) {
    return null;
  }

  if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {
    return null;
  }

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));
  }

  if (lvl < minLvl) {
    lvl = minLvl;
  } else if (zoom >= maxZoom || lvl > maxLvl) {
    return null;
  }

  var scale = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);

  if (!this.isVisible(ele, scaledLabelShown)) {
    return null;
  }

  var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric

  if (eleCache && eleCache.invalidated) {
    eleCache.invalidated = false;
    eleCache.texture.invalidatedWidth -= eleCache.width;
  }

  if (eleCache) {
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }

  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end

  var txr = txrQ[txrQ.length - 2];

  var addNewTxr = function addNewTxr() {
    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
  }; // try the last one if there is no second last one


  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  } // if the last one doesn't exist, we need a first one


  if (!txr) {
    txr = addNewTxr();
  } // if there's no room in the current texture, we need a new one


  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }

  var scalableFrom = function scalableFrom(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;
  var higherCache; // the nearest cache with a higher level

  for (var l = lvl + 1; l <= maxLvl; l++) {
    var c = lookup.get(ele, l);

    if (c) {
      higherCache = c;
      break;
    }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function downscale() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  }; // reset ele area in texture


  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

  if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
  } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level
    if (highQualityReq) {
      for (var _l = higherCache.level; _l > lvl; _l--) {
        oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
      }

      downscale();
    } else {
      self.queueElement(ele, higherCache.level - 1);
      return higherCache;
    }
  } else {
    var lowerCache; // the nearest cache with a lower level

    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var _l2 = lvl - 1; _l2 >= minLvl; _l2--) {
        var _c = lookup.get(ele, _l2);

        if (_c) {
          lowerCache = _c;
          break;
        }
      }
    }

    if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later
      self.queueElement(ele, lvl);
      return lowerCache;
    }

    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale, scale);
    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
    txr.context.scale(1 / scale, 1 / scale);
    txr.context.translate(-txr.usedWidth, 0);
  }

  eleCache = {
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };
  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
  txr.eleCaches.push(eleCache);
  lookup.set(ele, lvl, eleCache);
  self.checkTextureFullness(txr);
  return eleCache;
};

ETCp.invalidateElements = function (eles) {
  for (var i = 0; i < eles.length; i++) {
    this.invalidateElement(eles[i]);
  }
};

ETCp.invalidateElement = function (ele) {
  var self = this;
  var lookup = self.lookup;
  var caches = [];
  var invalid = lookup.isInvalid(ele);

  if (!invalid) {
    return; // override the invalidation request if the element key has not changed
  }

  for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
    var cache = lookup.getForCachedKey(ele, lvl);

    if (cache) {
      caches.push(cache);
    }
  }

  var noOtherElesUseCache = lookup.invalidate(ele);

  if (noOtherElesUseCache) {
    for (var i = 0; i < caches.length; i++) {
      var _cache = caches[i];
      var txr = _cache.texture; // remove space from the texture it belongs to

      txr.invalidatedWidth += _cache.width; // mark the cache as invalidated

      _cache.invalidated = true; // retire the texture if its utility is low

      self.checkTextureUtility(txr);
    }
  } // remove from queue since the old req was for the old state


  self.removeFromQueue(ele);
};

ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};

ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things
  var self = this;
  var txrQ = self.getTextureQueue(txr.height);

  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function (txr) {
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue(txrH);
  var lookup = this.lookup; // retire the texture from the active / searchable queue:

  removeFromArray(txrQ, txr);
  txr.retired = true; // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    lookup.deleteCache(eleCache.key, eleCache.level);
  }

  clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue(txrH);
  rtxtrQ.push(txr);
};

ETCp.addTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var txr = {};
  txrQ.push(txr);
  txr.eleCaches = [];
  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;
  txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
  txr.context = txr.canvas.getContext('2d');
  return txr;
};

ETCp.recycleTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];

    if (txr.width >= minW) {
      txr.retired = false;
      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;
      clearArray(txr.eleCaches);
      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);
      removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);
      return txr;
    }
  }
};

ETCp.queueElement = function (ele, lvl) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var existingReq = k2q[key];

  if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.eles.merge(ele);
    existingReq.reqs++;
    q.updateItem(existingReq);
  } else {
    var req = {
      eles: ele.spawn().merge(ele),
      level: lvl,
      reqs: 1,
      key: key
    };
    q.push(req);
    k2q[key] = req;
  }
};

ETCp.dequeue = function (pxRatio
/*, extent*/
) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var dequeued = [];
  var lookup = self.lookup;

  for (var i = 0; i < maxDeqSize; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var key = req.key;
      var ele = req.eles[0]; // all eles have the same key

      var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup

      k2q[key] = null; // dequeueing isn't necessary with an existing cache

      if (cacheExists) {
        continue;
      }

      dequeued.push(req);
      var bb = self.getBoundingBox(ele);
      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.removeFromQueue = function (ele) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var req = k2q[key];

  if (req != null) {
    if (req.eles.length === 1) {
      // remove if last ele in the req
      // bring to front of queue
      req.reqs = MAX_INT;
      q.updateItem(req);
      q.pop(); // remove from queue

      k2q[key] = null; // remove from lookup map
    } else {
      // otherwise just remove ele from req
      req.eles.unmerge(ele);
    }
  }
};

ETCp.onDequeue = function (fn) {
  this.onDequeues.push(fn);
};

ETCp.offDequeue = function (fn) {
  removeFromArray(this.onDequeues, fn);
};

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio, extent) {
    return self.dequeue(pxRatio, extent);
  },
  onDeqd: function onDeqd(self, deqd) {
    for (var i = 0; i < self.onDequeues.length; i++) {
      var fn = self.onDequeues[i];
      fn(deqd);
    }
  },
  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
    for (var i = 0; i < deqd.length; i++) {
      var eles = deqd[i].eles;

      for (var j = 0; j < eles.length; j++) {
        var bb = eles[j].boundingBox();

        if (boundingBoxesIntersect(bb, extent)) {
          return true;
        }
      }
    }

    return false;
  },
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

var defNumLayers = 1; // default number of layers to use

var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render

var maxLvl$1 = 2; // when larger than this scale just render directly (caching is not helpful)

var maxZoom$1 = 3.99; // beyond this zoom level, layered textures are not used

var deqRedrawThreshold$1 = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates

var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps

var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch

var invalidThreshold = 250; // time threshold for disabling b/c of invalidations

var maxLayerArea = 4000 * 4000; // layers can't be bigger than this

var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function LayeredTextureCache(renderer) {
  var self = this;
  var r = self.renderer = renderer;
  var cy = r.cy;
  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;
  self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
  self.skipping = false;
  self.eleTxrDeqs = cy.collection();
  self.scheduleElementRefinement = util(function () {
    self.refineElementTextures(self.eleTxrDeqs);
    self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
  }, refineEleDebounceTime);
  r.beforeRender(function (willDraw, now) {
    if (now - self.lastInvalidationTime <= invalidThreshold) {
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  }, r.beforeRenderPriorities.lyrTxrSkip);

  var qSort = function qSort(a, b) {
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap(qSort);
  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;
var layerIdPool = 0;
var MAX_INT$1 = Math.pow(2, 53) - 1;

LTCp.makeLayer = function (bb, lvl) {
  var scale = Math.pow(2, lvl);
  var w = Math.ceil(bb.w * scale);
  var h = Math.ceil(bb.h * scale);
  var canvas = this.renderer.makeOffscreenCanvas(w, h);
  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT$1,
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)

  cxt.scale(scale, scale);
  cxt.translate(dx, dy);
  return layer;
};

LTCp.getLayers = function (eles, pxRatio, lvl) {
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;
  self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));

    if (lvl < minLvl$1) {
      lvl = minLvl$1;
    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {
      return null;
    }
  }

  self.validateLayersElesOrdering(lvl, eles);
  var layersByLvl = self.layersByLevel;
  var scale = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;
  var lvlComplete = self.levelIsComplete(lvl, eles);
  var tmpLayers;

  var checkTempLevels = function checkTempLevels() {
    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
      self.validateLayersElesOrdering(l, eles);

      if (self.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function checkLvls(dir) {
      if (tmpLayers) {
        return;
      }

      for (var l = lvl + dir; minLvl$1 <= l && l <= maxLvl$1; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    };

    checkLvls(+1);
    checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function

    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (layer.invalid) {
        removeFromArray(layers, layer);
      }
    }
  };

  if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon
    checkTempLevels();
  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function getBb() {
    if (!bb) {
      bb = makeBoundingBox();

      for (var i = 0; i < eles.length; i++) {
        updateBoundingBox(bb, eles[i].boundingBox());
      }
    }

    return bb;
  };

  var makeLayer = function makeLayer(opts) {
    opts = opts || {};
    var after = opts.after;
    getBb();
    var area = bb.w * scale * (bb.h * scale);

    if (area > maxLayerArea) {
      return null;
    }

    var layer = self.makeLayer(bb, lvl);

    if (after != null) {
      var index = layers.indexOf(after) + 1;
      layers.splice(index, 0, layer);
    } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
      layers.unshift(layer);
    } // if( tmpLayers ){
    //self.queueLayer( layer );
    // }


    return layer;
  };

  if (self.skipping && !firstGet) {
    // log('skip layers');
    return null;
  } // log('do layers');


  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing =  !firstGet;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());

    var existingLayer = caches[lvl];

    if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());
      layer = makeLayer({
        insert: true,
        after: layer
      }); // if now layer can be built then we can't use layers at this level

      if (!layer) {
        return null;
      } // log('new layer with id %s', layer.id);

    }

    if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer(layer, ele);
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer(layer, ele, lvl, pxRatio);
    }

    layer.eles.push(ele);
    caches[lvl] = layer;
  } // log('--');


  if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
}; // a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level


LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
  return lvl;
};

LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

  {
    r.setImgSmoothing(context, false);
  }

  {
    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
  }

  {
    r.setImgSmoothing(context, true);
  }
};

LTCp.levelIsComplete = function (lvl, eles) {
  var self = this;
  var layers = self.layersByLevel[lvl];

  if (!layers || layers.length === 0) {
    return false;
  }

  var numElesInLayers = 0;

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete

    if (layer.reqs > 0) {
      return false;
    } // if the layer is invalid, the level is not complete


    if (layer.invalid) {
      return false;
    }

    numElesInLayers += layer.eles.length;
  } // we should have exactly the number of eles passed in to be complete


  if (numElesInLayers !== eles.length) {
    return false;
  }

  return true;
};

LTCp.validateLayersElesOrdering = function (lvl, eles) {
  var layers = this.layersByLevel[lvl];

  if (!layers) {
    return;
  } // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)


  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1; // find the offset

    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }

    if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer(layer);
      continue;
    } // the eles in the layer must be in the same continuous order, else the layer is invalid


    var o = offset;

    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);
        this.invalidateLayer(layer);
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function (eles, update) {
  var self = this;
  var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way

  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for (var l = minLvl$1; l <= maxLvl$1; l++) {
      var layer = caches[l];

      if (!layer) {
        continue;
      } // if update is a request from the ele cache, then it affects only
      // the matching level


      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }

      update(layer, ele, req);
    }
  }
};

LTCp.haveLayers = function () {
  var self = this;
  var haveLayers = false;

  for (var l = minLvl$1; l <= maxLvl$1; l++) {
    var layers = self.layersByLevel[l];

    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function (eles) {
  var self = this;

  if (eles.length === 0) {
    return;
  }

  self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');

  if (eles.length === 0 || !self.haveLayers()) {
    return;
  }

  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
    self.invalidateLayer(layer);
  });
};

LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');
  this.lastInvalidationTime = performanceNow();

  if (layer.invalid) {
    return;
  } // save cycles


  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );

  removeFromArray(layers, layer); // layer.eles = [];

  layer.elesQueue = [];
  layer.invalid = true;

  if (layer.replacement) {
    layer.replacement.invalid = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if (caches) {
      caches[lvl] = null;
    }
  }
};

LTCp.refineElementTextures = function (eles) {
  var self = this; // log('refine', eles.length);

  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;

    if (!rLyr) {
      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self.queueLayer(rLyr, rLyr.eles[i]);
      } // log('queue replacement layer refinement', rLyr.id);

    }
  });
};

LTCp.enqueueElementRefinement = function (ele) {

  this.eleTxrDeqs.merge(ele);
  this.scheduleElementRefinement();
};

LTCp.queueLayer = function (layer, ele) {
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time

  if (layer.replacement) {
    return;
  }

  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }

    elesQ.push(ele);
    hasId[ele.id()] = true;
  }

  if (layer.reqs) {
    layer.reqs++;
    q.updateItem(layer);
  } else {
    layer.reqs = 1;
    q.push(layer);
  }
};

LTCp.dequeue = function (pxRatio) {
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while (eleDeqs < maxDeqSize$1) {
    if (q.size() === 0) {
      break;
    }

    var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it

    if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    } // if this is a replacement layer that has been superceded, then forget it


    if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if (ele) {
      // log('dequeue layer %s', layer.id);
      self.drawEleInLayer(layer, ele, layer.level, pxRatio);
      eleDeqs++;
    }

    if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
      deqd.push(true);
    } // if the layer has all its eles done, then remove from the queue


    if (layer.elesQueue.length === 0) {
      q.pop();
      layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
      // when a replacement layer is dequeued, it replaces the old layer in the level

      if (layer.replaces) {
        self.applyLayerReplacement(layer);
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function (layer) {
  var self = this;
  var layersInLevel = self.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)

  if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[index] = layer; // replace level ref
  // replace refs in eles

  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if (cache) {
      cache[layer.level] = layer;
    }
  } // log('apply replacement layer %s over %s', layer.id, replaced.id);


  self.requestRedraw();
};

LTCp.requestRedraw = util(function () {
  var r = this.renderer;
  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  r.redraw();
}, 100);
LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold$1,
  deqCost: deqCost$1,
  deqAvgCost: deqAvgCost$1,
  deqNoDrawCost: deqNoDrawCost$1,
  deqFastCost: deqFastCost$1,
  deq: function deq(self, pxRatio) {
    return self.dequeue(pxRatio);
  },
  onDeqd: noop,
  shouldRedraw: trueify,
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

var CRp = {};
var impl;

function polygon(context, points) {
  for (var i = 0; i < points.length; i++) {
    var pt = points[i];
    context.lineTo(pt.x, pt.y);
  }
}

function triangleBackcurve(context, points, controlPoint) {
  var firstPt;

  for (var i = 0; i < points.length; i++) {
    var pt = points[i];

    if (i === 0) {
      firstPt = pt;
    }

    context.lineTo(pt.x, pt.y);
  }

  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
}

function triangleTee(context, trianglePoints, teePoints) {
  if (context.beginPath) {
    context.beginPath();
  }

  var triPts = trianglePoints;

  for (var i = 0; i < triPts.length; i++) {
    var pt = triPts[i];
    context.lineTo(pt.x, pt.y);
  }

  var teePts = teePoints;
  var firstTeePt = teePoints[0];
  context.moveTo(firstTeePt.x, firstTeePt.y);

  for (var i = 1; i < teePts.length; i++) {
    var pt = teePts[i];
    context.lineTo(pt.x, pt.y);
  }

  if (context.closePath) {
    context.closePath();
  }
}

function circle(context, rx, ry, r) {
  context.arc(rx, ry, r, 0, Math.PI * 2, false);
}

CRp.arrowShapeImpl = function (name) {
  return (impl || (impl = {
    'polygon': polygon,
    'triangle-backcurve': triangleBackcurve,
    'triangle-tee': triangleTee,
    'triangle-cross': triangleTee,
    'circle': circle
  }))[name];
};

var CRp$1 = {};

CRp$1.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
  var r = this;

  if (ele.isNode()) {
    r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  } else {
    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  }
};

CRp$1.drawElementOverlay = function (context, ele) {
  var r = this;

  if (ele.isNode()) {
    r.drawNodeOverlay(context, ele);
  } else {
    r.drawEdgeOverlay(context, ele);
  }
};

CRp$1.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
  var r = this;
  var bb = eleTxrCache.getBoundingBox(ele);

  if (bb.w === 0 || bb.h === 0) {
    return;
  } // ignore zero size case


  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);

  if (eleCache != null) {
    var opacity = getOpacity(r, ele);

    if (opacity === 0) {
      return;
    }

    var theta = getRotation(r, ele);
    var x1 = bb.x1,
        y1 = bb.y1,
        w = bb.w,
        h = bb.h;
    var x, y, sx, sy, smooth;

    if (theta !== 0) {
      var rotPt = eleTxrCache.getRotationPoint(ele);
      sx = rotPt.x;
      sy = rotPt.y;
      context.translate(sx, sy);
      context.rotate(theta);
      smooth = r.getImgSmoothing(context);

      if (!smooth) {
        r.setImgSmoothing(context, true);
      }

      var off = eleTxrCache.getRotationOffset(ele);
      x = off.x;
      y = off.y;
    } else {
      x = x1;
      y = y1;
    }

    var oldGlobalAlpha;

    if (opacity !== 1) {
      oldGlobalAlpha = context.globalAlpha;
      context.globalAlpha = oldGlobalAlpha * opacity;
    }

    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);

    if (opacity !== 1) {
      context.globalAlpha = oldGlobalAlpha;
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-sx, -sy);

      if (!smooth) {
        r.setImgSmoothing(context, false);
      }
    }
  } else {
    eleTxrCache.drawElement(context, ele); // direct draw fallback
  }
};

var getZeroRotation = function getZeroRotation() {
  return 0;
};

var getLabelRotation = function getLabelRotation(r, ele) {
  return r.getTextAngle(ele, null);
};

var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'source');
};

var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'target');
};

var getOpacity = function getOpacity(r, ele) {
  return ele.effectiveOpacity();
};

var getTextOpacity = function getTextOpacity(e, ele) {
  return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();
};

CRp$1.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {
  var r = this;
  var _r$data = r.data,
      eleTxrCache = _r$data.eleTxrCache,
      lblTxrCache = _r$data.lblTxrCache,
      slbTxrCache = _r$data.slbTxrCache,
      tlbTxrCache = _r$data.tlbTxrCache;
  var bb = ele.boundingBox();
  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  if (!extent || boundingBoxesIntersect(bb, extent)) {
    var isEdge = ele.isEdge();

    var badLine = ele.element()._private.rscratch.badLine;

    r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);

    if (!isEdge || !badLine) {
      r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
    }

    if (isEdge && !badLine) {
      r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
      r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
    }

    r.drawElementOverlay(context, ele);
  }
};

CRp$1.drawElements = function (context, eles) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawElement(context, ele);
  }
};

CRp$1.drawCachedElements = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawCachedNodes = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.isNode()) {
      continue;
    }

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawLayeredElements = function (context, eles, pxRatio, extent) {
  var r = this;
  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;

      if (bb.w === 0 || bb.h === 0) {
        continue;
      }

      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
  }
};

/* global Path2D */
var CRp$2 = {};

CRp$2.drawEdge = function (context, edge, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var rs = edge._private.rscratch;

  if (shouldDrawOpacity && !edge.visible()) {
    return;
  } // if bezier ctrl pts can not be calculated, then die


  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;
  var lineStyle = edge.pstyle('line-style').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var lineCap = edge.pstyle('line-cap').value;

  var drawLine = function drawLine() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    context.lineWidth = edgeWidth;
    context.lineCap = lineCap;
    r.eleStrokeStyle(context, edge, strokeOpacity);
    r.drawEdgePath(edge, context, rs.allpts, lineStyle);
    context.lineCap = 'butt'; // reset for other drawing functions
  };

  var drawOverlay = function drawOverlay() {
    if (!shouldDrawOverlay) {
      return;
    }

    r.drawEdgeOverlay(context, edge);
  };

  var drawArrows = function drawArrows() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    r.drawArrowheads(context, edge, arrowOpacity);
  };

  var drawText = function drawText() {
    r.drawElementText(context, edge, null, drawLabel);
  };

  context.lineJoin = 'round';
  var ghost = edge.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = edge.pstyle('ghost-offset-x').pfValue;
    var gy = edge.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = edge.pstyle('ghost-opacity').value;
    var effectiveGhostOpacity = opacity * ghostOpacity;
    context.translate(gx, gy);
    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);
    context.translate(-gx, -gy);
  }

  drawLine();
  drawArrows();
  drawOverlay();
  drawText();

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$2.drawEdgeOverlay = function (context, edge) {
  if (!edge.visible()) {
    return;
  }

  var overlayOpacity = edge.pstyle('overlay-opacity').value;

  if (overlayOpacity === 0) {
    return;
  }

  var r = this;
  var usePaths = r.usePaths();
  var rs = edge._private.rscratch;
  var overlayPadding = edge.pstyle('overlay-padding').pfValue;
  var overlayWidth = 2 * overlayPadding;
  var overlayColor = edge.pstyle('overlay-color').value;
  context.lineWidth = overlayWidth;

  if (rs.edgeType === 'self' && !usePaths) {
    context.lineCap = 'butt';
  } else {
    context.lineCap = 'round';
  }

  r.colorStrokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
  r.drawEdgePath(edge, context, rs.allpts, 'solid');
};

CRp$2.drawEdgePath = function (edge, context, pts, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();
  var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;
  var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;

  if (usePaths) {
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if (canvasCxt.setLineDash) {
    // for very outofdate browsers
    switch (type) {
      case 'dotted':
        canvasCxt.setLineDash([1, 1]);
        break;

      case 'dashed':
        canvasCxt.setLineDash(lineDashPattern);
        canvasCxt.lineDashOffset = lineDashOffset;
        break;

      case 'solid':
        canvasCxt.setLineDash([]);
        break;
    }
  }

  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }

    context.moveTo(pts[0], pts[1]);

    switch (rs.edgeType) {
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for (var i = 2; i + 3 < pts.length; i += 4) {
          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
        }

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for (var _i = 2; _i + 1 < pts.length; _i += 2) {
          context.lineTo(pts[_i], pts[_i + 1]);
        }

        break;
    }
  }

  context = canvasCxt;

  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  } // reset any line dashes


  if (context.setLineDash) {
    // for very outofdate browsers
    context.setLineDash([]);
  }
};

CRp$2.drawArrowheads = function (context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }

  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};

CRp$2.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
    return;
  }

  var self = this;
  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;

  if (arrowShape === 'none') {
    return;
  }

  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var edgeOpacity = edge.pstyle('opacity').value;

  if (opacity === undefined) {
    opacity = edgeOpacity;
  }

  var gco = context.globalCompositeOperation;

  if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';
    self.colorFillStyle(context, 255, 255, 255, 1);
    self.colorStrokeStyle(context, 255, 255, 255, 1);
    self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)


  var color = edge.pstyle(prefix + '-arrow-color').value;
  self.colorFillStyle(context, color[0], color[1], color[2], opacity);
  self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
  self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};

CRp$2.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths() && shape !== 'triangle-cross';
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = {
    x: x,
    y: y
  };
  var scale = edge.pstyle('arrow-scale').value;
  var size = this.getArrowWidth(edgeWidth, scale);
  var shapeImpl = r.arrowShapes[shape];

  if (usePaths) {
    var cache = r.arrowPathCache = r.arrowPathCache || [];
    var key = hashString(shape);
    var cachedPath = cache[key];

    if (cachedPath != null) {
      path = context = cachedPath;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      cache[key] = path;
    }
  }

  if (context.beginPath) {
    context.beginPath();
  }

  if (!pathCacheHit) {
    if (usePaths) {
      // store in the path cache with values easily manipulated later
      shapeImpl.draw(context, 1, 0, {
        x: 0,
        y: 0
      }, 1);
    } else {
      shapeImpl.draw(context, size, angle, translation, edgeWidth);
    }
  }

  if (context.closePath) {
    context.closePath();
  }

  context = canvasContext;

  if (usePaths) {
    // set transform to arrow position/orientation
    context.translate(x, y);
    context.rotate(angle);
    context.scale(size, size);
  }

  if (fill === 'filled' || fill === 'both') {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }

  if (fill === 'hollow' || fill === 'both') {
    context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
    context.lineJoin = 'miter';

    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }

  if (usePaths) {
    // reset transform by applying inverse
    context.scale(1 / size, 1 / size);
    context.rotate(-angle);
    context.translate(-x, -y);
  }
};

var CRp$3 = {};

CRp$3.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }

  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
};

CRp$3.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
  var r = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit = getIndexedStyle(node, 'background-fit', 'value', index);
  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = getIndexedStyle(node, 'background-clip', 'value', index);
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;
  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH; // workaround for broken browsers like ie

  if (null == imgW || null == imgH) {
    document.body.appendChild(img); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;
    document.body.removeChild(img); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
    } else {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index);
    }
  }

  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
    } else {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index);
    }
  }

  if (w === 0 || h === 0) {
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if (fit === 'contain') {
    var scale = Math.min(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  } else if (fit === 'cover') {
    var scale = Math.max(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  }

  var x = nodeX - nodeTW / 2; // left

  var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);
  var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);

  if (posXUnits === '%') {
    x += (nodeTW - w) * posXPfVal;
  } else {
    x += posXPfVal;
  }

  var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);
  var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);

  if (offXUnits === '%') {
    x += (nodeTW - w) * offXPfVal;
  } else {
    x += offXPfVal;
  }

  var y = nodeY - nodeTH / 2; // top

  var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);
  var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);

  if (posYUnits === '%') {
    y += (nodeTH - h) * posYPfVal;
  } else {
    y += posYPfVal;
  }

  var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);
  var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);

  if (offYUnits === '%') {
    y += (nodeTH - h) * offYPfVal;
  } else {
    y += offYPfVal;
  }

  if (rs.pathCache) {
    x -= nodeX;
    y -= nodeY;
    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;
  context.globalAlpha = imgOpacity;

  if (repeat === 'no-repeat') {
    if (shouldClip) {
      context.save();

      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
        context.clip();
      }
    }

    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;
    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
    context.translate(x, y);
    context.fill();
    context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;
};

var CRp$4 = {};

CRp$4.eleTextBiggerThanMin = function (ele, scale) {
  if (!scale) {
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level

    scale = Math.pow(2, lvl);
  }

  var computedSize = ele.pstyle('font-size').pfValue * scale;
  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

  if (computedSize < minSize) {
    return false;
  }

  return true;
};

CRp$4.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {
  var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;

  if (force == null) {
    if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else if (force === false) {
    return;
  }

  if (ele.isNode()) {
    var label = ele.pstyle('label');

    if (!label || !label.value) {
      return;
    }

    var justification = r.getLabelJustification(ele);
    context.textAlign = justification;
    context.textBaseline = 'bottom';
  } else {
    var badLine = ele.element()._private.rscratch.badLine;

    var _label = ele.pstyle('label');

    var srcLabel = ele.pstyle('source-label');
    var tgtLabel = ele.pstyle('target-label');

    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }

  var applyRotation = !shiftToOriginWithBb;
  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  if (prefix == null) {
    r.drawText(context, ele, null, applyRotation, useEleOpacity);

    if (ele.isEdge()) {
      r.drawText(context, ele, 'source', applyRotation, useEleOpacity);
      r.drawText(context, ele, 'target', applyRotation, useEleOpacity);
    }
  } else {
    r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
  }

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$4.getFontCache = function (context) {
  var cache;
  this.fontCaches = this.fontCaches || [];

  for (var i = 0; i < this.fontCaches.length; i++) {
    cache = this.fontCaches[i];

    if (cache.context === context) {
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);
  return cache;
}; // set up canvas context with font
// returns transformed text string


CRp$4.setupTextStyle = function (context, ele) {
  var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // Font style
  var labelStyle = ele.pstyle('font-style').strValue;
  var labelSize = ele.pstyle('font-size').pfValue + 'px';
  var labelFamily = ele.pstyle('font-family').strValue;
  var labelWeight = ele.pstyle('font-weight').strValue;
  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;
  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
  var color = ele.pstyle('color').value;
  var outlineColor = ele.pstyle('text-outline-color').value;
  context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
  context.lineJoin = 'round'; // so text outlines aren't jagged

  this.colorFillStyle(context, color[0], color[1], color[2], opacity);
  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
}; // TODO ensure re-used


function roundRect(ctx, x, y, width, height) {
  var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

CRp$4.getTextAngle = function (ele, prefix) {
  var theta;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var pdash = prefix ? prefix + '-' : '';
  var rotation = ele.pstyle(pdash + 'text-rotation');
  var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);

  if (rotation.strValue === 'autorotate') {
    theta = ele.isEdge() ? textAngle : 0;
  } else if (rotation.strValue === 'none') {
    theta = 0;
  } else {
    theta = rotation.pfValue;
  }

  return theta;
};

CRp$4.drawText = function (context, ele, prefix) {
  var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;

  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {
    return;
  } // use 'main' as an alias for the main label (i.e. null prefix)


  if (prefix === 'main') {
    prefix = null;
  }

  var textX = getPrefixedProperty(rscratch, 'labelX', prefix);
  var textY = getPrefixedProperty(rscratch, 'labelY', prefix);
  var orgTextX, orgTextY; // used for rotation

  var text = this.getLabelText(ele, prefix);

  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele, useEleOpacity);
    var pdash = prefix ? prefix + '-' : '';
    var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);
    var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);
    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var halign = ele.pstyle('text-halign').value;
    var valign = ele.pstyle('text-valign').value;

    if (isEdge) {
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;
    var theta;

    if (!applyRotation) {
      theta = 0;
    } else {
      theta = this.getTextAngle(ele, prefix);
    }

    if (theta !== 0) {
      orgTextX = textX;
      orgTextY = textY;
      context.translate(orgTextX, orgTextY);
      context.rotate(theta);
      textX = 0;
      textY = 0;
    }

    switch (valign) {
      case 'top':
        break;

      case 'center':
        textY += textH / 2;
        break;

      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle('text-background-opacity').value;
    var borderOpacity = ele.pstyle('text-border-opacity').value;
    var textBorderWidth = ele.pstyle('text-border-width').pfValue;
    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var bgX = textX - backgroundPadding;

      switch (halign) {
        case 'left':
          bgX -= textW;
          break;

        case 'center':
          bgX -= textW / 2;
          break;

        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;

      if (backgroundOpacity > 0) {
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle('text-background-color').value;
        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle('text-background-shape').strValue;

        if (styleShape.indexOf('round') === 0) {
          roundRect(context, bgX, bgY, bgW, bgH, 2);
        } else {
          context.fillRect(bgX, bgY, bgW, bgH);
        }

        context.fillStyle = textFill;
      }

      if (textBorderWidth > 0 && borderOpacity > 0) {
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle('text-border-color').value;
        var textBorderStyle = ele.pstyle('text-border-style').value;
        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if (context.setLineDash) {
          // for very outofdate browsers
          switch (textBorderStyle) {
            case 'dotted':
              context.setLineDash([1, 1]);
              break;

            case 'dashed':
              context.setLineDash([4, 2]);
              break;

            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders

              context.setLineDash([]);
              break;

            case 'solid':
              context.setLineDash([]);
              break;
          }
        }

        context.strokeRect(bgX, bgY, bgW, bgH);

        if (textBorderStyle === 'double') {
          var whiteWidth = textBorderWidth / 2;
          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
        }

        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }

        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }
    }

    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }

    if (ele.pstyle('text-wrap').value === 'wrap') {
      var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
      var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);
      var halfTextW = textW / 2;
      var justification = this.getLabelJustification(ele);

      if (justification === 'auto') ; else if (halign === 'left') {
        // auto justification : right
        if (justification === 'left') {
          textX += -textW;
        } else if (justification === 'center') {
          textX += -halfTextW;
        } // else same as auto

      } else if (halign === 'center') {
        // auto justfication : center
        if (justification === 'left') {
          textX += -halfTextW;
        } else if (justification === 'right') {
          textX += halfTextW;
        } // else same as auto

      } else if (halign === 'right') {
        // auto justification : left
        if (justification === 'center') {
          textX += halfTextW;
        } else if (justification === 'right') {
          textX += textW;
        } // else same as auto

      }

      switch (valign) {
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;

        case 'center':
        case 'bottom':
          textY -= (lines.length - 1) * lineHeight;
          break;
      }

      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }

        context.fillText(lines[l], textX, textY);
        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};

/* global Path2D */
var CRp$5 = {};

CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var nodeWidth, nodeHeight;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();

  if (!number(pos.x) || !number(pos.y)) {
    return; // can't draw node with undefined position
  }

  if (shouldDrawOpacity && !node.visible()) {
    return;
  }

  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
  var usePaths = r.usePaths();
  var path;
  var pathCacheHit = false;
  var padding = node.padding();
  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding; //
  // setup shift

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  } //
  // load bg image


  var bgImgProp = node.pstyle('background-image');
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;

  for (var i = 0; i < urls.length; i++) {
    var url = urls[i];
    var defd = urlDefined[i] = url != null && url !== 'none';

    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);
      numImages++; // get image, and if not loaded then ask to redraw when later loaded

      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
        _p.backgroundTimestamp = Date.now();
        node.emitAndNotify('background');
      });
    }
  } //
  // setup styles


  var darkness = node.pstyle('background-blacken').value;
  var borderWidth = node.pstyle('border-width').pfValue;
  var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;
  var borderColor = node.pstyle('border-color').value;
  var borderStyle = node.pstyle('border-style').value;
  var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;
  context.lineJoin = 'miter'; // so borders are square with the node shape

  var setupShapeColor = function setupShapeColor() {
    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
    r.eleFillStyle(context, node, bgOpy);
  };

  var setupBorderColor = function setupBorderColor() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
    r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  }; //
  // setup shape


  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if (usePaths) {
    context.translate(pos.x, pos.y);
    var pathCache = r.nodePathCache = r.nodePathCache || [];
    var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);
    var cachedPath = pathCache[key];

    if (cachedPath != null) {
      path = cachedPath;
      pathCacheHit = true;
      rs.pathCache = path;
    } else {
      path = new Path2D();
      pathCache[key] = rs.pathCache = path;
    }
  }

  var drawShape = function drawShape() {
    if (!pathCacheHit) {
      var npos = pos;

      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
    }

    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  };

  var drawImages = function drawImages() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var prevBging = _p.backgrounding;
    var totalCompleted = 0;

    for (var _i = 0; _i < image.length; _i++) {
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }

    _p.backgrounding = !(totalCompleted === numImages);

    if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
      node.updateStyle(false);
    }
  };

  var drawPie = function drawPie() {
    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;

    if (r.hasPie(node)) {
      r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it

      if (redrawShape) {
        if (!usePaths) {
          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
        }
      }
    }
  };

  var darken = function darken() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;

    if (darkness !== 0) {
      r.colorFillStyle(context, c, c, c, opacity);

      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  };

  var drawBorder = function drawBorder() {
    if (borderWidth > 0) {
      context.lineWidth = borderWidth;
      context.lineCap = 'butt';

      if (context.setLineDash) {
        // for very outofdate browsers
        switch (borderStyle) {
          case 'dotted':
            context.setLineDash([1, 1]);
            break;

          case 'dashed':
            context.setLineDash([4, 2]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([]);
            break;
        }
      }

      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      }

      if (borderStyle === 'double') {
        context.lineWidth = borderWidth / 3;
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      } // reset in case we changed the border style


      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    }
  };

  var drawOverlay = function drawOverlay() {
    if (shouldDrawOverlay) {
      r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
    }
  };

  var drawText = function drawText() {
    r.drawElementText(context, node, null, drawLabel);
  };

  var ghost = node.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = node.pstyle('ghost-offset-x').pfValue;
    var gy = node.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = node.pstyle('ghost-opacity').value;
    var effGhostOpacity = ghostOpacity * eleOpacity;
    context.translate(gx, gy);
    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity);
    drawPie(darkness !== 0 || borderWidth !== 0);
    darken(effGhostOpacity);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();
    context.translate(-gx, -gy);
  }

  setupShapeColor();
  drawShape();
  drawImages();
  drawPie(darkness !== 0 || borderWidth !== 0);
  darken();
  setupBorderColor();
  drawBorder();

  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }

  drawText();
  drawOverlay(); //
  // clean up shift

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$5.drawNodeOverlay = function (context, node, pos, nodeWidth, nodeHeight) {
  var r = this;

  if (!node.visible()) {
    return;
  }

  var overlayPadding = node.pstyle('overlay-padding').pfValue;
  var overlayOpacity = node.pstyle('overlay-opacity').value;
  var overlayColor = node.pstyle('overlay-color').value;

  if (overlayOpacity > 0) {
    pos = pos || node.position();

    if (nodeWidth == null || nodeHeight == null) {
      var padding = node.padding();
      nodeWidth = node.width() + 2 * padding;
      nodeHeight = node.height() + 2 * padding;
    }

    r.colorFillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
    r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);
    context.fill();
  }
}; // does the node have at least one pie piece?


CRp$5.hasPie = function (node) {
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp$5.drawPie = function (context, node, nodeOpacity, pos) {
  node = node[0]; // ensure ele ref

  pos = pos || node.position();
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle('pie-size');
  var x = pos.x;
  var y = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node

  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]

  var usePaths = this.usePaths();

  if (usePaths) {
    x = 0;
    y = 0;
  }

  if (pieSize.units === '%') {
    radius = radius * pieSize.pfValue;
  } else if (pieSize.pfValue !== undefined) {
    radius = pieSize.pfValue / 2;
  }

  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
    var size = node.pstyle('pie-' + i + '-background-size').value;
    var color = node.pstyle('pie-' + i + '-background-color').value;
    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]
    // percent can't push beyond 1

    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise

    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta; // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle

    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc(x, y, radius, angleStart, angleEnd);
    context.closePath();
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    context.fill();
    lastPercent += percent;
  }
};

var CRp$6 = {};
var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';

CRp$6.getPixelRatio = function () {
  var context = this.data.contexts[0];

  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp$6.paintCache = function (context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for (var i = 0; i < caches.length; i++) {
    cache = caches[i];

    if (cache.context === context) {
      needToCreateCache = false;
      break;
    }
  }

  if (needToCreateCache) {
    cache = {
      context: context
    };
    caches.push(cache);
  }

  return cache;
};

CRp$6.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {
  var gradientStyle;
  var usePaths = this.usePaths();
  var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,
      positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;

  if (fill === 'radial-gradient') {
    if (ele.isEdge()) {
      var start = ele.sourceEndpoint(),
          end = ele.targetEndpoint(),
          mid = ele.midpoint();
      var d1 = dist(start, mid);
      var d2 = dist(end, mid);
      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
    } else {
      var pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          width = ele.paddedWidth(),
          height = ele.paddedHeight();
      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
    }
  } else {
    if (ele.isEdge()) {
      var _start = ele.sourceEndpoint(),
          _end = ele.targetEndpoint();

      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
    } else {
      var _pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          _width = ele.paddedWidth(),
          _height = ele.paddedHeight(),
          halfWidth = _width / 2,
          halfHeight = _height / 2;

      var direction = ele.pstyle('background-gradient-direction').value;

      switch (direction) {
        case 'to-bottom':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
          break;

        case 'to-top':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
          break;

        case 'to-left':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
          break;

        case 'to-right':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
          break;

        case 'to-bottom-right':
        case 'to-right-bottom':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-right':
        case 'to-right-top':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
          break;

        case 'to-bottom-left':
        case 'to-left-bottom':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-left':
        case 'to-left-top':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
          break;
      }
    }
  }

  if (!gradientStyle) return null; // invalid gradient style

  var hasPositions = positions.length === colors.length;
  var length = colors.length;

  for (var i = 0; i < length; i++) {
    gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');
  }

  return gradientStyle;
};

CRp$6.gradientFillStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.fillStyle = gradientStyle;
};

CRp$6.colorFillStyle = function (context, r, g, b, a) {
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp$6.eleFillStyle = function (context, ele, opacity) {
  var backgroundFill = ele.pstyle('background-fill').value;

  if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {
    this.gradientFillStyle(context, ele, backgroundFill, opacity);
  } else {
    var backgroundColor = ele.pstyle('background-color').value;
    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
  }
};

CRp$6.gradientStrokeStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.strokeStyle = gradientStyle;
};

CRp$6.colorStrokeStyle = function (context, r, g, b, a) {
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp$6.eleStrokeStyle = function (context, ele, opacity) {
  var lineFill = ele.pstyle('line-fill').value;

  if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {
    this.gradientStrokeStyle(context, ele, lineFill, opacity);
  } else {
    var lineColor = ele.pstyle('line-color').value;
    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
  }
}; // Resize canvas


CRp$6.matchCanvasSize = function (container) {
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
    canvas = data.canvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {
    canvas = data.bufferCanvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;

  if (pixelRatio <= 1) {
    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;
};

CRp$6.renderTo = function (cxt, zoom, pan, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp$6.render = function (options) {
  options = options || staticEmptyObject();
  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy;
  var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if (!forcedContext) {
    if (r.prevPxRatio !== pixelRatio) {
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);
      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if (!forcedContext && r.motionBlurTimeout) {
    clearTimeout(r.motionBlurTimeout);
  }

  if (motionBlur) {
    if (r.mbFrames == null) {
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)


    if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if (r.clearingMotionBlur) {
    r.motionBlurPxRatio = 1;
  } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw


  if (r.textureDrawLastFrame && !textureDraw) {
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var style = cy.style();
  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };
  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)

  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
    r.motionBlurPxRatio = 1;
  }

  if (forcedPan) {
    effectivePan = forcedPan;
  } // apply pixel ratio


  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;
  var eles = r.getCachedZSortedEles();

  function mbclear(context, x, y, w, h) {
    var gco = context.globalCompositeOperation;
    context.globalCompositeOperation = 'destination-out';
    r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
    context.fillRect(x, y, w, h);
    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear) {
    var ePan, eZoom, w, h;

    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };
      eZoom = zoom * mbPxRatio;
      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;
      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (clear === 'motionBlur') {
      mbclear(context, 0, 0, w, h);
    } else if (!forcedContext && (clear === undefined || clear)) {
      context.clearRect(0, 0, w, h);
    }

    if (!drawAllLayers) {
      context.translate(ePan.x, ePan.y);
      context.scale(eZoom, eZoom);
    }

    if (forcedPan) {
      context.translate(forcedPan.x, forcedPan.y);
    }

    if (forcedZoom) {
      context.scale(forcedZoom, forcedZoom);
    }
  }

  if (!textureDraw) {
    r.textureDrawLastFrame = false;
  }

  if (textureDraw) {
    r.textureDrawLastFrame = true;

    if (!r.textureCache) {
      r.textureCache = {};
      r.textureCache.bb = cy.mutableElements().boundingBox();
      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });
      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };
      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;
    var context = data.contexts[r.NODE];
    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    context.setTransform(1, 0, 0, 1, 0, 0);

    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = style.core('outside-texture-bg-color').value;
    var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;
    r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);
    var zoom = cy.zoom();
    setContextTransform(context, false);
    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
  var hideEdges = r.hideEdgesOnViewport && vpManip;
  var needMbClear = [];
  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;

  if (needMbClear[r.NODE]) {
    r.clearedForMotionBlur[r.NODE] = true;
  }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;

  if (needMbClear[r.DRAG]) {
    r.clearedForMotionBlur[r.DRAG] = true;
  }

  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
    setContextTransform(context, clear);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
    } else {
      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.nondrag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.NODE] = false;
    }
  }

  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
    } else {
      r.drawCachedElements(context, eles.drag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.drag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.DRAG] = false;
    }
  }

  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];
    setContextTransform(context);

    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var zoom = r.cy.zoom();
      var borderWidth = style.core('selection-box-border-width').value / zoom;
      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
      }
    }

    if (data.bgActivePosistion && !r.hoverData.selecting) {
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;
      context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';
      context.beginPath();
      context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;

    if (r.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1000 / timeToRender);
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
    }

    if (!drawAllLayers) {
      needDraw[r.SELECT_BOX] = false;
    }
  } // motionblur: blit rendered blurry frames


  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if (needClear || !motionBlurFadeEffect) {
        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
      } else {
        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
      }

      var pxr = mbPxRatio;
      cxt.drawImage(txt, // img
      0, 0, // sx, sy
      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
      0, 0, // x, y
      r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if (needDraw[r.NODE] || needMbClear[r.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
      needDraw[r.NODE] = false;
    }

    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
      needDraw[r.DRAG] = false;
    }
  }

  r.prevViewport = vp;

  if (r.clearingMotionBlur) {
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if (motionBlur) {
    r.motionBlurTimeout = setTimeout(function () {
      r.motionBlurTimeout = null;
      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;
      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;
      r.redraw();
    }, motionBlurDelay);
  }

  if (!forcedContext) {
    cy.emit('render');
  }
};

var CRp$7 = {}; // @O Polygon drawing

CRp$7.drawPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x + halfW * points[0], y + halfH * points[1]);

  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
  }

  context.closePath();
};

CRp$7.drawRoundPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  for (var _i = 0; _i < points.length / 4; _i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (_i === 0) {
      sourceUv = points.length - 2;
    } else {
      sourceUv = _i * 4 - 2;
    }

    destUv = _i * 4 + 2;
    var px = x + halfW * points[_i * 4];
    var py = y + halfH * points[_i * 4 + 1];
    var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * points[sourceUv];
    var cp0y = py - offset * points[sourceUv + 1];
    var cp1x = px + offset * points[destUv];
    var cp1y = py + offset * points[destUv + 1];

    if (_i === 0) {
      context.moveTo(cp0x, cp0y);
    } else {
      context.lineTo(cp0x, cp0y);
    }

    context.arcTo(px, py, cp1x, cp1y, cornerRadius);
  }

  context.closePath();
}; // Round rectangle drawing


CRp$7.drawRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight); // Arc from middle top to right side

  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom

  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side

  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder

  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line

  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawBottomRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight);
  context.lineTo(x + halfWidth, y);
  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
  context.lineTo(x - halfWidth, y - halfHeight);
  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawCutRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerLength = getCutRectangleCornerLength();

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
  context.closePath();
};

CRp$7.drawBarrelPath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xBegin = x - halfWidth;
  var xEnd = x + halfWidth;
  var yBegin = y - halfHeight;
  var yEnd = y + halfHeight;
  var barrelCurveConstants = getBarrelCurveConstants(width, height);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(xBegin, yBegin + hOffset);
  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
  context.closePath();
};

var sin0 = Math.sin(0);
var cos0 = Math.cos(0);
var sin = {};
var cos = {};
var ellipseStepSize = Math.PI / 40;

for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}

CRp$7.drawEllipsePath = function (context, centerX, centerY, width, height) {
  if (context.beginPath) {
    context.beginPath();
  }

  if (context.ellipse) {
    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width / 2;
    var rh = height / 2;

    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }

  context.closePath();
};

/* global atob, ArrayBuffer, Uint8Array, Blob */
var CRp$8 = {};

CRp$8.createBuffer = function (w, h) {
  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef

  buffer.width = w;
  buffer.height = h;
  return [buffer, buffer.getContext('2d')];
};

CRp$8.bufferCanvasImage = function (options) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = number(options.maxWidth) || number(options.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if (options.scale !== undefined) {
    width *= options.scale;
    height *= options.scale;
    scale = options.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if (number(options.maxWidth)) {
      maxScaleW = scale * options.maxWidth / width;
    }

    if (number(options.maxHeight)) {
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min(maxScaleW, maxScaleH);
    width *= scale;
    height *= scale;
  }

  if (!specdMaxDims) {
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;
  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';
  var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size

  if (width > 0 && height > 0) {
    buffCxt.clearRect(0, 0, width, height);
    buffCxt.globalCompositeOperation = 'source-over';
    var zsortedEles = this.getCachedZSortedEles();

    if (options.full) {
      // draw the full bounds of the graph
      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
    } else {
      // draw the current view
      var pan = cy.pan();
      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };
      scale *= cy.zoom();
      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(-translation.x, -translation.y);
    } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs


    if (options.bg) {
      buffCxt.globalCompositeOperation = 'destination-over';
      buffCxt.fillStyle = options.bg;
      buffCxt.rect(0, 0, width, height);
      buffCxt.fill();
    }
  }

  return buffCanvas;
};

function b64ToBlob(b64, mimeType) {
  var bytes = atob(b64);
  var buff = new ArrayBuffer(bytes.length);
  var buffUint8 = new Uint8Array(buff);

  for (var i = 0; i < bytes.length; i++) {
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob([buff], {
    type: mimeType
  });
}

function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(',');
  return b64uri.substr(i + 1);
}

function output(options, canvas, mimeType) {
  var getB64Uri = function getB64Uri() {
    return canvas.toDataURL(mimeType, options.quality);
  };

  switch (options.output) {
    case 'blob-promise':
      return new Promise$1(function (resolve, reject) {
        try {
          canvas.toBlob(function (blob) {
            if (blob != null) {
              resolve(blob);
            } else {
              reject(new Error('`canvas.toBlob()` sent a null value in its callback'));
            }
          }, mimeType, options.quality);
        } catch (err) {
          reject(err);
        }
      });

    case 'blob':
      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);

    case 'base64':
      return b64UriToB64(getB64Uri());

    case 'base64uri':
    default:
      return getB64Uri();
  }
}

CRp$8.png = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/png');
};

CRp$8.jpg = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/jpeg');
};

var CRp$9 = {};

CRp$9.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
  switch (name) {
    case 'ellipse':
      return this.drawEllipsePath(context, centerX, centerY, width, height);

    case 'polygon':
      return this.drawPolygonPath(context, centerX, centerY, width, height, points);

    case 'round-polygon':
      return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);

    case 'roundrectangle':
    case 'round-rectangle':
      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);

    case 'cutrectangle':
    case 'cut-rectangle':
      return this.drawCutRectanglePath(context, centerX, centerY, width, height);

    case 'bottomroundrectangle':
    case 'bottom-round-rectangle':
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);

    case 'barrel':
      return this.drawBarrelPath(context, centerX, centerY, width, height);
  }
};

var CR = CanvasRenderer;
var CRp$a = CanvasRenderer.prototype;
CRp$a.CANVAS_LAYERS = 3; //

CRp$a.SELECT_BOX = 0;
CRp$a.DRAG = 1;
CRp$a.NODE = 2;
CRp$a.BUFFER_COUNT = 3; //

CRp$a.TEXTURE_BUFFER = 0;
CRp$a.MOTIONBLUR_BUFFER_NODE = 1;
CRp$a.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;
  r.data = {
    canvases: new Array(CRp$a.CANVAS_LAYERS),
    contexts: new Array(CRp$a.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp$a.CANVAS_LAYERS),
    bufferCanvases: new Array(CRp$a.BUFFER_COUNT),
    bufferContexts: new Array(CRp$a.CANVAS_LAYERS)
  };
  var tapHlOffAttr = '-webkit-tap-highlight-color';
  var tapHlOffStyle = 'rgba(0,0,0,0)';
  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef

  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';
  var container = options.cy.container();
  container.appendChild(r.data.canvasContainer);
  container.style[tapHlOffAttr] = tapHlOffStyle;
  var styleMap = {
    '-webkit-user-select': 'none',
    '-moz-user-select': '-moz-none',
    'user-select': 'none',
    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
    'outline-style': 'none'
  };

  if (ms()) {
    styleMap['-ms-touch-action'] = 'none';
    styleMap['touch-action'] = 'none';
  }

  for (var i = 0; i < CRp$a.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.contexts[i] = canvas.getContext('2d');
    Object.keys(styleMap).forEach(function (k) {
      canvas.style[k] = styleMap[k];
    });
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp$a.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);
    r.data.canvasNeedsRedraw[i] = false;
  }

  r.data.topCanvas = r.data.canvases[0];
  r.data.canvases[CRp$a.NODE].setAttribute('data-id', 'layer' + CRp$a.NODE + '-node');
  r.data.canvases[CRp$a.SELECT_BOX].setAttribute('data-id', 'layer' + CRp$a.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp$a.DRAG].setAttribute('data-id', 'layer' + CRp$a.DRAG + '-drag');

  for (var i = 0; i < CRp$a.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;
  var emptyBb = makeBoundingBox();

  var getBoxCenter = function getBoxCenter(bb) {
    return {
      x: (bb.x1 + bb.x2) / 2,
      y: (bb.y1 + bb.y2) / 2
    };
  };

  var getCenterOffset = function getCenterOffset(bb) {
    return {
      x: -bb.w / 2,
      y: -bb.h / 2
    };
  };

  var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
    var _p = ele[0]._private;
    var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
    return !same;
  };

  var getStyleKey = function getStyleKey(ele) {
    return ele[0]._private.nodeKey;
  };

  var getLabelKey = function getLabelKey(ele) {
    return ele[0]._private.labelStyleKey;
  };

  var getSourceLabelKey = function getSourceLabelKey(ele) {
    return ele[0]._private.sourceLabelStyleKey;
  };

  var getTargetLabelKey = function getTargetLabelKey(ele) {
    return ele[0]._private.targetLabelStyleKey;
  };

  var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElement(context, ele, bb, false, false, useEleOpacity);
  };

  var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);
  };

  var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);
  };

  var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);
  };

  var getElementBox = function getElementBox(ele) {
    ele.boundingBox();
    return ele[0]._private.bodyBounds;
  };

  var getLabelBox = function getLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.main || emptyBb;
  };

  var getSourceLabelBox = function getSourceLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.source || emptyBb;
  };

  var getTargetLabelBox = function getTargetLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.target || emptyBb;
  };

  var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
    return scaledLabelShown;
  };

  var getElementRotationPoint = function getElementRotationPoint(ele) {
    return getBoxCenter(getElementBox(ele));
  };

  var addTextMargin = function addTextMargin(prefix, pt, ele) {
    var pre = prefix ? prefix + '-' : '';
    return {
      x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,
      y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue
    };
  };

  var getRsPt = function getRsPt(ele, x, y) {
    var rs = ele[0]._private.rscratch;
    return {
      x: rs[x],
      y: rs[y]
    };
  };

  var getLabelRotationPoint = function getLabelRotationPoint(ele) {
    return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);
  };

  var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
    return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);
  };

  var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
    return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);
  };

  var getElementRotationOffset = function getElementRotationOffset(ele) {
    return getCenterOffset(getElementBox(ele));
  };

  var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
    return getCenterOffset(getSourceLabelBox(ele));
  };

  var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
    return getCenterOffset(getTargetLabelBox(ele));
  };

  var getLabelRotationOffset = function getLabelRotationOffset(ele) {
    var bb = getLabelBox(ele);
    var p = getCenterOffset(getLabelBox(ele));

    if (ele.isNode()) {
      switch (ele.pstyle('text-halign').value) {
        case 'left':
          p.x = -bb.w;
          break;

        case 'right':
          p.x = 0;
          break;
      }

      switch (ele.pstyle('text-valign').value) {
        case 'top':
          p.y = -bb.h;
          break;

        case 'bottom':
          p.y = 0;
          break;
      }
    }

    return p;
  };

  var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
    getKey: getStyleKey,
    doesEleInvalidateKey: backgroundTimestampHasChanged,
    drawElement: drawElement,
    getBoundingBox: getElementBox,
    getRotationPoint: getElementRotationPoint,
    getRotationOffset: getElementRotationOffset,
    allowEdgeTxrCaching: false,
    allowParentTxrCaching: false
  });
  var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
    getKey: getLabelKey,
    drawElement: drawLabel,
    getBoundingBox: getLabelBox,
    getRotationPoint: getLabelRotationPoint,
    getRotationOffset: getLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
    getKey: getSourceLabelKey,
    drawElement: drawSourceLabel,
    getBoundingBox: getSourceLabelBox,
    getRotationPoint: getSourceLabelRotationPoint,
    getRotationOffset: getSourceLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
    getKey: getTargetLabelKey,
    drawElement: drawTargetLabel,
    getBoundingBox: getTargetLabelBox,
    getRotationPoint: getTargetLabelRotationPoint,
    getRotationOffset: getTargetLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    // each cache should check for sub-key diff to see that the update affects that cache particularly
    eleTxrCache.invalidateElements(eles);
    lblTxrCache.invalidateElements(eles);
    slbTxrCache.invalidateElements(eles);
    tlbTxrCache.invalidateElements(eles); // any change invalidates the layers

    lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches

    for (var _i = 0; _i < eles.length; _i++) {
      var _p = eles[_i]._private;
      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
    }
  });

  var refineInLayers = function refineInLayers(reqs) {
    for (var i = 0; i < reqs.length; i++) {
      lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
    }
  };

  eleTxrCache.onDequeue(refineInLayers);
  lblTxrCache.onDequeue(refineInLayers);
  slbTxrCache.onDequeue(refineInLayers);
  tlbTxrCache.onDequeue(refineInLayers);
}

CRp$a.redrawHint = function (group, bool) {
  var r = this;

  switch (group) {
    case 'eles':
      r.data.canvasNeedsRedraw[CRp$a.NODE] = bool;
      break;

    case 'drag':
      r.data.canvasNeedsRedraw[CRp$a.DRAG] = bool;
      break;

    case 'select':
      r.data.canvasNeedsRedraw[CRp$a.SELECT_BOX] = bool;
      break;
  }
}; // whether to use Path2D caching for drawing


var pathsImpld = typeof Path2D !== 'undefined';

CRp$a.path2dEnabled = function (on) {
  if (on === undefined) {
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp$a.usePaths = function () {
  return pathsImpld && this.pathsEnabled;
};

CRp$a.setImgSmoothing = function (context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
};

CRp$a.getImgSmoothing = function (context) {
  if (context.imageSmoothingEnabled != null) {
    return context.imageSmoothingEnabled;
  } else {
    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
  }
};

CRp$a.makeOffscreenCanvas = function (width, height) {
  var canvas;

  if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== ( "undefined" )) {
    canvas = new OffscreenCanvas(width, height);
  } else {
    canvas = document.createElement('canvas'); // eslint-disable-line no-undef

    canvas.width = width;
    canvas.height = height;
  }

  return canvas;
};

[CRp, CRp$1, CRp$2, CRp$3, CRp$4, CRp$5, CRp$6, CRp$7, CRp$8, CRp$9].forEach(function (props) {
  extend(CRp$a, props);
});

var renderer = [{
  name: 'null',
  impl: NullRenderer
}, {
  name: 'base',
  impl: BR
}, {
  name: 'canvas',
  impl: CR
}];

var incExts = [{
  type: 'layout',
  extensions: layout
}, {
  type: 'renderer',
  extensions: renderer
}];

var extensions = {}; // registered modules for extensions, indexed by name

var modules = {};

function setExtension(type, name, registrant) {
  var ext = registrant;

  var overrideErr = function overrideErr(field) {
    error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
  };

  if (type === 'core') {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === 'collection') {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === 'layout') {
    // fill in missing layout functions in the prototype
    var Layout = function Layout(options) {
      this.options = options;
      registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()

      if (!plainObject(this._private)) {
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
      this.createEmitter();
    };

    var layoutProto = Layout.prototype = Object.create(registrant.prototype);
    var optLayoutFns = [];

    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function () {
        return this;
      };
    } // either .start() or .run() is defined, so autogen the other


    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function () {
        this.start();
        return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function () {
        this.run();
        return this;
      };
    }

    var regStop = registrant.prototype.stop;

    layoutProto.stop = function () {
      var opts = this.options;

      if (opts && opts.animate) {
        var anis = this.animations;

        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }

      if (regStop) {
        regStop.call(this);
      } else {
        this.emit('layoutstop');
      }

      return this;
    };

    if (!layoutProto.destroy) {
      layoutProto.destroy = function () {
        return this;
      };
    }

    layoutProto.cy = function () {
      return this._private.cy;
    };

    var getCy = function getCy(layout) {
      return layout._private.cy;
    };

    var emitterOpts = {
      addEventFields: function addEventFields(layout, evt) {
        evt.layout = layout;
        evt.cy = getCy(layout);
        evt.target = layout;
      },
      bubble: function bubble() {
        return true;
      },
      parent: function parent(layout) {
        return getCy(layout);
      }
    };
    extend(layoutProto, {
      createEmitter: function createEmitter() {
        this._private.emitter = new Emitter(emitterOpts, this);
        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(evt, cb) {
        this.emitter().on(evt, cb);
        return this;
      },
      one: function one(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      once: function once(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      removeListener: function removeListener(evt, cb) {
        this.emitter().removeListener(evt, cb);
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        this.emitter().removeAllListeners();
        return this;
      },
      emit: function emit(evt, params) {
        this.emitter().emit(evt, params);
        return this;
      }
    });
    define$3.eventAliasesOn(layoutProto);
    ext = Layout; // replace with our wrapped layout
  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base
    var BaseRenderer = getExtension('renderer', 'base');
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function Renderer() {
      BaseRenderer.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    };

    var proto = Renderer.prototype;

    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;

      if (existsInR) {
        return overrideErr(pName);
      }

      proto[pName] = pVal; // take impl from base
    }

    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName]; // take impl from registrant
    }

    bProto.clientFunctions.forEach(function (name) {
      proto[name] = proto[name] || function () {
        error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });
    ext = Renderer;
  }

  return setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}

function getExtension(type, name) {
  return getMap({
    map: extensions,
    keys: [type, name]
  });
}

function setModule(type, name, moduleType, moduleName, registrant) {
  return setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName) {
  return getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}

var extension = function extension() {
  // e.g. extension('renderer', 'svg')
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  } // e.g. extension('renderer', 'svg', { ... })
  else if (arguments.length === 3) {
      return setExtension.apply(null, arguments);
    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if (arguments.length === 4) {
        return getModule.apply(null, arguments);
      } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
      else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          error('Invalid extension access syntax');
        }
}; // allows a core instance to access extensions internally


Core.prototype.extension = extension; // included extensions

incExts.forEach(function (group) {
  group.extensions.forEach(function (ext) {
    setExtension(group.type, ext.name, ext.impl);
  });
});

// (useful for init)

var Stylesheet = function Stylesheet() {
  if (!(this instanceof Stylesheet)) {
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function () {
  return 'stylesheet';
}; // just store the selector to be parsed later


sheetfn.selector = function (selector) {
  var i = this.length++;
  this[i] = {
    selector: selector,
    properties: []
  };
  return this; // chaining
}; // just store the property to be parsed later


sheetfn.css = function (name, value) {
  var i = this.length - 1;

  if (string(name)) {
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if (plainObject(name)) {
    var map = name;
    var propNames = Object.keys(map);

    for (var j = 0; j < propNames.length; j++) {
      var key = propNames[j];
      var mapVal = map[key];

      if (mapVal == null) {
        continue;
      }

      var prop = Style.properties[key] || Style.properties[dash2camel(key)];

      if (prop == null) {
        continue;
      }

      var _name = prop.name;
      var _value = mapVal;
      this[i].properties.push({
        name: _name,
        value: _value
      });
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet

sheetfn.generateStyle = function (cy) {
  var style = new Style(cy);
  return this.appendToStyle(style);
}; // append a dummy stylesheet object on a real style object


sheetfn.appendToStyle = function (style) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;
    style.selector(selector); // apply selector

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      style.css(prop.name, prop.value); // apply property
    }
  }

  return style;
};

var version = "3.12.1";

var cytoscape = function cytoscape(options) {
  // if no options specified, use default
  if (options === undefined) {
    options = {};
  } // create instance


  if (plainObject(options)) {
    return new Core(options);
  } // allow for registration of extensions
  else if (string(options)) {
      return extension.apply(extension, arguments);
    }
}; // e.g. cytoscape.use( require('cytoscape-foo'), bar )


cytoscape.use = function (ext) {
  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

  args.unshift(cytoscape); // cytoscape is first arg to ext

  ext.apply(null, args);
  return this;
};

cytoscape.warnings = function (bool) {
  return warnings(bool);
}; // replaced by build system


cytoscape.version = version; // expose public apis (mostly for extensions)

cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/dagre/index.js":
/*!*************************************!*\
  !*** ./node_modules/dagre/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

module.exports = {
  graphlib: __webpack_require__(/*! ./lib/graphlib */ "./node_modules/dagre/lib/graphlib.js"),

  layout: __webpack_require__(/*! ./lib/layout */ "./node_modules/dagre/lib/layout.js"),
  debug: __webpack_require__(/*! ./lib/debug */ "./node_modules/dagre/lib/debug.js"),
  util: {
    time: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").time,
    notime: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").notime
  },
  version: __webpack_require__(/*! ./lib/version */ "./node_modules/dagre/lib/version.js")
};


/***/ }),

/***/ "./node_modules/dagre/lib/acyclic.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/acyclic.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var greedyFAS = __webpack_require__(/*! ./greedy-fas */ "./node_modules/dagre/lib/greedy-fas.js");

module.exports = {
  run: run,
  undo: undo
};

function run(g) {
  var fas = (g.graph().acyclicer === "greedy"
    ? greedyFAS(g, weightFn(g))
    : dfsFAS(g));
  _.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
  });

  function weightFn(g) {
    return function(e) {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};

  function dfs(v) {
    if (_.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    _.forEach(g.outEdges(v), function(e) {
      if (_.has(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  _.forEach(g.nodes(), dfs);
  return fas;
}

function undo(g) {
  _.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/add-border-segments.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/add-border-segments.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      _.forEach(children, dfs);
    }

    if (_.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  _.forEach(g.children(), dfs);
}

function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  var label = { width: 0, height: 0, rank: rank, borderType: prop };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/coordinate-system.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/coordinate-system.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  adjust: adjust,
  undo: undo
};

function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
}

function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, reverseYOne);
    if (_.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, swapXYOne);
    if (_.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}


/***/ }),

/***/ "./node_modules/dagre/lib/data/list.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/data/list.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

module.exports = List;

function List() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}

List.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};

List.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};

List.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/dagre/lib/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);

  var h = new Graph({ compound: true, multigraph: true }).setGraph({});

  _.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  _.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });

  _.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    _.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}


/***/ }),

/***/ "./node_modules/dagre/lib/graphlib.js":
/*!********************************************!*\
  !*** ./node_modules/dagre/lib/graphlib.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */

var graphlib;

if (true) {
  try {
    graphlib = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");
  } catch (e) {
    // continue regardless of error
  }
}

if (!graphlib) {
  graphlib = window.graphlib;
}

module.exports = graphlib;


/***/ }),

/***/ "./node_modules/dagre/lib/greedy-fas.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/greedy-fas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var List = __webpack_require__(/*! ./data/list */ "./node_modules/dagre/lib/data/list.js");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;

var DEFAULT_WEIGHT_FN = _.constant(1);

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return _.flatten(_.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}

function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];

  var entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;

  _.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  _.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  var fasGraph = new Graph();
  var maxIn = 0;
  var maxOut = 0;

  _.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  _.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });
  var zeroIdx = maxIn + 1;

  _.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/layout.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/layout.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var acyclic = __webpack_require__(/*! ./acyclic */ "./node_modules/dagre/lib/acyclic.js");
var normalize = __webpack_require__(/*! ./normalize */ "./node_modules/dagre/lib/normalize.js");
var rank = __webpack_require__(/*! ./rank */ "./node_modules/dagre/lib/rank/index.js");
var normalizeRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").normalizeRanks;
var parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/dagre/lib/parent-dummy-chains.js");
var removeEmptyRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").removeEmptyRanks;
var nestingGraph = __webpack_require__(/*! ./nesting-graph */ "./node_modules/dagre/lib/nesting-graph.js");
var addBorderSegments = __webpack_require__(/*! ./add-border-segments */ "./node_modules/dagre/lib/add-border-segments.js");
var coordinateSystem = __webpack_require__(/*! ./coordinate-system */ "./node_modules/dagre/lib/coordinate-system.js");
var order = __webpack_require__(/*! ./order */ "./node_modules/dagre/lib/order/index.js");
var position = __webpack_require__(/*! ./position */ "./node_modules/dagre/lib/position/index.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = layout;

function layout(g, opts) {
  var time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", function() {
    var layoutGraph = 
      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
    time("  runLayout",        function() { runLayout(layoutGraph, time); });
    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
  time("    acyclic",                function() { acyclic.run(g); });
  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
  time("    rank",                   function() { rank(util.asNonCompoundGraph(g)); });
  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
  time("    removeEmptyRanks",       function() { removeEmptyRanks(g); });
  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
  time("    normalizeRanks",         function() { normalizeRanks(g); });
  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
  time("    normalize.run",          function() { normalize.run(g); });
  time("    parentDummyChains",      function() { parentDummyChains(g); });
  time("    addBorderSegments",      function() { addBorderSegments(g); });
  time("    order",                  function() { order(g); });
  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
  time("    position",               function() { position(g); });
  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
  time("    normalize.undo",         function() { normalize.undo(g); });
  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
  time("    translateGraph",         function() { translateGraph(g); });
  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
  time("    acyclic.undo",           function() { acyclic.undo(g); });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  _.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  _.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (_.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph({ multigraph: true, compound: true });
  var graph = canonicalize(inputGraph.graph());

  g.setGraph(_.merge({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    _.pick(graph, graphAttrs)));

  _.forEach(inputGraph.nodes(), function(v) {
    var node = canonicalize(inputGraph.node(v));
    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });

  _.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, _.merge({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  var maxRank = 0;
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = _.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_.has(edge, "x")) { edge.x -= minX; }
    if (_.has(edge, "y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  _.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(_.last(node.borderLeft));
      var r = g.node(_.last(node.borderRight));

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  _.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  _.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  _.forEach(layers, function(layer) {
    var orderShift = 0;
    _.forEach(layer, function(v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      _.forEach(node.selfEdges, function(selfEdge) {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return _.mapValues(_.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  _.forEach(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}


/***/ }),

/***/ "./node_modules/dagre/lib/lodash.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/lodash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      defaults: __webpack_require__(/*! lodash/defaults */ "./node_modules/lodash/defaults.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      find: __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js"),
      flatten: __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js"),
      forEach: __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js"),
      forIn: __webpack_require__(/*! lodash/forIn */ "./node_modules/lodash/forIn.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      last: __webpack_require__(/*! lodash/last */ "./node_modules/lodash/last.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      mapValues: __webpack_require__(/*! lodash/mapValues */ "./node_modules/lodash/mapValues.js"),
      max: __webpack_require__(/*! lodash/max */ "./node_modules/lodash/max.js"),
      merge: __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js"),
      min: __webpack_require__(/*! lodash/min */ "./node_modules/lodash/min.js"),
      minBy: __webpack_require__(/*! lodash/minBy */ "./node_modules/lodash/minBy.js"),
      now: __webpack_require__(/*! lodash/now */ "./node_modules/lodash/now.js"),
      pick: __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js"),
      range: __webpack_require__(/*! lodash/range */ "./node_modules/lodash/range.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      sortBy: __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js"),
      uniqueId: __webpack_require__(/*! lodash/uniqueId */ "./node_modules/lodash/uniqueId.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js"),
      zipObject: __webpack_require__(/*! lodash/zipObject */ "./node_modules/lodash/zipObject.js"),
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/dagre/lib/nesting-graph.js":
/*!*************************************************!*\
  !*** ./node_modules/dagre/lib/nesting-graph.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  _.forEach(g.children(), function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  _.forEach(children, function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);

    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      _.forEach(children, function(child) {
        dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _.forEach(g.children(), function(v) { dfs(v, 1); });
  return depths;
}

function sumWeights(g) {
  return _.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/normalize.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/normalize.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
}

function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo(g) {
  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/add-subgraph-constraints.js":
/*!******************************************************************!*\
  !*** ./node_modules/dagre/lib/order/add-subgraph-constraints.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;

  _.forEach(vs, function(v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      _.each(children, function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/barycenter.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/barycenter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = barycenter;

function barycenter(g, movable) {
  return _.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      var result = _.reduce(inV, function(acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/order/build-layer-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/build-layer-graph.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(function(v) { return g.node(v); });

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      _.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = !_.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (_.has(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = _.uniqueId("_root"))));
  return v;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/cross-count.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/order/cross-count.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = _.zipObject(southLayer,
    _.map(southLayer, function (v, i) { return i; }));
  var southEntries = _.flatten(_.map(northLayer, function(v) {
    return _.sortBy(_.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = _.map(new Array(treeSize), function() { return 0; });

  // Calculate the weighted crossings
  var cc = 0;
  _.forEach(southEntries.forEach(function(entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));

  return cc;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/index.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/order/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var initOrder = __webpack_require__(/*! ./init-order */ "./node_modules/dagre/lib/order/init-order.js");
var crossCount = __webpack_require__(/*! ./cross-count */ "./node_modules/dagre/lib/order/cross-count.js");
var sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/dagre/lib/order/sort-subgraph.js");
var buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/dagre/lib/order/build-layer-graph.js");
var addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/dagre/lib/order/add-subgraph-constraints.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g) {
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");

  var layering = initOrder(g);
  assignOrder(g, layering);

  var bestCC = Number.POSITIVE_INFINITY,
    best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _.cloneDeep(layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return _.map(ranks, function(rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph();
  _.forEach(layerGraphs, function(lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph(lg, root, cg, biasRight);
    _.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/init-order.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/init-order.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = _.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));
  var layers = _.map(_.range(maxRank + 1), function() { return []; });

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    _.forEach(g.successors(v), dfs);
  }

  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
  _.forEach(orderedVs, dfs);

  return layers;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/resolve-conflicts.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/resolve-conflicts.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  _.forEach(entries, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (!_.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  _.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  var sourceSet = _.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  var entries = [];

  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_.isUndefined(uEntry.barycenter) ||
          _.isUndefined(vEntry.barycenter) ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    _.forEach(entry["in"].reverse(), handleIn(entry));
    _.forEach(entry.out, handleOut(entry));
  }

  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),
    function(entry) {
      return _.pick(entry, ["vs", "i", "barycenter", "weight"]);
    });

}

function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort-subgraph.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/order/sort-subgraph.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var barycenter = __webpack_require__(/*! ./barycenter */ "./node_modules/dagre/lib/order/barycenter.js");
var resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/dagre/lib/order/resolve-conflicts.js");
var sort = __webpack_require__(/*! ./sort */ "./node_modules/dagre/lib/order/sort.js");

module.exports = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight: undefined;
  var subgraphs = {};

  if (bl) {
    movable = _.filter(movable, function(w) {
      return w !== bl && w !== br;
    });
  }

  var barycenters = barycenter(g, movable);
  _.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  var result = sort(entries, biasRight);

  if (bl) {
    result.vs = _.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!_.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  _.forEach(entries, function(entry) {
    entry.vs = _.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}

function mergeBarycenters(target, other) {
  if (!_.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/order/sort.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = sort;

function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return _.has(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  _.forEach(sortable, function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  var result = { vs: _.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = _.last(unsortable)).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}


/***/ }),

/***/ "./node_modules/dagre/lib/parent-dummy-chains.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/parent-dummy-chains.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = parentDummyChains;

function parentDummyChains(g) {
  var postorderNums = postorder(g);

  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder(g) {
  var result = {};
  var lim = 0;

  function dfs(v) {
    var low = lim;
    _.forEach(g.children(v), dfs);
    result[v] = { low: low, lim: lim++ };
  }
  _.forEach(g.children(), dfs);

  return result;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/bk.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/position/bk.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

/*
 * This module provides coordinate assignment based on Brandes and KÃ¶pf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};

  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = _.last(layer);

    _.forEach(layer, function(v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {
          _.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findType2Conflicts(g, layering) {
  var conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _.forEach(_.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        _.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    _.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return _.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return _.has(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  _.forEach(layering, function(layer) {
    var prevIdx = -1;
    _.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _.sortBy(ws, function(w) { return pos[w]; });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  _.forEach(align, function(v) {
    xs[v] = xs[root[v]];
  });

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  _.forEach(layering, function(layer) {
    var u;
    _.forEach(layer, function(v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return _.minBy(_.values(xss), function (xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;

    _.forIn(xs, function (x, v) {
      var halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    return max - min;
  });
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = _.values(alignTo),
    alignToMin = _.min(alignToVals),
    alignToMax = _.max(alignToVals);

  _.forEach(["u", "d"], function(vert) {
    _.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment],
        delta;
      if (xs === alignTo) return;

      var xsVals = _.values(xs);
      delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);

      if (delta) {
        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });
      }
    });
  });
}

function balance(xss, align) {
  return _.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _.sortBy(_.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = _.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  _.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
    _.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _.map(adjustedLayering, function(inner) {
          return _.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = _.mapValues(xs, function(x) { return -x; });
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;

    sum += vLabel.width / 2;
    if (_.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (_.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dagre/lib/position/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");
var positionX = __webpack_require__(/*! ./bk */ "./node_modules/dagre/lib/position/bk.js").positionX;

module.exports = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  _.forEach(positionX(g), function(x, v) {
    g.node(v).x = x;
  });
}

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  _.forEach(layering, function(layer) {
    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));
    _.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/rank/feasible-tree.js":
/*!******************************************************!*\
  !*** ./node_modules/dagre/lib/rank/feasible-tree.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;

module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    _.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  _.forEach(t.nodes(), dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  return _.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack(g, e);
    }
  });
}

function shiftRanks(t, g, delta) {
  _.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/rank/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var rankUtil = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js");
var longestPath = rankUtil.longestPath;
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var networkSimplex = __webpack_require__(/*! ./network-simplex */ "./node_modules/dagre/lib/rank/network-simplex.js");

module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;

function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}

function networkSimplexRanker(g) {
  networkSimplex(g);
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/network-simplex.js":
/*!********************************************************!*\
  !*** ./node_modules/dagre/lib/rank/network-simplex.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;
var initRank = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").longestPath;
var preorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.preorder;
var postorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.postorder;
var simplify = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js").simplify;

module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  _.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  _.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  _.forEach(tree.neighbors(v), function(w) {
    if (!_.has(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return _.find(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = _.filter(g.edges(), function(edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return _.minBy(candidates, function(edge) { return slack(g, edge); });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });
  var vs = preorder(t, root);
  vs = vs.slice(1);
  _.forEach(vs, function(v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/util.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/rank/util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (_.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = _.min(_.map(g.outEdges(v), function(e) {
      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank === undefined || // return value of _.map([]) for Lodash 4
        rank === null) { // return value of _.map([null])
      rank = 0;
    }

    return (label.rank = rank);
  }

  _.forEach(g.sources(), dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}


/***/ }),

/***/ "./node_modules/dagre/lib/util.js":
/*!****************************************!*\
  !*** ./node_modules/dagre/lib/util.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint "no-console": off */



var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  addDummyNode: addDummyNode,
  simplify: simplify,
  asNonCompoundGraph: asNonCompoundGraph,
  successorWeights: successorWeights,
  predecessorWeights: predecessorWeights,
  intersectRect: intersectRect,
  buildLayerMatrix: buildLayerMatrix,
  normalizeRanks: normalizeRanks,
  removeEmptyRanks: removeEmptyRanks,
  addBorderNode: addBorderNode,
  maxRank: maxRank,
  partition: partition,
  time: time,
  notime: notime
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = _.uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph().setGraph(g.graph());
  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  _.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  _.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var sucs = {};
    _.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return _.zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var preds = {};
    _.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return _.zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    var rank = node.rank;
    if (!_.isUndefined(rank)) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (_.has(node, "rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));

  var layers = [];
  _.forEach(g.nodes(), function(v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  _.forEach(layers, function(vs, i) {
    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _.forEach(vs, function(v) { g.node(v).rank += delta; });
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  return _.max(_.map(g.nodes(), function(v) {
    var rank = g.node(v).rank;
    if (!_.isUndefined(rank)) {
      return rank;
    }
  }));
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = _.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (_.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}


/***/ }),

/***/ "./node_modules/dagre/lib/version.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/version.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "0.8.5";


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    _.each(g.successors(v), dfs);
    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var acc = [];
  var visited = {};
  _.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    _.each(navigation(v), function(w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });
    if (postorder) { acc.push(v); }
  }
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js");
var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      _.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}
CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};


/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = _.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = _.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self = this;
  _.each(vs, function(v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (_.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        self.setParent(child);
      });
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
      !_.isUndefined(ancestor);
      ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  var self = this;
  _.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this;
  var args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}


/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  _.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '2.1.8';


/***/ }),

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/heap */ "./node_modules/heap/lib/heap.js");


/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (true) {
      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(this, function() {
    return Heap;
  });

}).call(this);


/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.memoize/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.memoize/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseExtremum.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseExtremum.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseGt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseGt.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseLt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseLt.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

module.exports = baseLt;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseOrderBy.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseRange.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseSortBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_baseZipObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseZipObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

module.exports = baseZipObject;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_compareAscending.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ "./node_modules/lodash/_compareMultiple.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending = __webpack_require__(/*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js");

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createRange.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseRange = __webpack_require__(/*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;


/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_flatRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(/*! ./flatten */ "./node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/forIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/forIn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ "./node_modules/lodash/mapValues.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mapValues.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js");

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),

/***/ "./node_modules/lodash/max.js":
/*!************************************!*\
  !*** ./node_modules/lodash/max.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseGt = __webpack_require__(/*! ./_baseGt */ "./node_modules/lodash/_baseGt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/merge.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/min.js":
/*!************************************!*\
  !*** ./node_modules/lodash/min.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;


/***/ }),

/***/ "./node_modules/lodash/minBy.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/minBy.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js");

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

module.exports = minBy;


/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/range.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createRange = __webpack_require__(/*! ./_createRange */ "./node_modules/lodash/_createRange.js");

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}

module.exports = size;


/***/ }),

/***/ "./node_modules/lodash/sortBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),

/***/ "./node_modules/lodash/uniqueId.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqueId.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;


/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ "./node_modules/lodash/zipObject.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/zipObject.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ "./node_modules/lodash/_baseZipObject.js");

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

module.exports = zipObject;


/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return H; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return I; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toChildArray", function() { return b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_unmount", function() { return A; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return n; });
var n,l,u,t,i,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var t,i,o,r,f=arguments;if(l=s({},l),arguments.length>3)for(u=[u],t=3;t<arguments.length;t++)u.push(f[t]);if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps)for(i in n.defaultProps)void 0===l[i]&&(l[i]=n.defaultProps[i]);return r=l.key,null!=(o=l.ref)&&delete l.ref,null!=r&&delete l.key,v(n,l,r,o)}function v(l,u,t,i){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(o),o}function p(){return{}}function d(n){return n.children}function y(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__?m(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?m(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function g(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){var n,l,t,i,o,r,f;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();)n.__d&&(t=void 0,i=void 0,r=(o=(l=n).__v).__e,(f=l.__P)&&(t=[],i=T(f,o,s({},o),l.__n,void 0!==f.ownerSVGElement,null,t,null==r?m(o):r),$(t,o),i!=r&&w(o)))}function _(n,l,u,t,i,o,r,c,s){var h,v,p,d,y,w,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=o?o[0]:_?m(u,0):null),h=0,l.__k=b(l.__k,function(u){if(null!=u){if(u.__=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type)k[h]=void 0;else for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null}if(d=T(n,u,p=p||f,t,i,o,r,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,u),g.push(v,u.__c||d,u)),null!=d){if(null==w&&(w=d),null!=u.__d)d=u.__d,u.__d=null;else if(o==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n)n.appendChild(d);else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2)if(y==d)break n;n.insertBefore(d,c)}"option"==l.type&&(n.value="")}c=d.nextSibling,"function"==typeof l.type&&(l.__d=d)}}return h++,u}),l.__e=w,null!=o&&"function"!=typeof l.type)for(h=o.length;h--;)null!=o[h]&&a(o[h]);for(h=_;h--;)null!=k[h]&&A(k[h],k[h]);if(g)for(h=0;h<g.length;h++)z(g[h],g[++h],g[++h])}function b(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var t=0;t<n.length;t++)b(n[t],l,u);else u.push(l?l("string"==typeof n||"number"==typeof n?v(null,n,null,null):null!=n.__e||null!=n.__c?v(n.type,n.props,n.key,null):n):n);return u}function x(n,l,u,t,i){var o;for(o in u)o in l||P(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"value"===o||"checked"===o||u[o]===l[o]||P(n,o,l[o],u[o],t)}function C(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===c.test(l)?u+"px":null==u?"":u}function P(n,l,u,t,i){var o,r,f,e,c;if(i?"className"===l&&(l="class"):"class"===l&&(l="className"),"key"===l||"children"===l);else if("style"===l)if(o=n.style,"string"==typeof u)o.cssText=u;else{if("string"==typeof t&&(o.cssText="",t=null),t)for(r in t)u&&r in u||C(o,r,"");if(u)for(f in u)t&&u[f]===t[f]||C(o,f,u[f])}else"o"===l[0]&&"n"===l[1]?(e=l!==(l=l.replace(/Capture$/,"")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,N,e),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,N,e)):"list"!==l&&"tagName"!==l&&"form"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u))}function N(l){this.l[l.type](n.event?n.event(l):l)}function T(l,u,t,i,o,r,f,e,c){var a,h,v,p,m,w,g,k,x,C,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(k=u.props,x=(a=P.contextType)&&i[a.__c],C=a?x?x.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:("prototype"in P&&P.prototype.render?u.__c=h=new P(k,C):(u.__c=h=new y(k,C),h.constructor=P,h.render=D),x&&x.sub(h),h.props=k,h.state||(h.state={}),h.context=C,h.__n=i,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,P.getDerivedStateFromProps(k,h.__s))),p=h.props,m=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&null==h.__e&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,C),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,C)){for(h.props=k,h.state=h.__s,h.__d=!1,h.__v=u,u.__e=t.__e,u.__k=t.__k,h.__h.length&&f.push(h),a=0;a<u.__k.length;a++)u.__k[a]&&(u.__k[a].__=u);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,C),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,m,w)})}h.context=C,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),u.__k=b(null!=a&&a.type==d&&null==a.key?a.props.children:a),null!=h.getChildContext&&(i=s(s({},i),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(w=h.getSnapshotBeforeUpdate(p,m)),_(l,u,t,i,o,r,f,e,c),h.base=u.__e,h.__h.length&&f.push(h),g&&(h.__E=h.__=null),h.__e=null}else u.__e=j(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){n.__e(l,u,t)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,t,i,o,r,c){var s,a,h,v,p,d=u.props,y=l.props;if(i="svg"===l.type||i,null==n&&null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(y);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type),o=null}if(null===l.type)null!=o&&(o[o.indexOf(n)]=null),d!==y&&(n.data=y);else if(l!==u){if(null!=o&&(o=e.slice.call(n.childNodes)),h=(d=u.props||f).dangerouslySetInnerHTML,v=y.dangerouslySetInnerHTML,!c){if(d===f)for(d={},p=0;p<n.attributes.length;p++)d[n.attributes[p].name]=n.attributes[p].value;(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||""))}x(n,y,d,i,c),l.__k=l.props.children,v||_(n,l,u,t,"foreignObject"!==l.type&&i,o,r,f,c),c||("value"in y&&void 0!==y.value&&y.value!==n.value&&(n.value=null==y.value?"":y.value),"checked"in y&&void 0!==y.checked&&y.checked!==n.checked&&(n.checked=y.checked))}return n}function z(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function A(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&z(i,null,u),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=null,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&A(i[r],u,t);null!=o&&a(o)}function D(n,l,u){return this.constructor(n,u)}function E(l,u,t){var i,r,c;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],T(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:e.slice.call(u.childNodes),c,t||f,i),$(c,l)}function H(n,l){E(n,l,o)}function I(n,l){return l=s(s({},n.props),l),arguments.length>2&&(l.children=e.slice.call(arguments,2)),v(n.type,l,l.key||n.key,l.ref||n.ref)}function L(n){var l={},u={__c:"__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var t,i=this;return this.getChildContext||(t=[],this.getChildContext=function(){return l[u.__c]=i,l},this.shouldComponentUpdate=function(l){n.value!==l.value&&t.some(function(n){n.context=l.value,g(n)})},this.sub=function(n){t.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){t.splice(t.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u}n={__e:function(n,l){for(var u;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError)u.setState(u.constructor.getDerivedStateFromError(n));else{if(null==u.componentDidCatch)continue;u.componentDidCatch(n)}return g(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(u,this.props)),n&&s(u,n),null!=n&&this.__v&&(this.__e=!1,l&&this.__h.push(l),g(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),g(this))},y.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,o=f,r=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/client/components/app.js":
/*!**************************************!*\
  !*** ./src/client/components/app.js ***!
  \**************************************/
/*! exports provided: default, AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controller */ "./src/client/controller.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cytoscape */ "./node_modules/cytoscape/dist/cytoscape.cjs.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cytoscape__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _cy_conf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cy-conf */ "./src/client/cy-conf/index.js");
/* harmony import */ var _cytoscape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cytoscape */ "./src/client/components/cytoscape.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../env */ "./src/client/env.js");
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./menu */ "./src/client/components/menu.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter */ "./src/client/components/filter.js");
/* harmony import */ var _cy_conf_data_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cy-conf/data.json */ "./src/client/cy-conf/data.json");
var _cy_conf_data_json__WEBPACK_IMPORTED_MODULE_9___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../cy-conf/data.json */ "./src/client/cy-conf/data.json", 1);
/* harmony import */ var cytoscape_dagre__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cytoscape-dagre */ "./node_modules/cytoscape-dagre/cytoscape-dagre.js");
/* harmony import */ var cytoscape_dagre__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(cytoscape_dagre__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var cytoscape_euler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cytoscape-euler */ "./node_modules/cytoscape-euler/cytoscape-euler.js");
/* harmony import */ var cytoscape_euler__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(cytoscape_euler__WEBPACK_IMPORTED_MODULE_11__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }














var AppComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(AppComponent, _Component);

  function AppComponent(props) {
    var _this;

    _classCallCheck(this, AppComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AppComponent).call(this, props));
    var layouts = {
      DAG: {
        name: 'dagre',
        animate: false,
        padding: 10,
        rankDir: 'TB',
        nodeSep: 120,
        edgeSep: 200,
        rankSep: 150,
        avoidOverlap: true,
        fit: true
      },
      FDG: {
        name: 'euler',
        springLength: 300,
        animate: false,
        fit: false,
        padding: 10,
        centerGraph: true,
        springCoeff: 0.0008,
        mass: 15,
        gravity: -10,
        pull: 0.0001,
        theta: 0.333,
        dragCoeff: 0.02,
        movementThreshold: 1,
        timeStep: 20,
        refresh: 10,
        animationDuration: undefined,
        animationEasing: undefined,
        maxIterations: 1000,
        maxSimulationTime: 4000,
        ungrabifyWhileSimulating: false,
        randomize: true
      }
    };
    cytoscape__WEBPACK_IMPORTED_MODULE_2___default.a.use(cytoscape_dagre__WEBPACK_IMPORTED_MODULE_10___default.a);
    cytoscape__WEBPACK_IMPORTED_MODULE_2___default.a.use(cytoscape_euler__WEBPACK_IMPORTED_MODULE_11___default.a);

    function GetName(node) {
      var jfTypes = ["improvement", "pattern", "saga", "user"];

      if (jfTypes.includes(node.group)) {
        return node.name === null ? node.id : node.name.substring(0, 100);
      }

      return node.id;
    }

    var cy = new cytoscape__WEBPACK_IMPORTED_MODULE_2___default.a({
      elements: {
        nodes: _cy_conf_data_json__WEBPACK_IMPORTED_MODULE_9__["nodes"].map(function (node) {
          return {
            data: {
              id: node.id,
              name: GetName(node),
              description: node.name,
              NodeType: node.group,
              selected: false,
              weight: node.weight + 100,
              link: node.Link,
              priority: "false"
            },
            selected: false
          };
        }),
        edges: _cy_conf_data_json__WEBPACK_IMPORTED_MODULE_9__["links"].map(function (link) {
          return {
            data: {
              id: (Math.random() + 1).toString(36).substring(7),
              source: link.source,
              target: link.target,
              weight: link.weight + 20,
              sourceType: link.sourceType,
              targetType: link.targetType
            }
          };
        })
      },
      style: _cy_conf__WEBPACK_IMPORTED_MODULE_3__["style"],
      selectionType: 'single',
      boxSelectionEnabled: true,
      wheelSensitivity: 0.25
    });
    cy.nodes().panify().ungrabify(); //TODO - remove this hack when JF gives improvements a weighting generated
    //from the composite weights of their linked patterns

    cy.elements("node[NodeType = 'improvement']").forEach(function (element) {
      if (element.data().weight == 100) {
        var compositeWeight = 0;
        element.outgoers("node[NodeType = 'pattern']").forEach(function (pattern) {
          compositeWeight = compositeWeight + pattern.data().weight;
        });
        element.incomers("node[NodeType = 'saga']").forEach(function (pattern) {
          compositeWeight = compositeWeight + pattern.data().weight;
        });
        element.data().weight = 100 + compositeWeight / 8;
      }
    });
    var controller = new _controller__WEBPACK_IMPORTED_MODULE_1__["Controller"]({
      cy: cy,
      layouts: layouts
    });
    var bus = controller.bus;

    if (_env__WEBPACK_IMPORTED_MODULE_5__["isDev"]) {
      window.cy = cy;
      window.controller = controller;
    }

    _this.state = {
      controller: controller,
      cy: cy
    };
    controller.runLayout();
    bus.on('showInfo', _this.onShowInfo = function (node) {
      _this.setState({
        infoNode: node
      });
    });
    bus.on('hideInfo', _this.onHideInfo = function () {
      _this.setState({
        infoNode: null
      });
    });
    return _this;
  }

  _createClass(AppComponent, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.state.controller.bus;
      bus.removeListener('showInfo', this.onShowInfo);
      bus.removeListener('hideInfo', this.onHideInfo);
    }
  }, {
    key: "truncateString",
    value: function truncateString(str, num) {
      // If the length of str is less than or equal to num
      // just return str--don't truncate it.
      if (str.length <= num) {
        return str;
      } // Return str truncated with '...' concatenated to the end of str.


      return str.slice(0, num) + '...';
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          cy = _this$state.cy,
          controller = _this$state.controller,
          infoNode = _this$state.infoNode;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_cytoscape__WEBPACK_IMPORTED_MODULE_4__["default"], {
        cy: cy,
        controller: controller
      }), infoNode ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app-node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_6__["NodeInfo"], {
        node: infoNode
      })]) : null, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_menu__WEBPACK_IMPORTED_MODULE_7__["Menu"], {
        controller: controller
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_filter__WEBPACK_IMPORTED_MODULE_8__["Filter"], {
        controller: controller
      })]);
    }
  }]);

  return AppComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (AppComponent);


/***/ }),

/***/ "./src/client/components/cytoscape.js":
/*!********************************************!*\
  !*** ./src/client/components/cytoscape.js ***!
  \********************************************/
/*! exports provided: default, CytoscapeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CytoscapeComponent", function() { return CytoscapeComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var CytoscapeComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(CytoscapeComponent, _Component);

  function CytoscapeComponent(props) {
    _classCallCheck(this, CytoscapeComponent);

    return _possibleConstructorReturn(this, _getPrototypeOf(CytoscapeComponent).call(this, props));
  }

  _createClass(CytoscapeComponent, [{
    key: "render",
    value: function render() {
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        id: 'cy'
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          cy = _this$props.cy,
          controller = _this$props.controller;
      var container = document.getElementById('cy');
      cy.mount(container);
      cy.fit(10);
      cy.on('tap', this.onTap = function (e) {
        if (e.target === cy) {
          controller.unhighlight();
          controller.hideInfo();
          controller.closeMenu();
        } else {
          controller.highlight(e.target);
          controller.showInfo(e.target);
          controller.closeMenu();
        }
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var cy = this.props.cy;
      cy.removeListener('tap', this.onTap);
    }
  }]);

  return CytoscapeComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (CytoscapeComponent);


/***/ }),

/***/ "./src/client/components/filter.js":
/*!*****************************************!*\
  !*** ./src/client/components/filter.js ***!
  \*****************************************/
/*! exports provided: default, Filter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filter", function() { return Filter; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Filter =
/*#__PURE__*/
function (_Component) {
  _inherits(Filter, _Component);

  function Filter(props) {
    var _this;

    _classCallCheck(this, Filter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Filter).call(this, props));
    var controller = props.controller;
    var bus = controller.bus;
    bus.on('changeType', _this.changeChartType = function () {
      _this.setState({
        open: false
      });
    });
    return _this;
  }

  _createClass(Filter, [{
    key: "setChartTypeLabel",
    value: function setChartTypeLabel() {
      var controller = this.props.controller;
      var toggle = document.getElementById('chart-type-label');
      toggle.value = "Chart Type: " + controller.chartType;
    }
  }, {
    key: "togglePatterns",
    value: function togglePatterns() {
      var controller = this.props.controller;
      controller.togglePatterns();
    }
  }, {
    key: "toggleImprovements",
    value: function toggleImprovements() {
      var controller = this.props.controller;
      controller.toggleImprovements();
    }
  }, {
    key: "toggleSagas",
    value: function toggleSagas() {
      var controller = this.props.controller;
      controller.toggleSagas();
    }
  }, {
    key: "toggleAssumptions",
    value: function toggleAssumptions() {
      var controller = this.props.controller;
      controller.toggleAssumptions();
    }
  }, {
    key: "toggleApproaches",
    value: function toggleApproaches() {
      var controller = this.props.controller;
      controller.toggleApproaches();
    }
  }, {
    key: "toggleGoals",
    value: function toggleGoals() {
      var controller = this.props.controller;
      controller.toggleGoals();
    }
  }, {
    key: "toggleOrphans",
    value: function toggleOrphans() {
      var controller = this.props.controller;
      controller.toggleOrphans();
    }
  }, {
    key: "togglePriority",
    value: function togglePriority() {
      var controller = this.props.controller;
      controller.togglePriority();
    }
  }, {
    key: "toggleUsers",
    value: function toggleUsers() {
      var controller = this.props.controller;
      controller.toggleUsers();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.props.controller.bus;
      bus.removeListener('changeType', this.changeChartType);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var controller = this.props.controller;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'filter'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'chart-type-toggle': true
        }),
        onClick: function onClick() {
          return controller.toggleChartType();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels chart-type',
        id: 'chart-type-label'
      }, "Chart Type: " + controller.chartType), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.assumptions,
        onClick: function onClick() {
          return _this2.toggleAssumptions();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round assumption'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels assumptions'
      }, 'assumptions')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.goals,
        onClick: function onClick() {
          return _this2.toggleGoals();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round goal'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels goals'
      }, 'goals')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.approaches,
        onClick: function onClick() {
          return _this2.toggleApproaches();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round approach'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels approaches'
      }, 'approaches')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.sagas,
        onClick: function onClick() {
          return _this2.toggleSagas();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round saga'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels sagas'
      }, 'sagas')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.improvements,
        onClick: function onClick() {
          return _this2.toggleImprovements();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round improvement'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels improvements'
      }, 'improvements')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.patterns,
        onClick: function onClick() {
          return _this2.togglePatterns();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round pattern'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels patterns'
      }, 'patterns')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.users,
        onClick: function onClick() {
          return _this2.toggleUsers();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round users'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels users'
      }, 'users')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.orphans,
        onClick: function onClick() {
          return _this2.toggleOrphans();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels orphans'
      }, 'orphans')]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'filter-position': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('label', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'switch': true
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'checkbox',
        checked: controller.priority,
        onClick: function onClick() {
          return _this2.togglePriority();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider round priority'
      })]), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('span', {
        "class": 'slider-labels priority'
      }, 'prioritisation')])]);
    }
  }]);

  return Filter;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (Filter);


/***/ }),

/***/ "./src/client/components/menu.js":
/*!***************************************!*\
  !*** ./src/client/components/menu.js ***!
  \***************************************/
/*! exports provided: default, Menu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Menu", function() { return Menu; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var Menu =
/*#__PURE__*/
function (_Component) {
  _inherits(Menu, _Component);

  function Menu(props) {
    var _this;

    _classCallCheck(this, Menu);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, props));
    var controller = props.controller;
    var bus = controller.bus;
    _this.state = {
      open: controller.isMenuOpen()
    };
    bus.on('openMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: true
      });

      _this.focusTextBox();
    });
    bus.on('closeMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: false
      });
    });
    bus.on('updateSearch', _this.onUpdateSearch = function (searchMatchNodes) {
      _this.setState({
        searchMatchNodes: searchMatchNodes
      });
    });
    _this.debouncedUpdateSearch = lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default()(function () {
      return _this.updateSearch();
    }, 250);
    return _this;
  }

  _createClass(Menu, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.props.controller.bus;
      bus.removeListener('openMenu', this.onOpenMenu);
      bus.removeListener('closeMenu', this.onCloseMenu);
      bus.removeListener('updateSearch', this.onUpdateSearch);
    }
  }, {
    key: "open",
    value: function open() {
      var controller = this.props.controller;
      controller.openMenu();
    }
  }, {
    key: "updateSearch",
    value: function updateSearch() {
      var controller = this.props.controller;
      var input = document.getElementById('menu-search');
      var results = document.getElementById('menu-search-results');
      var queryString = input.value;
      results.scrollTo(0, 0);
      controller.updateSearch(queryString);
    }
  }, {
    key: "focusTextBox",
    value: function focusTextBox() {
      var input = document.getElementById('menu-search');

      if (input) {
        input.focus();
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode(node) {
      var controller = this.props.controller;
      controller.closeMenu();
      controller.highlight(node);
      controller.showInfo(node);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var controller = this.props.controller;
      var _this$state = this.state,
          open = _this$state.open,
          searchMatchNodes = _this$state.searchMatchNodes;
      var closed = !open;
      var searchResults = [];

      if (searchMatchNodes) {
        searchResults = searchMatchNodes.map(function (node) {
          return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div.menu-node-info', {
            onClick: function onClick() {
              return _this2.selectNode(node);
            }
          }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_3__["NodeInfo"], {
            node: node
          })]);
        });
      }

      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-parent'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu-toggle': true,
          'menu-open': open
        }),
        onClick: function onClick() {
          return controller.toggleMenu();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu': true,
          'menu-closed': closed
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'text',
        "class": 'menu-search',
        placeholder: 'Search',
        id: 'menu-search',
        onClick: function onClick() {
          return _this2.open();
        },
        onKeyDown: function onKeyDown() {
          return _this2.debouncedUpdateSearch();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-search-results',
        id: 'menu-search-results'
      }, searchResults)])]);
    }
  }]);

  return Menu;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (Menu);


/***/ }),

/***/ "./src/client/components/node-info.js":
/*!********************************************!*\
  !*** ./src/client/components/node-info.js ***!
  \********************************************/
/*! exports provided: default, NodeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodeInfo", function() { return NodeInfo; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var NodeInfo =
/*#__PURE__*/
function (_Component) {
  _inherits(NodeInfo, _Component);

  function NodeInfo(props) {
    _classCallCheck(this, NodeInfo);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeInfo).call(this, props));
  }

  _createClass(NodeInfo, [{
    key: "render",
    value: function render() {
      var node = this.props.node;
      var data = node.data();
      var name = data.name;
      var description = data.description;
      var type = data.NodeType;
      var q = data.link;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-name'
      }, name), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-description'
      }, description), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-type'
      }, type), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-more'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('a', {
        target: '_blank',
        href: "".concat(q)
      }, 'View Jellyfish card')])]);
    }
  }]);

  return NodeInfo;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (NodeInfo);


/***/ }),

/***/ "./src/client/controller.js":
/*!**********************************!*\
  !*** ./src/client/controller.js ***!
  \**********************************/
/*! exports provided: default, Controller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller", function() { return Controller; });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.memoize */ "./node_modules/lodash.memoize/index.js");
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_memoize__WEBPACK_IMPORTED_MODULE_1__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


 // search parameters

var minMetricValue = 0.25; // filter out nodes from search results if they have total scores lower than this

var minSimilarityValue = 0; // only include in total metric if the individual sim val is on [0.5, 1]
//chart type enum

var ChartTypes = Object.freeze({
  FDG: 'FDG',
  DAG: 'DAG'
});

var Controller =
/*#__PURE__*/
function () {
  function Controller(_ref) {
    var cy = _ref.cy,
        layouts = _ref.layouts;

    _classCallCheck(this, Controller);

    this.chartType = ChartTypes.DAG;
    this.orphans = false;
    this.patterns = false;
    this.improvements = false;
    this.sagas = true;
    this.approaches = true;
    this.assumptions = true;
    this.goals = true;
    this.users = false;
    this.cy = cy;
    this.layouts = layouts;
    this.bus = new eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a();
    this.menu = false;
    this.nodes = cy.nodes();
    this.searchMatchNodes = cy.collection();
    this.removedNodes = cy.collection();
    this.priority = false;
  }

  _createClass(Controller, [{
    key: "isMenuOpen",
    value: function isMenuOpen() {
      return this.menu;
    }
  }, {
    key: "openMenu",
    value: function openMenu() {
      this.menu = true;
      this.bus.emit('openMenu');
      this.bus.emit('toggleMenu', true);
    }
  }, {
    key: "closeMenu",
    value: function closeMenu() {
      this.menu = false;
      this.bus.emit('closeMenu');
      this.bus.emit('toggleMenu', false);
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.isMenuOpen()) {
        this.closeMenu();
      } else {
        this.openMenu();
      }
    }
  }, {
    key: "isInfoShown",
    value: function isInfoShown() {
      return this.infoNode != null;
    }
  }, {
    key: "showInfo",
    value: function showInfo(node) {
      this.infoNode = node;
      this.bus.emit('showInfo', node);
    }
  }, {
    key: "hideInfo",
    value: function hideInfo() {
      this.bus.emit('hideInfo', this.infoNode);
      this.infoNode = null;
    }
  }, {
    key: "hasHighlight",
    value: function hasHighlight() {
      return this.lastHighlighted != null;
    }
  }, {
    key: "toggleChartType",
    value: function toggleChartType() {
      if (this.chartType === ChartTypes.FDG) {
        this.chartType = ChartTypes.DAG;
      } else {
        this.chartType = ChartTypes.FDG;
      }

      this.bus.emit('changeType');
      this.runLayout();
    }
  }, {
    key: "runLayout",
    value: function runLayout(randomise) {
      var _this = this;

      this.drawLayout(randomise).then(function () {
        _this.animateView();
      });
    }
  }, {
    key: "animateView",
    value: function animateView() {
      this.cy.animate({
        fit: {
          eles: this.cy,
          padding: 10
        }
      }, {
        duration: 1000
      });
    }
  }, {
    key: "drawLayout",
    value: function drawLayout() {
      this.removedNodes.restore();
      this.removedNodes = this.cy.collection();

      if (!this.users) {
        this.removeNodeType("user");
      }

      if (!this.patterns) {
        this.removeNodeType("pattern");
      }

      if (!this.goals) {
        this.removeNodeType("goal");
      }

      if (!this.improvements) {
        this.removeNodeType("improvement");
      }

      if (!this.approaches) {
        this.removeNodeType("approach");
      }

      if (!this.assumptions) {
        this.removeNodeType("assumption");
      }

      if (!this.sagas) {
        this.removeNodeType("saga");
      }

      if (!this.orphans) {
        this.removeOrphans();
      }

      var promise = this.cy.promiseOn('layoutstop');
      this.cy.layout(this.layouts[this.chartType]).run();
      return promise;
    }
  }, {
    key: "removeNodeType",
    value: function removeNodeType(type) {
      this.removedNodes = this.removedNodes.union(this.cy.remove('node[NodeType = "' + type + '"]'));
    }
  }, {
    key: "removeOrphans",
    value: function removeOrphans() {
      var removed = this.cy.collection();
      this.cy.nodes(function (element) {
        if (element.isNode() && element.degree() < 1) {
          removed = removed.union(element.remove());
        }
      });
      this.removedNodes = this.removedNodes.union(removed);
    }
  }, {
    key: "togglePriority",
    value: function togglePriority() {
      this.priority = !this.priority;
      this.unhighlight();
      this.renderPriority();
    }
  }, {
    key: "renderPriority",
    value: function renderPriority() {
      var _this2 = this;

      var prioritisedTypes = ['improvement', 'saga'];
      prioritisedTypes.forEach(function (type) {
        _this2.togglePriorityForType(type);
      });
      this.runLayout();
    }
  }, {
    key: "togglePriorityForType",
    value: function togglePriorityForType(type) {
      var improvements = this.cy.elements("node[NodeType = '" + type + "']");
      var allElles = this.cy.elements();

      if (this.priority) {
        this.cy.batch(function () {
          improvements.addClass('prioritised');
        });
      } else {
        this.cy.batch(function () {
          allElles.removeClass('prioritised');
        });
      }
    }
  }, {
    key: "resetView",
    value: function resetView() {
      this.unhighlight();
      this.hideInfo();
      this.closeMenu();
      this.runLayout();
      this.renderPriority();
    }
  }, {
    key: "togglePatterns",
    value: function togglePatterns() {
      this.patterns = !this.patterns;
      this.resetView();
    }
  }, {
    key: "toggleUsers",
    value: function toggleUsers() {
      this.users = !this.users;
      this.resetView();
    }
  }, {
    key: "toggleSagas",
    value: function toggleSagas() {
      this.sagas = !this.sagas;
      this.resetView();
    }
  }, {
    key: "toggleGoals",
    value: function toggleGoals() {
      this.goals = !this.goals;
      this.resetView();
    }
  }, {
    key: "toggleAssumptions",
    value: function toggleAssumptions() {
      this.assumptions = !this.assumptions;
      this.resetView();
    }
  }, {
    key: "toggleApproaches",
    value: function toggleApproaches() {
      this.approaches = !this.approaches;
      this.resetView();
    }
  }, {
    key: "toggleImprovements",
    value: function toggleImprovements() {
      this.improvements = !this.improvements;
      this.resetView();
    }
  }, {
    key: "toggleOrphans",
    value: function toggleOrphans() {
      this.orphans = !this.orphans;
      this.resetView();
    }
  }, {
    key: "highlight",
    value: function highlight(node) {
      var _this3 = this;

      var cy = this.cy;

      if (this.highlightInProgress) {
        return Promise.resolve();
      }

      this.highlightInProgress = true;
      var allEles = cy.elements();
      var nhood = this.lastHighlighted = node.closedNeighborhood();
      var predecessors = node.predecessors();
      var highlighted = nhood.union(predecessors);
      var others = this.lastUnhighlighted = allEles.not(highlighted);

      var runLayout = function runLayout() {
        var layout = highlighted.layout({
          name: _this3.layouts[_this3.chartType].name,
          rankDir: 'TB',
          fit: true,
          avoidOverlap: true,
          levelWidth: function levelWidth() {
            return 1;
          },
          padding: 10,
          springLength: 300,
          animate: 'end',
          centerGraph: true,
          springCoeff: 0.0008,
          mass: 20,
          gravity: -10,
          pull: 0.0001,
          theta: 0.333,
          dragCoeff: 0.02,
          movementThreshold: 1,
          timeStep: 20,
          refresh: 10,
          animationDuration: undefined,
          animationEasing: undefined,
          maxIterations: 1000,
          maxSimulationTime: 4000,
          ungrabifyWhileSimulating: false,
          randomize: false
        });
        var promise = layout.promiseOn('layoutstop');
        layout.run();
        return promise;
      };

      var animateView = function animateView() {
        cy.animate({
          fit: {
            eles: highlighted,
            padding: 10
          }
        }, {
          duration: 1000
        });
      };

      var resetClasses = function resetClasses() {
        cy.batch(function () {
          allEles.removeClass('hidden').removeClass('faded').removeClass('highlighted');
        });
        return Promise.resolve();
      };

      var showOthersFaded = function showOthersFaded() {
        cy.batch(function () {
          others.removeClass('hidden').addClass('faded');
        });
      };

      this.bus.emit('highlight', node);
      return Promise.resolve().then(resetClasses).then(runLayout).then(showOthersFaded).then(animateView).then(function () {
        _this3.highlightInProgress = false;

        _this3.bus.emit('highlightend', node);
      });
    }
  }, {
    key: "unhighlight",
    value: function unhighlight() {
      var _this4 = this;

      if (!this.hasHighlight()) {
        return Promise.resolve();
      }

      var cy = this.cy;
      var allEles = cy.elements();
      var allNodes = cy.nodes();
      cy.stop();
      allNodes.stop();
      var others = this.lastUnhighlighted;
      this.lastHighlighted = this.lastUnhighlighted = null;

      var hideOthers = function hideOthers() {
        others.addClass('hidden');
        return Promise.resolve();
      };

      var resetClasses = function resetClasses() {
        cy.batch(function () {
          allEles.removeClass('hidden').removeClass('faded').removeClass('highlighted');
        });
        return Promise.resolve();
      };

      var animateView = function animateView() {
        cy.animate({
          fit: {
            eles: _this4.cy,
            padding: 10
          }
        }, {
          duration: 1000
        });
      };

      var runLayout = function runLayout() {
        _this4.bus.emit('unhighlight');

        var layout = _this4.cy.layout(_this4.layouts[_this4.chartType]);

        layout.run();
      };

      return Promise.resolve().then(hideOthers).then(resetClasses).then(runLayout).then(animateView);
    }
  }, {
    key: "updateSearch",
    value: function updateSearch(queryString) {
      var _this5 = this;

      var normalize = function normalize(str) {
        return str.toLowerCase();
      };

      var getWords = function getWords(str) {
        return str.split(/\s+/);
      };

      var queryWords = getWords(normalize(queryString));

      var addWords = function addWords(wordList, wordsStr) {
        if (wordsStr) {
          wordList.push.apply(wordList, _toConsumableArray(getWords(normalize(wordsStr))));
        }
      };

      var cacheNodeWords = function cacheNodeWords(node) {
        var data = node.data();
        var wordList = [];
        addWords(wordList, data.name);
        addWords(wordList, data.Synonym);
        addWords(wordList, data.NodeTypeFormatted);
        node.data('words', wordList);
      };

      var getStringSimilarity = function getStringSimilarity(queryWord, nodeWord) {
        var index = nodeWord.indexOf(queryWord);

        if (index === 0) {
          var diff = Math.abs(nodeWord.length - queryWord.length);
          var maxLength = Math.max(nodeWord.length, queryWord.length);
          return 1 - diff / maxLength;
        } else {
          return 0;
        }
      };

      var getMetric = function getMetric(node, queryWords) {
        var nodeWords = node.data('words');
        var score = 0;

        for (var i = 0; i < nodeWords.length; i++) {
          var nodeWord = nodeWords[i];

          for (var j = 0; j < queryWords.length; j++) {
            var queryWord = queryWords[j];
            var similarity = getStringSimilarity(queryWord, nodeWord);

            if (similarity > minSimilarityValue) {
              score += similarity;
            }
          }
        }

        return score;
      };

      var getNodeMetric = lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default()(function (node) {
        return getMetric(node, queryWords);
      }, function (node) {
        return node.id();
      });

      if (!this.cachedNodeWords) {
        this.cy.batch(function () {
          _this5.nodes.forEach(cacheNodeWords);
        });
        this.cachedNodeWords = true;
      }

      this.searchMatchNodes = this.nodes.filter(function (node) {
        return getNodeMetric(node) > minMetricValue;
      }).sort(function (nodeA, nodeB) {
        return getNodeMetric(nodeB) - getNodeMetric(nodeA);
      });
      this.bus.emit('updateSearch', this.searchMatchNodes);
      return this.searchMatchNodes;
    }
  }, {
    key: "getSearchMatchNodes",
    value: function getSearchMatchNodes() {
      return this.searchMatchNodes;
    }
  }]);

  return Controller;
}();

/* harmony default export */ __webpack_exports__["default"] = (Controller);


/***/ }),

/***/ "./src/client/cy-conf/data.json":
/*!**************************************!*\
  !*** ./src/client/cy-conf/data.json ***!
  \**************************************/
/*! exports provided: links, nodes, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"links\":[{\"source\":\"Mission\",\"target\":\"Edge computing 4th compute paradigm\",\"Source Weight\":100,\"Target Weight\":40,\"weight\":140},{\"source\":\"Mission\",\"target\":\"New paradigms require bottom up thinking\",\"Source Weight\":100,\"Target Weight\":5,\"weight\":105},{\"source\":\"Edge computing 4th compute paradigm\",\"target\":\"Default alive\",\"Source Weight\":40,\"Target Weight\":25,\"weight\":65},{\"source\":\"Edge computing 4th compute paradigm\",\"target\":\"IOT is a big market\",\"Source Weight\":40,\"Target Weight\":35,\"weight\":75},{\"source\":\"Edge computing 4th compute paradigm\",\"target\":\"IOT market still growing\",\"Source Weight\":40,\"Target Weight\":20,\"weight\":60},{\"source\":\"Default alive\",\"target\":\"STPLTG\",\"Source Weight\":25,\"Target Weight\":15,\"weight\":40},{\"source\":\"New paradigms require bottom up thinking\",\"target\":\"Build the org we want to become\",\"Source Weight\":5,\"Target Weight\":15,\"weight\":20},{\"source\":\"Build the org we want to become\",\"target\":\"Per-component teams will not work\",\"Source Weight\":15,\"Target Weight\":5,\"weight\":20},{\"source\":\"Build the org we want to become\",\"target\":\"The standard way of running large companies is sub-optimal\",\"Source Weight\":15,\"Target Weight\":5,\"weight\":20},{\"source\":\"New paradigms require bottom up thinking\",\"target\":\"Compute paradigms need developers\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"IOT market still growing\",\"target\":\"Fleet owners will pay for our product\",\"Source Weight\":20,\"Target Weight\":20,\"weight\":40},{\"source\":\"New paradigms require bottom up thinking\",\"target\":\"More product surface = more feedback loops\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"New paradigms require bottom up thinking\",\"target\":\"Per-component teams will not work\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"STPLTG\",\"target\":\"Engine of plenty\",\"Source Weight\":15,\"Target Weight\":5,\"weight\":20},{\"source\":\"IOT is a big market\",\"target\":\"$100m ARR\",\"Source Weight\":35,\"Target Weight\":5,\"weight\":40},{\"source\":\"IOT market still growing\",\"target\":\"10X customer base\",\"Source Weight\":20,\"Target Weight\":5,\"weight\":25},{\"source\":\"Compute paradigms need developers\",\"target\":\"Engine of plenty\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Fleet owners will pay for our product\",\"target\":\"2X device ASP\",\"Source Weight\":20,\"Target Weight\":5,\"weight\":25},{\"source\":\"More product surface = more feedback loops\",\"target\":\"Build a scalable omni-win-win antifragile organisation\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Per-component teams will not work\",\"target\":\"Build a scalable omni-win-win antifragile organisation\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Productive work is fulfilling and interesting\",\"target\":\"Build a scalable omni-win-win antifragile organisation\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Engine of plenty\",\"target\":\"Platformise software\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Engine of plenty\",\"target\":\"Platformise hardware\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Engine of plenty\",\"target\":\"Platformise logistics\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"3X speed to scale\",\"target\":\"Platformise software\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"3X speed to scale\",\"target\":\"Platformise hardware\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"3X speed to scale\",\"target\":\"Platformise logistics\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"3X devices per customer\",\"target\":\"Expand the potential devices we can manage\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Expand the potential devices we can manage\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"2X device ASP\",\"target\":\"Additional features chargeable per device\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"2X device ASP\",\"target\":\"Creative pricing\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Platformise software\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Remove friction from onboarding devices\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Improve conversation rate\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Partner with leading industry players\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"10X customer base\",\"target\":\"Find more fleet owners\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Protocols over management\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Automate internal bureaucracy\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Enablement over control\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Remote first\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Surface the flow of information\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Reason from first principles\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Loops\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Build a scalable omni-win-win antifragile organisation\",\"target\":\"Reduce cycle times\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Platformise hardware\",\"target\":\"saga-fin-2-0-8bca872\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise hardware\",\"target\":\"saga-hardware-demand-807485a\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise logistics\",\"target\":\"saga-etcher-pro-1962875\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise logistics\",\"target\":\"saga-hardware-demand-807485a\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise software\",\"target\":\"saga-balenahub-f401df6\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise software\",\"target\":\"saga-analytics-2-0-e9bfa23\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Platformise software\",\"target\":\"saga-development-experience-e1cb478\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Creative pricing\",\"target\":\"saga-billing-v2-0-a7e5732\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Creative pricing\",\"target\":\"saga-pricing-2-0-1a85d4b\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Remove friction from onboarding devices\",\"target\":\"saga-pricing-2-0-1a85d4b\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Improve conversation rate\",\"target\":\"saga-analytics-2-0-e9bfa23\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Improve conversation rate\",\"target\":\"saga-balena-model-db35ff1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Partner with leading industry players\",\"target\":\"saga-balenahub-f401df6\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Find more fleet owners\",\"target\":\"saga-balenahub-f401df6\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Find more fleet owners\",\"target\":\"saga-etcher-2-0-b9bacd1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Protocols over management\",\"target\":\"saga-protocols-management-1cde95f\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Automate internal bureaucracy\",\"target\":\"saga-finance-2-0-72a3e71\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Automate internal bureaucracy\",\"target\":\"saga-team-context-ccedeb3\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Automate internal bureaucracy\",\"target\":\"saga-transformers-b0d299e\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Automate internal bureaucracy\",\"target\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Enablement over control\",\"target\":\"saga-team-context-ccedeb3\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Remote first\",\"target\":\"saga-team-context-ccedeb3\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Surface the flow of information\",\"target\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reason from first principles\",\"target\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Loops\",\"target\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-balenaos-3-0-86974a1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-balena-model-db35ff1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-finance-2-0-72a3e71\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-transformers-b0d299e\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Reduce cycle times\",\"target\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"The standard way of running large companies is sub-optimal\",\"target\":\"Build a scalable omni-win-win antifragile organisation\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Expand the potential devices we can manage\",\"target\":\"saga-etcher-2-0-b9bacd1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"$100m ARR\",\"target\":\"3X speed to scale\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"$100m ARR\",\"target\":\"3X devices per customer\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"$100m ARR\",\"target\":\"10X customer base\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"$100m ARR\",\"target\":\"2X device ASP\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Automate internal bureaucracy\",\"target\":\"saga-support-2-0-838fc0c\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"3X devices per customer\",\"target\":\"Be a reliable, scalable, trustworth partner to our customers\",\"Source Weight\":5,\"Target Weight\":5,\"weight\":10},{\"source\":\"Be a reliable, scalable, trustworth partner to our customers\",\"target\":\"saga-development-experience-e1cb478\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Be a reliable, scalable, trustworth partner to our customers\",\"target\":\"saga-balenaos-3-0-86974a1\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Be a reliable, scalable, trustworth partner to our customers\",\"target\":\"saga-security-1-0-a6ed6c9\",\"Source Weight\":5,\"Target Weight\":0,\"weight\":5},{\"source\":\"Build the org we want to become\",\"target\":\"Productive work is fulfilling and interesting\",\"Source Weight\":15,\"Target Weight\":0,\"weight\":15},{\"source\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"target\":\"improvement-getting-strategy-jellyfish-2fbcbf7\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-protocols-management-1cde95f\",\"target\":\"improvement-getting-strategy-jellyfish-2fbcbf7\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-getting-strategy-jellyfish-2fbcbf7\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-getting-strategy-jellyfish-2fbcbf7\",\"target\":\"user-michaellwilks\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"target\":\"pattern-missing-accesslist-whitelist-entry-cloudlink-27e73a6\",\"weight\":7,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"target\":\"pattern-number-devices-theoretically-support-cloudlink-hostos-2-14-0-uses-vpn-balena-cloud-com--538bcab\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"target\":\"pattern-devices-using-open-vpn-instances-instead-cloudlink-b509673\",\"weight\":9,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"target\":\"pattern-balenaos-resinos-2-14-0-will-connect-vpn-balena-cloud-com-instead-cloudlink-70c855c\",\"weight\":7,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"target\":\"user-jaomaloy\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-non-caching-forwarding-proxy-api-endpoint-s--1dfa353\",\"target\":\"user-ab77\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-query-timeout-logging--e0ad070\",\"target\":\"pattern-query-timeouts-affect-ux-sync-components-7e93d70\",\"weight\":27,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-remove-rec-files-boot-partition-triggering-host-os-update-793416d\",\"target\":\"pattern-recovery-files-fill-boot-partition-36a49a9\",\"weight\":6,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-support-booting-metadata-md-device-software-raid-arrays-c538001\",\"target\":\"pattern-software-raid-configurations-not-booting-e9ec7cb\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-support-booting-metadata-md-device-software-raid-arrays-c538001\",\"target\":\"pattern-md-raid-arrays-numbered-127-down-boot-ca940a5\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-support-booting-metadata-md-device-software-raid-arrays-c538001\",\"target\":\"user-jakogut\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-team-context-ccedeb3\",\"target\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"pattern-unclear-transition-labs-residency-day-day-balena-5868dac\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"pattern-it-s-not-clear-work-once-finish-residency-2bd59c3\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"pattern-balena-team-member-struggles-step-away-current-workload-order-labs-residency-dadb046\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"pattern-unclear-criteria-finishing-balena-residency-c2b3042\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"user-poshrolls\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"user-poshrolls\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"user-natasakyvetou\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-normalize-release-contracts-proper-json-fields-c081175\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-move-hardware-process-versionbot-ci-github-actions-e8a1d6e\",\"target\":\"pattern-making-changes-hardware-process-its-current-architecture-slow-limiting-fd59945\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-loki-optimizations-killing-logentries--5ed3a65\",\"target\":\"user-page-\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-restore-open-drain-balenafin-software-i2c-pins-preserving-functionality-de-pop-boards--a349413\",\"target\":\"pattern-unreliable-i2c-de-populated-balenafin-when-resetting-cellular-modem--055929a\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-restore-open-drain-balenafin-software-i2c-pins-preserving-functionality-de-pop-boards--a349413\",\"target\":\"user-hraftery\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-document-sync-workflow-02e51c5\",\"target\":\"pattern-query-timeouts-affect-ux-sync-components-7e93d70\",\"weight\":27,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-device-freezing-679ef79\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-device-uis-11f0807\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-getting-efp-not-accessible-fleet-app-owner-03f3a4f\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-user-can-t-stage-efp-see-changes-will-look-etcher-1b74f9b\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-efp-etcher-featured-projects-analytics-data-available-for-featured-app-owners-a3d4b012-0875-42e9-ba88-3917c4e2cc01\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-user-one-change-time-etcher-success-screen-d747796\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-changing-efp-manually-time-consuming-leaves-room-mistakes-bc42521\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-significant-drop-off-ctr-efp-1-month-featured-d067706\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"pattern-featured-efp-community-growth-benefits-fleet-owners-d3dba1b\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"user-jmakivic\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"user-chrisys\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"user-otaviojacobi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"target\":\"user-user-jmakivic\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-etcher-2-0-b9bacd1\",\"target\":\"improvement-etcher-cleanup-rewrite--cfc3d26\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-etcher-cleanup-rewrite--cfc3d26\",\"target\":\"user-mcraa\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-fix-errors-front-sync-related-unexpected-schema-127cce2\",\"target\":\"pattern-query-timeouts-affect-ux-sync-components-7e93d70\",\"weight\":27,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"saga-security-1-0-a6ed6c9\",\"target\":\"improvement-compile-list-domains-need-removed-3f3b01b\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-compile-list-domains-need-removed-3f3b01b\",\"target\":\"pattern-domain-hijack-ea25db1\",\"weight\":4,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-compile-list-domains-need-removed-3f3b01b\",\"target\":\"user-20k-ultra\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"target\":\"pattern-user-wants-download-kernel-headers-device-f12bafb\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"target\":\"pattern-user-info-particluar-balena-os-version-bf969c6\",\"weight\":17,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"target\":\"user-rahul-thakoor\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"target\":\"user-myarmolinsky\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenablock-hup-acc2a8c\",\"target\":\"user-jaomaloy\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-update-renovate-handle-custom-regex-parsing--d37047a\",\"target\":\"user-olamiko\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-offer-raw-images-device-types-ce76d0f\",\"target\":\"pattern-distinguish-flasher-images-regular-images-docs-c08c993\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-offer-raw-images-device-types-ce76d0f\",\"target\":\"user-jakogut\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-add-separate-feed-subscriptions-jellyfish-3fed410\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-billing-v2-0-a7e5732\",\"target\":\"improvement-lock-orgs-90-days-pastdue--f836645\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-lock-orgs-90-days-pastdue--f836645\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-bitwarden-password-manager-44bf2d5\",\"target\":\"user-lpapapo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-bitwarden-password-manager-44bf2d5\",\"target\":\"user-apostolism\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-bitwarden-password-manager-44bf2d5\",\"target\":\"user-lpapapo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenaos-3-0-86974a1\",\"target\":\"product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\",\"target\":\"pattern-user-wants-os-built-in-toolkit-described-https-www-balena-io-blog-how-to-use-nvidia-jetson-devices-on-balenaos--27ee084\",\"weight\":6,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\",\"target\":\"user-alexgg\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\",\"target\":\"user-pipex\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"target\":\"pattern-requests-for-secure-boot-8c2ea16b-e3da-46c9-9318-929841d1f13c\",\"weight\":23,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"target\":\"pattern-users-are-asking-for-full-disk-encryption-d8b4ee91-74aa-4bfc-b2be-b6a0a7c3f9d7\",\"weight\":32,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"target\":\"user-mtoman\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"target\":\"user-alexgg\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"target\":\"user-mtoman\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-x86-device-types-c65151cd-10be-4093-8427-36c3fd37ef17\",\"target\":\"pattern-jenkins-master-disk-space-due-dt-build-artefact-history-5abf0dc\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-x86-device-types-c65151cd-10be-4093-8427-36c3fd37ef17\",\"target\":\"pattern-user-confused-new-x86-64-amd64-images-24a5f6e\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-x86-device-types-c65151cd-10be-4093-8427-36c3fd37ef17\",\"target\":\"user-jakogut\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-klutchell\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-acostach\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-rcooke-warwick\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-jakogut\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-g-paulo-nascimento\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-alexgg\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-vipulgupta2048\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"target\":\"user-lmbarros\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenaos-3-versioning-ff204a5\",\"target\":\"pattern-user-wants-os-built-in-toolkit-described-https-www-balena-io-blog-how-to-use-nvidia-jetson-devices-on-balenaos--27ee084\",\"weight\":6,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaos-3-versioning-ff204a5\",\"target\":\"user-alexgg\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-managed-redshift-data-pipeline-deployment-7b4f4e7\",\"target\":\"user-olamiko\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-faulty-or-slow-sd-cards-causing-problems-b62c3dcf-bd2e-4852-bc9a-6d0b26b25054\",\"weight\":26,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"scratchpad-entry-4efe4a9e-2793-4869-b161-18eb3e01d9c7\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"support-issue-evice-ime-randomly-is-incorrect-f8a87e75-5389-4fbd-a666-6996b323e281\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-user-would-like-a-passive-set-of-device-diagnostics-eager-diagnostics-to-avoid-issues-in-advance-1ef047be-53a3-42af-a0a6-31a711256276\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-no-device-diagnostics-heartbeat-only-mode-39daf72\",\"weight\":8,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-fsck-n-read-only-filesystem-check-part-device-health-checks-378245f\",\"weight\":8,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"support-issue-leaked-aufs-dirs-cleanup-5c75c693-7e0a-4766-a17c-77b48cd14af0\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-undervoltage-warning-dashboard-not-informative-ab6fcab\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-clean-docker-balena-engine-folder-2d843c1\",\"weight\":23,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-ticket-does-not-include-diagnostics-information-6442446\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern--could-not-communicate-registry2-balena-cloud-com-authentication-diagnostics-checks-7054399\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-warn-users-when-drop-ipv4-connectivity-diagnostics--279f8c4\",\"weight\":5,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"pattern-detection-of-path-mtu-discovery-issues-in-device-diagnostics-52ae82b4-ac30-4515-a6aa-f3808a85a5d5\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-active-eager-diagnostics-40b468b\",\"target\":\"user-jaomaloy\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"pattern-user-would-like-a-passive-set-of-device-diagnostics-eager-diagnostics-to-avoid-issues-in-advance-1ef047be-53a3-42af-a0a6-31a711256276\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"user-jaomaloy\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"user-pranavpeshwe\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"user-jaomaloy\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"user-20k-ultra\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"target\":\"user-cywang117\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-support-auditing-e26f74f\",\"target\":\"user-jazzagi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-content-getting-started-guides--4f62835\",\"target\":\"user-vipulgupta2048\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-content-getting-started-guides--4f62835\",\"target\":\"user-gh-vipulgupta2048\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\",\"target\":\"pattern-user-requesting-feature-keep-track-operations-variables-etc-similar-audit-log-e2f9202\",\"weight\":5,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\",\"target\":\"pattern-user-wants-to-see-the-release-history-for-a-given-device-e870a272-6b93-4e71-ae01-9ecf15fa23bc\",\"weight\":9,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\",\"target\":\"pattern-customers-requesting-support-for-dashboard-auditing-2b0490a2-52a5-424c-ad01-0684e2578440\",\"weight\":27,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\",\"target\":\"user-fisehara\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"pattern-user-gets-confused-by-the-unique-release-version-constraint-when-trying-to-re-push-a-release-with-the-same-version-df66f4b0-1bb1-45a9-998c-837b47a5b550\",\"weight\":8,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"pattern-we-are-missing-docs-about-release-versioning-draft-releases-1a419144-e730-4b77-9d40-5d07e013013a\",\"weight\":6,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"pattern-customer-identified-missing-unique-identifiers-in-case-of-multiple-releases-in-a-day-731090c0-c129-446d-9421-9c20905b8769\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"pattern-user-wants-to-be-able-to-use-any-valid-semver-string-as-the-release-version-including-pre-release-parts-e5f76ee9-21fd-4475-9ef5-b8d58a7bc560\",\"weight\":5,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"user-cywang117\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"user-20k-ultra\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"target\":\"user-pipex\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-become-oauth-provider-ory-hydra-e0a87a7\",\"target\":\"user-karaxuna\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-migrate-product-repo-to-jellyfish-457ae485-7938-4bad-9ec0-d8656626a022\",\"target\":\"user-jazzagi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-migrate-product-repo-to-jellyfish-457ae485-7938-4bad-9ec0-d8656626a022\",\"target\":\"user-nucleardreamer\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-migrate-product-repo-to-jellyfish-457ae485-7938-4bad-9ec0-d8656626a022\",\"target\":\"user-poshrolls\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-running-regular-virtual-events-45824053-750c-4c29-a57c-cd7a9a532ebd\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-running-regular-virtual-events-45824053-750c-4c29-a57c-cd7a9a532ebd\",\"target\":\"user-dtischler\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-stop-relying-device-types-v1-device-type-json-unrelated-things-4fbac3c\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-stop-relying-device-types-v1-device-type-json-unrelated-things-4fbac3c\",\"target\":\"user-mehalter\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-stop-relying-device-types-v1-device-type-json-unrelated-things-4fbac3c\",\"target\":\"user-myarmolinsky\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-centralize-docs-balenacloud-repository--b4aea99\",\"target\":\"user-vipulgupta2048\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balena-model-db35ff1\",\"target\":\"improvement-services-model-upgrade-spec-0e2ebee\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-services-model-upgrade-spec-0e2ebee\",\"target\":\"pattern-models-cannot-handle-one-off-revenue-expenses-eab69ac\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-services-model-upgrade-spec-0e2ebee\",\"target\":\"pattern-accounts-payable-processes-manual-time-consuming-d0e006c\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-services-model-upgrade-spec-0e2ebee\",\"target\":\"user-somombo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-on-balena-05772643-0191-4886-b000-a4ccbcb5fec5\",\"target\":\"pattern-user-wants-first-class-support-release-channels-staged-rollouts-new-releases-specific-groups-df03371\",\"weight\":11,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balena-on-balena-05772643-0191-4886-b000-a4ccbcb5fec5\",\"target\":\"user-ab77\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenair-c005f86\",\"target\":\"improvement-create-mechanism-advertises-balenair-devices-via-dns-sd--c5684b0\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-create-mechanism-advertises-balenair-devices-via-dns-sd--c5684b0\",\"target\":\"user-wjlove\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenair-c005f86\",\"target\":\"improvement-implement-touchscreen-device-093b162\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-implement-touchscreen-device-093b162\",\"target\":\"user-wjlove\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-migrate-balena-blog-to-gatsbyjs-de6503ee-0bb9-4ddd-9451-2d644bb0f474\",\"target\":\"user-iamsolankiamit\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-jip-improve-performance-triggers-47b1dc8\",\"target\":\"user-ramirogm\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-jip-add-emoji-reactions-msgs-6a67721\",\"target\":\"user-inwenc\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\",\"target\":\"pattern-customers-asking-about-support-for-login-authentication-directory-services-with-balena-cloud-94771535-7bf3-407b-a8ed-a3781ab152f4\",\"weight\":5,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\",\"target\":\"pattern-user-would-like-to-sign-in-to-the-dashboard-with-azure-single-sign-on-eb553e2a-c90a-4f49-89c6-d9474e9aeac2\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\",\"target\":\"user-joe-hounsham\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"target\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"pattern-balenaci-resinci-concourse-not-running-pr-builds-missing-gh-events-etc--67e667e\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"pattern-concourse-env-var-leak-b543347\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"pattern-etcher-tests-hang-when-ci-process-running-windows-service-77d808b\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"pattern-remove-concourse-1a383cb\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"user-klutchell\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"user-gh-anujdeshpande\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"user-gh-ab77\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"user-gh-klutchell\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"target\":\"user-gh-bucknalla\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-salary-calculator-spec-a0b0dca1-d6b4-4d22-8b4d-873e3ef3ab47\",\"target\":\"user-alidaodendaal\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"pattern-customers-not-reading-docs-find-release-strategies-work-45373b4\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"pattern-user-would-like-preloaded-images-d1b83f68-7eb2-46f3-8cc6-b066920b42f0\",\"weight\":7,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"user-zoobot\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"user-aethernet\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"target\":\"user-zwhitchcox\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-tg-odoo-migration-b500ee1\",\"target\":\"pattern-it-s-difficult-track-component-stock-manufacturer--7bcd80f\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-tg-odoo-migration-b500ee1\",\"target\":\"pattern-difficult-trace-components-products-purchase-disposal-62a836e\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-tg-odoo-migration-b500ee1\",\"target\":\"user-stefsak\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-openbalena-balena-balenafy-openbalena-3ca0178\",\"target\":\"pattern-update-openbalena-certificates-vpn-certificates-669f4c9\",\"weight\":4,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-openbalena-balena-balenafy-openbalena-3ca0178\",\"target\":\"user-ab77\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-hardware-demand-807485a\",\"target\":\"improvement-automationkit-6d5af37\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-automationkit-6d5af37\",\"target\":\"user-rcooke-warwick\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-automationkit-6d5af37\",\"target\":\"user-phckopper\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-automationkit-6d5af37\",\"target\":\"user-bucknalla\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-automationkit-6d5af37\",\"target\":\"user-rcooke-warwick\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-automationkit-6d5af37\",\"target\":\"user-gh-bucknalla\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-billing-v2-0-a7e5732\",\"target\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-pricing-2-0-1a85d4b\",\"target\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"pattern-self-serve-pricing-page-8a213ba\",\"weight\":14,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"pattern-customer-asks-volume-discount-better-pricing-4b140a4\",\"weight\":5,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"user-rhampt\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"user-ryan-hampton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"user-aethernet\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"target\":\"user-rhampt\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-increase-coverage-supported-attributes-features-docker-compose-yml-c328938\",\"target\":\"user-dfunckt\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-autogenerated-openapi-autoui-compatible-specification-files-4aec541\",\"target\":\"user-fisehara\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"pattern-high-staff-turnover-show-newer-members-staff-appreciation-feel-supported--06def36\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"pattern-2022-2-team-members-reaching-10-year-anniversaries-working-balena-want-recognise-fc5bde4\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"pattern-few-ways-show-recognition-employees-besides-cheers-peers-ad-hoc--0f23967\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\",\"target\":\"pattern-no-email-verification-for-user-signups-b5f8a358-8d90-49f4-9c2a-60707a2432bb\",\"weight\":7,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\",\"target\":\"user-nitish\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\",\"target\":\"user-jazzagi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-productising-call-papers-loop-events-conferences--695c31e\",\"target\":\"pattern-team-members-interested-speaking-work-balena-conferences--3a7fdfd\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-productising-call-papers-loop-events-conferences--695c31e\",\"target\":\"pattern-team-members-need-motivation-help-submitting-cfps-conferences-6068ce7\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-etcherpro-msd-sd-speed-testing--5e96eda\",\"target\":\"user-zisis00\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-replace-social-media-bio-link-link-aggregator--32a6b97\",\"target\":\"pattern-no-analytics-social-media-bio-link-cd46afb\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-replace-social-media-bio-link-link-aggregator--32a6b97\",\"target\":\"pattern-people-not-using-forums-technical-queries-bde549b\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-builder-cli-automatically-authenticate-balenahub-container-registry-e3a1e5d\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-builder-cli-automatically-authenticate-balenahub-container-registry-e3a1e5d\",\"target\":\"pattern-local-balena-build-push-requires-registry-secrets-use-private-blocks-5be0138\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-builder-cli-automatically-authenticate-balenahub-container-registry-e3a1e5d\",\"target\":\"user-klutchell\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-transformers-b0d299e\",\"target\":\"improvement-rename-transformer-worker-relationships-b7cea3d\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-balenair-c005f86\",\"target\":\"improvement-add-support-consolidation-data-multiple-balenair-devices-84a4d12\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-add-support-consolidation-data-multiple-balenair-devices-84a4d12\",\"target\":\"user-wjlove\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenair-c005f86\",\"target\":\"improvement-create-blog-announcing-balenair-thing--35b653a\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-balenair-c005f86\",\"target\":\"improvement-creating-product-inform-balenahub-road-map-2accd0f\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-creating-product-inform-balenahub-road-map-2accd0f\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-creating-product-inform-balenahub-road-map-2accd0f\",\"target\":\"user-alanb128\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-creating-product-inform-balenahub-road-map-2accd0f\",\"target\":\"user-wjlove\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-billing-v2-0-a7e5732\",\"target\":\"improvement-support-fixed-licenses--176ba3f\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-support-fixed-licenses--176ba3f\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-revamp-all-hands-user-charts-5f30dee\",\"target\":\"user-pranasziaukas\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-user-surveys-16f1391\",\"target\":\"pattern-need-capture-share-positive-feedback--c639ac5\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-user-surveys-16f1391\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-blog-header-design-bd4220b\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-linking-twilio-project-front-inbox-6655a40\",\"target\":\"pattern-sms-email-automation-0a6e7eb\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-linking-twilio-project-front-inbox-6655a40\",\"target\":\"user-lpapapo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-projects-involving-others-communities-orgs-start-relationship-attract-new-contributors-4b4a4d3\",\"target\":\"pattern-user-want-log-sensor-values-notion-page-f32982d\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-projects-involving-others-communities-orgs-start-relationship-attract-new-contributors-4b4a4d3\",\"target\":\"pattern-user-wants-send-data-adafruitio-balena--3addc59\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-projects-involving-others-communities-orgs-start-relationship-attract-new-contributors-4b4a4d3\",\"target\":\"pattern-interests-observed-mining-cryptocurrencies-using-sbcs-299b13c\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-ux-design-tasks-jon-rich-1cdeaca\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-development-experience-e1cb478\",\"target\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"target\":\"pattern-wifi-connect-block-requires-port-80-and-prevents-using-public-url-for-other-services-fbc19f7d-2d98-419a-9f65-4918dadd42de\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"target\":\"pattern-reverse-proxy-requests-91cfa5f3-2fb7-4524-bd70-510634837d11\",\"weight\":10,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"target\":\"user-pranavpeshwe\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-balenaide-c02ce28\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-development-experience-e1cb478\",\"target\":\"improvement-balenaide-c02ce28\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"pattern-ondevice-ide-0e29276d-09cc-4769-b14e-e2d57eadc3c1\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"pattern-user-doesn-t-know-how-and-where-to-edit-the-dockerfile-of-their-app-5f84eaa8-5cbb-466e-ac3a-377f85094f70\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"pattern-user-benefit-on-device-ide-79ac4c0\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"pattern-openfleet-user-does-not-access-logs-fleet-owner-needs-instruct-end-users-create-fleet-help-debugging-16bc855\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"user-rahul-thakoor\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenaide-c02ce28\",\"target\":\"user-rahul-thakoor\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-swag-automation-eef25aa\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-swag-automation-eef25aa\",\"target\":\"user-konmouz\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-swag-automation-eef25aa\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-delta-generation-speed-sizes-cf5e98f\",\"target\":\"user-lmbarros\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"target\":\"pattern-balena-image-flasher-unwrap-fails-chown-cannot-access-no-file-directory--0c7170e\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"target\":\"pattern-user-wants-run-generic-x86-64-image-using-virtualbox-13cb5ca\",\"weight\":4,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"target\":\"pattern-request-non-flasher-raw-image-rock-pi-4b-e7fda51\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"target\":\"pattern-user-want-use-dd-flash-preloaded-images-ssd-hard-drives-massively-manufacturing-process-16f9726\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"target\":\"user-jakogut\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"target\":\"improvement-jip-remove-field-level-permissions-8d561c94-2d33-4026-829c-272600018558\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-team-context-ccedeb3\",\"target\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-users-write-wants-needs-interests-varying-formats-537d1ea\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-update-the-katapult-github-code-to-use-the-latest-contract-format-eb93edf1-1e12-4d9b-845c-02468a3dd6ec\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-user-somewhere-keep-track-open-tasks-relation-hard-problem-team-directory--14a5775\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-users-need-markdown-primer-91f192b\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern--user-woukld-wiki-capability-team-directory-github-balenaltd-org-enabled-499f4ee\",\"weight\":4,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-need-somewhere-document-hack-friday-projects-38b9bdc\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-users-want-repo-continue-improving-upon-next-job-5906319\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"pattern-users-unclear-blog-folder-syntax-markdown-bc71e2c\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"user-poshrolls\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"user-g-carlo-miguel-cruz1\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"target\":\"user-lucian-buzzo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balenahub-f401df6\",\"target\":\"improvement-add-user-engagement-balenahub-2901d00\",\"weight\":100,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-add-user-engagement-balenahub-2901d00\",\"target\":\"pattern-fleet-app-block-owners-cannot-engage-users-0ed58ef\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-add-user-engagement-balenahub-2901d00\",\"target\":\"user-jmakivic\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-support-2-0-838fc0c\",\"target\":\"improvement-support-v2-8701e9a\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-support-v2-8701e9a\",\"target\":\"user-jazzagi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balena-brand-system-refinement-ae5c5c2\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-outreach-design-support-3b490dd\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-improve-branding-product-builders-0a53e27\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-balenacloud-table-header-ui-actions-integration-2577746\",\"target\":\"pattern-user-customize-columns-order-summary-fleet-page-0d51b46\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-balenacloud-table-header-ui-actions-integration-2577746\",\"target\":\"user-jonjrich\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-native-pinejs-translations-b5431ce\",\"target\":\"user-page-\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-productize-pinejs-064c842\",\"target\":\"user-fisehara\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-stop-shipping-coin-shell-batteries-0d87c18\",\"target\":\"pattern-shipping-coin-cell-batteries-lot-friction-743fdcc\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"target\":\"improvement-jip-link-constraints-using-relationship-contract-f3666fd0-e5d6-4ca4-9fa8-73959e72e7c3\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-jip-link-constraints-using-relationship-contract-f3666fd0-e5d6-4ca4-9fa8-73959e72e7c3\",\"target\":\"user-ramirogm\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-sunset-chartio-adopt-superset-179c6da\",\"target\":\"user-pranasziaukas\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-teamwork-score-ec32177c-75ce-4681-a8d6-4332b34715bd\",\"target\":\"user-alidaodendaal\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-teamwork-score-ec32177c-75ce-4681-a8d6-4332b34715bd\",\"target\":\"user-michaellwilks\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-create-blocks-repo-landr-a8dcf22\",\"target\":\"user-phil-d-wilson\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-provide-daily-analytics-metrics-within-balenacloud-api-b043df50-b5be-46d2-98ff-e93ac563b1b0\",\"target\":\"user-pranasziaukas\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balena-model-db35ff1\",\"target\":\"improvement-bottom-up-model-framework-eba2c04e-d769-4c68-b5e1-80b2b4536585\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-bottom-up-model-framework-eba2c04e-d769-4c68-b5e1-80b2b4536585\",\"target\":\"pattern-financial-projections-lack-desirable-level-robustness-e6849a3\",\"weight\":3,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-bottom-up-model-framework-eba2c04e-d769-4c68-b5e1-80b2b4536585\",\"target\":\"user-michaellwilks\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-sanitize-component-logs-remove-pii-sensitive-information-834a3be\",\"target\":\"user-cmfcruz\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-full-support-for-tri-app-ee583baa-6097-49e2-aed3-c7a3039dbcd1\",\"target\":\"user-pipex\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"target\":\"support-issue-customer-needs-invoices-emailed-to-new-additional-address-3d11fe69-1fa6-4869-99ec-4abb54ff564f\",\"weight\":14,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"target\":\"support-issue-configure-additional-invoicing-email-address-for-invoicing-87793511-1a55-4e7b-a6e4-7b81d179c1ba\",\"weight\":12,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"target\":\"pattern-user-wants-to-be-able-to-set-separate-email-to-receive-billing-invoices-493da437-dc28-4e08-840f-b9cb49694366\",\"weight\":19,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"target\":\"pattern-users-colleague-cc-ed-when-invoices-payment-notifications-sent-0d19f43\",\"weight\":6,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"target\":\"user-fisehara\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-backfill-os-release-dates-e657f44\",\"target\":\"user-pranasziaukas\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-billing-v2-0-a7e5732\",\"target\":\"improvement-support-trials-cf71c3f\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-support-trials-cf71c3f\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-billing-v2-0-a7e5732\",\"target\":\"improvement-enable-dynamic-usage-custom-plans--6495ae7\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-enable-dynamic-usage-custom-plans--6495ae7\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-productized-support-limited-access-b2021611-87b0-4052-b5d5-830f5745e0a8\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\",\"target\":\"pattern-handle-pulling-os-versions-from-productions-and-notify-users-7256568e-2bc5-4329-8ac9-213c40a7f85c\",\"weight\":7,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\",\"target\":\"pattern-user-would-like-to-be-warned-when-balenaos-images-are-pulled-from-production-d7e469ce-5b8c-45a4-9837-5edd6dffadf6\",\"weight\":9,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\",\"target\":\"user-myarmolinsky\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-start-using-the-balena-org-in-balenacloud-to-manage-roles-and-access-for-balena-team-members-0c281073-5085-4dea-9259-d896f2befb97\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-start-using-the-balena-org-in-balenacloud-to-manage-roles-and-access-for-balena-team-members-0c281073-5085-4dea-9259-d896f2befb97\",\"target\":\"user-apostolism\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-start-using-the-balena-org-in-balenacloud-to-manage-roles-and-access-for-balena-team-members-0c281073-5085-4dea-9259-d896f2befb97\",\"target\":\"user-stefsak\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-automated-base-images-deployment-process-2bb3eff\",\"target\":\"user-nghiant2710\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"target\":\"improvement-transformers-stage-3-554b91a\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-transformers-stage-3-554b91a\",\"target\":\"user-codewithcheese\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"target\":\"improvement-l1-transformer-e7b0d58\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"saga-transformers-b0d299e\",\"target\":\"improvement-l1-transformer-e7b0d58\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-l1-transformer-e7b0d58\",\"target\":\"user-cmfcruz\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-l1-transformer-e7b0d58\",\"target\":\"user-cmfcruz\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-etcher-pro-hardware-diagnostics-9440ac1\",\"target\":\"user-mcraa\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"target\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"target\":\"pattern-adding-balena-yml-repository-in-pr-removes-previously-required-check-runs-c400938\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"target\":\"pattern-github-reflector-create-git-tags-2ef7dba\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"target\":\"pattern-release-transformer-2dc6c8c\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"target\":\"user-lucian-buzzo\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"target\":\"user-stathismor\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-try-simple-transformer-hardware-ci-125161d\",\"target\":\"pattern-transformers-usable-hw-process--b4454a2\",\"weight\":1,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-add-altium-outjob-automation-ci-58d95b5\",\"target\":\"pattern-create-release-archives-hardware-projects-pull-requests-f543e7a\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-add-altium-outjob-automation-ci-58d95b5\",\"target\":\"user-anujdeshpande\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-events-product-e843fb9\",\"target\":\"user-lizzieepton\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-start-guide-doc-mention-relevant-people-notes-changes-etc--a4c0acb\",\"target\":\"pattern-create-guide-new-service-addition-services-model-f177046\",\"weight\":2,\"sourceType\":\"improvement\",\"targetType\":\"pattern\"},{\"source\":\"improvement-start-guide-doc-mention-relevant-people-notes-changes-etc--a4c0acb\",\"target\":\"user-stefsak\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"saga-balena-model-db35ff1\",\"target\":\"improvement-model-framework-3cdc3c8c-e93b-4101-af61-1e34b399ef6b\",\"weight\":0,\"sourceType\":\"saga\",\"targetType\":\"improvement\"},{\"source\":\"improvement-model-framework-3cdc3c8c-e93b-4101-af61-1e34b399ef6b\",\"target\":\"user-michaellwilks\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-fin-2-0-fin-relaunch-73f56224-7e0d-4891-aff8-1446851402f6\",\"target\":\"user-ntzovanis\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-fin-2-0-fin-relaunch-73f56224-7e0d-4891-aff8-1446851402f6\",\"target\":\"user-bucknalla\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"improvement-fin-2-0-fin-relaunch-73f56224-7e0d-4891-aff8-1446851402f6\",\"target\":\"user-curcuz\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"},{\"source\":\"product-improvement-customer-source-of-truth-03454cdf-cc8d-47b1-a533-84a140fe507e\",\"target\":\"user-thgreasi\",\"weight\":0,\"sourceType\":\"improvement\",\"targetType\":\"user\"}],\"nodes\":[{\"id\":\"Mission\",\"name\":\"Unlock the promise of physical computing by reducing friction for fleet owners\",\"group\":\"mission\",\"weight\":100},{\"id\":\"Edge computing 4th compute paradigm\",\"name\":\"Edge computing will be the fourth and largest compute paradigm. Its future will be defined by \\\"fleet owners\\\" building differentiated fleets using linux, containers, PaaS cloud workflows, and SBC-like hardware.\",\"group\":\"assumption\",\"weight\":40,\"Link\":\"https://www.slideshare.net/IanSkerrett/iot-developer-survey-2017\"},{\"id\":\"New paradigms require bottom up thinking\",\"name\":\"New paradigmatic platforms require rethinking from the bottom-up, which is why existing platforms cannot colonise new paradigms\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"Compute paradigms need developers\",\"name\":\"Computing paradigms only take off when theyâre opened up to mainstream developers\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"IOT is a big market\",\"name\":\"Weâre in a big market, and itâs getting bigger all the time as new entrants arrive\",\"group\":\"assumption\",\"weight\":35,\"Link\":\"http://www.businessinsider.com/the-internet-of-things-2017-report-2017-1)\"},{\"id\":\"Default alive\",\"name\":\"Weâre default alive, and there is no other external threat that could kill us if we donât rush.\",\"group\":\"assumption\",\"weight\":25},{\"id\":\"Fleet owners will pay for our product\",\"name\":\"Weâre the leader among non-DIY solutions. Still nothing worthwhile from the big players, and startups make interesting attempts but will never catch up. Fleet owners will therefore happily pay for our product.\",\"group\":\"assumption\",\"weight\":20},{\"id\":\"IOT market still growing\",\"name\":\"The IoT market is still growing slowly, although it will eventually take off and we need to have a solid market position when it does\",\"group\":\"assumption\",\"weight\":20,\"Link\":\"http://wing.vc/blog/iot-startup-state-of-the-union-2017\"},{\"id\":\"Build the org we want to become\",\"name\":\"The larger you get, the harder it is to change your organisational structure, so we need to put the effort now into building the organisation we want to become\",\"group\":\"assumption\",\"weight\":15},{\"id\":\"Per-component teams will not work\",\"name\":\"The sorts of leaps we want to make involve product-wide evolution, so per-component teams will not work\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"Productive work is fulfilling and interesting\",\"name\":\"People are more productive if their work is fulfilling and interesting\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"The standard way of running large companies is sub-optimal\",\"name\":\"We will be large, and the standard way of running large companies stifles innovation and is inefficient and soul destroying\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"STPLTG\",\"name\":\"Since thereâs no hurry, we can afford to invest in work that only pays off in the long term, and do not need to focus solely on delivering features\",\"group\":\"assumption\",\"weight\":15},{\"id\":\"More product surface = more feedback loops\",\"name\":\"More product surface = more feedback loops\",\"group\":\"assumption\",\"weight\":5},{\"id\":\"Engine of plenty\",\"name\":\"To win is to promote sustainable, scalable, adaptive, compounding positive-sum interactions for humanity. To win is to build an engine of plenty.\",\"group\":\"goal\",\"weight\":5},{\"id\":\"3X speed to scale\",\"name\":\"Tripling the speed at which our customers reach scale is one of the four things that, if they are all achieved, will get us to $100m ARR.\",\"group\":\"goal\",\"weight\":5,\"Link\":\"https://docs.google.com/presentation/d/1tklES843hwRCgOPuqHX7hBZwbvUzW7g0zVZ40a0Ur2o/edit?usp=sharing\"},{\"id\":\"3X devices per customer\",\"name\":\"Tripling our customers' average fleet size is one of the four things that, if they are all achieved, will get us to $100m ARR.\",\"group\":\"goal\",\"weight\":5,\"Link\":\"https://docs.google.com/presentation/d/1tklES843hwRCgOPuqHX7hBZwbvUzW7g0zVZ40a0Ur2o/edit?usp=sharing\"},{\"id\":\"10X customer base\",\"name\":\"Increasing our number of paying customers 10x is one of the four things that, if they are all achieved, will get us to $100m ARR\",\"group\":\"goal\",\"weight\":5,\"Link\":\"https://docs.google.com/presentation/d/1tklES843hwRCgOPuqHX7hBZwbvUzW7g0zVZ40a0Ur2o/edit?usp=sharing\"},{\"id\":\"2X device ASP\",\"name\":\"Doubling the average revenue we generate from each chargeable device is one of the four things that, if they are all achieved, will get us to $100m ARR\",\"group\":\"goal\",\"weight\":5,\"Link\":\"https://docs.google.com/presentation/d/1tklES843hwRCgOPuqHX7hBZwbvUzW7g0zVZ40a0Ur2o/edit?usp=sharing\"},{\"id\":\"Build a scalable omni-win-win antifragile organisation\",\"name\":\"Build a scalable omni-win-win antifragile organisation\",\"group\":\"goal\",\"weight\":5,\"Link\":\"https://drive.google.com/file/d/19k_4xUjJbO5hOi7RthSQitzRl7KlAb2d/view?usp=sharing\"},{\"id\":\"Platformise software\",\"name\":\"Platformise software\",\"group\":\"approach\",\"weight\":5,\"Link\":\"https://docs.google.com/presentation/d/1YWPb_zYj1PqFQBskppvjBzOlctOKXF6F030xaH1hbQU/edit?usp=sharing\"},{\"id\":\"Platformise hardware\",\"name\":\"Platformise hardware\",\"group\":\"approach\",\"weight\":5,\"Link\":\"https://drive.google.com/file/d/1Un5mSjTQoZPICHcQ9FQ-52WpuGivgcOO/view?usp=sharing\"},{\"id\":\"Platformise logistics\",\"name\":\"Platformise logistics\",\"group\":\"approach\",\"weight\":5,\"Link\":\"https://drive.google.com/file/d/1rCBTUcROjmE6bmMPNWPa4RysLXRlZMdV/view?usp=sharing\"},{\"id\":\"Expand the potential devices we can manage\",\"name\":\"Expand the potential devices we can manage\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Be a reliable, scalable, trustworth partner to our customers\",\"name\":\"Be a reliable, scalable, trustworth partner to our customers\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Additional features chargeable per device\",\"name\":\"Additional features chargeable per device\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Remove friction from onboarding devices\",\"name\":\"Remove friction from onboarding devices\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Creative pricing\",\"name\":\"Creative pricing\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Improve conversation rate\",\"name\":\"Improve conversation rate\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Find more fleet owners\",\"name\":\"Find more fleet owners\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Partner with leading industry players\",\"name\":\"Partner with leading industry players\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Protocols over management\",\"name\":\"Protocols over management\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Automate internal bureaucracy\",\"name\":\"Automate internal bureaucracy\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Enablement over control\",\"name\":\"Enablement over control\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Remote first\",\"name\":\"Remote first\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Loops\",\"name\":\"Loops\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Surface the flow of information\",\"name\":\"Surface the flow of information\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Reason from first principles\",\"name\":\"Reason from first principles\",\"group\":\"approach\",\"weight\":5},{\"id\":\"Reduce cycle times\",\"name\":\"Reduce cycle times\",\"group\":\"approach\",\"weight\":5},{\"id\":\"$100m ARR\",\"name\":\"$100m ARR\",\"group\":\"goal\",\"weight\":5},{\"id\":\"saga-pricing-4872873\",\"name\":\"Pricing 3.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"archived\",\"Link\":\"https://jel.ly.fish/saga-pricing-4872873\"},{\"id\":\"saga-balenair-c005f86\",\"name\":\"balenAir\",\"group\":\"saga\",\"weight\":0,\"status\":\"closed\",\"Link\":\"https://jel.ly.fish/saga-balenair-c005f86\"},{\"id\":\"saga-commercialize-open-fleets-hub-0582db4\",\"name\":\"Commercialize Open Fleets on Hub\",\"group\":\"saga\",\"weight\":0,\"status\":\"closed\",\"Link\":\"https://jel.ly.fish/saga-commercialize-open-fleets-hub-0582db4\"},{\"id\":\"saga-hardware-demand-807485a\",\"name\":\"Hardware on Demand\",\"group\":\"saga\",\"weight\":100,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-hardware-demand-807485a\"},{\"id\":\"saga-balenahub-f401df6\",\"name\":\"balenaHub\",\"group\":\"saga\",\"weight\":100,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-balenahub-f401df6\"},{\"id\":\"saga-pricing-2-0-1a85d4b\",\"name\":\"Pricing 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-pricing-2-0-1a85d4b\"},{\"id\":\"saga-security-next-32ef32c\",\"name\":\"Security Next\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-security-next-32ef32c\"},{\"id\":\"saga-security-1-0-a6ed6c9\",\"name\":\"Security 1.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-security-1-0-a6ed6c9\"},{\"id\":\"saga-analytics-2-0-e9bfa23\",\"name\":\"Analytics 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-analytics-2-0-e9bfa23\"},{\"id\":\"saga-balenaos-3-0-86974a1\",\"name\":\"balenaOS 3.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-balenaos-3-0-86974a1\"},{\"id\":\"saga-etcher-pro-1962875\",\"name\":\"Etcher Pro\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-etcher-pro-1962875\"},{\"id\":\"saga-protocols-management-1cde95f\",\"name\":\"Protocols for management\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-protocols-management-1cde95f\"},{\"id\":\"saga-fin-2-0-8bca872\",\"name\":\"Fin 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"archived\",\"Link\":\"https://jel.ly.fish/saga-fin-2-0-8bca872\"},{\"id\":\"saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\",\"name\":\"Close the balenaCloud loop (AKA \\\"merge equals deploy\\\")\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-close-balenacloud-loop-aka-merge-equals-deploy--19576be\"},{\"id\":\"saga-development-experience-e1cb478\",\"name\":\"Development Experience\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-development-experience-e1cb478\"},{\"id\":\"saga-team-context-ccedeb3\",\"name\":\"Team Context 1.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-team-context-ccedeb3\"},{\"id\":\"saga-support-2-0-838fc0c\",\"name\":\"Support 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-support-2-0-838fc0c\"},{\"id\":\"saga-etcher-2-0-b9bacd1\",\"name\":\"Etcher 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-etcher-2-0-b9bacd1\"},{\"id\":\"saga-finance-2-0-72a3e71\",\"name\":\"Finance 2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-finance-2-0-72a3e71\"},{\"id\":\"saga-transformers-b0d299e\",\"name\":\"Transformers\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-transformers-b0d299e\"},{\"id\":\"saga-billing-v2-0-a7e5732\",\"name\":\"Billing v2.0\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-billing-v2-0-a7e5732\"},{\"id\":\"saga-balena-model-db35ff1\",\"name\":\"Balena Model\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-balena-model-db35ff1\"},{\"id\":\"saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\",\"name\":\"Jellyfish 2\",\"group\":\"saga\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/saga-jellyfish-2-6d13007d-7764-4234-b7ee-3c46b73e0071\"},{\"id\":\"improvement-getting-strategy-jellyfish-2fbcbf7\",\"name\":\"Getting our strategy into Jellyfish\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-getting-strategy-jellyfish-2fbcbf7\"},{\"id\":\"user-phil-d-wilson\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-phil-d-wilson\"},{\"id\":\"user-michaellwilks\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-michaellwilks\"},{\"id\":\"improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\",\"name\":\"Remove `vpn.balena-cloud.com` due to expiring CA Cert\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-remove-vpn-balena-cloud-com-due-expiring-ca-cert-f53f026\"},{\"id\":\"pattern-missing-accesslist-whitelist-entry-cloudlink-27e73a6\",\"name\":\"Missing accesslist (whitelist) entry for cloudlink\",\"group\":\"pattern\",\"weight\":7,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-missing-accesslist-whitelist-entry-cloudlink-27e73a6\"},{\"id\":\"pattern-number-devices-theoretically-support-cloudlink-hostos-2-14-0-uses-vpn-balena-cloud-com--538bcab\",\"name\":\"A number of devices that theoretically support Cloudlink (hostOS >= 2.14.0) still uses `vpn.balena-cloud.com`\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-number-devices-theoretically-support-cloudlink-hostos-2-14-0-uses-vpn-balena-cloud-com--538bcab\"},{\"id\":\"pattern-devices-using-open-vpn-instances-instead-cloudlink-b509673\",\"name\":\"Devices are still using open-vpn instances instead of cloudlink\",\"group\":\"pattern\",\"weight\":9,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-devices-using-open-vpn-instances-instead-cloudlink-b509673\"},{\"id\":\"pattern-balenaos-resinos-2-14-0-will-connect-vpn-balena-cloud-com-instead-cloudlink-70c855c\",\"name\":\"balenaOS (resinOS) <= 2.14.0 will still connect to `vpn.balena-cloud.com` instead of cloudlink\",\"group\":\"pattern\",\"weight\":7,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-balenaos-resinos-2-14-0-will-connect-vpn-balena-cloud-com-instead-cloudlink-70c855c\"},{\"id\":\"user-jaomaloy\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-jaomaloy\"},{\"id\":\"improvement-non-caching-forwarding-proxy-api-endpoint-s--1dfa353\",\"name\":\"Non-caching/forwarding proxy on the API endpoint(s)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-non-caching-forwarding-proxy-api-endpoint-s--1dfa353\"},{\"id\":\"user-ab77\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-ab77\"},{\"id\":\"improvement-improve-query-timeout-logging--e0ad070\",\"name\":\"Improve query error information and logging \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improve-query-timeout-logging--e0ad070\"},{\"id\":\"pattern-query-timeouts-affect-ux-sync-components-7e93d70\",\"name\":\"[JF] Query timeouts affect UX and sync components\",\"group\":\"pattern\",\"weight\":27,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-query-timeouts-affect-ux-sync-components-7e93d70\"},{\"id\":\"improvement-remove-rec-files-boot-partition-triggering-host-os-update-793416d\",\"name\":\"Remove REC files from boot partition before triggering host OS update\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-remove-rec-files-boot-partition-triggering-host-os-update-793416d\"},{\"id\":\"pattern-recovery-files-fill-boot-partition-36a49a9\",\"name\":\"Recovery files fill up boot partition\",\"group\":\"pattern\",\"weight\":6,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-recovery-files-fill-boot-partition-36a49a9\"},{\"id\":\"improvement-balenaos-support-booting-metadata-md-device-software-raid-arrays-c538001\",\"name\":\"balenaOS should support booting from metadata (MD) device (software RAID) arrays\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenaos-support-booting-metadata-md-device-software-raid-arrays-c538001\"},{\"id\":\"pattern-software-raid-configurations-not-booting-e9ec7cb\",\"name\":\"software RAID configurations not booting up\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-software-raid-configurations-not-booting-e9ec7cb\"},{\"id\":\"pattern-md-raid-arrays-numbered-127-down-boot-ca940a5\",\"name\":\"MD RAID arrays come up numbered from 127 down after boot\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-md-raid-arrays-numbered-127-down-boot-ca940a5\"},{\"id\":\"user-jakogut\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-jakogut\"},{\"id\":\"improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\",\"name\":\"Labs Residency 2.0\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improve-completion-protocol-feedback-loops-residency-product-add87fc\"},{\"id\":\"pattern-unclear-transition-labs-residency-day-day-balena-5868dac\",\"name\":\"Unclear how to transition from labs residency to day to day balena\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-unclear-transition-labs-residency-day-day-balena-5868dac\"},{\"id\":\"pattern-it-s-not-clear-work-once-finish-residency-2bd59c3\",\"name\":\"It's not clear what to work on once you finish your residency\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-it-s-not-clear-work-once-finish-residency-2bd59c3\"},{\"id\":\"pattern-balena-team-member-struggles-step-away-current-workload-order-labs-residency-dadb046\",\"name\":\"balena team member struggles to step away from current workload in order to do a labs residency\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-balena-team-member-struggles-step-away-current-workload-order-labs-residency-dadb046\"},{\"id\":\"pattern-unclear-criteria-finishing-balena-residency-c2b3042\",\"name\":\"Unclear what the criteria is for finishing a balena residency\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-unclear-criteria-finishing-balena-residency-c2b3042\"},{\"id\":\"user-poshrolls\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-poshrolls\"},{\"id\":\"user-natasakyvetou\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-natasakyvetou\"},{\"id\":\"improvement-clean-items-boms-mrp-181ca8e\",\"name\":\"Clean up items and BoMs on MRP\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-clean-items-boms-mrp-181ca8e\"},{\"id\":\"improvement-normalize-release-contracts-proper-json-fields-c081175\",\"name\":\"Normalize the release contracts to proper JSON fields\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-normalize-release-contracts-proper-json-fields-c081175\"},{\"id\":\"user-thgreasi\",\"name\":\"thgreasi\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-thgreasi\"},{\"id\":\"improvement-move-hardware-process-versionbot-ci-github-actions-e8a1d6e\",\"name\":\"Move hardware process from versionbot/CI to github actions\",\"group\":\"improvement\",\"weight\":0,\"status\":\"awaiting-approval\",\"Link\":\"https://jel.ly.fish/improvement-move-hardware-process-versionbot-ci-github-actions-e8a1d6e\"},{\"id\":\"pattern-making-changes-hardware-process-its-current-architecture-slow-limiting-fd59945\",\"name\":\"Making changes to hardware process in its current architecture is slow/limiting\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-making-changes-hardware-process-its-current-architecture-slow-limiting-fd59945\"},{\"id\":\"improvement-loki-optimizations-killing-logentries--5ed3a65\",\"name\":\"Loki optimizations / Killing logentries \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-loki-optimizations-killing-logentries--5ed3a65\"},{\"id\":\"user-page-\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-page-\"},{\"id\":\"improvement-restore-open-drain-balenafin-software-i2c-pins-preserving-functionality-de-pop-boards--a349413\",\"name\":\"Restore open-drain to the balenaFin software I2C pins while preserving functionality on de-pop boards.\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-restore-open-drain-balenafin-software-i2c-pins-preserving-functionality-de-pop-boards--a349413\"},{\"id\":\"pattern-unreliable-i2c-de-populated-balenafin-when-resetting-cellular-modem--055929a\",\"name\":\"Unreliable I2C on (de-populated) balenaFin, such as when resetting the cellular modem.\",\"group\":\"pattern\",\"weight\":3,\"status\":\"improvement-in-progress\",\"Link\":\"https://jel.ly.fish/pattern-unreliable-i2c-de-populated-balenafin-when-resetting-cellular-modem--055929a\"},{\"id\":\"user-hraftery\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-hraftery\"},{\"id\":\"improvement-document-sync-workflow-02e51c5\",\"name\":\"Document sync workflow\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-document-sync-workflow-02e51c5\"},{\"id\":\"improvement-device-freezing-679ef79\",\"name\":\"Device Freezing\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-device-freezing-679ef79\"},{\"id\":\"improvement-device-uis-11f0807\",\"name\":\"device-UIs\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-device-uis-11f0807\"},{\"id\":\"improvement-etcher-featured-project-v2-e8a5a4d\",\"name\":\"Etcher Featured Project v2\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-etcher-featured-project-v2-e8a5a4d\"},{\"id\":\"pattern-getting-efp-not-accessible-fleet-app-owner-03f3a4f\",\"name\":\"Getting on EFP is not accessible to any Fleet/App owner\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-getting-efp-not-accessible-fleet-app-owner-03f3a4f\"},{\"id\":\"pattern-user-can-t-stage-efp-see-changes-will-look-etcher-1b74f9b\",\"name\":\"User can't stage EFP to see how changes will look in Etcher\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-can-t-stage-efp-see-changes-will-look-etcher-1b74f9b\"},{\"id\":\"pattern-efp-etcher-featured-projects-analytics-data-available-for-featured-app-owners-a3d4b012-0875-42e9-ba88-3917c4e2cc01\",\"name\":\"EFP (Etcher Featured Projects) analytics data available for featured app owners\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-efp-etcher-featured-projects-analytics-data-available-for-featured-app-owners-a3d4b012-0875-42e9-ba88-3917c4e2cc01\"},{\"id\":\"pattern-user-one-change-time-etcher-success-screen-d747796\",\"name\":\"User can only make one change at a time to Etcher Success Screen\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-one-change-time-etcher-success-screen-d747796\"},{\"id\":\"pattern-changing-efp-manually-time-consuming-leaves-room-mistakes-bc42521\",\"name\":\"Changing EFP Manually is time consuming and leaves room for mistakes\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-changing-efp-manually-time-consuming-leaves-room-mistakes-bc42521\"},{\"id\":\"pattern-significant-drop-off-ctr-efp-1-month-featured-d067706\",\"name\":\"Significant drop off in CTR on EFP after 1 month of being featured\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-significant-drop-off-ctr-efp-1-month-featured-d067706\"},{\"id\":\"pattern-featured-efp-community-growth-benefits-fleet-owners-d3dba1b\",\"name\":\"Being featured on EFP can have community growth benefits for Fleet owners\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-featured-efp-community-growth-benefits-fleet-owners-d3dba1b\"},{\"id\":\"user-lizzieepton\",\"name\":\"lizzieepton\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-lizzieepton\"},{\"id\":\"user-jmakivic\",\"name\":\"jmakivic\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-jmakivic\"},{\"id\":\"user-chrisys\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-chrisys\"},{\"id\":\"user-otaviojacobi\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-otaviojacobi\"},{\"id\":\"user-user-jmakivic\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-user-jmakivic\"},{\"id\":\"improvement-etcher-cleanup-rewrite--cfc3d26\",\"name\":\"Etcher cleanup (rewrite?)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-etcher-cleanup-rewrite--cfc3d26\"},{\"id\":\"user-mcraa\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-mcraa\"},{\"id\":\"improvement-fix-errors-front-sync-related-unexpected-schema-127cce2\",\"name\":\"FIX errors on Front sync that abort a sync instance ( schema, email format, permissions )\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-fix-errors-front-sync-related-unexpected-schema-127cce2\"},{\"id\":\"improvement-compile-list-domains-need-removed-3f3b01b\",\"name\":\"Compile list of domains that need to be removed\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-compile-list-domains-need-removed-3f3b01b\"},{\"id\":\"pattern-domain-hijack-ea25db1\",\"name\":\"Domain hijack\",\"group\":\"pattern\",\"weight\":4,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-domain-hijack-ea25db1\"},{\"id\":\"user-20k-ultra\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-20k-ultra\"},{\"id\":\"improvement-expose-balenaos-info-hub-03ccffc\",\"name\":\"Expose balenaOS info on hub\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-expose-balenaos-info-hub-03ccffc\"},{\"id\":\"pattern-user-wants-download-kernel-headers-device-f12bafb\",\"name\":\"User wants to download kernel headers for device\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-download-kernel-headers-device-f12bafb\"},{\"id\":\"pattern-user-info-particluar-balena-os-version-bf969c6\",\"name\":\"User would like to get more info about a particular balena OS version\",\"group\":\"pattern\",\"weight\":17,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-info-particluar-balena-os-version-bf969c6\"},{\"id\":\"user-rahul-thakoor\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-rahul-thakoor\"},{\"id\":\"user-myarmolinsky\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-myarmolinsky\"},{\"id\":\"improvement-balenablock-hup-acc2a8c\",\"name\":\"balenaBlock for HUP\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenablock-hup-acc2a8c\"},{\"id\":\"improvement-update-renovate-handle-custom-regex-parsing--d37047a\",\"name\":\"Update renovate to handle custom regex parsing \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-update-renovate-handle-custom-regex-parsing--d37047a\"},{\"id\":\"user-olamiko\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-olamiko\"},{\"id\":\"improvement-offer-raw-images-device-types-ce76d0f\",\"name\":\"Support alternate image types for balenaOS, such as raw alongside flasher/installer\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-offer-raw-images-device-types-ce76d0f\"},{\"id\":\"pattern-distinguish-flasher-images-regular-images-docs-c08c993\",\"name\":\"Distinguish flasher images from regular images in the docs\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-distinguish-flasher-images-regular-images-docs-c08c993\"},{\"id\":\"improvement-etcherpro-usb-sd-slot-pc-ad-e42cafd\",\"name\":\"EtcherPro, USB SD Slot PC AD\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-etcherpro-usb-sd-slot-pc-ad-e42cafd\"},{\"id\":\"improvement-add-separate-feed-subscriptions-jellyfish-3fed410\",\"name\":\"Add a separate feed of subscriptions to Jellyfish\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-separate-feed-subscriptions-jellyfish-3fed410\"},{\"id\":\"user-jonjrich\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-jonjrich\"},{\"id\":\"improvement-lock-orgs-90-days-pastdue--f836645\",\"name\":\"Limit access for orgs that are pastdue â³\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-lock-orgs-90-days-pastdue--f836645\"},{\"id\":\"improvement-project-repos-cleanup-organization-49645cc\",\"name\":\"Project Repos Cleanup & Organization\",\"group\":\"improvement\",\"weight\":0,\"status\":\"awaiting-approval\",\"Link\":\"https://jel.ly.fish/improvement-project-repos-cleanup-organization-49645cc\"},{\"id\":\"improvement-bitwarden-password-manager-44bf2d5\",\"name\":\"New password manager\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-bitwarden-password-manager-44bf2d5\"},{\"id\":\"user-lpapapo\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-lpapapo\"},{\"id\":\"user-apostolism\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-apostolism\"},{\"id\":\"product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\",\"name\":\"Multi-container hostOS app\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-multi-container-hostos-app-c6211ae3-8217-4dae-be69-bfe5d2c621f3\"},{\"id\":\"pattern-user-wants-os-built-in-toolkit-described-https-www-balena-io-blog-how-to-use-nvidia-jetson-devices-on-balenaos--27ee084\",\"name\":\"User wants the OS built-in toolkit described in https://www.balena.io/blog/how-to-use-nvidia-jetson-devices-on-balenaos/\",\"group\":\"pattern\",\"weight\":6,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-os-built-in-toolkit-described-https-www-balena-io-blog-how-to-use-nvidia-jetson-devices-on-balenaos--27ee084\"},{\"id\":\"user-alexgg\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-alexgg\"},{\"id\":\"user-pipex\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-pipex\"},{\"id\":\"improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\",\"name\":\"balenaOS secure boot and disk encryption\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenaos-secure-boot-and-disk-encryption-770858c2-ed9b-4b2a-89af-c03b3812072d\"},{\"id\":\"pattern-requests-for-secure-boot-8c2ea16b-e3da-46c9-9318-929841d1f13c\",\"name\":\"Requests for Secure Boot\",\"group\":\"pattern\",\"weight\":23,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-requests-for-secure-boot-8c2ea16b-e3da-46c9-9318-929841d1f13c\"},{\"id\":\"pattern-users-are-asking-for-full-disk-encryption-d8b4ee91-74aa-4bfc-b2be-b6a0a7c3f9d7\",\"name\":\"Users are asking for full disk encryption.\",\"group\":\"pattern\",\"weight\":32,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-are-asking-for-full-disk-encryption-d8b4ee91-74aa-4bfc-b2be-b6a0a7c3f9d7\"},{\"id\":\"user-mtoman\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-mtoman\"},{\"id\":\"improvement-publish-balenaos-amis-to-aws-ec2-9b022726-a23d-4aca-bed1-c1cfbadb973c\",\"name\":\"publish balenaOS AMIs to AWS/EC2\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-publish-balenaos-amis-to-aws-ec2-9b022726-a23d-4aca-bed1-c1cfbadb973c\"},{\"id\":\"improvement-x86-device-types-c65151cd-10be-4093-8427-36c3fd37ef17\",\"name\":\"x86 device types\",\"group\":\"improvement\",\"weight\":0,\"status\":\"awaiting-approval\",\"Link\":\"https://jel.ly.fish/improvement-x86-device-types-c65151cd-10be-4093-8427-36c3fd37ef17\"},{\"id\":\"pattern-jenkins-master-disk-space-due-dt-build-artefact-history-5abf0dc\",\"name\":\"Jenkins master out of disk space due to DT build artefact history\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-jenkins-master-disk-space-due-dt-build-artefact-history-5abf0dc\"},{\"id\":\"pattern-user-confused-new-x86-64-amd64-images-24a5f6e\",\"name\":\"User Confused with new x86-64/amd64 images\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-confused-new-x86-64-amd64-images-24a5f6e\"},{\"id\":\"improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\",\"name\":\"Fully automated OS releases for all ESR devices\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-os-test-automation-and-coverage-8ccd0bac-6aad-43ad-a910-599870b2bac0\"},{\"id\":\"user-klutchell\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-klutchell\"},{\"id\":\"user-acostach\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-acostach\"},{\"id\":\"user-rcooke-warwick\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-rcooke-warwick\"},{\"id\":\"user-g-paulo-nascimento\",\"name\":\"g_paulo_nascimento\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-g-paulo-nascimento\"},{\"id\":\"user-vipulgupta2048\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-vipulgupta2048\"},{\"id\":\"user-lmbarros\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-lmbarros\"},{\"id\":\"improvement-balenaos-3-versioning-ff204a5\",\"name\":\"BalenaOS versioning\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenaos-3-versioning-ff204a5\"},{\"id\":\"improvement-managed-redshift-data-pipeline-deployment-7b4f4e7\",\"name\":\"Managed Redshift and Data Pipeline deployment\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-managed-redshift-data-pipeline-deployment-7b4f4e7\"},{\"id\":\"improvement-active-eager-diagnostics-40b468b\",\"name\":\"Active 'eager' diagnostics\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-active-eager-diagnostics-40b468b\"},{\"id\":\"pattern-faulty-or-slow-sd-cards-causing-problems-b62c3dcf-bd2e-4852-bc9a-6d0b26b25054\",\"name\":\"Faulty or slow SD cards causing problems\",\"group\":\"pattern\",\"weight\":26,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-faulty-or-slow-sd-cards-causing-problems-b62c3dcf-bd2e-4852-bc9a-6d0b26b25054\"},{\"id\":\"scratchpad-entry-4efe4a9e-2793-4869-b161-18eb3e01d9c7\",\"name\":\"Checking Disk Space Usage (btrfs)\",\"group\":\"pattern\",\"weight\":0,\"Link\":\"https://jel.ly.fish/scratchpad-entry-4efe4a9e-2793-4869-b161-18eb3e01d9c7\"},{\"id\":\"support-issue-evice-ime-randomly-is-incorrect-f8a87e75-5389-4fbd-a666-6996b323e281\",\"name\":\"Device Time randomly is incorrect.\",\"group\":\"pattern\",\"weight\":2,\"status\":\"closed-resolved\",\"Link\":\"https://jel.ly.fish/support-issue-evice-ime-randomly-is-incorrect-f8a87e75-5389-4fbd-a666-6996b323e281\"},{\"id\":\"pattern-user-would-like-a-passive-set-of-device-diagnostics-eager-diagnostics-to-avoid-issues-in-advance-1ef047be-53a3-42af-a0a6-31a711256276\",\"name\":\"User would like a passive set of device diagnostics (eager diagnostics) to avoid issues in advance\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-would-like-a-passive-set-of-device-diagnostics-eager-diagnostics-to-avoid-issues-in-advance-1ef047be-53a3-42af-a0a6-31a711256276\"},{\"id\":\"pattern-no-device-diagnostics-heartbeat-only-mode-39daf72\",\"name\":\"No way to get device diagnostics in (Heartbeat Only) mode\",\"group\":\"pattern\",\"weight\":8,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-no-device-diagnostics-heartbeat-only-mode-39daf72\"},{\"id\":\"pattern-fsck-n-read-only-filesystem-check-part-device-health-checks-378245f\",\"name\":\"fsck -n (read-only filesystem check) should be part of device health checks\",\"group\":\"pattern\",\"weight\":8,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-fsck-n-read-only-filesystem-check-part-device-health-checks-378245f\"},{\"id\":\"support-issue-leaked-aufs-dirs-cleanup-5c75c693-7e0a-4766-a17c-77b48cd14af0\",\"name\":\"Device is Out of Space - Leaked AUFS or OverlayFS Directories Cleanup\",\"group\":\"pattern\",\"weight\":0,\"Link\":\"https://jel.ly.fish/support-issue-leaked-aufs-dirs-cleanup-5c75c693-7e0a-4766-a17c-77b48cd14af0\"},{\"id\":\"pattern-undervoltage-warning-dashboard-not-informative-ab6fcab\",\"name\":\"Undervoltage warning in dashboard not informative\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-undervoltage-warning-dashboard-not-informative-ab6fcab\"},{\"id\":\"pattern-clean-docker-balena-engine-folder-2d843c1\",\"name\":\"Clean docker/balena engine folder\",\"group\":\"pattern\",\"weight\":23,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-clean-docker-balena-engine-folder-2d843c1\"},{\"id\":\"pattern-ticket-does-not-include-diagnostics-information-6442446\",\"name\":\"Ticket does not include diagnostics information\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-ticket-does-not-include-diagnostics-information-6442446\"},{\"id\":\"pattern--could-not-communicate-registry2-balena-cloud-com-authentication-diagnostics-checks-7054399\",\"name\":\"Fake error on diagnostics checks: \\\"Could not communicate with registry2.balena-cloud.com for authentication\\\"\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern--could-not-communicate-registry2-balena-cloud-com-authentication-diagnostics-checks-7054399\"},{\"id\":\"pattern-warn-users-when-drop-ipv4-connectivity-diagnostics--279f8c4\",\"name\":\"Warn users upon dropping dual-stack (IPv4 + IPv6) connectivity\",\"group\":\"pattern\",\"weight\":5,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-warn-users-when-drop-ipv4-connectivity-diagnostics--279f8c4\"},{\"id\":\"pattern-detection-of-path-mtu-discovery-issues-in-device-diagnostics-52ae82b4-ac30-4515-a6aa-f3808a85a5d5\",\"name\":\"Detection of path MTU discovery issues in device diagnostics\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-detection-of-path-mtu-discovery-issues-in-device-diagnostics-52ae82b4-ac30-4515-a6aa-f3808a85a5d5\"},{\"id\":\"improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\",\"name\":\"Improved device diagnostics & metrics (eager diagnostics)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improved-device-diagnostics-metrics-eager-diagnostics-396942a9-d007-4585-95b3-decfe0550b72\"},{\"id\":\"user-pranavpeshwe\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-pranavpeshwe\"},{\"id\":\"user-cywang117\",\"name\":\"cywang117\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-cywang117\"},{\"id\":\"improvement-support-auditing-e26f74f\",\"name\":\"Support Auditing\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-support-auditing-e26f74f\"},{\"id\":\"user-jazzagi\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-jazzagi\"},{\"id\":\"improvement-improve-content-getting-started-guides--4f62835\",\"name\":\"Improve the content of Getting Started guides \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improve-content-getting-started-guides--4f62835\"},{\"id\":\"user-gh-vipulgupta2048\",\"name\":\"gh_vipulgupta2048\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-gh-vipulgupta2048\"},{\"id\":\"improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\",\"name\":\"Balena API should generate history tables according to SBVR model description\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balena-api-generate-history-tables-according-sbvr-model-description-900d7bb\"},{\"id\":\"pattern-user-requesting-feature-keep-track-operations-variables-etc-similar-audit-log-e2f9202\",\"name\":\"User requesting a feature to keep track of operations, variables, etc. Similar to the audit log\",\"group\":\"pattern\",\"weight\":5,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-requesting-feature-keep-track-operations-variables-etc-similar-audit-log-e2f9202\"},{\"id\":\"pattern-user-wants-to-see-the-release-history-for-a-given-device-e870a272-6b93-4e71-ae01-9ecf15fa23bc\",\"name\":\"User wants to see the release history for a given device \",\"group\":\"pattern\",\"weight\":9,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-to-see-the-release-history-for-a-given-device-e870a272-6b93-4e71-ae01-9ecf15fa23bc\"},{\"id\":\"pattern-customers-requesting-support-for-dashboard-auditing-2b0490a2-52a5-424c-ad01-0684e2578440\",\"name\":\"Customers requesting support for dashboard auditing \",\"group\":\"pattern\",\"weight\":27,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-customers-requesting-support-for-dashboard-auditing-2b0490a2-52a5-424c-ad01-0684e2578440\"},{\"id\":\"user-fisehara\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-fisehara\"},{\"id\":\"product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\",\"name\":\"Release versioning, draft releases & variants\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-draft-releases-and-release-versioning-d0391f45-c2f9-4f4e-b964-1a7e9023a3f4\"},{\"id\":\"pattern-user-gets-confused-by-the-unique-release-version-constraint-when-trying-to-re-push-a-release-with-the-same-version-df66f4b0-1bb1-45a9-998c-837b47a5b550\",\"name\":\"User gets confused by the unique release_version constraint when trying to re-push a release with the same version\",\"group\":\"pattern\",\"weight\":8,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-gets-confused-by-the-unique-release-version-constraint-when-trying-to-re-push-a-release-with-the-same-version-df66f4b0-1bb1-45a9-998c-837b47a5b550\"},{\"id\":\"pattern-we-are-missing-docs-about-release-versioning-draft-releases-1a419144-e730-4b77-9d40-5d07e013013a\",\"name\":\"We are missing docs about release versioning & draft releases\",\"group\":\"pattern\",\"weight\":6,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-we-are-missing-docs-about-release-versioning-draft-releases-1a419144-e730-4b77-9d40-5d07e013013a\"},{\"id\":\"pattern-customer-identified-missing-unique-identifiers-in-case-of-multiple-releases-in-a-day-731090c0-c129-446d-9421-9c20905b8769\",\"name\":\"Customer identified missing unique identifiers in case of multiple releases in a day\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-customer-identified-missing-unique-identifiers-in-case-of-multiple-releases-in-a-day-731090c0-c129-446d-9421-9c20905b8769\"},{\"id\":\"pattern-user-wants-to-be-able-to-use-any-valid-semver-string-as-the-release-version-including-pre-release-parts-e5f76ee9-21fd-4475-9ef5-b8d58a7bc560\",\"name\":\"User wants to be able to use any valid semver string as the release version (including pre-release parts)\",\"group\":\"pattern\",\"weight\":5,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-to-be-able-to-use-any-valid-semver-string-as-the-release-version-including-pre-release-parts-e5f76ee9-21fd-4475-9ef5-b8d58a7bc560\"},{\"id\":\"improvement-become-oauth-provider-ory-hydra-e0a87a7\",\"name\":\"Become oauth provider with ory hydra\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-become-oauth-provider-ory-hydra-e0a87a7\"},{\"id\":\"user-karaxuna\",\"name\":\"karaxuna\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-karaxuna\"},{\"id\":\"improvement-migrate-product-repo-to-jellyfish-457ae485-7938-4bad-9ec0-d8656626a022\",\"name\":\"Migrate product repo to jellyfish\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-migrate-product-repo-to-jellyfish-457ae485-7938-4bad-9ec0-d8656626a022\"},{\"id\":\"user-nucleardreamer\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-nucleardreamer\"},{\"id\":\"improvement-running-regular-virtual-events-45824053-750c-4c29-a57c-cd7a9a532ebd\",\"name\":\"BalenaHub Meetups\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-running-regular-virtual-events-45824053-750c-4c29-a57c-cd7a9a532ebd\"},{\"id\":\"user-dtischler\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-dtischler\"},{\"id\":\"improvement-stop-relying-device-types-v1-device-type-json-unrelated-things-4fbac3c\",\"name\":\"Stop relying on /device-types/v1 & device-type.json for unrelated things\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-stop-relying-device-types-v1-device-type-json-unrelated-things-4fbac3c\"},{\"id\":\"user-mehalter\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-mehalter\"},{\"id\":\"improvement-centralize-docs-balenacloud-repository--b4aea99\",\"name\":\"Centralize docs into balenaCloud repository.\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-centralize-docs-balenacloud-repository--b4aea99\"},{\"id\":\"improvement-services-model-upgrade-spec-0e2ebee\",\"name\":\"Services Model Upgrade\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-services-model-upgrade-spec-0e2ebee\"},{\"id\":\"pattern-models-cannot-handle-one-off-revenue-expenses-eab69ac\",\"name\":\"Our models cannot handle one-off revenue or expenses\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-models-cannot-handle-one-off-revenue-expenses-eab69ac\"},{\"id\":\"pattern-accounts-payable-processes-manual-time-consuming-d0e006c\",\"name\":\"Our accounts payable processes are manual and time consuming\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-accounts-payable-processes-manual-time-consuming-d0e006c\"},{\"id\":\"user-somombo\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-somombo\"},{\"id\":\"improvement-balena-on-balena-05772643-0191-4886-b000-a4ccbcb5fec5\",\"name\":\"balena-on-balena\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balena-on-balena-05772643-0191-4886-b000-a4ccbcb5fec5\"},{\"id\":\"pattern-user-wants-first-class-support-release-channels-staged-rollouts-new-releases-specific-groups-df03371\",\"name\":\"User wants first class support for release channels to do staged rollouts of new releases to specific groups\",\"group\":\"pattern\",\"weight\":11,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-first-class-support-release-channels-staged-rollouts-new-releases-specific-groups-df03371\"},{\"id\":\"improvement-create-mechanism-advertises-balenair-devices-via-dns-sd--c5684b0\",\"name\":\"Create a mechanism that advertises balenair devices via DNS-SD \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-create-mechanism-advertises-balenair-devices-via-dns-sd--c5684b0\"},{\"id\":\"user-wjlove\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-wjlove\"},{\"id\":\"improvement-implement-touchscreen-device-093b162\",\"name\":\"Implement a touchscreen device\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-implement-touchscreen-device-093b162\"},{\"id\":\"improvement-migrate-balena-blog-to-gatsbyjs-de6503ee-0bb9-4ddd-9451-2d644bb0f474\",\"name\":\"Productize balena-blog / make it public\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-migrate-balena-blog-to-gatsbyjs-de6503ee-0bb9-4ddd-9451-2d644bb0f474\"},{\"id\":\"user-iamsolankiamit\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-iamsolankiamit\"},{\"id\":\"improvement-jip-improve-performance-triggers-47b1dc8\",\"name\":\"JIP: Improve performance of triggers\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-improve-performance-triggers-47b1dc8\"},{\"id\":\"user-ramirogm\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-ramirogm\"},{\"id\":\"improvement-jip-add-emoji-reactions-msgs-6a67721\",\"name\":\"JIP: add emoji reactions to msgs\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-add-emoji-reactions-msgs-6a67721\"},{\"id\":\"user-inwenc\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-inwenc\"},{\"id\":\"product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\",\"name\":\"SAML Integration For Balena Cloud Authentication \",\"group\":\"improvement\",\"weight\":0,\"status\":\"awaiting-approval\",\"Link\":\"https://jel.ly.fish/product-improvement-saml-integration-for-balena-cloud-authentication-e2aaf3dc-ffab-4f3d-bb82-d167fa228e0c\"},{\"id\":\"pattern-customers-asking-about-support-for-login-authentication-directory-services-with-balena-cloud-94771535-7bf3-407b-a8ed-a3781ab152f4\",\"name\":\"Customers asking about support for login/ authentication directory services with balena cloud\",\"group\":\"pattern\",\"weight\":5,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-customers-asking-about-support-for-login-authentication-directory-services-with-balena-cloud-94771535-7bf3-407b-a8ed-a3781ab152f4\"},{\"id\":\"pattern-user-would-like-to-sign-in-to-the-dashboard-with-azure-single-sign-on-eb553e2a-c90a-4f49-89c6-d9474e9aeac2\",\"name\":\"User would like to sign in to the dashboard with single sign on (SSO)\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-would-like-to-sign-in-to-the-dashboard-with-azure-single-sign-on-eb553e2a-c90a-4f49-89c6-d9474e9aeac2\"},{\"id\":\"user-joe-hounsham\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-joe-hounsham\"},{\"id\":\"improvement-athens-office-safety-guidelines-d488d04\",\"name\":\"Athens office safety guidelines\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-athens-office-safety-guidelines-d488d04\"},{\"id\":\"improvement-move-balenaci-github-actions-17bfd7b\",\"name\":\"Move from balenaCI to GitHub Actions\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-move-balenaci-github-actions-17bfd7b\"},{\"id\":\"pattern-balenaci-resinci-concourse-not-running-pr-builds-missing-gh-events-etc--67e667e\",\"name\":\"balenaCI (resinCI/Concourse) not running PR builds, missing GH events, etc.\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-balenaci-resinci-concourse-not-running-pr-builds-missing-gh-events-etc--67e667e\"},{\"id\":\"pattern-concourse-env-var-leak-b543347\",\"name\":\"Concourse env var leak\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-concourse-env-var-leak-b543347\"},{\"id\":\"pattern-etcher-tests-hang-when-ci-process-running-windows-service-77d808b\",\"name\":\"Etcher tests hang when CI process is running as a Windows service\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-etcher-tests-hang-when-ci-process-running-windows-service-77d808b\"},{\"id\":\"pattern-remove-concourse-1a383cb\",\"name\":\"Remove concourse\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-remove-concourse-1a383cb\"},{\"id\":\"user-gh-anujdeshpande\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-gh-anujdeshpande\"},{\"id\":\"user-gh-ab77\",\"name\":\"gh_ab77\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-gh-ab77\"},{\"id\":\"user-gh-klutchell\",\"name\":\"gh_klutchell\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-gh-klutchell\"},{\"id\":\"user-gh-bucknalla\",\"name\":\"gh_bucknalla\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-gh-bucknalla\"},{\"id\":\"improvement-salary-calculator-spec-a0b0dca1-d6b4-4d22-8b4d-873e3ef3ab47\",\"name\":\"Compensation Calculator\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-salary-calculator-spec-a0b0dca1-d6b4-4d22-8b4d-873e3ef3ab47\"},{\"id\":\"user-alidaodendaal\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-alidaodendaal\"},{\"id\":\"improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\",\"name\":\"Preloaded images: Reducing time between power-on and running services\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-preloading-images-via-cloud-2f9857af-5af2-43bf-a49b-b9b032fcdb25\"},{\"id\":\"pattern-customers-not-reading-docs-find-release-strategies-work-45373b4\",\"name\":\"Customers are not reading through the docs to find out how release strategies work\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-customers-not-reading-docs-find-release-strategies-work-45373b4\"},{\"id\":\"pattern-user-would-like-preloaded-images-d1b83f68-7eb2-46f3-8cc6-b066920b42f0\",\"name\":\"User would like preloaded images served by default\",\"group\":\"pattern\",\"weight\":7,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-would-like-preloaded-images-d1b83f68-7eb2-46f3-8cc6-b066920b42f0\"},{\"id\":\"user-zoobot\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-zoobot\"},{\"id\":\"user-aethernet\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-aethernet\"},{\"id\":\"user-zwhitchcox\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-zwhitchcox\"},{\"id\":\"improvement-tg-odoo-migration-b500ee1\",\"name\":\"TG to MRPeasy migration\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-tg-odoo-migration-b500ee1\"},{\"id\":\"pattern-it-s-difficult-track-component-stock-manufacturer--7bcd80f\",\"name\":\"itâs difficult to track what component stock we have at each manufacturer \",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-it-s-difficult-track-component-stock-manufacturer--7bcd80f\"},{\"id\":\"pattern-difficult-trace-components-products-purchase-disposal-62a836e\",\"name\":\"It is difficult to trace components and products from purchase through to disposal\",\"group\":\"pattern\",\"weight\":1,\"status\":\"improvement-in-progress\",\"Link\":\"https://jel.ly.fish/pattern-difficult-trace-components-products-purchase-disposal-62a836e\"},{\"id\":\"user-stefsak\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-stefsak\"},{\"id\":\"improvement-openbalena-balena-balenafy-openbalena-3ca0178\",\"name\":\"openBalena on balena / balenafy openBalena\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-openbalena-balena-balenafy-openbalena-3ca0178\"},{\"id\":\"pattern-update-openbalena-certificates-vpn-certificates-669f4c9\",\"name\":\"Difficult and risky to update openBalena certificates and VPN certificates\",\"group\":\"pattern\",\"weight\":4,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-update-openbalena-certificates-vpn-certificates-669f4c9\"},{\"id\":\"improvement-automationkit-6d5af37\",\"name\":\"automationKit\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-automationkit-6d5af37\"},{\"id\":\"user-phckopper\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-phckopper\"},{\"id\":\"user-bucknalla\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-bucknalla\"},{\"id\":\"improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\",\"name\":\"Phase 1: Self-Serve PPAYG Device License Pricing\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-volume-pricing-computation-factors-modeling-self-service-pricing-display-ba42226\"},{\"id\":\"pattern-self-serve-pricing-page-8a213ba\",\"name\":\"Pricing isn't self-serve and volume pricing is confusing for customers\",\"group\":\"pattern\",\"weight\":14,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-self-serve-pricing-page-8a213ba\"},{\"id\":\"pattern-customer-asks-volume-discount-better-pricing-4b140a4\",\"name\":\"Customer asks for volume discount / better pricing\",\"group\":\"pattern\",\"weight\":5,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-customer-asks-volume-discount-better-pricing-4b140a4\"},{\"id\":\"user-rhampt\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-rhampt\"},{\"id\":\"user-ryan-hampton\",\"name\":\"ryan_hampton\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-ryan-hampton\"},{\"id\":\"improvement-increase-coverage-supported-attributes-features-docker-compose-yml-c328938\",\"name\":\"Increase coverage of supported attributes and features of docker-compose.yml\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-increase-coverage-supported-attributes-features-docker-compose-yml-c328938\"},{\"id\":\"user-dfunckt\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-dfunckt\"},{\"id\":\"improvement-autogenerated-openapi-autoui-compatible-specification-files-4aec541\",\"name\":\"Autogenerated openAPI / autoUI compatible specification files\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-autogenerated-openapi-autoui-compatible-specification-files-4aec541\"},{\"id\":\"improvement-tenure-anniversary-rewards-5b22ae7\",\"name\":\"Anniversary Gifts\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-tenure-anniversary-rewards-5b22ae7\"},{\"id\":\"pattern-high-staff-turnover-show-newer-members-staff-appreciation-feel-supported--06def36\",\"name\":\"High staff turnover - how do we show newer members of staff appreciation and make them feel supported?\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-high-staff-turnover-show-newer-members-staff-appreciation-feel-supported--06def36\"},{\"id\":\"pattern-2022-2-team-members-reaching-10-year-anniversaries-working-balena-want-recognise-fc5bde4\",\"name\":\"2022 - 2 team members are reaching 10 year anniversaries of working at balena and we want to recognise that\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-2022-2-team-members-reaching-10-year-anniversaries-working-balena-want-recognise-fc5bde4\"},{\"id\":\"pattern-few-ways-show-recognition-employees-besides-cheers-peers-ad-hoc--0f23967\",\"name\":\"There are few ways to show recognition to employees besides cheers for peers or ad hoc \",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-few-ways-show-recognition-employees-besides-cheers-peers-ad-hoc--0f23967\"},{\"id\":\"product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\",\"name\":\"Email verification\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-email-verification-bb0e4fc4-c871-4246-8074-2ffcca2166bc\"},{\"id\":\"pattern-no-email-verification-for-user-signups-b5f8a358-8d90-49f4-9c2a-60707a2432bb\",\"name\":\"No email verification for user signups\",\"group\":\"pattern\",\"weight\":7,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-no-email-verification-for-user-signups-b5f8a358-8d90-49f4-9c2a-60707a2432bb\"},{\"id\":\"user-nitish\",\"name\":\"nitish\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-nitish\"},{\"id\":\"improvement-productising-call-papers-loop-events-conferences--695c31e\",\"name\":\"Productising effective event tracking loop (conferences, call for Papers)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-productising-call-papers-loop-events-conferences--695c31e\"},{\"id\":\"pattern-team-members-interested-speaking-work-balena-conferences--3a7fdfd\",\"name\":\"team members are interested in speaking about their work at balena in conferences \",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-team-members-interested-speaking-work-balena-conferences--3a7fdfd\"},{\"id\":\"pattern-team-members-need-motivation-help-submitting-cfps-conferences-6068ce7\",\"name\":\"team members need motivation and help submitting CFPs in conferences\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-team-members-need-motivation-help-submitting-cfps-conferences-6068ce7\"},{\"id\":\"improvement-etcherpro-msd-sd-speed-testing--5e96eda\",\"name\":\"EtcherPro, mSD and SD  speed testing.\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-etcherpro-msd-sd-speed-testing--5e96eda\"},{\"id\":\"user-zisis00\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-zisis00\"},{\"id\":\"improvement-audit-logs-df0dad2\",\"name\":\"Audit Logs\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-audit-logs-df0dad2\"},{\"id\":\"improvement-replace-social-media-bio-link-link-aggregator--32a6b97\",\"name\":\"Replace social media bio link with a link aggregator \",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-replace-social-media-bio-link-link-aggregator--32a6b97\"},{\"id\":\"pattern-no-analytics-social-media-bio-link-cd46afb\",\"name\":\"there is no analytics on social media bio link\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-no-analytics-social-media-bio-link-cd46afb\"},{\"id\":\"pattern-people-not-using-forums-technical-queries-bde549b\",\"name\":\"people are not using forums for technical queries\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-people-not-using-forums-technical-queries-bde549b\"},{\"id\":\"improvement-builder-cli-automatically-authenticate-balenahub-container-registry-e3a1e5d\",\"name\":\"Using private blocks from balenaHub container registry\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-builder-cli-automatically-authenticate-balenahub-container-registry-e3a1e5d\"},{\"id\":\"pattern-local-balena-build-push-requires-registry-secrets-use-private-blocks-5be0138\",\"name\":\"local balena build/push requires registry secrets to use private blocks\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-local-balena-build-push-requires-registry-secrets-use-private-blocks-5be0138\"},{\"id\":\"improvement-create-specific-support-terms-balenamachine-e61c59d\",\"name\":\"Create specific support terms for balenaMachine\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-create-specific-support-terms-balenamachine-e61c59d\"},{\"id\":\"improvement-rename-transformer-worker-relationships-b7cea3d\",\"name\":\"Rename transformer-worker relationships\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-rename-transformer-worker-relationships-b7cea3d\"},{\"id\":\"improvement-add-support-consolidation-data-multiple-balenair-devices-84a4d12\",\"name\":\"Add support for the consolidation of data from multiple balenair devices\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-support-consolidation-data-multiple-balenair-devices-84a4d12\"},{\"id\":\"improvement-create-blog-announcing-balenair-thing--35b653a\",\"name\":\"Create a blog announcing balenair as a \\\"thing\\\"\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-create-blog-announcing-balenair-thing--35b653a\"},{\"id\":\"improvement-creating-product-inform-balenahub-road-map-2accd0f\",\"name\":\"Creating a product to inform balenaHub road map\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-creating-product-inform-balenahub-road-map-2accd0f\"},{\"id\":\"user-alanb128\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-alanb128\"},{\"id\":\"improvement-support-fixed-licenses--176ba3f\",\"name\":\"Support for Fixed Licensesâ³\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-support-fixed-licenses--176ba3f\"},{\"id\":\"improvement-revamp-all-hands-user-charts-5f30dee\",\"name\":\"Revamp all-hands user charts\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-revamp-all-hands-user-charts-5f30dee\"},{\"id\":\"user-pranasziaukas\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-pranasziaukas\"},{\"id\":\"improvement-user-surveys-16f1391\",\"name\":\"Improve User Survey Curation Process\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-user-surveys-16f1391\"},{\"id\":\"pattern-need-capture-share-positive-feedback--c639ac5\",\"name\":\"Need a way to capture and share positive feedback \",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-need-capture-share-positive-feedback--c639ac5\"},{\"id\":\"improvement-blog-header-design-bd4220b\",\"name\":\"Blog header Design\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-blog-header-design-bd4220b\"},{\"id\":\"improvement-linking-twilio-project-front-inbox-6655a40\",\"name\":\"Linking Twilio project with Front inbox\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-linking-twilio-project-front-inbox-6655a40\"},{\"id\":\"pattern-sms-email-automation-0a6e7eb\",\"name\":\"SMS to email automation\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-sms-email-automation-0a6e7eb\"},{\"id\":\"improvement-projects-involving-others-communities-orgs-start-relationship-attract-new-contributors-4b4a4d3\",\"name\":\"Make projects involving others communities and orgs to start a relationships and attract new community members to balena\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-projects-involving-others-communities-orgs-start-relationship-attract-new-contributors-4b4a4d3\"},{\"id\":\"pattern-user-want-log-sensor-values-notion-page-f32982d\",\"name\":\"user want to log sensor values to notion page\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-want-log-sensor-values-notion-page-f32982d\"},{\"id\":\"pattern-user-wants-send-data-adafruitio-balena--3addc59\",\"name\":\"user wants to send data to adafruitIO from balena \",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-send-data-adafruitio-balena--3addc59\"},{\"id\":\"pattern-interests-observed-mining-cryptocurrencies-using-sbcs-299b13c\",\"name\":\"interests observed in mining cryptocurrencies using SBCs\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-interests-observed-mining-cryptocurrencies-using-sbcs-299b13c\"},{\"id\":\"improvement-ux-design-tasks-jon-rich-1cdeaca\",\"name\":\"UX Design tasks for Jon Rich\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-ux-design-tasks-jon-rich-1cdeaca\"},{\"id\":\"product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\",\"name\":\"Extend  supported use cases for public device URLs (aka weburls, PDUv2)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-improve-supported-use-cases-for-public-device-urls-3df410d3-e014-4445-ba9e-808de47ea8bb\"},{\"id\":\"pattern-wifi-connect-block-requires-port-80-and-prevents-using-public-url-for-other-services-fbc19f7d-2d98-419a-9f65-4918dadd42de\",\"name\":\"wifi-connect block requires port 80 and prevents using Public URL for other services\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-wifi-connect-block-requires-port-80-and-prevents-using-public-url-for-other-services-fbc19f7d-2d98-419a-9f65-4918dadd42de\"},{\"id\":\"pattern-reverse-proxy-requests-91cfa5f3-2fb7-4524-bd70-510634837d11\",\"name\":\"Customers asking about public device port(s)\",\"group\":\"pattern\",\"weight\":10,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-reverse-proxy-requests-91cfa5f3-2fb7-4524-bd70-510634837d11\"},{\"id\":\"improvement-balenaide-c02ce28\",\"name\":\"onDevice IDE: PoC\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenaide-c02ce28\"},{\"id\":\"pattern-ondevice-ide-0e29276d-09cc-4769-b14e-e2d57eadc3c1\",\"name\":\"onDevice IDE\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-ondevice-ide-0e29276d-09cc-4769-b14e-e2d57eadc3c1\"},{\"id\":\"pattern-user-doesn-t-know-how-and-where-to-edit-the-dockerfile-of-their-app-5f84eaa8-5cbb-466e-ac3a-377f85094f70\",\"name\":\"User doesn't know how and where to edit the dockerfile of their app\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-doesn-t-know-how-and-where-to-edit-the-dockerfile-of-their-app-5f84eaa8-5cbb-466e-ac3a-377f85094f70\"},{\"id\":\"pattern-user-benefit-on-device-ide-79ac4c0\",\"name\":\"User would benefit from an on-device IDE\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-benefit-on-device-ide-79ac4c0\"},{\"id\":\"pattern-openfleet-user-does-not-access-logs-fleet-owner-needs-instruct-end-users-create-fleet-help-debugging-16bc855\",\"name\":\"openFleet user does not have access to logs and fleet owner needs to instruct end users to create a fleet to help in debugging\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-openfleet-user-does-not-access-logs-fleet-owner-needs-instruct-end-users-create-fleet-help-debugging-16bc855\"},{\"id\":\"improvement-add-blues-wireless-lte-m-nb-iot-project-0c5a7d5\",\"name\":\"Add Blues Wireless LTE-M, NB-IoT project\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-blues-wireless-lte-m-nb-iot-project-0c5a7d5\"},{\"id\":\"improvement-balena-swag-automation-eef25aa\",\"name\":\"Balena swag automation\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balena-swag-automation-eef25aa\"},{\"id\":\"user-konmouz\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-konmouz\"},{\"id\":\"improvement-publish-github-actions-explainer-post-8c2cc71\",\"name\":\"Publish GitHub Actions explainer post\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-publish-github-actions-explainer-post-8c2cc71\"},{\"id\":\"improvement-improve-delta-generation-speed-sizes-cf5e98f\",\"name\":\"Improve delta generation speed and sizes\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improve-delta-generation-speed-sizes-cf5e98f\"},{\"id\":\"improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\",\"name\":\"Expose both flasher and raw images in the dashboard for generic DTs\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-expose-flasher-raw-images-dashboard-generic-dts-90f2f44\"},{\"id\":\"pattern-balena-image-flasher-unwrap-fails-chown-cannot-access-no-file-directory--0c7170e\",\"name\":\"balena-image-flasher-unwrap fails with \\\"chown: cannot access '': No such file or directory\\\"\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-balena-image-flasher-unwrap-fails-chown-cannot-access-no-file-directory--0c7170e\"},{\"id\":\"pattern-user-wants-run-generic-x86-64-image-using-virtualbox-13cb5ca\",\"name\":\"User wants to run a generic x86_64 image using VirtualBox\",\"group\":\"pattern\",\"weight\":4,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-run-generic-x86-64-image-using-virtualbox-13cb5ca\"},{\"id\":\"pattern-request-non-flasher-raw-image-rock-pi-4b-e7fda51\",\"name\":\"Request for non-flasher (raw) image for ROCK Pi 4B\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-request-non-flasher-raw-image-rock-pi-4b-e7fda51\"},{\"id\":\"pattern-user-want-use-dd-flash-preloaded-images-ssd-hard-drives-massively-manufacturing-process-16f9726\",\"name\":\"User want to use dd to flash preloaded images in SSD hard drives massively in their manufacturing process\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-want-use-dd-flash-preloaded-images-ssd-hard-drives-massively-manufacturing-process-16f9726\"},{\"id\":\"improvement-jip-remove-field-level-permissions-8d561c94-2d33-4026-829c-272600018558\",\"name\":\"JIP: Remove field level permissions\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-remove-field-level-permissions-8d561c94-2d33-4026-829c-272600018558\"},{\"id\":\"improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\",\"name\":\"Create the Team Directory\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-create-a-contract-for-each-balenista-milestone-a70cc130-96a1-4625-bad3-91ab53f6a875\"},{\"id\":\"pattern-users-write-wants-needs-interests-varying-formats-537d1ea\",\"name\":\"Users write their wants, needs, and interests in varying formats\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-write-wants-needs-interests-varying-formats-537d1ea\"},{\"id\":\"pattern-update-the-katapult-github-code-to-use-the-latest-contract-format-eb93edf1-1e12-4d9b-845c-02468a3dd6ec\",\"name\":\"Update the katapult-github code to use the latest contract format\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-update-the-katapult-github-code-to-use-the-latest-contract-format-eb93edf1-1e12-4d9b-845c-02468a3dd6ec\"},{\"id\":\"pattern-user-somewhere-keep-track-open-tasks-relation-hard-problem-team-directory--14a5775\",\"name\":\"User would like somewhere  keep track of open tasks in relation to their hard problem (team directory)\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-somewhere-keep-track-open-tasks-relation-hard-problem-team-directory--14a5775\"},{\"id\":\"pattern-users-need-markdown-primer-91f192b\",\"name\":\"Some users need a markdown primer\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-need-markdown-primer-91f192b\"},{\"id\":\"pattern--user-woukld-wiki-capability-team-directory-github-balenaltd-org-enabled-499f4ee\",\"name\":\" user would like the wiki capability in the team directory Github balenaltd org enabled\",\"group\":\"pattern\",\"weight\":4,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern--user-woukld-wiki-capability-team-directory-github-balenaltd-org-enabled-499f4ee\"},{\"id\":\"pattern-need-somewhere-document-hack-friday-projects-38b9bdc\",\"name\":\"we need somewhere to document hack friday projects\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-need-somewhere-document-hack-friday-projects-38b9bdc\"},{\"id\":\"pattern-users-want-repo-continue-improving-upon-next-job-5906319\",\"name\":\"Users want a repo that they can take with them to continue improving upon on their next job\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-want-repo-continue-improving-upon-next-job-5906319\"},{\"id\":\"pattern-users-unclear-blog-folder-syntax-markdown-bc71e2c\",\"name\":\"Some users unclear about blog folder/syntax for markdown\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-unclear-blog-folder-syntax-markdown-bc71e2c\"},{\"id\":\"user-g-carlo-miguel-cruz1\",\"name\":\"g_carlo_miguel_cruz1\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-g-carlo-miguel-cruz1\"},{\"id\":\"user-lucian-buzzo\",\"name\":\"lucian_buzzo\",\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-lucian-buzzo\"},{\"id\":\"improvement-publish-q2-hackweek-2022-reflection-posts-9549515\",\"name\":\"Publish Q2 Hackweek 2022 Reflection Posts\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-publish-q2-hackweek-2022-reflection-posts-9549515\"},{\"id\":\"improvement-add-user-engagement-balenahub-2901d00\",\"name\":\"Add more user engagement to balenaHub\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-user-engagement-balenahub-2901d00\"},{\"id\":\"pattern-fleet-app-block-owners-cannot-engage-users-0ed58ef\",\"name\":\"Fleet, App and Block owners cannot engage with their users\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-fleet-app-block-owners-cannot-engage-users-0ed58ef\"},{\"id\":\"improvement-support-v2-8701e9a\",\"name\":\"Support v2\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-support-v2-8701e9a\"},{\"id\":\"improvement-server-side-filtering-pagination-sorting-autoui-d8cc8c0\",\"name\":\"Server side filtering, pagination & sorting in autoUI\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-server-side-filtering-pagination-sorting-autoui-d8cc8c0\"},{\"id\":\"improvement-website-automated-content-informing-landr-for-loops-orgs-e334c6b8-7e8a-4fb4-9317-0375361eef08\",\"name\":\"Use Landr to build marketing site (balena-site)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-website-automated-content-informing-landr-for-loops-orgs-e334c6b8-7e8a-4fb4-9317-0375361eef08\"},{\"id\":\"improvement-jip-authentication-tokens-9aea2bb0-2c76-4679-9062-6da2f54415c8\",\"name\":\"JIP: Authentication tokens\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-authentication-tokens-9aea2bb0-2c76-4679-9062-6da2f54415c8\"},{\"id\":\"improvement-balena-brand-system-refinement-ae5c5c2\",\"name\":\"balena Brand system refinement\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balena-brand-system-refinement-ae5c5c2\"},{\"id\":\"improvement-outreach-design-support-3b490dd\",\"name\":\"Outreach design support\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-outreach-design-support-3b490dd\"},{\"id\":\"improvement-improve-branding-product-builders-0a53e27\",\"name\":\"Improve branding for Product Builders\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-improve-branding-product-builders-0a53e27\"},{\"id\":\"improvement-balenacloud-table-header-ui-actions-integration-2577746\",\"name\":\"balenaCloud table header UI and actions integration\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-balenacloud-table-header-ui-actions-integration-2577746\"},{\"id\":\"pattern-user-customize-columns-order-summary-fleet-page-0d51b46\",\"name\":\"User would like to customize columns order on the summary fleet page\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-customize-columns-order-summary-fleet-page-0d51b46\"},{\"id\":\"improvement-native-pinejs-translations-b5431ce\",\"name\":\"Native pinejs translations\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-native-pinejs-translations-b5431ce\"},{\"id\":\"improvement-productize-pinejs-064c842\",\"name\":\"productize pinejs\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-productize-pinejs-064c842\"},{\"id\":\"improvement-stop-shipping-coin-shell-batteries-0d87c18\",\"name\":\"Stop shipping coin shell batteries\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-stop-shipping-coin-shell-batteries-0d87c18\"},{\"id\":\"pattern-shipping-coin-cell-batteries-lot-friction-743fdcc\",\"name\":\"shipping coin shell batteries has a lot of friction\",\"group\":\"pattern\",\"weight\":1,\"status\":\"improvement-in-progress\",\"Link\":\"https://jel.ly.fish/pattern-shipping-coin-cell-batteries-lot-friction-743fdcc\"},{\"id\":\"improvement-jip-link-constraints-using-relationship-contract-f3666fd0-e5d6-4ca4-9fa8-73959e72e7c3\",\"name\":\"JIP: Link constraints using relationship contract\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-link-constraints-using-relationship-contract-f3666fd0-e5d6-4ca4-9fa8-73959e72e7c3\"},{\"id\":\"improvement-sunset-chartio-adopt-superset-179c6da\",\"name\":\"Sunset Chartio / Adopt Superset\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-sunset-chartio-adopt-superset-179c6da\"},{\"id\":\"improvement-add-support-specifying-docker-compose-yml-file-balena-cli-95d0313\",\"name\":\"Add support for specifying docker-compose.yml file to balena-CLI\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-support-specifying-docker-compose-yml-file-balena-cli-95d0313\"},{\"id\":\"improvement-teamwork-score-ec32177c-75ce-4681-a8d6-4332b34715bd\",\"name\":\"Teamwork Balance\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-teamwork-score-ec32177c-75ce-4681-a8d6-4332b34715bd\"},{\"id\":\"improvement-create-blocks-repo-landr-a8dcf22\",\"name\":\"Create Blocks repo and landr\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-create-blocks-repo-landr-a8dcf22\"},{\"id\":\"product-improvement-provide-daily-analytics-metrics-within-balenacloud-api-b043df50-b5be-46d2-98ff-e93ac563b1b0\",\"name\":\"Provide daily analytics metrics within balenaCloud API\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-provide-daily-analytics-metrics-within-balenacloud-api-b043df50-b5be-46d2-98ff-e93ac563b1b0\"},{\"id\":\"improvement-bottom-up-model-framework-eba2c04e-d769-4c68-b5e1-80b2b4536585\",\"name\":\"Bottom-up Model\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-bottom-up-model-framework-eba2c04e-d769-4c68-b5e1-80b2b4536585\"},{\"id\":\"pattern-financial-projections-lack-desirable-level-robustness-e6849a3\",\"name\":\"Our financial projections lack the desirable level of robustness\",\"group\":\"pattern\",\"weight\":3,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-financial-projections-lack-desirable-level-robustness-e6849a3\"},{\"id\":\"improvement-sanitize-component-logs-remove-pii-sensitive-information-834a3be\",\"name\":\"Sanitize the component logs to remove any PII and sensitive information\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-sanitize-component-logs-remove-pii-sensitive-information-834a3be\"},{\"id\":\"user-cmfcruz\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-cmfcruz\"},{\"id\":\"improvement-full-support-for-tri-app-ee583baa-6097-49e2-aed3-c7a3039dbcd1\",\"name\":\"Full support for tri-app\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-full-support-for-tri-app-ee583baa-6097-49e2-aed3-c7a3039dbcd1\"},{\"id\":\"improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\",\"name\":\"Allow customers to change billing address and add a CC billing email address for invoices\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-allow-customers-change-billing-address-add-cc-billing-email-address-invoices-eec36a3\"},{\"id\":\"support-issue-customer-needs-invoices-emailed-to-new-additional-address-3d11fe69-1fa6-4869-99ec-4abb54ff564f\",\"name\":\"Customer needs invoices emailed to new/additional address\",\"group\":\"pattern\",\"weight\":14,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/support-issue-customer-needs-invoices-emailed-to-new-additional-address-3d11fe69-1fa6-4869-99ec-4abb54ff564f\"},{\"id\":\"support-issue-configure-additional-invoicing-email-address-for-invoicing-87793511-1a55-4e7b-a6e4-7b81d179c1ba\",\"name\":\"Configure additional email address for balenaCloud invoicing.\",\"group\":\"pattern\",\"weight\":12,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/support-issue-configure-additional-invoicing-email-address-for-invoicing-87793511-1a55-4e7b-a6e4-7b81d179c1ba\"},{\"id\":\"pattern-user-wants-to-be-able-to-set-separate-email-to-receive-billing-invoices-493da437-dc28-4e08-840f-b9cb49694366\",\"name\":\"User wants to be able to set separate email to receive billing invoices\",\"group\":\"pattern\",\"weight\":19,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-wants-to-be-able-to-set-separate-email-to-receive-billing-invoices-493da437-dc28-4e08-840f-b9cb49694366\"},{\"id\":\"pattern-users-colleague-cc-ed-when-invoices-payment-notifications-sent-0d19f43\",\"name\":\"Users would like to a colleague to be cc'ed when invoices  / payment notifications are sent out\",\"group\":\"pattern\",\"weight\":6,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-users-colleague-cc-ed-when-invoices-payment-notifications-sent-0d19f43\"},{\"id\":\"improvement-backfill-os-release-dates-e657f44\",\"name\":\"Backfill OS release dates\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-backfill-os-release-dates-e657f44\"},{\"id\":\"improvement-support-trials-cf71c3f\",\"name\":\"Support trialsâ³\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-support-trials-cf71c3f\"},{\"id\":\"improvement-enable-dynamic-usage-custom-plans--6495ae7\",\"name\":\"Enable dynamic usage on custom plans â³\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-enable-dynamic-usage-custom-plans--6495ae7\"},{\"id\":\"improvement-productized-support-limited-access-b2021611-87b0-4052-b5d5-830f5745e0a8\",\"name\":\"Productized support/limited/delegated access\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-productized-support-limited-access-b2021611-87b0-4052-b5d5-830f5745e0a8\"},{\"id\":\"improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\",\"name\":\"Release invalidation, notes & notification feeds\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-release-invalidation-feeds-f227c7d1-44d6-41f1-8e11-1adb20be7858\"},{\"id\":\"pattern-handle-pulling-os-versions-from-productions-and-notify-users-7256568e-2bc5-4329-8ac9-213c40a7f85c\",\"name\":\"User does not know that balena team pulled OS version from the production environment\",\"group\":\"pattern\",\"weight\":7,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-handle-pulling-os-versions-from-productions-and-notify-users-7256568e-2bc5-4329-8ac9-213c40a7f85c\"},{\"id\":\"pattern-user-would-like-to-be-warned-when-balenaos-images-are-pulled-from-production-d7e469ce-5b8c-45a4-9837-5edd6dffadf6\",\"name\":\"User would like to be warned when balenaOS images are pulled from production\",\"group\":\"pattern\",\"weight\":9,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-user-would-like-to-be-warned-when-balenaos-images-are-pulled-from-production-d7e469ce-5b8c-45a4-9837-5edd6dffadf6\"},{\"id\":\"improvement-start-using-the-balena-org-in-balenacloud-to-manage-roles-and-access-for-balena-team-members-0c281073-5085-4dea-9259-d896f2befb97\",\"name\":\"Start using the balena org in balenaCloud to manage roles and access for balena team members\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-start-using-the-balena-org-in-balenacloud-to-manage-roles-and-access-for-balena-team-members-0c281073-5085-4dea-9259-d896f2befb97\"},{\"id\":\"improvement-automated-base-images-deployment-process-2bb3eff\",\"name\":\"Automated  base images deployment process\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-automated-base-images-deployment-process-2bb3eff\"},{\"id\":\"user-nghiant2710\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-nghiant2710\"},{\"id\":\"improvement-transformers-stage-3-554b91a\",\"name\":\"Transformers Stage 3\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-transformers-stage-3-554b91a\"},{\"id\":\"user-codewithcheese\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-codewithcheese\"},{\"id\":\"improvement-l1-transformer-e7b0d58\",\"name\":\"L1 transformer\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-l1-transformer-e7b0d58\"},{\"id\":\"improvement-etcher-pro-hardware-diagnostics-9440ac1\",\"name\":\"etcher pro / hardware diagnostics\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-etcher-pro-hardware-diagnostics-9440ac1\"},{\"id\":\"improvement-create-personal-repos-f1288c8\",\"name\":\"Create Personal Repos\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-create-personal-repos-f1288c8\"},{\"id\":\"improvement-transparency-behaviour-container-restart-policies--428ae49\",\"name\":\"Transparency and behaviour of container restart policies \",\"group\":\"improvement\",\"weight\":0,\"status\":\"awaiting-approval\",\"Link\":\"https://jel.ly.fish/improvement-transparency-behaviour-container-restart-policies--428ae49\"},{\"id\":\"product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\",\"name\":\"Transformers System\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-transformers-system-7987ae6a-c480-459d-a64e-f5788576b33d\"},{\"id\":\"pattern-adding-balena-yml-repository-in-pr-removes-previously-required-check-runs-c400938\",\"name\":\"Adding balena.yml to a repository (in a PR) removes previously required check-runs\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-adding-balena-yml-repository-in-pr-removes-previously-required-check-runs-c400938\"},{\"id\":\"pattern-github-reflector-create-git-tags-2ef7dba\",\"name\":\"Github reflector should create git tags\",\"group\":\"pattern\",\"weight\":0,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-github-reflector-create-git-tags-2ef7dba\"},{\"id\":\"pattern-release-transformer-2dc6c8c\",\"name\":\"Release transformer\",\"group\":\"pattern\",\"weight\":1,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-release-transformer-2dc6c8c\"},{\"id\":\"user-stathismor\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-stathismor\"},{\"id\":\"improvement-try-simple-transformer-hardware-ci-125161d\",\"name\":\"Try a simple transformer for hardware CI\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-try-simple-transformer-hardware-ci-125161d\"},{\"id\":\"pattern-transformers-usable-hw-process--b4454a2\",\"name\":\"Are transformers usable for hw process?\",\"group\":\"pattern\",\"weight\":1,\"status\":\"improvement-in-progress\",\"Link\":\"https://jel.ly.fish/pattern-transformers-usable-hw-process--b4454a2\"},{\"id\":\"improvement-add-altium-outjob-automation-ci-58d95b5\",\"name\":\"Add altium outjob automation to CI\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-add-altium-outjob-automation-ci-58d95b5\"},{\"id\":\"pattern-create-release-archives-hardware-projects-pull-requests-f543e7a\",\"name\":\"Hard to share release archives of hardware projects\",\"group\":\"pattern\",\"weight\":2,\"status\":\"improvement-in-progress\",\"Link\":\"https://jel.ly.fish/pattern-create-release-archives-hardware-projects-pull-requests-f543e7a\"},{\"id\":\"user-anujdeshpande\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-anujdeshpande\"},{\"id\":\"improvement-events-product-e843fb9\",\"name\":\"Events as a product\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-events-product-e843fb9\"},{\"id\":\"improvement-start-guide-doc-mention-relevant-people-notes-changes-etc--a4c0acb\",\"name\":\"Start the guide on a doc and mention the relevant people for notes/changes etc.\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-start-guide-doc-mention-relevant-people-notes-changes-etc--a4c0acb\"},{\"id\":\"pattern-create-guide-new-service-addition-services-model-f177046\",\"name\":\"New Service creation guide\",\"group\":\"pattern\",\"weight\":2,\"status\":\"open\",\"Link\":\"https://jel.ly.fish/pattern-create-guide-new-service-addition-services-model-f177046\"},{\"id\":\"improvement-automate-supervisor-documentation-dcb0ca0\",\"name\":\"Automate the Supervisor Documentation\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-automate-supervisor-documentation-dcb0ca0\"},{\"id\":\"improvement-model-framework-3cdc3c8c-e93b-4101-af61-1e34b399ef6b\",\"name\":\"Model Framework\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-model-framework-3cdc3c8c-e93b-4101-af61-1e34b399ef6b\"},{\"id\":\"improvement-fin-2-0-fin-relaunch-73f56224-7e0d-4891-aff8-1446851402f6\",\"name\":\"Fin 2.0 (Fin relaunch)\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-fin-2-0-fin-relaunch-73f56224-7e0d-4891-aff8-1446851402f6\"},{\"id\":\"user-ntzovanis\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-ntzovanis\"},{\"id\":\"user-curcuz\",\"name\":null,\"group\":\"user\",\"weight\":0,\"Link\":\"https://jel.ly.fish/user-curcuz\"},{\"id\":\"improvement-notifications-in-jellyfish-edd62665-3d71-4a8e-bdc6-1931144ed467\",\"name\":\"Notifications in Jellyfish\",\"group\":\"improvement\",\"weight\":0,\"status\":\"ready-to-implement\",\"Link\":\"https://jel.ly.fish/improvement-notifications-in-jellyfish-edd62665-3d71-4a8e-bdc6-1931144ed467\"},{\"id\":\"improvement-jip-typeform-integration-5b07d5d5-bffb-4746-b752-5784aeebfbd3\",\"name\":\"JIP: Typeform integration\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/improvement-jip-typeform-integration-5b07d5d5-bffb-4746-b752-5784aeebfbd3\"},{\"id\":\"product-improvement-customer-source-of-truth-03454cdf-cc8d-47b1-a533-84a140fe507e\",\"name\":\"Customer source of truth\",\"group\":\"improvement\",\"weight\":0,\"status\":\"implementation\",\"Link\":\"https://jel.ly.fish/product-improvement-customer-source-of-truth-03454cdf-cc8d-47b1-a533-84a140fe507e\"}]}");

/***/ }),

/***/ "./src/client/cy-conf/index.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/index.js ***!
  \*************************************/
/*! exports provided: style, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./src/client/cy-conf/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _style__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/* harmony default export */ __webpack_exports__["default"] = ({
  style: _style__WEBPACK_IMPORTED_MODULE_0__["default"]
});

/***/ }),

/***/ "./src/client/cy-conf/style.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/style.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\ncore {\n\tactive-bg-color: rgb(52, 58, 64);\n\tactive-bg-opacity: 0.333;\n}\n\nedge {\n\tcurve-style: straight;\n\topacity: 0.333;\n\twidth: 5px;\n\tz-index: 0;\n\toverlay-opacity: 0;\n  events: no;\n}\n\nnode {\n\twidth: 100;\n\theight: 100;\n\tfont-size: 9;\n\tfont-weight: bold;\n\tmin-zoomed-font-size: 4;\n\tlabel: data(name);\n\ttext-wrap: wrap;\n\ttext-max-width: 70;\n\ttext-valign: center;\n\ttext-halign: center;\n\ttext-events: yes;\n\tcolor: #000;\n\ttext-outline-width: 1;\n\ttext-outline-color: #fff;\n\ttext-outline-opacity: 1;\n\toverlay-color: #fff;\n}\n\nedge[interaction = \"cc\"] {\n\tline-color: #FACD37;\n\topacity: 0.666;\n\tz-index: 9;\n\twidth: 4;\n}\n\nnode[NodeType = \"saga\"] {\n\tbackground-color: #9e79db;\n\ttext-outline-color: white;\n}\n\nnode[NodeType = \"mission\"] {\n\tbackground-color: #b53737;\n\ttext-outline-color: white;\n\theight: 150;\n\twidth: 150;\n}\n\nnode[NodeType = \"assumption\"] {\n\tbackground-color: #86cbff;\n\ttext-outline-color: white;\n}\n\nnode[NodeType = \"goal\"] {\n\tbackground-color: #c2e5a0;\n\ttext-outline-color: white;\n}\n\nnode[NodeType = \"approach\"] {\n\tbackground-color: #fff686;\n\ttext-outline-color: white;\n}\n\nnode[NodeType = \"improvement\"] {\n\tbackground-color: #ff9e6d;\n\ttext-outline-color: white;\n}\n\n\nnode[NodeType = \"pattern\"] {\n\tbackground-color: #E91E63;\n\ttext-outline-color: white;\n}\n\nnode[NodeType = \"user\"] {\n\ttext-outline-color: white;\n}\n\nedge[targetType = \"pattern\"] {\n\tline-color: red;\n\twidth: data(weight);\n}\n\nnode.highlighted {\n\tmin-zoomed-font-size: 0;\n  z-index: 9999;\n}\n\nedge.highlighted {\n\tcurve-style: taxi;\n\topacity: 0.8;\n\twidth: 4;\n\tz-index: 9999;\n}\n\n.prioritised {\n\theight: data(weight);\n\twidth: data(weight);\n}\n\n.faded {\n  events: no;\n}\n\nnode.faded {\n  opacity: 0.08;\n}\n\nedge.faded {\n  opacity: 0.06;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\n.orphans-filtered {\n\tdisplay: none;\n}\n\n.patterns-filtered {\n\tdisplay: none;\n}\n\n");

/***/ }),

/***/ "./src/client/env.js":
/*!***************************!*\
  !*** ./src/client/env.js ***!
  \***************************/
/*! exports provided: NODE_ENV, isProd, isDev */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NODE_ENV", function() { return NODE_ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProd", function() { return isProd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDev", function() { return isDev; });
var NODE_ENV = "development";
var isProd = NODE_ENV === 'production';
var isDev = !isProd;

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/client/env.js");
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _components_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/app */ "./src/client/components/app.js");




if (!_env__WEBPACK_IMPORTED_MODULE_0__["isProd"]) {
  // set up livereload for dev
  var script = document.createElement('script');
  script.src = 'http://' + location.hostname + ':35729/livereload.js?snipver=1';
  document.head.appendChild(script);
}

var root = document.createElement('div');
root.setAttribute('id', 'root');
document.body.appendChild(root);
Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(_components_app__WEBPACK_IMPORTED_MODULE_2__["AppComponent"]), root);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1kYWdyZS9jeXRvc2NhcGUtZGFncmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1ldWxlci9jeXRvc2NhcGUtZXVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5janMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2FkZC1ib3JkZXItc2VnbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9jb29yZGluYXRlLXN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RhdGEvbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvZ3JhcGhsaWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9ncmVlZHktZmFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbG9kYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2FkZC1zdWJncmFwaC1jb25zdHJhaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2JhcnljZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2Nyb3NzLWNvdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9pbml0LW9yZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvcmVzb2x2ZS1jb25mbGljdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9zb3J0LXN1YmdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3BhcmVudC1kdW1teS1jaGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9wb3NpdGlvbi9iay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3Bvc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmVvcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvbG9kYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gubWVtb2l6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNjaWlTaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXh0cmVtdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUd0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlT3JkZXJCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTb3J0QnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuaXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlWmlwT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdTaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlU2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVW5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXBWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9taW5CeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9yYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zb3J0QnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxdWVJZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ppcE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9jeXRvc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jb21wb25lbnRzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbm9kZS1pbmZvLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2N5LWNvbmYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jeS1jb25mL3N0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvZW52LmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvaW5kZXguanMiXSwibmFtZXMiOlsiQXBwQ29tcG9uZW50IiwicHJvcHMiLCJsYXlvdXRzIiwiREFHIiwibmFtZSIsImFuaW1hdGUiLCJwYWRkaW5nIiwicmFua0RpciIsIm5vZGVTZXAiLCJlZGdlU2VwIiwicmFua1NlcCIsImF2b2lkT3ZlcmxhcCIsImZpdCIsIkZERyIsInNwcmluZ0xlbmd0aCIsImNlbnRlckdyYXBoIiwic3ByaW5nQ29lZmYiLCJtYXNzIiwiZ3Jhdml0eSIsInB1bGwiLCJ0aGV0YSIsImRyYWdDb2VmZiIsIm1vdmVtZW50VGhyZXNob2xkIiwidGltZVN0ZXAiLCJyZWZyZXNoIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ1bmRlZmluZWQiLCJhbmltYXRpb25FYXNpbmciLCJtYXhJdGVyYXRpb25zIiwibWF4U2ltdWxhdGlvblRpbWUiLCJ1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmciLCJyYW5kb21pemUiLCJDeXRvc2NhcGUiLCJ1c2UiLCJkYWdyZSIsImV1bGVyIiwiR2V0TmFtZSIsIm5vZGUiLCJqZlR5cGVzIiwiaW5jbHVkZXMiLCJncm91cCIsImlkIiwic3Vic3RyaW5nIiwiY3kiLCJlbGVtZW50cyIsIm5vZGVzIiwiZGF0YSIsIm1hcCIsImRlc2NyaXB0aW9uIiwiTm9kZVR5cGUiLCJzZWxlY3RlZCIsIndlaWdodCIsImxpbmsiLCJMaW5rIiwicHJpb3JpdHkiLCJlZGdlcyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNvdXJjZSIsInRhcmdldCIsInNvdXJjZVR5cGUiLCJ0YXJnZXRUeXBlIiwic3R5bGUiLCJzZWxlY3Rpb25UeXBlIiwiYm94U2VsZWN0aW9uRW5hYmxlZCIsIndoZWVsU2Vuc2l0aXZpdHkiLCJwYW5pZnkiLCJ1bmdyYWJpZnkiLCJmb3JFYWNoIiwiZWxlbWVudCIsImNvbXBvc2l0ZVdlaWdodCIsIm91dGdvZXJzIiwicGF0dGVybiIsImluY29tZXJzIiwiY29udHJvbGxlciIsIkNvbnRyb2xsZXIiLCJidXMiLCJpc0RldiIsIndpbmRvdyIsInN0YXRlIiwicnVuTGF5b3V0Iiwib24iLCJvblNob3dJbmZvIiwic2V0U3RhdGUiLCJpbmZvTm9kZSIsIm9uSGlkZUluZm8iLCJyZW1vdmVMaXN0ZW5lciIsInN0ciIsIm51bSIsImxlbmd0aCIsInNsaWNlIiwiaCIsIkN5dG9zY2FwZUNvbXBvbmVudCIsIk5vZGVJbmZvIiwiTWVudSIsIkZpbHRlciIsIkNvbXBvbmVudCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtb3VudCIsIm9uVGFwIiwiZSIsInVuaGlnaGxpZ2h0IiwiaGlkZUluZm8iLCJjbG9zZU1lbnUiLCJoaWdobGlnaHQiLCJzaG93SW5mbyIsImNoYW5nZUNoYXJ0VHlwZSIsIm9wZW4iLCJ0b2dnbGUiLCJ2YWx1ZSIsImNoYXJ0VHlwZSIsInRvZ2dsZVBhdHRlcm5zIiwidG9nZ2xlSW1wcm92ZW1lbnRzIiwidG9nZ2xlU2FnYXMiLCJ0b2dnbGVBc3N1bXB0aW9ucyIsInRvZ2dsZUFwcHJvYWNoZXMiLCJ0b2dnbGVHb2FscyIsInRvZ2dsZU9ycGhhbnMiLCJ0b2dnbGVQcmlvcml0eSIsInRvZ2dsZVVzZXJzIiwiY2xhc3NOYW1lcyIsIm9uQ2xpY2siLCJ0b2dnbGVDaGFydFR5cGUiLCJ0eXBlIiwiY2hlY2tlZCIsImFzc3VtcHRpb25zIiwiZ29hbHMiLCJhcHByb2FjaGVzIiwic2FnYXMiLCJpbXByb3ZlbWVudHMiLCJwYXR0ZXJucyIsInVzZXJzIiwib3JwaGFucyIsImlzTWVudU9wZW4iLCJvbk9wZW5NZW51IiwiZm9jdXNUZXh0Qm94Iiwib25VcGRhdGVTZWFyY2giLCJzZWFyY2hNYXRjaE5vZGVzIiwiZGVib3VuY2VkVXBkYXRlU2VhcmNoIiwiZGVib3VuY2UiLCJ1cGRhdGVTZWFyY2giLCJvbkNsb3NlTWVudSIsIm9wZW5NZW51IiwiaW5wdXQiLCJyZXN1bHRzIiwicXVlcnlTdHJpbmciLCJzY3JvbGxUbyIsImZvY3VzIiwiY2xvc2VkIiwic2VhcmNoUmVzdWx0cyIsInNlbGVjdE5vZGUiLCJ0b2dnbGVNZW51IiwicGxhY2Vob2xkZXIiLCJvbktleURvd24iLCJxIiwiaHJlZiIsIm1pbk1ldHJpY1ZhbHVlIiwibWluU2ltaWxhcml0eVZhbHVlIiwiQ2hhcnRUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIkV2ZW50RW1pdHRlciIsIm1lbnUiLCJjb2xsZWN0aW9uIiwicmVtb3ZlZE5vZGVzIiwiZW1pdCIsImxhc3RIaWdobGlnaHRlZCIsInJhbmRvbWlzZSIsImRyYXdMYXlvdXQiLCJ0aGVuIiwiYW5pbWF0ZVZpZXciLCJlbGVzIiwiZHVyYXRpb24iLCJyZXN0b3JlIiwicmVtb3ZlTm9kZVR5cGUiLCJyZW1vdmVPcnBoYW5zIiwicHJvbWlzZSIsInByb21pc2VPbiIsImxheW91dCIsInJ1biIsInVuaW9uIiwicmVtb3ZlIiwicmVtb3ZlZCIsImlzTm9kZSIsImRlZ3JlZSIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdGlzZWRUeXBlcyIsInRvZ2dsZVByaW9yaXR5Rm9yVHlwZSIsImFsbEVsbGVzIiwiYmF0Y2giLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwicmVzZXRWaWV3IiwiaGlnaGxpZ2h0SW5Qcm9ncmVzcyIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWxsRWxlcyIsIm5ob29kIiwiY2xvc2VkTmVpZ2hib3Job29kIiwicHJlZGVjZXNzb3JzIiwiaGlnaGxpZ2h0ZWQiLCJvdGhlcnMiLCJsYXN0VW5oaWdobGlnaHRlZCIsIm5vdCIsImxldmVsV2lkdGgiLCJyZXNldENsYXNzZXMiLCJzaG93T3RoZXJzRmFkZWQiLCJoYXNIaWdobGlnaHQiLCJhbGxOb2RlcyIsInN0b3AiLCJoaWRlT3RoZXJzIiwibm9ybWFsaXplIiwidG9Mb3dlckNhc2UiLCJnZXRXb3JkcyIsInNwbGl0IiwicXVlcnlXb3JkcyIsImFkZFdvcmRzIiwid29yZExpc3QiLCJ3b3Jkc1N0ciIsInB1c2giLCJjYWNoZU5vZGVXb3JkcyIsIlN5bm9ueW0iLCJOb2RlVHlwZUZvcm1hdHRlZCIsImdldFN0cmluZ1NpbWlsYXJpdHkiLCJxdWVyeVdvcmQiLCJub2RlV29yZCIsImluZGV4IiwiaW5kZXhPZiIsImRpZmYiLCJhYnMiLCJtYXhMZW5ndGgiLCJtYXgiLCJnZXRNZXRyaWMiLCJub2RlV29yZHMiLCJzY29yZSIsImkiLCJqIiwic2ltaWxhcml0eSIsImdldE5vZGVNZXRyaWMiLCJtZW1vaXplIiwiY2FjaGVkTm9kZVdvcmRzIiwiZmlsdGVyIiwic29ydCIsIm5vZGVBIiwibm9kZUIiLCJOT0RFX0VOViIsInByb2Nlc3MiLCJpc1Byb2QiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwibG9jYXRpb24iLCJob3N0bmFtZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInJvb3QiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwicmVuZGVyIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FB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QUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlC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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7OztBQUdwQyxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw0QkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLFdBQVc7QUFDWCxxQ0FBcUM7QUFDckMsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztB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QUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMkJBQTJCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsV0FBVzs7QUFFWDtBQUNBLDhGQUE4RjtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsSUFBSTs7QUFFTCwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBDQUEwQzs7QUFFMUM7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QUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFD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OztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFD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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsbUNBQW1DOztB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QTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTCxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCLEdBQUc7OztBQUdILG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLGtDQUFrQztBQUNsQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsR0FBRztBQUNwQjtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsR0FBRztBQUNwQjtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsR0FBRztBQUNwQjtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsNkJBQTZCO0FBQ2hELHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQSxpQkFBaUIsNEJBQTRCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxxQkFBcUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsaUdBQWlHO0FBQ2pHLGlEQUFpRDtBQUNqRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdILGNBQWM7QUFDZDs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQ0FBaUM7QUFDakMscUJBQXFCLHNCQUFzQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qiw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLEdBQUc7OztBQUdILGlDQUFpQyw2QkFBNkI7O0FBRTlEOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsT0FBTzs7O0FBR1AscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCOztBQUVBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTLEVBQUU7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsaUJBQWlCLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osbUJBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGlCQUFpQixLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLGtGQUFrRjs7QUFFbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGlCQUFpQixLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSzs7QUFFM0I7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQSxHQUFHOzs7QUFHSCxzQkFBc0I7O0FBRXRCLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdILHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsZUFBZTs7QUFFZixtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsaUJBQWlCLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOzs7QUFHSCx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsZ0NBQWdDOztBQUVoQyw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQsMEdBQTBHOztBQUUxRywwQ0FBMEM7O0FBRTFDO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxnQkFBZ0I7O0FBRWhCLGVBQWU7O0FBRWYscUJBQXFCO0FBQ3JCOztBQUVBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsaUJBQWlCLGdDQUFnQztBQUNqRDs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0EscUdBQXFHOztBQUVyRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRTtBQUNBLG9CQUFvQjs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFdBQVcsd0JBRVY7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCO0FBQzFDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQyxrQ0FBa0M7O0FBRWxDLDhDQUE4Qzs7QUFFOUMsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7O0FBRUEseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUMsZ0ZBQWdGOztBQUVoRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUEsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBLG1CQUFtQixjQUFjO0FBQ2pDLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUMsa0ZBQWtGOztBQUVsRjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix5QkFBeUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gsaUJBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxpQkFBaUIsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLGNBQWMsV0FBVztBQUN6QjtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7O0FBRzVCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEI7O0FBRTFCLEVBQUU7QUFDRjs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsY0FBYztBQUNkLEVBQUU7OztBQUdGO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CLGVBQWU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxpQkFBaUIsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGlCQUFpQixpQkFBaUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQzs7QUFFbEMsc0JBQXNCOztBQUV0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEOzs7QUFHOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUEsd0hBQXdIOzs7QUFHeEg7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxTQUFTOztBQUVULFdBQVc7O0FBRVgsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCwyQkFBMkI7QUFDM0IsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCO0FBQzNCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1Asd0RBQXdEO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsNEJBQTRCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7O0FBRWpJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxFQUFFO0FBQ3hEO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Qsa0JBQWtCLEVBQUU7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEVBQUU7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZKYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsdURBQVU7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxX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Q2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtB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QUFnQyxnQ0FBN0M7QUFFQTVKLFVBQVEsQ0FBQzZKLElBQVQsQ0FBY0MsV0FBZCxDQUEyQk4sTUFBM0I7QUFDRDs7QUFFRCxJQUFNTyxJQUFJLEdBQUcvSixRQUFRLENBQUN5SixhQUFULENBQXVCLEtBQXZCLENBQWI7QUFFQU0sSUFBSSxDQUFDQyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLE1BQXhCO0FBQ0FoSyxRQUFRLENBQUNpSyxJQUFULENBQWNILFdBQWQsQ0FBMEJDLElBQTFCO0FBRUFHLHFEQUFNLENBQUN6SyxnREFBQyxDQUFDNUYsNERBQUQsQ0FBRixFQUFrQmtRLElBQWxCLENBQU4sQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9jbGllbnQvaW5kZXguanNcIik7XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJkYWdyZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJkYWdyZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVEYWdyZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImRhZ3JlXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjeXRvc2NhcGVEYWdyZVwiXSA9IGZhY3Rvcnkocm9vdFtcImRhZ3JlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzRfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbXBsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTsgLy8gcmVnaXN0ZXJzIHRoZSBleHRlbnNpb24gb24gYSBjeXRvc2NhcGUgbGliIHJlZlxuXG5cbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGN5dG9zY2FwZSkge1xuICBpZiAoIWN5dG9zY2FwZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBjYW4ndCByZWdpc3RlciBpZiBjeXRvc2NhcGUgdW5zcGVjaWZpZWRcblxuXG4gIGN5dG9zY2FwZSgnbGF5b3V0JywgJ2RhZ3JlJywgaW1wbCk7IC8vIHJlZ2lzdGVyIHdpdGggY3l0b3NjYXBlLmpzXG59O1xuXG5pZiAodHlwZW9mIGN5dG9zY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZXhwb3NlIHRvIGdsb2JhbCBjeXRvc2NhcGUgKGkuZS4gd2luZG93LmN5dG9zY2FwZSlcbiAgcmVnaXN0ZXIoY3l0b3NjYXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBkYWdyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7IC8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcblxuXG5mdW5jdGlvbiBEYWdyZUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufSAvLyBydW5zIHRoZSBsYXlvdXRcblxuXG5EYWdyZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGxheW91dCA9IHRoaXM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcblxuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24gZ2V0VmFsKGVsZSwgdmFsKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsKSA/IHZhbC5hcHBseShlbGUsIFtlbGVdKSA6IHZhbDtcbiAgfTtcblxuICB2YXIgYmIgPSBvcHRpb25zLmJvdW5kaW5nQm94IHx8IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH07XG5cbiAgaWYgKGJiLngyID09PSB1bmRlZmluZWQpIHtcbiAgICBiYi54MiA9IGJiLngxICsgYmIudztcbiAgfVxuXG4gIGlmIChiYi53ID09PSB1bmRlZmluZWQpIHtcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgfVxuXG4gIGlmIChiYi55MiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYmIueTIgPSBiYi55MSArIGJiLmg7XG4gIH1cblxuICBpZiAoYmIuaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cblxuICB2YXIgZyA9IG5ldyBkYWdyZS5ncmFwaGxpYi5HcmFwaCh7XG4gICAgbXVsdGlncmFwaDogdHJ1ZSxcbiAgICBjb21wb3VuZDogdHJ1ZVxuICB9KTtcbiAgdmFyIGdPYmogPSB7fTtcblxuICB2YXIgc2V0R09iaiA9IGZ1bmN0aW9uIHNldEdPYmoobmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICBnT2JqW25hbWVdID0gdmFsO1xuICAgIH1cbiAgfTtcblxuICBzZXRHT2JqKCdub2Rlc2VwJywgb3B0aW9ucy5ub2RlU2VwKTtcbiAgc2V0R09iaignZWRnZXNlcCcsIG9wdGlvbnMuZWRnZVNlcCk7XG4gIHNldEdPYmooJ3JhbmtzZXAnLCBvcHRpb25zLnJhbmtTZXApO1xuICBzZXRHT2JqKCdyYW5rZGlyJywgb3B0aW9ucy5yYW5rRGlyKTtcbiAgc2V0R09iaignYWxpZ24nLCBvcHRpb25zLmFsaWduKTtcbiAgc2V0R09iaigncmFua2VyJywgb3B0aW9ucy5yYW5rZXIpO1xuICBzZXRHT2JqKCdhY3ljbGljZXInLCBvcHRpb25zLmFjeWNsaWNlcik7XG4gIGcuc2V0R3JhcGgoZ09iaik7XG4gIGcuc2V0RGVmYXVsdEVkZ2VMYWJlbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KTtcbiAgZy5zZXREZWZhdWx0Tm9kZUxhYmVsKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pOyAvLyBhZGQgbm9kZXMgdG8gZGFncmVcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG5vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICBnLnNldE5vZGUobm9kZS5pZCgpLCB7XG4gICAgICB3aWR0aDogbmJiLncsXG4gICAgICBoZWlnaHQ6IG5iYi5oLFxuICAgICAgbmFtZTogbm9kZS5pZCgpXG4gICAgfSk7IC8vIGNvbnNvbGUubG9nKCBnLm5vZGUobm9kZS5pZCgpKSApO1xuICB9IC8vIHNldCBjb21wb3VuZCBwYXJlbnRzXG5cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuXG4gICAgaWYgKF9ub2RlLmlzQ2hpbGQoKSkge1xuICAgICAgZy5zZXRQYXJlbnQoX25vZGUuaWQoKSwgX25vZGUucGFyZW50KCkuaWQoKSk7XG4gICAgfVxuICB9IC8vIGFkZCBlZGdlcyB0byBkYWdyZVxuXG5cbiAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgIHJldHVybiAhZWRnZS5zb3VyY2UoKS5pc1BhcmVudCgpICYmICFlZGdlLnRhcmdldCgpLmlzUGFyZW50KCk7IC8vIGRhZ3JlIGNhbid0IGhhbmRsZSBlZGdlcyBvbiBjb21wb3VuZCBub2Rlc1xuICB9KTtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTJdO1xuICAgIGcuc2V0RWRnZShlZGdlLnNvdXJjZSgpLmlkKCksIGVkZ2UudGFyZ2V0KCkuaWQoKSwge1xuICAgICAgbWlubGVuOiBnZXRWYWwoZWRnZSwgb3B0aW9ucy5taW5MZW4pLFxuICAgICAgd2VpZ2h0OiBnZXRWYWwoZWRnZSwgb3B0aW9ucy5lZGdlV2VpZ2h0KSxcbiAgICAgIG5hbWU6IGVkZ2UuaWQoKVxuICAgIH0sIGVkZ2UuaWQoKSk7IC8vIGNvbnNvbGUubG9nKCBnLmVkZ2UoZWRnZS5zb3VyY2UoKS5pZCgpLCBlZGdlLnRhcmdldCgpLmlkKCksIGVkZ2UuaWQoKSkgKTtcbiAgfVxuXG4gIGRhZ3JlLmxheW91dChnKTtcbiAgdmFyIGdOb2RlSWRzID0gZy5ub2RlcygpO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGdOb2RlSWRzLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgaWQgPSBnTm9kZUlkc1tfaTNdO1xuICAgIHZhciBuID0gZy5ub2RlKGlkKTtcbiAgICBjeS5nZXRFbGVtZW50QnlJZChpZCkuc2NyYXRjaCgpLmRhZ3JlID0gbjtcbiAgfVxuXG4gIHZhciBkYWdyZUJCO1xuXG4gIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgZGFncmVCQiA9IHtcbiAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB5MjogLUluZmluaXR5XG4gICAgfTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgZE1vZGVsID0gbm9kZS5zY3JhdGNoKCkuZGFncmU7XG4gICAgICBkYWdyZUJCLngxID0gTWF0aC5taW4oZGFncmVCQi54MSwgZE1vZGVsLngpO1xuICAgICAgZGFncmVCQi54MiA9IE1hdGgubWF4KGRhZ3JlQkIueDIsIGRNb2RlbC54KTtcbiAgICAgIGRhZ3JlQkIueTEgPSBNYXRoLm1pbihkYWdyZUJCLnkxLCBkTW9kZWwueSk7XG4gICAgICBkYWdyZUJCLnkyID0gTWF0aC5tYXgoZGFncmVCQi55MiwgZE1vZGVsLnkpO1xuICAgIH0pO1xuICAgIGRhZ3JlQkIudyA9IGRhZ3JlQkIueDIgLSBkYWdyZUJCLngxO1xuICAgIGRhZ3JlQkIuaCA9IGRhZ3JlQkIueTIgLSBkYWdyZUJCLnkxO1xuICB9IGVsc2Uge1xuICAgIGRhZ3JlQkIgPSBiYjtcbiAgfVxuXG4gIHZhciBjb25zdHJhaW5Qb3MgPSBmdW5jdGlvbiBjb25zdHJhaW5Qb3MocCkge1xuICAgIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgeFBjdCA9IGRhZ3JlQkIudyA9PT0gMCA/IDAgOiAocC54IC0gZGFncmVCQi54MSkgLyBkYWdyZUJCLnc7XG4gICAgICB2YXIgeVBjdCA9IGRhZ3JlQkIuaCA9PT0gMCA/IDAgOiAocC55IC0gZGFncmVCQi55MSkgLyBkYWdyZUJCLmg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHhQY3QgKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHlQY3QgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgIGVsZSA9IF90eXBlb2YoZWxlKSA9PT0gXCJvYmplY3RcIiA/IGVsZSA6IHRoaXM7XG4gICAgdmFyIGRNb2RlbCA9IGVsZS5zY3JhdGNoKCkuZGFncmU7XG4gICAgcmV0dXJuIGNvbnN0cmFpblBvcyh7XG4gICAgICB4OiBkTW9kZWwueCxcbiAgICAgIHk6IGRNb2RlbC55XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFncmVMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIGRhZ3JlIGFsZ28gb3B0aW9ucywgdXNlcyBkZWZhdWx0IHZhbHVlIG9uIHVuZGVmaW5lZFxuICBub2RlU2VwOiB1bmRlZmluZWQsXG4gIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgaW4gdGhlIHNhbWUgcmFua1xuICBlZGdlU2VwOiB1bmRlZmluZWQsXG4gIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgZWRnZXMgaW4gdGhlIHNhbWUgcmFua1xuICByYW5rU2VwOiB1bmRlZmluZWQsXG4gIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgaW4gdGhlIHNhbWUgcmFua1xuICByYW5rRGlyOiB1bmRlZmluZWQsXG4gIC8vIGFsaWdubWVudCBmb3IgcmFuayBub2Rlcy4gQ2FuIGJlICdVTCcsICdVUicsICdETCcsIG9yICdEUicsIHdoZXJlIFUgPSB1cCwgRCA9IGRvd24sIEwgPSBsZWZ0LCBhbmQgUiA9IHJpZ2h0XG4gIGFsaWduOiB1bmRlZmluZWQsXG4gIC8vICdUQicgZm9yIHRvcCB0byBib3R0b20gZmxvdywgJ0xSJyBmb3IgbGVmdCB0byByaWdodCxcbiAgcmFua2VyOiB1bmRlZmluZWQsXG4gIC8vIFR5cGUgb2YgYWxnb3JpdGhtIHRvIGFzc2lnbnMgYSByYW5rIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGguXG4gIC8vIFBvc3NpYmxlIHZhbHVlczogbmV0d29yay1zaW1wbGV4LCB0aWdodC10cmVlIG9yIGxvbmdlc3QtcGF0aFxuICBtaW5MZW46IGZ1bmN0aW9uIG1pbkxlbihlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIC8vIG51bWJlciBvZiByYW5rcyB0byBrZWVwIGJldHdlZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG9mIHRoZSBlZGdlXG4gIGVkZ2VXZWlnaHQ6IGZ1bmN0aW9uIGVkZ2VXZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICAvLyBoaWdoZXIgd2VpZ2h0IGVkZ2VzIGFyZSBnZW5lcmFsbHkgbWFkZSBzaG9ydGVyIGFuZCBzdHJhaWdodGVyIHRoYW4gbG93ZXIgd2VpZ2h0IGVkZ2VzXG4gIC8vIGdlbmVyYWwgbGF5b3V0IG9wdGlvbnNcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gZml0IHBhZGRpbmdcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyB3aGV0aGVyIGxhYmVscyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gZGV0ZXJtaW5pbmcgdGhlIHNwYWNlIHVzZWQgYnkgYSBub2RlXG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyB3aGV0aGVyIHRvIGFuaW1hdGUgc3BlY2lmaWMgbm9kZXMgd2hlbiBhbmltYXRpb24gaXMgb247IG5vbi1hbmltYXRlZCBub2RlcyBpbW1lZGlhdGVseSBnbyB0byB0aGVpciBmaW5hbCBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zKSB7XG4gICAgcmV0dXJuIHBvcztcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgYSB0cmFuc2Zvcm0gdG8gdGhlIGZpbmFsIG5vZGUgcG9zaXRpb25cbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG5cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gU2ltcGxlLCBpbnRlcm5hbCBPYmplY3QuYXNzaWduKCkgcG9seWZpbGwgZm9yIG9wdGlvbnMgb2JqZWN0cyBldGMuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3Jjc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzcmNzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHRndFtrXSA9IHNyY1trXTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0Z3Q7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180X187XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImN5dG9zY2FwZUV1bGVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUV1bGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gdGd0W2tdID0gc3JjW2tdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGd0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgZGVmYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcbiAgc291cmNlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIGxlbmd0aDogODAsXG4gIGNvZWZmOiAwLjAwMDIsXG4gIHdlaWdodDogMVxufSk7XG5cbmZ1bmN0aW9uIG1ha2VTcHJpbmcoc3ByaW5nKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIGRlZmF1bHRzLCBzcHJpbmcpO1xufVxuXG5mdW5jdGlvbiBhcHBseVNwcmluZyhzcHJpbmcpIHtcbiAgdmFyIGJvZHkxID0gc3ByaW5nLnNvdXJjZSxcbiAgICAgIGJvZHkyID0gc3ByaW5nLnRhcmdldCxcbiAgICAgIGxlbmd0aCA9IHNwcmluZy5sZW5ndGggPCAwID8gZGVmYXVsdHMubGVuZ3RoIDogc3ByaW5nLmxlbmd0aCxcbiAgICAgIGR4ID0gYm9keTIucG9zLnggLSBib2R5MS5wb3MueCxcbiAgICAgIGR5ID0gYm9keTIucG9zLnkgLSBib2R5MS5wb3MueSxcbiAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIGlmIChyID09PSAwKSB7XG4gICAgZHggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA1MDtcbiAgICBkeSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDUwO1xuICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9XG5cbiAgdmFyIGQgPSByIC0gbGVuZ3RoO1xuICB2YXIgY29lZmYgPSAoIXNwcmluZy5jb2VmZiB8fCBzcHJpbmcuY29lZmYgPCAwID8gZGVmYXVsdHMuc3ByaW5nQ29lZmYgOiBzcHJpbmcuY29lZmYpICogZCAvIHIgKiBzcHJpbmcud2VpZ2h0O1xuXG4gIGJvZHkxLmZvcmNlLnggKz0gY29lZmYgKiBkeDtcbiAgYm9keTEuZm9yY2UueSArPSBjb2VmZiAqIGR5O1xuXG4gIGJvZHkyLmZvcmNlLnggLT0gY29lZmYgKiBkeDtcbiAgYm9keTIuZm9yY2UueSAtPSBjb2VmZiAqIGR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbWFrZVNwcmluZzogbWFrZVNwcmluZywgYXBwbHlTcHJpbmc6IGFwcGx5U3ByaW5nIH07XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBFdWxlciBsYXlvdXQgYWxnb3JpdGhtXG4qL1xuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLFxuICAgIF90aWNrID0gX3JlcXVpcmUudGljaztcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyksXG4gICAgbWFrZVF1YWR0cmVlID0gX3JlcXVpcmUyLm1ha2VRdWFkdHJlZTtcblxudmFyIF9yZXF1aXJlMyA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgbWFrZUJvZHkgPSBfcmVxdWlyZTMubWFrZUJvZHk7XG5cbnZhciBfcmVxdWlyZTQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIG1ha2VTcHJpbmcgPSBfcmVxdWlyZTQubWFrZVNwcmluZztcblxudmFyIGlzRm4gPSBmdW5jdGlvbiBpc0ZuKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XG59O1xudmFyIGlzUGFyZW50ID0gZnVuY3Rpb24gaXNQYXJlbnQobikge1xuICByZXR1cm4gbi5pc1BhcmVudCgpO1xufTtcbnZhciBub3RJc1BhcmVudCA9IGZ1bmN0aW9uIG5vdElzUGFyZW50KG4pIHtcbiAgcmV0dXJuICFpc1BhcmVudChuKTtcbn07XG52YXIgaXNMb2NrZWQgPSBmdW5jdGlvbiBpc0xvY2tlZChuKSB7XG4gIHJldHVybiBuLmxvY2tlZCgpO1xufTtcbnZhciBub3RJc0xvY2tlZCA9IGZ1bmN0aW9uIG5vdElzTG9ja2VkKG4pIHtcbiAgcmV0dXJuICFpc0xvY2tlZChuKTtcbn07XG52YXIgaXNQYXJlbnRFZGdlID0gZnVuY3Rpb24gaXNQYXJlbnRFZGdlKGUpIHtcbiAgcmV0dXJuIGlzUGFyZW50KGUuc291cmNlKCkpIHx8IGlzUGFyZW50KGUudGFyZ2V0KCkpO1xufTtcbnZhciBub3RJc1BhcmVudEVkZ2UgPSBmdW5jdGlvbiBub3RJc1BhcmVudEVkZ2UoZSkge1xuICByZXR1cm4gIWlzUGFyZW50RWRnZShlKTtcbn07XG52YXIgZ2V0Qm9keSA9IGZ1bmN0aW9uIGdldEJvZHkobikge1xuICByZXR1cm4gbi5zY3JhdGNoKCdldWxlcicpLmJvZHk7XG59O1xudmFyIGdldE5vblBhcmVudERlc2NlbmRhbnRzID0gZnVuY3Rpb24gZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMobikge1xuICByZXR1cm4gaXNQYXJlbnQobikgPyBuLmRlc2NlbmRhbnRzKCkuZmlsdGVyKG5vdElzUGFyZW50KSA6IG47XG59O1xuXG52YXIgZ2V0U2NyYXRjaCA9IGZ1bmN0aW9uIGdldFNjcmF0Y2goZWwpIHtcbiAgdmFyIHNjcmF0Y2ggPSBlbC5zY3JhdGNoKCdldWxlcicpO1xuXG4gIGlmICghc2NyYXRjaCkge1xuICAgIHNjcmF0Y2ggPSB7fTtcblxuICAgIGVsLnNjcmF0Y2goJ2V1bGVyJywgc2NyYXRjaCk7XG4gIH1cblxuICByZXR1cm4gc2NyYXRjaDtcbn07XG5cbnZhciBvcHRGbiA9IGZ1bmN0aW9uIG9wdEZuKG9wdCwgZWxlKSB7XG4gIGlmIChpc0ZuKG9wdCkpIHtcbiAgICByZXR1cm4gb3B0KGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9wdDtcbiAgfVxufTtcblxudmFyIEV1bGVyID0gZnVuY3Rpb24gKF9MYXlvdXQpIHtcbiAgX2luaGVyaXRzKEV1bGVyLCBfTGF5b3V0KTtcblxuICBmdW5jdGlvbiBFdWxlcihvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV1bGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXVsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFdWxlcikpLmNhbGwodGhpcywgYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucykpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdWxlciwgW3tcbiAgICBrZXk6ICdwcmVydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVydW4oc3RhdGUpIHtcbiAgICAgIHZhciBzID0gc3RhdGU7XG5cbiAgICAgIHMucXVhZHRyZWUgPSBtYWtlUXVhZHRyZWUoKTtcblxuICAgICAgdmFyIGJvZGllcyA9IHMuYm9kaWVzID0gW107XG5cbiAgICAgIC8vIHJlZ3VsYXIgbm9kZXNcbiAgICAgIHMubm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBub3RJc1BhcmVudChuKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHNjcmF0Y2ggPSBnZXRTY3JhdGNoKG4pO1xuXG4gICAgICAgIHZhciBib2R5ID0gbWFrZUJvZHkoe1xuICAgICAgICAgIHBvczogeyB4OiBzY3JhdGNoLngsIHk6IHNjcmF0Y2gueSB9LFxuICAgICAgICAgIG1hc3M6IG9wdEZuKHMubWFzcywgbiksXG4gICAgICAgICAgbG9ja2VkOiBzY3JhdGNoLmxvY2tlZFxuICAgICAgICB9KTtcblxuICAgICAgICBib2R5Ll9jeU5vZGUgPSBuO1xuXG4gICAgICAgIHNjcmF0Y2guYm9keSA9IGJvZHk7XG5cbiAgICAgICAgYm9keS5fc2NyYXRjaCA9IHNjcmF0Y2g7XG5cbiAgICAgICAgYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNwcmluZ3MgPSBzLnNwcmluZ3MgPSBbXTtcblxuICAgICAgLy8gcmVndWxhciBlZGdlIHNwcmluZ3NcbiAgICAgIHMuZWRnZXMuZmlsdGVyKG5vdElzUGFyZW50RWRnZSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc3ByaW5nID0gbWFrZVNwcmluZyh7XG4gICAgICAgICAgc291cmNlOiBnZXRCb2R5KGUuc291cmNlKCkpLFxuICAgICAgICAgIHRhcmdldDogZ2V0Qm9keShlLnRhcmdldCgpKSxcbiAgICAgICAgICBsZW5ndGg6IG9wdEZuKHMuc3ByaW5nTGVuZ3RoLCBlKSxcbiAgICAgICAgICBjb2VmZjogb3B0Rm4ocy5zcHJpbmdDb2VmZiwgZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3ByaW5nLl9jeUVkZ2UgPSBlO1xuXG4gICAgICAgIHZhciBzY3JhdGNoID0gZ2V0U2NyYXRjaChlKTtcblxuICAgICAgICBzcHJpbmcuX3NjcmF0Y2ggPSBzY3JhdGNoO1xuXG4gICAgICAgIHNjcmF0Y2guc3ByaW5nID0gc3ByaW5nO1xuXG4gICAgICAgIHNwcmluZ3MucHVzaChzcHJpbmcpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNvbXBvdW5kIGVkZ2Ugc3ByaW5nc1xuICAgICAgcy5lZGdlcy5maWx0ZXIoaXNQYXJlbnRFZGdlKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzb3VyY2VzID0gZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMoZS5zb3VyY2UoKSk7XG4gICAgICAgIHZhciB0YXJnZXRzID0gZ2V0Tm9uUGFyZW50RGVzY2VuZGFudHMoZS50YXJnZXQoKSk7XG5cbiAgICAgICAgLy8ganVzdCBhZGQgb25lIHNwcmluZyBmb3IgcGVyZlxuICAgICAgICBzb3VyY2VzID0gW3NvdXJjZXNbMF1dO1xuICAgICAgICB0YXJnZXRzID0gW3RhcmdldHNbMF1dO1xuXG4gICAgICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0Z3QpIHtcbiAgICAgICAgICAgIHNwcmluZ3MucHVzaChtYWtlU3ByaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBnZXRCb2R5KHNyYyksXG4gICAgICAgICAgICAgIHRhcmdldDogZ2V0Qm9keSh0Z3QpLFxuICAgICAgICAgICAgICBsZW5ndGg6IG9wdEZuKHMuc3ByaW5nTGVuZ3RoLCBlKSxcbiAgICAgICAgICAgICAgY29lZmY6IG9wdEZuKHMuc3ByaW5nQ29lZmYsIGUpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2soc3RhdGUpIHtcbiAgICAgIHZhciBtb3ZlbWVudCA9IF90aWNrKHN0YXRlKTtcblxuICAgICAgdmFyIGlzRG9uZSA9IG1vdmVtZW50IDw9IHN0YXRlLm1vdmVtZW50VGhyZXNob2xkO1xuXG4gICAgICByZXR1cm4gaXNEb25lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdWxlcjtcbn0oTGF5b3V0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdWxlcjtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICBwb3M6IHsgeDogMCwgeTogMCB9LFxuICBwcmV2UG9zOiB7IHg6IDAsIHk6IDAgfSxcbiAgZm9yY2U6IHsgeDogMCwgeTogMCB9LFxuICB2ZWxvY2l0eTogeyB4OiAwLCB5OiAwIH0sXG4gIG1hc3M6IDFcbn0pO1xuXG52YXIgY29weVZlYyA9IGZ1bmN0aW9uIGNvcHlWZWModikge1xuICByZXR1cm4geyB4OiB2LngsIHk6IHYueSB9O1xufTtcbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKHZhbCwgZGVmKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbCA6IGRlZjtcbn07XG52YXIgZ2V0VmVjID0gZnVuY3Rpb24gZ2V0VmVjKHZlYywgZGVmKSB7XG4gIHJldHVybiBjb3B5VmVjKGdldFZhbHVlKHZlYywgZGVmKSk7XG59O1xuXG5mdW5jdGlvbiBtYWtlQm9keShvcHRzKSB7XG4gIHZhciBiID0ge307XG5cbiAgYi5wb3MgPSBnZXRWZWMob3B0cy5wb3MsIGRlZmF1bHRzLnBvcyk7XG4gIGIucHJldlBvcyA9IGdldFZlYyhvcHRzLnByZXZQb3MsIGIucG9zKTtcbiAgYi5mb3JjZSA9IGdldFZlYyhvcHRzLmZvcmNlLCBkZWZhdWx0cy5mb3JjZSk7XG4gIGIudmVsb2NpdHkgPSBnZXRWZWMob3B0cy52ZWxvY2l0eSwgZGVmYXVsdHMudmVsb2NpdHkpO1xuICBiLm1hc3MgPSBvcHRzLm1hc3MgIT0gbnVsbCA/IG9wdHMubWFzcyA6IGRlZmF1bHRzLm1hc3M7XG4gIGIubG9ja2VkID0gb3B0cy5sb2NrZWQ7XG5cbiAgcmV0dXJuIGI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBtYWtlQm9keTogbWFrZUJvZHkgfTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBUaGUgaWRlYWwgbGVndGggb2YgYSBzcHJpbmdcbiAgLy8gLSBUaGlzIGFjdHMgYXMgYSBoaW50IGZvciB0aGUgZWRnZSBsZW5ndGhcbiAgLy8gLSBUaGUgZWRnZSBsZW5ndGggY2FuIGJlIGxvbmdlciBvciBzaG9ydGVyIGlmIHRoZSBmb3JjZXMgYXJlIHNldCB0byBleHRyZW1lIHZhbHVlc1xuICBzcHJpbmdMZW5ndGg6IGZ1bmN0aW9uIHNwcmluZ0xlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDgwO1xuICB9LFxuXG4gIC8vIEhvb2tlJ3MgbGF3IGNvZWZmaWNpZW50XG4gIC8vIC0gVGhlIHZhbHVlIHJhbmdlcyBvbiBbMCwgMV1cbiAgLy8gLSBMb3dlciB2YWx1ZXMgZ2l2ZSBsb29zZXIgc3ByaW5nc1xuICAvLyAtIEhpZ2hlciB2YWx1ZXMgZ2l2ZSB0aWdodGVyIHNwcmluZ3NcbiAgc3ByaW5nQ29lZmY6IGZ1bmN0aW9uIHNwcmluZ0NvZWZmKGVkZ2UpIHtcbiAgICByZXR1cm4gMC4wMDA4O1xuICB9LFxuXG4gIC8vIFRoZSBtYXNzIG9mIHRoZSBub2RlIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cbiAgLy8gLSBUaGUgbWFzcyBhZmZlY3RzIHRoZSBncmF2aXR5IG5vZGUgcmVwdWxzaW9uL2F0dHJhY3Rpb25cbiAgbWFzczogZnVuY3Rpb24gbWFzcyhub2RlKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0sXG5cbiAgLy8gQ291bG9tYidzIGxhdyBjb2VmZmljaWVudFxuICAvLyAtIE1ha2VzIHRoZSBub2RlcyByZXBlbCBlYWNoIG90aGVyIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgLy8gLSBNYWtlcyB0aGUgbm9kZXMgYXR0cmFjdCBlYWNoIG90aGVyIGZvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgZ3Jhdml0eTogLTEuMixcblxuICAvLyBBIGZvcmNlIHRoYXQgcHVsbHMgbm9kZXMgdG93YXJkcyB0aGUgb3JpZ2luICgwLCAwKVxuICAvLyBIaWdoZXIgdmFsdWVzIGtlZXAgdGhlIGNvbXBvbmVudHMgbGVzcyBzcHJlYWQgb3V0XG4gIHB1bGw6IDAuMDAxLFxuXG4gIC8vIFRoZXRhIGNvZWZmaWNpZW50IGZyb20gQmFybmVzLUh1dCBzaW11bGF0aW9uXG4gIC8vIC0gVmFsdWUgcmFuZ2VzIG9uIFswLCAxXVxuICAvLyAtIFBlcmZvcm1hbmNlIGlzIGJldHRlciB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIC8vIC0gVmVyeSBzbWFsbCB2YWx1ZXMgbWF5IG5vdCBjcmVhdGUgZW5vdWdoIGZvcmNlIHRvIGdpdmUgYSBnb29kIHJlc3VsdFxuICB0aGV0YTogMC42NjYsXG5cbiAgLy8gRnJpY3Rpb24gLyBkcmFnIGNvZWZmaWNpZW50IHRvIG1ha2UgdGhlIHN5c3RlbSBzdGFiaWxpc2Ugb3ZlciB0aW1lXG4gIGRyYWdDb2VmZjogMC4wMixcblxuICAvLyBXaGVuIHRoZSB0b3RhbCBvZiB0aGUgc3F1YXJlZCBwb3NpdGlvbiBkZWx0YXMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUsIHRoZSBzaW11bGF0aW9uIGVuZHNcbiAgbW92ZW1lbnRUaHJlc2hvbGQ6IDEsXG5cbiAgLy8gVGhlIGFtb3VudCBvZiB0aW1lIHBhc3NlZCBwZXIgdGlja1xuICAvLyAtIExhcmdlciB2YWx1ZXMgcmVzdWx0IGluIGZhc3RlciBydW50aW1lcyBidXQgbWlnaHQgc3ByZWFkIHRoaW5ncyBvdXQgdG9vIGZhclxuICAvLyAtIFNtYWxsZXIgdmFsdWVzIHByb2R1Y2UgbW9yZSBhY2N1cmF0ZSByZXN1bHRzXG4gIHRpbWVTdGVwOiAyMFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmYXVsdENvZWZmID0gMC4wMjtcblxuZnVuY3Rpb24gYXBwbHlEcmFnKGJvZHksIG1hbnVhbERyYWdDb2VmZikge1xuICB2YXIgZHJhZ0NvZWZmID0gdm9pZCAwO1xuXG4gIGlmIChtYW51YWxEcmFnQ29lZmYgIT0gbnVsbCkge1xuICAgIGRyYWdDb2VmZiA9IG1hbnVhbERyYWdDb2VmZjtcbiAgfSBlbHNlIGlmIChib2R5LmRyYWdDb2VmZiAhPSBudWxsKSB7XG4gICAgZHJhZ0NvZWZmID0gYm9keS5kcmFnQ29lZmY7XG4gIH0gZWxzZSB7XG4gICAgZHJhZ0NvZWZmID0gZGVmYXVsdENvZWZmO1xuICB9XG5cbiAgYm9keS5mb3JjZS54IC09IGRyYWdDb2VmZiAqIGJvZHkudmVsb2NpdHkueDtcbiAgYm9keS5mb3JjZS55IC09IGRyYWdDb2VmZiAqIGJvZHkudmVsb2NpdHkueTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGFwcGx5RHJhZzogYXBwbHlEcmFnIH07XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyB1c2UgZXVsZXIgbWV0aG9kIGZvciBmb3JjZSBpbnRlZ3JhdGlvbiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX21ldGhvZFxuLy8gcmV0dXJuIHN1bSBvZiBzcXVhcmVkIHBvc2l0aW9uIGRlbHRhc1xuZnVuY3Rpb24gaW50ZWdyYXRlKGJvZGllcywgdGltZVN0ZXApIHtcbiAgdmFyIGR4ID0gMCxcbiAgICAgIHR4ID0gMCxcbiAgICAgIGR5ID0gMCxcbiAgICAgIHR5ID0gMCxcbiAgICAgIGksXG4gICAgICBtYXggPSBib2RpZXMubGVuZ3RoO1xuXG4gIGlmIChtYXggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7ICsraSkge1xuICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICBjb2VmZiA9IHRpbWVTdGVwIC8gYm9keS5tYXNzO1xuXG4gICAgaWYgKGJvZHkuZ3JhYmJlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGJvZHkubG9ja2VkKSB7XG4gICAgICBib2R5LnZlbG9jaXR5LnggPSAwO1xuICAgICAgYm9keS52ZWxvY2l0eS55ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keS52ZWxvY2l0eS54ICs9IGNvZWZmICogYm9keS5mb3JjZS54O1xuICAgICAgYm9keS52ZWxvY2l0eS55ICs9IGNvZWZmICogYm9keS5mb3JjZS55O1xuICAgIH1cblxuICAgIHZhciB2eCA9IGJvZHkudmVsb2NpdHkueCxcbiAgICAgICAgdnkgPSBib2R5LnZlbG9jaXR5LnksXG4gICAgICAgIHYgPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gICAgaWYgKHYgPiAxKSB7XG4gICAgICBib2R5LnZlbG9jaXR5LnggPSB2eCAvIHY7XG4gICAgICBib2R5LnZlbG9jaXR5LnkgPSB2eSAvIHY7XG4gICAgfVxuXG4gICAgZHggPSB0aW1lU3RlcCAqIGJvZHkudmVsb2NpdHkueDtcbiAgICBkeSA9IHRpbWVTdGVwICogYm9keS52ZWxvY2l0eS55O1xuXG4gICAgYm9keS5wb3MueCArPSBkeDtcbiAgICBib2R5LnBvcy55ICs9IGR5O1xuXG4gICAgdHggKz0gTWF0aC5hYnMoZHgpO3R5ICs9IE1hdGguYWJzKGR5KTtcbiAgfVxuXG4gIHJldHVybiAodHggKiB0eCArIHR5ICogdHkpIC8gbWF4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaW50ZWdyYXRlOiBpbnRlZ3JhdGUgfTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGltcGwgb2YgYmFybmVzIGh1dFxuLy8gaHR0cDovL3d3dy5lZWNzLmJlcmtlbGV5LmVkdS9+ZGVtbWVsL2NzMjY3L2xlY3R1cmUyNi9sZWN0dXJlMjYuaHRtbFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXJuZXMlRTIlODAlOTNIdXRfc2ltdWxhdGlvblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgSW5zZXJ0U3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgcmVzZXRWZWMgPSBmdW5jdGlvbiByZXNldFZlYyh2KSB7XG4gIHYueCA9IDA7di55ID0gMDtcbn07XG5cbnZhciBpc1NhbWVQb3NpdGlvbiA9IGZ1bmN0aW9uIGlzU2FtZVBvc2l0aW9uKHAxLCBwMikge1xuICB2YXIgdGhyZXNob2xkID0gMWUtODtcbiAgdmFyIGR4ID0gTWF0aC5hYnMocDEueCAtIHAyLngpO1xuICB2YXIgZHkgPSBNYXRoLmFicyhwMS55IC0gcDIueSk7XG5cbiAgcmV0dXJuIGR4IDwgdGhyZXNob2xkICYmIGR5IDwgdGhyZXNob2xkO1xufTtcblxuZnVuY3Rpb24gbWFrZVF1YWR0cmVlKCkge1xuICB2YXIgdXBkYXRlUXVldWUgPSBbXSxcbiAgICAgIGluc2VydFN0YWNrID0gbmV3IEluc2VydFN0YWNrKCksXG4gICAgICBub2Rlc0NhY2hlID0gW10sXG4gICAgICBjdXJyZW50SW5DYWNoZSA9IDAsXG4gICAgICByb290ID0gbmV3Tm9kZSgpO1xuXG4gIGZ1bmN0aW9uIG5ld05vZGUoKSB7XG4gICAgLy8gVG8gYXZvaWQgcHJlc3N1cmUgb24gR0Mgd2UgcmV1c2Ugbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBub2Rlc0NhY2hlW2N1cnJlbnRJbkNhY2hlXTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5xdWFkMCA9IG51bGw7XG4gICAgICBub2RlLnF1YWQxID0gbnVsbDtcbiAgICAgIG5vZGUucXVhZDIgPSBudWxsO1xuICAgICAgbm9kZS5xdWFkMyA9IG51bGw7XG4gICAgICBub2RlLmJvZHkgPSBudWxsO1xuICAgICAgbm9kZS5tYXNzID0gbm9kZS5tYXNzWCA9IG5vZGUubWFzc1kgPSAwO1xuICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG5vZGUudG9wID0gbm9kZS5ib3R0b20gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgIG5vZGVzQ2FjaGVbY3VycmVudEluQ2FjaGVdID0gbm9kZTtcbiAgICB9XG5cbiAgICArK2N1cnJlbnRJbkNhY2hlO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHNvdXJjZUJvZHksIGdyYXZpdHksIHRoZXRhLCBwdWxsKSB7XG4gICAgdmFyIHF1ZXVlID0gdXBkYXRlUXVldWUsXG4gICAgICAgIHYgPSB2b2lkIDAsXG4gICAgICAgIGR4ID0gdm9pZCAwLFxuICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgciA9IHZvaWQgMCxcbiAgICAgICAgZnggPSAwLFxuICAgICAgICBmeSA9IDAsXG4gICAgICAgIHF1ZXVlTGVuZ3RoID0gMSxcbiAgICAgICAgc2hpZnRJZHggPSAwLFxuICAgICAgICBwdXNoSWR4ID0gMTtcblxuICAgIHF1ZXVlWzBdID0gcm9vdDtcblxuICAgIHJlc2V0VmVjKHNvdXJjZUJvZHkuZm9yY2UpO1xuXG4gICAgdmFyIHB4ID0gLXNvdXJjZUJvZHkucG9zLng7XG4gICAgdmFyIHB5ID0gLXNvdXJjZUJvZHkucG9zLnk7XG4gICAgdmFyIHByID0gTWF0aC5zcXJ0KHB4ICogcHggKyBweSAqIHB5KTtcbiAgICB2YXIgcHYgPSBzb3VyY2VCb2R5Lm1hc3MgKiBwdWxsIC8gcHI7XG5cbiAgICBmeCArPSBwdiAqIHB4O1xuICAgIGZ5ICs9IHB2ICogcHk7XG5cbiAgICB3aGlsZSAocXVldWVMZW5ndGgpIHtcbiAgICAgIHZhciBub2RlID0gcXVldWVbc2hpZnRJZHhdLFxuICAgICAgICAgIGJvZHkgPSBub2RlLmJvZHk7XG5cbiAgICAgIHF1ZXVlTGVuZ3RoIC09IDE7XG4gICAgICBzaGlmdElkeCArPSAxO1xuICAgICAgdmFyIGRpZmZlcmVudEJvZHkgPSBib2R5ICE9PSBzb3VyY2VCb2R5O1xuICAgICAgaWYgKGJvZHkgJiYgZGlmZmVyZW50Qm9keSkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgbGVhZiBub2RlIChhbmQgaXQgaXMgbm90IHNvdXJjZSBib2R5KSxcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBmb3JjZSBleGVydGVkIGJ5IHRoZSBjdXJyZW50IG5vZGUgb24gYm9keSwgYW5kIGFkZCB0aGlzXG4gICAgICAgIC8vIGFtb3VudCB0byBib2R5J3MgbmV0IGZvcmNlLlxuICAgICAgICBkeCA9IGJvZHkucG9zLnggLSBzb3VyY2VCb2R5LnBvcy54O1xuICAgICAgICBkeSA9IGJvZHkucG9zLnkgLSBzb3VyY2VCb2R5LnBvcy55O1xuICAgICAgICByID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgIC8vIFBvb3IgbWFuJ3MgcHJvdGVjdGlvbiBhZ2FpbnN0IHplcm8gZGlzdGFuY2UuXG4gICAgICAgICAgZHggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA1MDtcbiAgICAgICAgICBkeSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDUwO1xuICAgICAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBzdGFuZGFyZCBncmF2aXRpb24gZm9yY2UgY2FsY3VsYXRpb24gYnV0IHdlIGRpdmlkZVxuICAgICAgICAvLyBieSByXjMgdG8gc2F2ZSB0d28gb3BlcmF0aW9ucyB3aGVuIG5vcm1hbGl6aW5nIGZvcmNlIHZlY3Rvci5cbiAgICAgICAgdiA9IGdyYXZpdHkgKiBib2R5Lm1hc3MgKiBzb3VyY2VCb2R5Lm1hc3MgLyAociAqIHIgKiByKTtcbiAgICAgICAgZnggKz0gdiAqIGR4O1xuICAgICAgICBmeSArPSB2ICogZHk7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZlcmVudEJvZHkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgdGhlIHJhdGlvIHMgLyByLCAgd2hlcmUgcyBpcyB0aGUgd2lkdGggb2YgdGhlIHJlZ2lvblxuICAgICAgICAvLyByZXByZXNlbnRlZCBieSB0aGUgaW50ZXJuYWwgbm9kZSwgYW5kIHIgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZHlcbiAgICAgICAgLy8gYW5kIHRoZSBub2RlJ3MgY2VudGVyLW9mLW1hc3NcbiAgICAgICAgZHggPSBub2RlLm1hc3NYIC8gbm9kZS5tYXNzIC0gc291cmNlQm9keS5wb3MueDtcbiAgICAgICAgZHkgPSBub2RlLm1hc3NZIC8gbm9kZS5tYXNzIC0gc291cmNlQm9keS5wb3MueTtcbiAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAvLyBTb3JyeSBhYm91dCBjb2RlIGR1cGx1Y2F0aW9uLiBJIGRvbid0IHdhbnQgdG8gY3JlYXRlIG1hbnkgZnVuY3Rpb25zXG4gICAgICAgICAgLy8gcmlnaHQgYXdheS4gSnVzdCB3YW50IHRvIHNlZSBwZXJmb3JtYW5jZSBmaXJzdC5cbiAgICAgICAgICBkeCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDUwO1xuICAgICAgICAgIGR5ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNTA7XG4gICAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcyAvIHIgPCDOuCwgdHJlYXQgdGhpcyBpbnRlcm5hbCBub2RlIGFzIGEgc2luZ2xlIGJvZHksIGFuZCBjYWxjdWxhdGUgdGhlXG4gICAgICAgIC8vIGZvcmNlIGl0IGV4ZXJ0cyBvbiBzb3VyY2VCb2R5LCBhbmQgYWRkIHRoaXMgYW1vdW50IHRvIHNvdXJjZUJvZHkncyBuZXQgZm9yY2UuXG4gICAgICAgIGlmICgobm9kZS5yaWdodCAtIG5vZGUubGVmdCkgLyByIDwgdGhldGEpIHtcbiAgICAgICAgICAvLyBpbiB0aGUgaWYgc3RhdGVtZW50IGFib3ZlIHdlIGNvbnNpZGVyIG5vZGUncyB3aWR0aCBvbmx5XG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgcmVnaW9uIHdhcyBzcXVhcmlmaWVkIGR1cmluZyB0cmVlIGNyZWF0aW9uLlxuICAgICAgICAgIC8vIFRodXMgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHVzaW5nIHdpZHRoIG9yIGhlaWdodC5cbiAgICAgICAgICB2ID0gZ3Jhdml0eSAqIG5vZGUubWFzcyAqIHNvdXJjZUJvZHkubWFzcyAvIChyICogciAqIHIpO1xuICAgICAgICAgIGZ4ICs9IHYgKiBkeDtcbiAgICAgICAgICBmeSArPSB2ICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBydW4gdGhlIHByb2NlZHVyZSByZWN1cnNpdmVseSBvbiBlYWNoIG9mIHRoZSBjdXJyZW50IG5vZGUncyBjaGlsZHJlbi5cblxuICAgICAgICAgIC8vIEkgaW50ZW50aW9uYWxseSB1bmZvbGRlZCB0aGlzIGxvb3AsIHRvIHNhdmUgc2V2ZXJhbCBDUFUgY3ljbGVzLlxuICAgICAgICAgIGlmIChub2RlLnF1YWQwKSB7XG4gICAgICAgICAgICBxdWV1ZVtwdXNoSWR4XSA9IG5vZGUucXVhZDA7XG4gICAgICAgICAgICBxdWV1ZUxlbmd0aCArPSAxO1xuICAgICAgICAgICAgcHVzaElkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5xdWFkMSkge1xuICAgICAgICAgICAgcXVldWVbcHVzaElkeF0gPSBub2RlLnF1YWQxO1xuICAgICAgICAgICAgcXVldWVMZW5ndGggKz0gMTtcbiAgICAgICAgICAgIHB1c2hJZHggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUucXVhZDIpIHtcbiAgICAgICAgICAgIHF1ZXVlW3B1c2hJZHhdID0gbm9kZS5xdWFkMjtcbiAgICAgICAgICAgIHF1ZXVlTGVuZ3RoICs9IDE7XG4gICAgICAgICAgICBwdXNoSWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnF1YWQzKSB7XG4gICAgICAgICAgICBxdWV1ZVtwdXNoSWR4XSA9IG5vZGUucXVhZDM7XG4gICAgICAgICAgICBxdWV1ZUxlbmd0aCArPSAxO1xuICAgICAgICAgICAgcHVzaElkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZUJvZHkuZm9yY2UueCArPSBmeDtcbiAgICBzb3VyY2VCb2R5LmZvcmNlLnkgKz0gZnk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRCb2RpZXMoYm9kaWVzKSB7XG4gICAgaWYgKGJvZGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICB5MSA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIHgyID0gTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgeTIgPSBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICBpID0gdm9pZCAwLFxuICAgICAgICBtYXggPSBib2RpZXMubGVuZ3RoO1xuXG4gICAgLy8gVG8gcmVkdWNlIHF1YWQgdHJlZSBkZXB0aCB3ZSBhcmUgbG9va2luZyBmb3IgZXhhY3QgYm91bmRpbmcgYm94IG9mIGFsbCBwYXJ0aWNsZXMuXG4gICAgaSA9IG1heDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgeCA9IGJvZGllc1tpXS5wb3MueDtcbiAgICAgIHZhciB5ID0gYm9kaWVzW2ldLnBvcy55O1xuICAgICAgaWYgKHggPCB4MSkge1xuICAgICAgICB4MSA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgIHgyID0geDtcbiAgICAgIH1cbiAgICAgIGlmICh5IDwgeTEpIHtcbiAgICAgICAgeTEgPSB5O1xuICAgICAgfVxuICAgICAgaWYgKHkgPiB5Mikge1xuICAgICAgICB5MiA9IHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3F1YXJpZnkgdGhlIGJvdW5kcy5cbiAgICB2YXIgZHggPSB4MiAtIHgxLFxuICAgICAgICBkeSA9IHkyIC0geTE7XG4gICAgaWYgKGR4ID4gZHkpIHtcbiAgICAgIHkyID0geTEgKyBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSB4MSArIGR5O1xuICAgIH1cblxuICAgIGN1cnJlbnRJbkNhY2hlID0gMDtcbiAgICByb290ID0gbmV3Tm9kZSgpO1xuICAgIHJvb3QubGVmdCA9IHgxO1xuICAgIHJvb3QucmlnaHQgPSB4MjtcbiAgICByb290LnRvcCA9IHkxO1xuICAgIHJvb3QuYm90dG9tID0geTI7XG5cbiAgICBpID0gbWF4IC0gMTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICByb290LmJvZHkgPSBib2RpZXNbaV07XG4gICAgfVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGluc2VydChib2RpZXNbaV0sIHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydChuZXdCb2R5KSB7XG4gICAgaW5zZXJ0U3RhY2sucmVzZXQoKTtcbiAgICBpbnNlcnRTdGFjay5wdXNoKHJvb3QsIG5ld0JvZHkpO1xuXG4gICAgd2hpbGUgKCFpbnNlcnRTdGFjay5pc0VtcHR5KCkpIHtcbiAgICAgIHZhciBzdGFja0l0ZW0gPSBpbnNlcnRTdGFjay5wb3AoKSxcbiAgICAgICAgICBub2RlID0gc3RhY2tJdGVtLm5vZGUsXG4gICAgICAgICAgYm9keSA9IHN0YWNrSXRlbS5ib2R5O1xuXG4gICAgICBpZiAoIW5vZGUuYm9keSkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVybmFsIG5vZGUuIFVwZGF0ZSB0aGUgdG90YWwgbWFzcyBvZiB0aGUgbm9kZSBhbmQgY2VudGVyLW9mLW1hc3MuXG4gICAgICAgIHZhciB4ID0gYm9keS5wb3MueDtcbiAgICAgICAgdmFyIHkgPSBib2R5LnBvcy55O1xuICAgICAgICBub2RlLm1hc3MgPSBub2RlLm1hc3MgKyBib2R5Lm1hc3M7XG4gICAgICAgIG5vZGUubWFzc1ggPSBub2RlLm1hc3NYICsgYm9keS5tYXNzICogeDtcbiAgICAgICAgbm9kZS5tYXNzWSA9IG5vZGUubWFzc1kgKyBib2R5Lm1hc3MgKiB5O1xuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCB0aGUgYm9keSBpbiB0aGUgYXBwcm9wcmlhdGUgcXVhZHJhbnQuXG4gICAgICAgIC8vIEJ1dCBmaXJzdCBmaW5kIHRoZSBhcHByb3ByaWF0ZSBxdWFkcmFudC5cbiAgICAgICAgdmFyIHF1YWRJZHggPSAwLFxuICAgICAgICAgICAgLy8gQXNzdW1lIHdlIGFyZSBpbiB0aGUgMCdzIHF1YWQuXG4gICAgICAgIGxlZnQgPSBub2RlLmxlZnQsXG4gICAgICAgICAgICByaWdodCA9IChub2RlLnJpZ2h0ICsgbGVmdCkgLyAyLFxuICAgICAgICAgICAgdG9wID0gbm9kZS50b3AsXG4gICAgICAgICAgICBib3R0b20gPSAobm9kZS5ib3R0b20gKyB0b3ApIC8gMjtcblxuICAgICAgICBpZiAoeCA+IHJpZ2h0KSB7XG4gICAgICAgICAgLy8gc29tZXdoZXJlIGluIHRoZSBlYXN0ZXJuIHBhcnQuXG4gICAgICAgICAgcXVhZElkeCA9IHF1YWRJZHggKyAxO1xuICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiBib3R0b20pIHtcbiAgICAgICAgICAvLyBhbmQgaW4gc291dGguXG4gICAgICAgICAgcXVhZElkeCA9IHF1YWRJZHggKyAyO1xuICAgICAgICAgIHRvcCA9IGJvdHRvbTtcbiAgICAgICAgICBib3R0b20gPSBub2RlLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IGdldENoaWxkKG5vZGUsIHF1YWRJZHgpO1xuICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgLy8gVGhlIG5vZGUgaXMgaW50ZXJuYWwgYnV0IHRoaXMgcXVhZHJhbnQgaXMgbm90IHRha2VuLiBBZGRcbiAgICAgICAgICAvLyBzdWJub2RlIHRvIGl0LlxuICAgICAgICAgIGNoaWxkID0gbmV3Tm9kZSgpO1xuICAgICAgICAgIGNoaWxkLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIGNoaWxkLnRvcCA9IHRvcDtcbiAgICAgICAgICBjaGlsZC5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIGNoaWxkLmJvdHRvbSA9IGJvdHRvbTtcbiAgICAgICAgICBjaGlsZC5ib2R5ID0gYm9keTtcblxuICAgICAgICAgIHNldENoaWxkKG5vZGUsIHF1YWRJZHgsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb250aW51ZSBzZWFyY2hpbmcgaW4gdGhpcyBxdWFkcmFudC5cbiAgICAgICAgICBpbnNlcnRTdGFjay5wdXNoKGNoaWxkLCBib2R5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBhZGQgdG8gdGhlIGxlYWYgbm9kZS5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBjb252ZXJ0IGN1cnJlbnQgbGVhZiBpbnRvIGludGVybmFsIG5vZGVcbiAgICAgICAgLy8gYW5kIGNvbnRpbnVlIGFkZGluZyB0d28gbm9kZXMuXG4gICAgICAgIHZhciBvbGRCb2R5ID0gbm9kZS5ib2R5O1xuICAgICAgICBub2RlLmJvZHkgPSBudWxsOyAvLyBpbnRlcm5hbCBub2RlcyBkbyBub3QgY2FyeSBib2RpZXNcblxuICAgICAgICBpZiAoaXNTYW1lUG9zaXRpb24ob2xkQm9keS5wb3MsIGJvZHkucG9zKSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgc3ViZGl2aXNpb24gYnkgYnVtcGluZyBvbmUgbm9kZVxuICAgICAgICAgIC8vIGFueXdoZXJlIGluIHRoaXMgcXVhZHJhbnRcbiAgICAgICAgICB2YXIgcmV0cmllc0NvdW50ID0gMztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIHZhciBkeCA9IChub2RlLnJpZ2h0IC0gbm9kZS5sZWZ0KSAqIG9mZnNldDtcbiAgICAgICAgICAgIHZhciBkeSA9IChub2RlLmJvdHRvbSAtIG5vZGUudG9wKSAqIG9mZnNldDtcblxuICAgICAgICAgICAgb2xkQm9keS5wb3MueCA9IG5vZGUubGVmdCArIGR4O1xuICAgICAgICAgICAgb2xkQm9keS5wb3MueSA9IG5vZGUudG9wICsgZHk7XG4gICAgICAgICAgICByZXRyaWVzQ291bnQgLT0gMTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBidW1wIGl0IG91dCBvZiB0aGUgYm94LiBJZiB3ZSBkbywgbmV4dCBpdGVyYXRpb24gc2hvdWxkIGZpeCBpdFxuICAgICAgICAgIH0gd2hpbGUgKHJldHJpZXNDb3VudCA+IDAgJiYgaXNTYW1lUG9zaXRpb24ob2xkQm9keS5wb3MsIGJvZHkucG9zKSk7XG5cbiAgICAgICAgICBpZiAocmV0cmllc0NvdW50ID09PSAwICYmIGlzU2FtZVBvc2l0aW9uKG9sZEJvZHkucG9zLCBib2R5LnBvcykpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdmVyeSBiYWQsIHdlIHJhbiBvdXQgb2YgcHJlY2lzaW9uLlxuICAgICAgICAgICAgLy8gaWYgd2UgZG8gbm90IHJldHVybiBmcm9tIHRoZSBtZXRob2Qgd2UnbGwgZ2V0IGludG9cbiAgICAgICAgICAgIC8vIGluZmluaXRlIGxvb3AgaGVyZS4gU28gd2Ugc2FjcmlmaWNlIGNvcnJlY3RuZXNzIG9mIGxheW91dCwgYW5kIGtlZXAgdGhlIGFwcCBydW5uaW5nXG4gICAgICAgICAgICAvLyBOZXh0IGxheW91dCBpdGVyYXRpb24gc2hvdWxkIGdldCBsYXJnZXIgYm91bmRpbmcgYm94IGluIHRoZSBmaXJzdCBzdGVwIGFuZCBmaXggdGhpc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvbiBzaG91bGQgc3ViZGl2aWRlIG5vZGUgZnVydGhlci5cbiAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChub2RlLCBvbGRCb2R5KTtcbiAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChub2RlLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGluc2VydEJvZGllczogaW5zZXJ0Qm9kaWVzLFxuICAgIHVwZGF0ZUJvZHlGb3JjZTogdXBkYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkKG5vZGUsIGlkeCkge1xuICBpZiAoaWR4ID09PSAwKSByZXR1cm4gbm9kZS5xdWFkMDtcbiAgaWYgKGlkeCA9PT0gMSkgcmV0dXJuIG5vZGUucXVhZDE7XG4gIGlmIChpZHggPT09IDIpIHJldHVybiBub2RlLnF1YWQyO1xuICBpZiAoaWR4ID09PSAzKSByZXR1cm4gbm9kZS5xdWFkMztcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldENoaWxkKG5vZGUsIGlkeCwgY2hpbGQpIHtcbiAgaWYgKGlkeCA9PT0gMCkgbm9kZS5xdWFkMCA9IGNoaWxkO2Vsc2UgaWYgKGlkeCA9PT0gMSkgbm9kZS5xdWFkMSA9IGNoaWxkO2Vsc2UgaWYgKGlkeCA9PT0gMikgbm9kZS5xdWFkMiA9IGNoaWxkO2Vsc2UgaWYgKGlkeCA9PT0gMykgbm9kZS5xdWFkMyA9IGNoaWxkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbWFrZVF1YWR0cmVlOiBtYWtlUXVhZHRyZWUgfTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSW5zZXJ0U3RhY2s7XG5cbi8qKlxuICogT3VyIGltcGxtZW50YXRpb24gb2YgUXVhZFRyZWUgaXMgbm9uLXJlY3Vyc2l2ZSB0byBhdm9pZCBHQyBoaXRcbiAqIFRoaXMgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50IHN0YWNrIG9mIGVsZW1lbnRzXG4gKiB3aGljaCB3ZSBhcmUgdHJ5aW5nIHRvIGluc2VydCBpbnRvIHF1YWQgdHJlZS5cbiAqL1xuZnVuY3Rpb24gSW5zZXJ0U3RhY2soKSB7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMucG9wSWR4ID0gMDtcbn1cblxuSW5zZXJ0U3RhY2sucHJvdG90eXBlID0ge1xuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcElkeCA9PT0gMDtcbiAgICB9LFxuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2gobm9kZSwgYm9keSkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc3RhY2tbdGhpcy5wb3BJZHhdO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSB0cnlpbmcgdG8gYXZvaWQgbWVtb3J5IHByZXNzdWU6IGNyZWF0ZSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgLy8gb25seSB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMucG9wSWR4XSA9IG5ldyBJbnNlcnRTdGFja0VsZW1lbnQobm9kZSwgYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaXRlbS5ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMucG9wSWR4O1xuICAgIH0sXG4gICAgcG9wOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcElkeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrWy0tdGhpcy5wb3BJZHhdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucG9wSWR4ID0gMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBJbnNlcnRTdGFja0VsZW1lbnQobm9kZSwgYm9keSkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7IC8vIFF1YWRUcmVlIG5vZGVcbiAgICB0aGlzLmJvZHkgPSBib2R5OyAvLyBwaHlzaWNhbCBib2R5IHdoaWNoIG5lZWRzIHRvIGJlIGluc2VydGVkIHRvIG5vZGVcbn1cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogSW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IDJEIFF1YWRUcmVlIG5vZGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBOb2RlKCkge1xuICAvLyBib2R5IHN0b3JlZCBpbnNpZGUgdGhpcyBub2RlLiBJbiBxdWFkIHRyZWUgb25seSBsZWFmIG5vZGVzIChieSBjb25zdHJ1Y3Rpb24pXG4gIC8vIGNvbnRhaW4gYm9pZGVzOlxuICB0aGlzLmJvZHkgPSBudWxsO1xuXG4gIC8vIENoaWxkIG5vZGVzIGFyZSBzdG9yZWQgaW4gcXVhZHMuIEVhY2ggcXVhZCBpcyBwcmVzZW50ZWQgYnkgbnVtYmVyOlxuICAvLyAwIHwgMVxuICAvLyAtLS0tLVxuICAvLyAyIHwgM1xuICB0aGlzLnF1YWQwID0gbnVsbDtcbiAgdGhpcy5xdWFkMSA9IG51bGw7XG4gIHRoaXMucXVhZDIgPSBudWxsO1xuICB0aGlzLnF1YWQzID0gbnVsbDtcblxuICAvLyBUb3RhbCBtYXNzIG9mIGN1cnJlbnQgbm9kZVxuICB0aGlzLm1hc3MgPSAwO1xuXG4gIC8vIENlbnRlciBvZiBtYXNzIGNvb3JkaW5hdGVzXG4gIHRoaXMubWFzc1ggPSAwO1xuICB0aGlzLm1hc3NZID0gMDtcblxuICAvLyBib3VuZGluZyBib3ggY29vcmRpbmF0ZXNcbiAgdGhpcy5sZWZ0ID0gMDtcbiAgdGhpcy50b3AgPSAwO1xuICB0aGlzLmJvdHRvbSA9IDA7XG4gIHRoaXMucmlnaHQgPSAwO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIGludGVncmF0ZSA9IF9yZXF1aXJlLmludGVncmF0ZTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gICAgYXBwbHlEcmFnID0gX3JlcXVpcmUyLmFwcGx5RHJhZztcblxudmFyIF9yZXF1aXJlMyA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgYXBwbHlTcHJpbmcgPSBfcmVxdWlyZTMuYXBwbHlTcHJpbmc7XG5cbmZ1bmN0aW9uIHRpY2soX3JlZikge1xuICB2YXIgYm9kaWVzID0gX3JlZi5ib2RpZXMsXG4gICAgICBzcHJpbmdzID0gX3JlZi5zcHJpbmdzLFxuICAgICAgcXVhZHRyZWUgPSBfcmVmLnF1YWR0cmVlLFxuICAgICAgdGltZVN0ZXAgPSBfcmVmLnRpbWVTdGVwLFxuICAgICAgZ3Jhdml0eSA9IF9yZWYuZ3Jhdml0eSxcbiAgICAgIHRoZXRhID0gX3JlZi50aGV0YSxcbiAgICAgIGRyYWdDb2VmZiA9IF9yZWYuZHJhZ0NvZWZmLFxuICAgICAgcHVsbCA9IF9yZWYucHVsbDtcblxuICAvLyB1cGRhdGUgYm9keSBmcm9tIHNjcmF0Y2ggaW4gY2FzZSBvZiBhbnkgY2hhbmdlc1xuICBib2RpZXMuZm9yRWFjaChmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBwID0gYm9keS5fc2NyYXRjaDtcblxuICAgIGlmICghcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJvZHkubG9ja2VkID0gcC5sb2NrZWQ7XG4gICAgYm9keS5ncmFiYmVkID0gcC5ncmFiYmVkO1xuICAgIGJvZHkucG9zLnggPSBwLng7XG4gICAgYm9keS5wb3MueSA9IHAueTtcbiAgfSk7XG5cbiAgcXVhZHRyZWUuaW5zZXJ0Qm9kaWVzKGJvZGllcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgIHF1YWR0cmVlLnVwZGF0ZUJvZHlGb3JjZShib2R5LCBncmF2aXR5LCB0aGV0YSwgcHVsbCk7XG4gICAgYXBwbHlEcmFnKGJvZHksIGRyYWdDb2VmZik7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc3ByaW5ncy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgc3ByaW5nID0gc3ByaW5nc1tfaV07XG5cbiAgICBhcHBseVNwcmluZyhzcHJpbmcpO1xuICB9XG5cbiAgdmFyIG1vdmVtZW50ID0gaW50ZWdyYXRlKGJvZGllcywgdGltZVN0ZXApO1xuXG4gIC8vIHVwZGF0ZSBzY3JhdGNoIHBvc2l0aW9ucyBmcm9tIGJvZHkgcG9zaXRpb25zXG4gIGJvZGllcy5mb3JFYWNoKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgdmFyIHAgPSBib2R5Ll9zY3JhdGNoO1xuXG4gICAgaWYgKCFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcC54ID0gYm9keS5wb3MueDtcbiAgICBwLnkgPSBib2R5LnBvcy55O1xuICB9KTtcblxuICByZXR1cm4gbW92ZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyB0aWNrOiB0aWNrIH07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEV1bGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gcmVnaXN0ZXJzIHRoZSBleHRlbnNpb24gb24gYSBjeXRvc2NhcGUgbGliIHJlZlxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY3l0b3NjYXBlKSB7XG4gIGlmICghY3l0b3NjYXBlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNhbid0IHJlZ2lzdGVyIGlmIGN5dG9zY2FwZSB1bnNwZWNpZmllZFxuXG4gIGN5dG9zY2FwZSgnbGF5b3V0JywgJ2V1bGVyJywgRXVsZXIpOyAvLyByZWdpc3RlciB3aXRoIGN5dG9zY2FwZS5qc1xufTtcblxuaWYgKHR5cGVvZiBjeXRvc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGV4cG9zZSB0byBnbG9iYWwgY3l0b3NjYXBlIChpLmUuIHdpbmRvdy5jeXRvc2NhcGUpXG4gIHJlZ2lzdGVyKGN5dG9zY2FwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gZ2VuZXJhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIGZvcmNlLWRpcmVjdGVkIGxheW91dFxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmc7IHNwZWNpYWwgJ2VuZCcgdmFsdWUgbWFrZXMgdGhlIGxheW91dCBhbmltYXRlIGxpa2UgYSBkaXNjcmV0ZSBsYXlvdXRcbiAgcmVmcmVzaDogMTAsIC8vIG51bWJlciBvZiB0aWNrcyBwZXIgZnJhbWU7IGhpZ2hlciBpcyBmYXN0ZXIgYnV0IG1vcmUgamVya3lcbiAgbWF4SXRlcmF0aW9uczogMTAwMCwgLy8gbWF4IGl0ZXJhdGlvbnMgYmVmb3JlIHRoZSBsYXlvdXQgd2lsbCBiYWlsIG91dFxuICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG4gIGZpdDogdHJ1ZSwgLy8gb24gZXZlcnkgbGF5b3V0IHJlcG9zaXRpb24gb2Ygbm9kZXMsIGZpdCB0aGUgdmlld3BvcnRcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgYXJvdW5kIHRoZSBzaW11bGF0aW9uXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuXG4gIC8vIGxheW91dCBldmVudCBjYWxsYmFja3NcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSwgLy8gb24gbGF5b3V0c3RvcFxuXG4gIC8vIHBvc2l0aW9uaW5nIG9wdGlvbnNcbiAgcmFuZG9taXplOiBmYWxzZSwgLy8gdXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG5cbiAgLy8gaW5maW5pdGUgbGF5b3V0IG9wdGlvbnNcbiAgaW5maW5pdGU6IGZhbHNlIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuQSBnZW5lcmljIGNvbnRpbnVvdXMgbGF5b3V0IGNsYXNzXG4qL1xuXG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIG1ha2VCb3VuZGluZ0JveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcbiAgICBzZXRJbml0aWFsUG9zaXRpb25TdGF0ZSA9IF9yZXF1aXJlLnNldEluaXRpYWxQb3NpdGlvblN0YXRlLFxuICAgIHJlZnJlc2hQb3NpdGlvbnMgPSBfcmVxdWlyZS5yZWZyZXNoUG9zaXRpb25zLFxuICAgIGdldE5vZGVQb3NpdGlvbkRhdGEgPSBfcmVxdWlyZS5nZXROb2RlUG9zaXRpb25EYXRhO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgbXVsdGl0aWNrID0gX3JlcXVpcmUyLm11bHRpdGljaztcblxudmFyIExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGF5b3V0KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0KTtcblxuICAgIHZhciBvID0gdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcyA9IHRoaXMuc3RhdGUgPSBhc3NpZ24oe30sIG8sIHtcbiAgICAgIGxheW91dDogdGhpcyxcbiAgICAgIG5vZGVzOiBvLmVsZXMubm9kZXMoKSxcbiAgICAgIGVkZ2VzOiBvLmVsZXMuZWRnZXMoKSxcbiAgICAgIHRpY2tJbmRleDogMCxcbiAgICAgIGZpcnN0VXBkYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBzLmFuaW1hdGVFbmQgPSBvLmFuaW1hdGUgJiYgby5hbmltYXRlID09PSAnZW5kJztcbiAgICBzLmFuaW1hdGVDb250aW51b3VzbHkgPSBvLmFuaW1hdGUgJiYgIXMuYW5pbWF0ZUVuZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMYXlvdXQsIFt7XG4gICAga2V5OiAncnVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdmFyIGwgPSB0aGlzO1xuICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlO1xuXG4gICAgICBzLnRpY2tJbmRleCA9IDA7XG4gICAgICBzLmZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICAgIHMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHMucnVubmluZyA9IHRydWU7XG5cbiAgICAgIHMuY3VycmVudEJvdW5kaW5nQm94ID0gbWFrZUJvdW5kaW5nQm94KHMuYm91bmRpbmdCb3gsIHMuY3kpO1xuXG4gICAgICBpZiAocy5yZWFkeSkge1xuICAgICAgICBsLm9uZSgncmVhZHknLCBzLnJlYWR5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnN0b3ApIHtcbiAgICAgICAgbC5vbmUoJ3N0b3AnLCBzLnN0b3ApO1xuICAgICAgfVxuXG4gICAgICBzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHNldEluaXRpYWxQb3NpdGlvblN0YXRlKG4sIHMpO1xuICAgICAgfSk7XG5cbiAgICAgIGwucHJlcnVuKHMpO1xuXG4gICAgICBpZiAocy5hbmltYXRlQ29udGludW91c2x5KSB7XG4gICAgICAgIHZhciB1bmdyYWJpZnkgPSBmdW5jdGlvbiB1bmdyYWJpZnkobm9kZSkge1xuICAgICAgICAgIGlmICghcy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3JhYmJhYmxlID0gZ2V0Tm9kZVBvc2l0aW9uRGF0YShub2RlLCBzKS5ncmFiYmFibGUgPSBub2RlLmdyYWJiYWJsZSgpO1xuXG4gICAgICAgICAgaWYgKGdyYWJiYWJsZSkge1xuICAgICAgICAgICAgbm9kZS51bmdyYWJpZnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlZ3JhYmlmeSA9IGZ1bmN0aW9uIHJlZ3JhYmlmeShub2RlKSB7XG4gICAgICAgICAgaWYgKCFzLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFiYmFibGUgPSBnZXROb2RlUG9zaXRpb25EYXRhKG5vZGUsIHMpLmdyYWJiYWJsZTtcblxuICAgICAgICAgIGlmIChncmFiYmFibGUpIHtcbiAgICAgICAgICAgIG5vZGUuZ3JhYmlmeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlR3JhYlN0YXRlID0gZnVuY3Rpb24gdXBkYXRlR3JhYlN0YXRlKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Tm9kZVBvc2l0aW9uRGF0YShub2RlLCBzKS5ncmFiYmVkID0gbm9kZS5ncmFiYmVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uR3JhYiA9IGZ1bmN0aW9uIG9uR3JhYihfcmVmKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IF9yZWYudGFyZ2V0O1xuXG4gICAgICAgICAgdXBkYXRlR3JhYlN0YXRlKHRhcmdldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uRnJlZSA9IG9uR3JhYjtcblxuICAgICAgICB2YXIgb25EcmFnID0gZnVuY3Rpb24gb25EcmFnKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldDtcblxuICAgICAgICAgIHZhciBwID0gZ2V0Tm9kZVBvc2l0aW9uRGF0YSh0YXJnZXQsIHMpO1xuICAgICAgICAgIHZhciB0cCA9IHRhcmdldC5wb3NpdGlvbigpO1xuXG4gICAgICAgICAgcC54ID0gdHAueDtcbiAgICAgICAgICBwLnkgPSB0cC55O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5Ub0dyYWIgPSBmdW5jdGlvbiBsaXN0ZW5Ub0dyYWIobm9kZSkge1xuICAgICAgICAgIG5vZGUub24oJ2dyYWInLCBvbkdyYWIpO1xuICAgICAgICAgIG5vZGUub24oJ2ZyZWUnLCBvbkZyZWUpO1xuICAgICAgICAgIG5vZGUub24oJ2RyYWcnLCBvbkRyYWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1bmxpc3RlblRvR3JhYiA9IGZ1bmN0aW9uIHVubGlzdGVuVG9HcmFiKG5vZGUpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUxpc3RlbmVyKCdncmFiJywgb25HcmFiKTtcbiAgICAgICAgICBub2RlLnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcbiAgICAgICAgICBub2RlLnJlbW92ZUxpc3RlbmVyKCdkcmFnJywgb25EcmFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZml0ID0gZnVuY3Rpb24gZml0KCkge1xuICAgICAgICAgIGlmIChzLmZpdCAmJiBzLmFuaW1hdGVDb250aW51b3VzbHkpIHtcbiAgICAgICAgICAgIHMuY3kuZml0KHMucGFkZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbk5vdERvbmUgPSBmdW5jdGlvbiBvbk5vdERvbmUoKSB7XG4gICAgICAgICAgcmVmcmVzaFBvc2l0aW9ucyhzLm5vZGVzLCBzKTtcbiAgICAgICAgICBmaXQoKTtcblxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShfZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZnJhbWUgPSBmdW5jdGlvbiBfZnJhbWUoKSB7XG4gICAgICAgICAgbXVsdGl0aWNrKHMsIG9uTm90RG9uZSwgX29uRG9uZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9vbkRvbmUgPSBmdW5jdGlvbiBfb25Eb25lKCkge1xuICAgICAgICAgIHJlZnJlc2hQb3NpdGlvbnMocy5ub2Rlcywgcyk7XG4gICAgICAgICAgZml0KCk7XG5cbiAgICAgICAgICBzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJlZ3JhYmlmeShuKTtcbiAgICAgICAgICAgIHVubGlzdGVuVG9HcmFiKG4pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBsLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsLmVtaXQoJ2xheW91dHN0YXJ0Jyk7XG5cbiAgICAgICAgcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdW5ncmFiaWZ5KG4pO1xuICAgICAgICAgIGxpc3RlblRvR3JhYihuKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2ZyYW1lKCk7IC8vIGtpY2sgb2ZmXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgX29uTm90RG9uZSA9IGZ1bmN0aW9uIF9vbk5vdERvbmUoKSB7fTtcbiAgICAgICAgdmFyIF9vbkRvbmUyID0gZnVuY3Rpb24gX29uRG9uZTIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgIG11bHRpdGljayhzLCBfb25Ob3REb25lLCBfb25Eb25lMik7XG4gICAgICAgIH1cblxuICAgICAgICBzLmVsZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIHMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHBkID0gZ2V0Tm9kZVBvc2l0aW9uRGF0YShub2RlLCBzKTtcblxuICAgICAgICAgIHJldHVybiB7IHg6IHBkLngsIHk6IHBkLnkgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGwucG9zdHJ1bihzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJlcnVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcnVuKCkge31cbiAgfSwge1xuICAgIGtleTogJ3Bvc3RydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cnVuKCkge31cbiAgfSwge1xuICAgIGtleTogJ3RpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKCkge31cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5zdGF0ZS5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheW91dDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmIsIGN5KSB7XG4gIGlmIChiYiA9PSBudWxsKSB7XG4gICAgYmIgPSB7IHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KCkgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb3B5XG4gICAgYmIgPSB7IHgxOiBiYi54MSwgeDI6IGJiLngyLCB5MTogYmIueTEsIHkyOiBiYi55MiwgdzogYmIudywgaDogYmIuaCB9O1xuICB9XG5cbiAgaWYgKGJiLngyID09IG51bGwpIHtcbiAgICBiYi54MiA9IGJiLngxICsgYmIudztcbiAgfVxuICBpZiAoYmIudyA9PSBudWxsKSB7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIH1cbiAgaWYgKGJiLnkyID09IG51bGwpIHtcbiAgICBiYi55MiA9IGJiLnkxICsgYmIuaDtcbiAgfVxuICBpZiAoYmIuaCA9PSBudWxsKSB7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cblxuICByZXR1cm4gYmI7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgc2V0SW5pdGlhbFBvc2l0aW9uU3RhdGUgPSBmdW5jdGlvbiBzZXRJbml0aWFsUG9zaXRpb25TdGF0ZShub2RlLCBzdGF0ZSkge1xuICB2YXIgcCA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIGJiID0gc3RhdGUuY3VycmVudEJvdW5kaW5nQm94O1xuICB2YXIgc2NyYXRjaCA9IG5vZGUuc2NyYXRjaChzdGF0ZS5uYW1lKTtcblxuICBpZiAoc2NyYXRjaCA9PSBudWxsKSB7XG4gICAgc2NyYXRjaCA9IHt9O1xuXG4gICAgbm9kZS5zY3JhdGNoKHN0YXRlLm5hbWUsIHNjcmF0Y2gpO1xuICB9XG5cbiAgYXNzaWduKHNjcmF0Y2gsIHN0YXRlLnJhbmRvbWl6ZSA/IHtcbiAgICB4OiBiYi54MSArIE1hdGgucmFuZG9tKCkgKiBiYi53LFxuICAgIHk6IGJiLnkxICsgTWF0aC5yYW5kb20oKSAqIGJiLmhcbiAgfSA6IHtcbiAgICB4OiBwLngsXG4gICAgeTogcC55XG4gIH0pO1xuXG4gIHNjcmF0Y2gubG9ja2VkID0gbm9kZS5sb2NrZWQoKTtcbn07XG5cbnZhciBnZXROb2RlUG9zaXRpb25EYXRhID0gZnVuY3Rpb24gZ2V0Tm9kZVBvc2l0aW9uRGF0YShub2RlLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS5zY3JhdGNoKHN0YXRlLm5hbWUpO1xufTtcblxudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKG5vZGVzLCBzdGF0ZSkge1xuICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgc2NyYXRjaCA9IG5vZGUuc2NyYXRjaChzdGF0ZS5uYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBzY3JhdGNoLngsXG4gICAgICB5OiBzY3JhdGNoLnlcbiAgICB9O1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBzZXRJbml0aWFsUG9zaXRpb25TdGF0ZTogc2V0SW5pdGlhbFBvc2l0aW9uU3RhdGUsIGdldE5vZGVQb3NpdGlvbkRhdGE6IGdldE5vZGVQb3NpdGlvbkRhdGEsIHJlZnJlc2hQb3NpdGlvbnM6IHJlZnJlc2hQb3NpdGlvbnMgfTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbm9wID0gZnVuY3Rpb24gbm9wKCkge307XG5cbnZhciB0aWNrID0gZnVuY3Rpb24gdGljayhzdGF0ZSkge1xuICB2YXIgcyA9IHN0YXRlO1xuICB2YXIgbCA9IHN0YXRlLmxheW91dDtcblxuICB2YXIgdGlja0luZGljYXRlc0RvbmUgPSBsLnRpY2socyk7XG5cbiAgaWYgKHMuZmlyc3RVcGRhdGUpIHtcbiAgICBpZiAocy5hbmltYXRlQ29udGludW91c2x5KSB7XG4gICAgICAvLyBpbmRpY2F0ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgaGF2ZSBiZWVuIHNldFxuICAgICAgcy5sYXlvdXQuZW1pdCgnbGF5b3V0cmVhZHknKTtcbiAgICB9XG4gICAgcy5maXJzdFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcy50aWNrSW5kZXgrKztcblxuICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gcy5zdGFydFRpbWU7XG5cbiAgcmV0dXJuICFzLmluZmluaXRlICYmICh0aWNrSW5kaWNhdGVzRG9uZSB8fCBzLnRpY2tJbmRleCA+PSBzLm1heEl0ZXJhdGlvbnMgfHwgZHVyYXRpb24gPj0gcy5tYXhTaW11bGF0aW9uVGltZSk7XG59O1xuXG52YXIgbXVsdGl0aWNrID0gZnVuY3Rpb24gbXVsdGl0aWNrKHN0YXRlKSB7XG4gIHZhciBvbk5vdERvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vcDtcbiAgdmFyIG9uRG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbm9wO1xuXG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBzID0gc3RhdGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLnJlZnJlc2g7IGkrKykge1xuICAgIGRvbmUgPSAhcy5ydW5uaW5nIHx8IHRpY2socyk7XG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkb25lKSB7XG4gICAgb25Ob3REb25lKCk7XG4gIH0gZWxzZSB7XG4gICAgb25Eb25lKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0aWNrOiB0aWNrLCBtdWx0aXRpY2s6IG11bHRpdGljayB9O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZkMlZpY0dGamF5OTFibWwyWlhKellXeE5iMlIxYkdWRVpXWnBibWwwYVc5dUlpd2lkMlZpY0dGamF6b3ZMeTkzWldKd1lXTnJMMkp2YjNSemRISmhjQ0EyTUdGaE56aGxPVEk0TkRjMU1UaG1aREJtTXlJc0luZGxZbkJoWTJzNkx5OHZMaTl6Y21NdllYTnphV2R1TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDNOeVl5OWxkV3hsY2k5emNISnBibWN1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2YzNKakwyVjFiR1Z5TDJsdVpHVjRMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMM055WXk5bGRXeGxjaTlpYjJSNUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzTnlZeTlsZFd4bGNpOWtaV1poZFd4MGN5NXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXpjbU12WlhWc1pYSXZaSEpoWnk1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5emNtTXZaWFZzWlhJdmFXNTBaV2R5WVhSbExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzTnlZeTlsZFd4bGNpOXhkV0ZrZEhKbFpTOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5emNtTXZaWFZzWlhJdmNYVmhaSFJ5WldVdmFXNXpaWEowVTNSaFkyc3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZjM0pqTDJWMWJHVnlMM0YxWVdSMGNtVmxMMjV2WkdVdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmMzSmpMMlYxYkdWeUwzUnBZMnN1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2YzNKakwybHVaR1Y0TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDNOeVl5OXNZWGx2ZFhRdlpHVm1ZWFZzZEhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmMzSmpMMnhoZVc5MWRDOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5emNtTXZiR0Y1YjNWMEwyMWhhMlV0WW1JdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmMzSmpMMnhoZVc5MWRDOXdiM05wZEdsdmJpNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXpjbU12YkdGNWIzVjBMM1JwWTJzdWFuTWlYU3dpYm1GdFpYTWlPbHNpYlc5a2RXeGxJaXdpWlhod2IzSjBjeUlzSWs5aWFtVmpkQ0lzSW1GemMybG5iaUlzSW1KcGJtUWlMQ0owWjNRaUxDSnpjbU56SWl3aVptOXlSV0ZqYUNJc0ltdGxlWE1pTENKemNtTWlMQ0pySWl3aWNtVnhkV2x5WlNJc0ltUmxabUYxYkhSeklpd2labkpsWlhwbElpd2ljMjkxY21ObElpd2lkR0Z5WjJWMElpd2liR1Z1WjNSb0lpd2lZMjlsWm1ZaUxDSjNaV2xuYUhRaUxDSnRZV3RsVTNCeWFXNW5JaXdpYzNCeWFXNW5JaXdpWVhCd2JIbFRjSEpwYm1jaUxDSmliMlI1TVNJc0ltSnZaSGt5SWl3aVpIZ2lMQ0p3YjNNaUxDSjRJaXdpWkhraUxDSjVJaXdpY2lJc0lrMWhkR2dpTENKemNYSjBJaXdpY21GdVpHOXRJaXdpWkNJc0luTndjbWx1WjBOdlpXWm1JaXdpWm05eVkyVWlMQ0pNWVhsdmRYUWlMQ0owYVdOcklpd2liV0ZyWlZGMVlXUjBjbVZsSWl3aWJXRnJaVUp2WkhraUxDSnBjMFp1SWl3aVptNGlMQ0pwYzFCaGNtVnVkQ0lzSW00aUxDSnViM1JKYzFCaGNtVnVkQ0lzSW1selRHOWphMlZrSWl3aWJHOWphMlZrSWl3aWJtOTBTWE5NYjJOclpXUWlMQ0pwYzFCaGNtVnVkRVZrWjJVaUxDSmxJaXdpYm05MFNYTlFZWEpsYm5SRlpHZGxJaXdpWjJWMFFtOWtlU0lzSW5OamNtRjBZMmdpTENKaWIyUjVJaXdpWjJWMFRtOXVVR0Z5Wlc1MFJHVnpZMlZ1WkdGdWRITWlMQ0prWlhOalpXNWtZVzUwY3lJc0ltWnBiSFJsY2lJc0ltZGxkRk5qY21GMFkyZ2lMQ0psYkNJc0ltOXdkRVp1SWl3aWIzQjBJaXdpWld4bElpd2lSWFZzWlhJaUxDSnZjSFJwYjI1eklpd2ljM1JoZEdVaUxDSnpJaXdpY1hWaFpIUnlaV1VpTENKaWIyUnBaWE1pTENKdWIyUmxjeUlzSW0xaGMzTWlMQ0pmWTNsT2IyUmxJaXdpWDNOamNtRjBZMmdpTENKd2RYTm9JaXdpYzNCeWFXNW5jeUlzSW1Wa1oyVnpJaXdpYzNCeWFXNW5UR1Z1WjNSb0lpd2lYMk41UldSblpTSXNJbk52ZFhKalpYTWlMQ0owWVhKblpYUnpJaXdpYlc5MlpXMWxiblFpTENKcGMwUnZibVVpTENKdGIzWmxiV1Z1ZEZSb2NtVnphRzlzWkNJc0luQnlaWFpRYjNNaUxDSjJaV3h2WTJsMGVTSXNJbU52Y0hsV1pXTWlMQ0oySWl3aVoyVjBWbUZzZFdVaUxDSjJZV3dpTENKa1pXWWlMQ0puWlhSV1pXTWlMQ0oyWldNaUxDSnZjSFJ6SWl3aVlpSXNJbWR5WVhacGRIa2lMQ0p3ZFd4c0lpd2lkR2hsZEdFaUxDSmtjbUZuUTI5bFptWWlMQ0owYVcxbFUzUmxjQ0lzSW1SbFptRjFiSFJEYjJWbVppSXNJbUZ3Y0d4NVJISmhaeUlzSW0xaGJuVmhiRVJ5WVdkRGIyVm1aaUlzSW1sdWRHVm5jbUYwWlNJc0luUjRJaXdpZEhraUxDSnBJaXdpYldGNElpd2laM0poWW1KbFpDSXNJblo0SWl3aWRua2lMQ0poWW5NaUxDSk9iMlJsSWl3aVNXNXpaWEowVTNSaFkyc2lMQ0p5WlhObGRGWmxZeUlzSW1selUyRnRaVkJ2YzJsMGFXOXVJaXdpY0RFaUxDSndNaUlzSW5Sb2NtVnphRzlzWkNJc0luVndaR0YwWlZGMVpYVmxJaXdpYVc1elpYSjBVM1JoWTJzaUxDSnViMlJsYzBOaFkyaGxJaXdpWTNWeWNtVnVkRWx1UTJGamFHVWlMQ0p5YjI5MElpd2libVYzVG05a1pTSXNJbTV2WkdVaUxDSnhkV0ZrTUNJc0luRjFZV1F4SWl3aWNYVmhaRElpTENKeGRXRmtNeUlzSW0xaGMzTllJaXdpYldGemMxa2lMQ0pzWldaMElpd2ljbWxuYUhRaUxDSjBiM0FpTENKaWIzUjBiMjBpTENKMWNHUmhkR1VpTENKemIzVnlZMlZDYjJSNUlpd2ljWFZsZFdVaUxDSm1lQ0lzSW1aNUlpd2ljWFZsZFdWTVpXNW5kR2dpTENKemFHbG1kRWxrZUNJc0luQjFjMmhKWkhnaUxDSndlQ0lzSW5CNUlpd2ljSElpTENKd2RpSXNJbVJwWm1abGNtVnVkRUp2WkhraUxDSnBibk5sY25SQ2IyUnBaWE1pTENKNE1TSXNJazUxYldKbGNpSXNJazFCV0Y5V1FVeFZSU0lzSW5reElpd2llRElpTENKTlNVNWZWa0ZNVlVVaUxDSjVNaUlzSW1sdWMyVnlkQ0lzSW01bGQwSnZaSGtpTENKeVpYTmxkQ0lzSW1selJXMXdkSGtpTENKemRHRmphMGwwWlcwaUxDSndiM0FpTENKeGRXRmtTV1I0SWl3aVkyaHBiR1FpTENKblpYUkRhR2xzWkNJc0luTmxkRU5vYVd4a0lpd2liMnhrUW05a2VTSXNJbkpsZEhKcFpYTkRiM1Z1ZENJc0ltOW1abk5sZENJc0luVndaR0YwWlVKdlpIbEdiM0pqWlNJc0ltbGtlQ0lzSW5OMFlXTnJJaXdpY0c5d1NXUjRJaXdpY0hKdmRHOTBlWEJsSWl3aWFYUmxiU0lzSWtsdWMyVnlkRk4wWVdOclJXeGxiV1Z1ZENJc0luQWlMQ0p5WldkcGMzUmxjaUlzSW1ONWRHOXpZMkZ3WlNJc0ltRnVhVzFoZEdVaUxDSnlaV1p5WlhOb0lpd2liV0Y0U1hSbGNtRjBhVzl1Y3lJc0ltMWhlRk5wYlhWc1lYUnBiMjVVYVcxbElpd2lkVzVuY21GaWFXWjVWMmhwYkdWVGFXMTFiR0YwYVc1bklpd2labWwwSWl3aWNHRmtaR2x1WnlJc0ltSnZkVzVrYVc1blFtOTRJaXdpZFc1a1pXWnBibVZrSWl3aWNtVmhaSGtpTENKemRHOXdJaXdpY21GdVpHOXRhWHBsSWl3aWFXNW1hVzVwZEdVaUxDSnRZV3RsUW05MWJtUnBibWRDYjNnaUxDSnpaWFJKYm1sMGFXRnNVRzl6YVhScGIyNVRkR0YwWlNJc0luSmxabkpsYzJoUWIzTnBkR2x2Ym5NaUxDSm5aWFJPYjJSbFVHOXphWFJwYjI1RVlYUmhJaXdpYlhWc2RHbDBhV05ySWl3aWJ5SXNJbXhoZVc5MWRDSXNJbVZzWlhNaUxDSjBhV05yU1c1a1pYZ2lMQ0ptYVhKemRGVndaR0YwWlNJc0ltRnVhVzFoZEdWRmJtUWlMQ0poYm1sdFlYUmxRMjl1ZEdsdWRXOTFjMng1SWl3aWJDSXNJbk4wWVhKMFZHbHRaU0lzSWtSaGRHVWlMQ0p1YjNjaUxDSnlkVzV1YVc1bklpd2lZM1Z5Y21WdWRFSnZkVzVrYVc1blFtOTRJaXdpWTNraUxDSnZibVVpTENKd2NtVnlkVzRpTENKMWJtZHlZV0pwWm5raUxDSm5jbUZpWW1GaWJHVWlMQ0p5WldkeVlXSnBabmtpTENKbmNtRmlhV1o1SWl3aWRYQmtZWFJsUjNKaFlsTjBZWFJsSWl3aWIyNUhjbUZpSWl3aWIyNUdjbVZsSWl3aWIyNUVjbUZuSWl3aWRIQWlMQ0p3YjNOcGRHbHZiaUlzSW14cGMzUmxibFJ2UjNKaFlpSXNJbTl1SWl3aWRXNXNhWE4wWlc1VWIwZHlZV0lpTENKeVpXMXZkbVZNYVhOMFpXNWxjaUlzSW05dVRtOTBSRzl1WlNJc0luSmxjWFZsYzNSQmJtbHRZWFJwYjI1R2NtRnRaU0lzSW1aeVlXMWxJaXdpYjI1RWIyNWxJaXdpWlcxcGRDSXNJbVJ2Ym1VaUxDSnNZWGx2ZFhSUWIzTnBkR2x2Ym5NaUxDSndaQ0lzSW5CdmMzUnlkVzRpTENKaVlpSXNJbmNpTENKM2FXUjBhQ0lzSW1naUxDSm9aV2xuYUhRaUxDSnVZVzFsSWl3aWNHOXphWFJwYjI1eklpd2libTl3SWl3aWRHbGphMGx1WkdsallYUmxjMFJ2Ym1VaUxDSmtkWEpoZEdsdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXp0QlFVTkVMRTg3UVVOV1FUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzYlVSQlFUSkRMR05CUVdNN08wRkJSWHBFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWVVGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVOQlFUSkNMREJDUVVFd1FpeEZRVUZGTzBGQlEzWkVMSGxEUVVGcFF5eGxRVUZsTzBGQlEyaEVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTERoRVFVRnpSQ3dyUkVGQkswUTdPMEZCUlhKSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN096czdPenM3T3p0QlEyaEZRVUVzVDBGQlQwTXNUMEZCVUN4SFFVRnBRa01zVDBGQlQwTXNUVUZCVUN4SlFVRnBRaXhKUVVGcVFpeEhRVUYzUWtRc1QwRkJUME1zVFVGQlVDeERRVUZqUXl4SlFVRmtMRU5CUVc5Q1JpeE5RVUZ3UWl4RFFVRjRRaXhIUVVGMVJDeFZRVUZWUnl4SFFVRldMRVZCUVhkQ08wRkJRVUVzYjBOQlFVNURMRWxCUVUwN1FVRkJUa0VzVVVGQlRUdEJRVUZCT3p0QlFVTTVSa0VzVDBGQlMwTXNUMEZCVEN4RFFVRmpMR1ZCUVU4N1FVRkRia0pNTEZkQlFVOU5MRWxCUVZBc1EwRkJZVU1zUjBGQllpeEZRVUZ0UWtZc1QwRkJia0lzUTBGQk5FSTdRVUZCUVN4aFFVRkxSaXhKUVVGSlN5eERRVUZLTEVsQlFWTkVMRWxCUVVsRExFTkJRVW9zUTBGQlpEdEJRVUZCTEV0QlFUVkNPMEZCUTBRc1IwRkdSRHM3UVVGSlFTeFRRVUZQVEN4SFFVRlFPMEZCUTBRc1EwRk9SQ3hET3pzN096czdPenM3UVVOQlFTeEpRVUZOUml4VFFVRlRMRzFDUVVGQlVTeERRVUZSTEVOQlFWSXNRMEZCWmpzN1FVRkZRU3hKUVVGTlF5eFhRVUZYVml4UFFVRlBWeXhOUVVGUUxFTkJRV003UVVGRE4wSkRMRlZCUVZFc1NVRkVjVUk3UVVGRk4wSkRMRlZCUVZFc1NVRkdjVUk3UVVGSE4wSkRMRlZCUVZFc1JVRkljVUk3UVVGSk4wSkRMRk5CUVU4c1RVRktjMEk3UVVGTE4wSkRMRlZCUVZFN1FVRk1jVUlzUTBGQlpDeERRVUZxUWpzN1FVRlJRU3hUUVVGVFF5eFZRVUZVTEVOQlFYRkNReXhOUVVGeVFpeEZRVUUyUWp0QlFVTXpRaXhUUVVGUGFrSXNUMEZCVVN4RlFVRlNMRVZCUVZsVExGRkJRVm9zUlVGQmMwSlJMRTFCUVhSQ0xFTkJRVkE3UVVGRFJEczdRVUZGUkN4VFFVRlRReXhYUVVGVUxFTkJRWE5DUkN4TlFVRjBRaXhGUVVFNFFqdEJRVU0xUWl4TlFVRkpSU3hSUVVGUlJpeFBRVUZQVGl4TlFVRnVRanRCUVVGQkxFMUJRMGxUTEZGQlFWRklMRTlCUVU5TUxFMUJSRzVDTzBGQlFVRXNUVUZGU1VNc1UwRkJVMGtzVDBGQlQwb3NUVUZCVUN4SFFVRm5RaXhEUVVGb1FpeEhRVUZ2UWtvc1UwRkJVMGtzVFVGQk4wSXNSMEZCYzBOSkxFOUJRVTlLTEUxQlJqRkVPMEZCUVVFc1RVRkhTVkVzUzBGQlMwUXNUVUZCVFVVc1IwRkJUaXhEUVVGVlF5eERRVUZXTEVkQlFXTktMRTFCUVUxSExFZEJRVTRzUTBGQlZVTXNRMEZJYWtNN1FVRkJRU3hOUVVsSlF5eExRVUZMU2l4TlFVRk5SU3hIUVVGT0xFTkJRVlZITEVOQlFWWXNSMEZCWTA0c1RVRkJUVWNzUjBGQlRpeERRVUZWUnl4RFFVcHFRenRCUVVGQkxFMUJTMGxETEVsQlFVbERMRXRCUVV0RExFbEJRVXdzUTBGQlZWQXNTMEZCUzBFc1JVRkJUQ3hIUVVGVlJ5eExRVUZMUVN4RlFVRjZRaXhEUVV4U096dEJRVTlCTEUxQlFVbEZMRTFCUVUwc1EwRkJWaXhGUVVGaE8wRkJRMVJNTEZOQlFVc3NRMEZCUTAwc1MwRkJTMFVzVFVGQlRDeExRVUZuUWl4SFFVRnFRaXhKUVVGM1FpeEZRVUUzUWp0QlFVTkJUQ3hUUVVGTExFTkJRVU5ITEV0QlFVdEZMRTFCUVV3c1MwRkJaMElzUjBGQmFrSXNTVUZCZDBJc1JVRkJOMEk3UVVGRFFVZ3NVVUZCU1VNc1MwRkJTME1zU1VGQlRDeERRVUZWVUN4TFFVRkxRU3hGUVVGTUxFZEJRVlZITEV0QlFVdEJMRVZCUVhwQ0xFTkJRVW83UVVGRFNEczdRVUZGUkN4TlFVRkpUU3hKUVVGSlNpeEpRVUZKWWl4TlFVRmFPMEZCUTBFc1RVRkJTVU1zVVVGQlVTeERRVUZGTEVOQlFVTkhMRTlCUVU5SUxFdEJRVklzU1VGQmFVSkhMRTlCUVU5SUxFdEJRVkFzUjBGQlpTeERRVUZxUXl4SFFVRnpRMHdzVTBGQlUzTkNMRmRCUVM5RExFZEJRVFpFWkN4UFFVRlBTQ3hMUVVGeVJTeEpRVUU0UldkQ0xFTkJRVGxGTEVkQlFXdEdTaXhEUVVGc1JpeEhRVUZ6UmxRc1QwRkJUMFlzVFVGQmVrYzdPMEZCUlVGSkxGRkJRVTFoTEV0QlFVNHNRMEZCV1ZRc1EwRkJXaXhKUVVGcFFsUXNVVUZCVVU4c1JVRkJla0k3UVVGRFFVWXNVVUZCVFdFc1MwRkJUaXhEUVVGWlVDeERRVUZhTEVsQlFXbENXQ3hSUVVGUlZTeEZRVUY2UWpzN1FVRkZRVW9zVVVGQlRWa3NTMEZCVGl4RFFVRlpWQ3hEUVVGYUxFbEJRV2xDVkN4UlFVRlJUeXhGUVVGNlFqdEJRVU5CUkN4UlFVRk5XU3hMUVVGT0xFTkJRVmxRTEVOQlFWb3NTVUZCYVVKWUxGRkJRVkZWTEVWQlFYcENPMEZCUTBRN08wRkJSVVF6UWl4UFFVRlBReXhQUVVGUUxFZEJRV2xDTEVWQlFVVnJRaXh6UWtGQlJpeEZRVUZqUlN4M1FrRkJaQ3hGUVVGcVFpeERPenM3T3pzN096czdPenM3T3pzN096dEJRM1JEUVRzN096dEJRVWxCTEVsQlFVMWxMRk5CUVZNc2JVSkJRVUY2UWl4RFFVRlJMRVZCUVZJc1EwRkJaanRCUVVOQkxFbEJRVTFTTEZOQlFWTXNiVUpCUVVGUkxFTkJRVkVzUTBGQlVpeERRVUZtTzBGQlEwRXNTVUZCVFVNc1YwRkJWeXh0UWtGQlFVUXNRMEZCVVN4RFFVRlNMRU5CUVdwQ096dGxRVU5wUWl4dFFrRkJRVUVzUTBGQlVTeEZRVUZTTEVNN1NVRkJWREJDTEVzc1dVRkJRVUVzU1RzN1owSkJRMmxDTEcxQ1FVRkJNVUlzUTBGQlVTeERRVUZTTEVNN1NVRkJha0l5UWl4WkxHRkJRVUZCTEZrN08yZENRVU5oTEcxQ1FVRkJNMElzUTBGQlVTeERRVUZTTEVNN1NVRkJZalJDTEZFc1lVRkJRVUVzVVRzN1owSkJRMlVzYlVKQlFVRTFRaXhEUVVGUkxFTkJRVklzUXp0SlFVRm1VU3hWTEdGQlFVRkJMRlU3TzBGQlExSXNTVUZCVFhGQ0xFOUJRVThzVTBGQlVFRXNTVUZCVHp0QlFVRkJMRk5CUVUwc1QwRkJUME1zUlVGQlVDeExRVUZqTEZWQlFYQkNPMEZCUVVFc1EwRkJZanRCUVVOQkxFbEJRVTFETEZkQlFWY3NVMEZCV0VFc1VVRkJWenRCUVVGQkxGTkJRVXRETEVWQlFVVkVMRkZCUVVZc1JVRkJURHRCUVVGQkxFTkJRV3BDTzBGQlEwRXNTVUZCVFVVc1kwRkJZeXhUUVVGa1FTeFhRVUZqTzBGQlFVRXNVMEZCU3l4RFFVRkRSaXhUUVVGVFF5eERRVUZVTEVOQlFVNDdRVUZCUVN4RFFVRndRanRCUVVOQkxFbEJRVTFGTEZkQlFWY3NVMEZCV0VFc1VVRkJWenRCUVVGQkxGTkJRVXRHTEVWQlFVVkhMRTFCUVVZc1JVRkJURHRCUVVGQkxFTkJRV3BDTzBGQlEwRXNTVUZCVFVNc1kwRkJZeXhUUVVGa1FTeFhRVUZqTzBGQlFVRXNVMEZCU3l4RFFVRkRSaXhUUVVGVFJpeERRVUZVTEVOQlFVNDdRVUZCUVN4RFFVRndRanRCUVVOQkxFbEJRVTFMTEdWQlFXVXNVMEZCWmtFc1dVRkJaVHRCUVVGQkxGTkJRVXRPTEZOQlFWVlBMRVZCUVVWdVF5eE5RVUZHTEVWQlFWWXNTMEZCTUVJMFFpeFRRVUZWVHl4RlFVRkZiRU1zVFVGQlJpeEZRVUZXTEVOQlFTOUNPMEZCUVVFc1EwRkJja0k3UVVGRFFTeEpRVUZOYlVNc2EwSkJRV3RDTEZOQlFXeENRU3hsUVVGclFqdEJRVUZCTEZOQlFVc3NRMEZCUTBZc1lVRkJZVU1zUTBGQllpeERRVUZPTzBGQlFVRXNRMEZCZUVJN1FVRkRRU3hKUVVGTlJTeFZRVUZWTEZOQlFWWkJMRTlCUVZVN1FVRkJRU3hUUVVGTFVpeEZRVUZGVXl4UFFVRkdMRU5CUVZVc1QwRkJWaXhGUVVGdFFrTXNTVUZCZUVJN1FVRkJRU3hEUVVGb1FqdEJRVU5CTEVsQlFVMURMREJDUVVFd1FpeFRRVUV4UWtFc2RVSkJRVEJDTzBGQlFVRXNVMEZCUzFvc1UwRkJVME1zUTBGQlZDeEpRVUZqUVN4RlFVRkZXU3hYUVVGR0xFZEJRV2RDUXl4TlFVRm9RaXhEUVVGM1Fsb3NWMEZCZUVJc1EwRkJaQ3hIUVVGelJFUXNRMEZCTTBRN1FVRkJRU3hEUVVGb1F6czdRVUZGUVN4SlFVRk5ZeXhoUVVGaExGTkJRV0pCTEZWQlFXRXNTMEZCVFR0QlFVTjJRaXhOUVVGSlRDeFZRVUZWVFN4SFFVRkhUaXhQUVVGSUxFTkJRVmNzVDBGQldDeERRVUZrT3p0QlFVVkJMRTFCUVVrc1EwRkJRMEVzVDBGQlRDeEZRVUZqTzBGQlExcEJMR05CUVZVc1JVRkJWanM3UVVGRlFVMHNUMEZCUjA0c1QwRkJTQ3hEUVVGWExFOUJRVmdzUlVGQmIwSkJMRTlCUVhCQ08wRkJRMFE3TzBGQlJVUXNVMEZCVDBFc1QwRkJVRHRCUVVORUxFTkJWa1E3TzBGQldVRXNTVUZCVFU4c1VVRkJVU3hUUVVGU1FTeExRVUZSTEVOQlFVVkRMRWRCUVVZc1JVRkJUME1zUjBGQlVDeEZRVUZuUWp0QlFVTTFRaXhOUVVGSmNrSXNTMEZCVFc5Q0xFZEJRVTRzUTBGQlNpeEZRVUZwUWp0QlFVTm1MRmRCUVU5QkxFbEJRVXRETEVkQlFVd3NRMEZCVUR0QlFVTkVMRWRCUmtRc1RVRkZUenRCUVVOTUxGZEJRVTlFTEVkQlFWQTdRVUZEUkR0QlFVTkdMRU5CVGtRN08wbEJVVTFGTEVzN096dEJRVU5LTEdsQ1FVRmhReXhQUVVGaUxFVkJRWE5DTzBGQlFVRTdPMEZCUVVFc2VVZEJRMkkxUkN4UFFVRlJMRVZCUVZJc1JVRkJXVk1zVVVGQldpeEZRVUZ6UW0xRUxFOUJRWFJDTEVOQlJHRTdRVUZGY2tJN096czdNa0pCUlU5RExFc3NSVUZCVHp0QlFVTmlMRlZCUVVsRExFbEJRVWxFTEV0QlFWSTdPMEZCUlVGRExGRkJRVVZETEZGQlFVWXNSMEZCWVRWQ0xHTkJRV0k3TzBGQlJVRXNWVUZCU1RaQ0xGTkJRVk5HTEVWQlFVVkZMRTFCUVVZc1IwRkJWeXhGUVVGNFFqczdRVUZGUVR0QlFVTkJSaXhSUVVGRlJ5eExRVUZHTEVOQlFWRmFMRTFCUVZJc1EwRkJaMEk3UVVGQlFTeGxRVUZMV2l4WlFVRlpSQ3hEUVVGYUxFTkJRVXc3UVVGQlFTeFBRVUZvUWl4RlFVRnpRM0JETEU5QlFYUkRMRU5CUVN0RExHRkJRVXM3UVVGRGJFUXNXVUZCU1RaRExGVkJRVlZMTEZkQlFWbGtMRU5CUVZvc1EwRkJaRHM3UVVGRlFTeFpRVUZKVlN4UFFVRlBaQ3hUUVVGVE8wRkJRMnhDWkN4bFFVRkxMRVZCUVVWRExFZEJRVWN3UWl4UlFVRlJNVUlzUTBGQllpeEZRVUZuUWtVc1IwRkJSM2RDTEZGQlFWRjRRaXhEUVVFelFpeEZRVVJoTzBGQlJXeENlVU1zWjBKQlFVMVdMRTFCUVU5TkxFVkJRVVZKTEVsQlFWUXNSVUZCWlRGQ0xFTkJRV1lzUTBGR1dUdEJRVWRzUWtjc2EwSkJRVkZOTEZGQlFWRk9PMEZCU0VVc1UwRkJWQ3hEUVVGWU96dEJRVTFCVHl4aFFVRkxhVUlzVDBGQlRDeEhRVUZsTTBJc1EwRkJaanM3UVVGRlFWTXNaMEpCUVZGRExFbEJRVklzUjBGQlpVRXNTVUZCWmpzN1FVRkZRVUVzWVVGQlMydENMRkZCUVV3c1IwRkJaMEp1UWl4UFFVRm9RanM3UVVGRlFXVXNaVUZCVDBzc1NVRkJVQ3hEUVVGaGJrSXNTVUZCWWp0QlFVTkVMRTlCYUVKRU96dEJRV3RDUVN4VlFVRkpiMElzVlVGQlZWSXNSVUZCUlZFc1QwRkJSaXhIUVVGWkxFVkJRVEZDT3p0QlFVVkJPMEZCUTBGU0xGRkJRVVZUTEV0QlFVWXNRMEZCVVd4Q0xFMUJRVklzUTBGQlowSk9MR1ZCUVdoQ0xFVkJRV3RETTBNc1QwRkJiRU1zUTBGQk1rTXNZVUZCU3p0QlFVTTVReXhaUVVGSllTeFRRVUZUUkN4WFFVRlhPMEZCUTNSQ1RDeHJRa0ZCVVhGRExGRkJRVk5HTEVWQlFVVnVReXhOUVVGR0xFVkJRVlFzUTBGRVl6dEJRVVYwUWtNc2EwSkJRVkZ2UXl4UlFVRlRSaXhGUVVGRmJFTXNUVUZCUml4RlFVRlVMRU5CUm1NN1FVRkhkRUpETEd0Q1FVRlJNa01zVFVGQlQwMHNSVUZCUlZVc1dVRkJWQ3hGUVVGMVFqRkNMRU5CUVhaQ0xFTkJTR003UVVGSmRFSm9ReXhwUWtGQlR6QkRMRTFCUVU5TkxFVkJRVVV2UWl4WFFVRlVMRVZCUVhOQ1pTeERRVUYwUWp0QlFVcGxMRk5CUVZnc1EwRkJZanM3UVVGUFFUZENMR1ZCUVU5M1JDeFBRVUZRTEVkQlFXbENNMElzUTBGQmFrSTdPMEZCUlVFc1dVRkJTVWNzVlVGQlZVc3NWMEZCV1ZJc1EwRkJXaXhEUVVGa096dEJRVVZCTjBJc1pVRkJUMjFFTEZGQlFWQXNSMEZCYTBKdVFpeFBRVUZzUWpzN1FVRkZRVUVzWjBKQlFWRm9ReXhOUVVGU0xFZEJRV2xDUVN4TlFVRnFRanM3UVVGRlFYRkVMR2RDUVVGUlJDeEpRVUZTTEVOQlFXTndSQ3hOUVVGa08wRkJRMFFzVDBGcVFrUTdPMEZCYlVKQk8wRkJRMEUyUXl4UlFVRkZVeXhMUVVGR0xFTkJRVkZzUWl4TlFVRlNMRU5CUVdkQ1VpeFpRVUZvUWl4RlFVRXJRbnBETEU5QlFTOUNMRU5CUVhkRExHRkJRVXM3UVVGRE0wTXNXVUZCU1hORkxGVkJRVlYyUWl4M1FrRkJlVUpNTEVWQlFVVnVReXhOUVVGR0xFVkJRWHBDTEVOQlFXUTdRVUZEUVN4WlFVRkpaMFVzVlVGQlZYaENMSGRDUVVGNVFrd3NSVUZCUld4RExFMUJRVVlzUlVGQmVrSXNRMEZCWkRzN1FVRkZRVHRCUVVOQk9FUXNhMEpCUVZVc1EwRkJSVUVzVVVGQlVTeERRVUZTTEVOQlFVWXNRMEZCVmp0QlFVTkJReXhyUWtGQlZTeERRVUZGUVN4UlFVRlJMRU5CUVZJc1EwRkJSaXhEUVVGV096dEJRVVZCUkN4blFrRkJVWFJGTEU5QlFWSXNRMEZCYVVJc1pVRkJUenRCUVVOMFFuVkZMR3RDUVVGUmRrVXNUMEZCVWl4RFFVRnBRaXhsUVVGUE8wRkJRM1JDYTBVc2IwSkJRVkZFTEVsQlFWSXNRMEZCWTNKRUxGZEJRVmM3UVVGRGRrSk1MSE5DUVVGUmNVTXNVVUZCVXpGRExFZEJRVlFzUTBGRVpUdEJRVVYyUWswc2MwSkJRVkZ2UXl4UlFVRlRPVU1zUjBGQlZDeERRVVpsTzBGQlIzWkNWeXh6UWtGQlVUSkRMRTFCUVU5TkxFVkJRVVZWTEZsQlFWUXNSVUZCZFVJeFFpeERRVUYyUWl4RFFVaGxPMEZCU1haQ2FFTXNjVUpCUVU4d1F5eE5RVUZQVFN4RlFVRkZMMElzVjBGQlZDeEZRVUZ6UW1Vc1EwRkJkRUk3UVVGS1owSXNZVUZCV0N4RFFVRmtPMEZCVFVRc1YwRlFSRHRCUVZGRUxGTkJWRVE3UVVGVlJDeFBRV3hDUkR0QlFXMUNSRHM3TzNsQ1FVVkxaU3hMTEVWQlFVODdRVUZEV0N4VlFVRkpaU3hYUVVGWE1VTXNUVUZCVFRKQ0xFdEJRVTRzUTBGQlpqczdRVUZGUVN4VlFVRkpaMElzVTBGQlUwUXNXVUZCV1dZc1RVRkJUV2xDTEdsQ1FVRXZRanM3UVVGRlFTeGhRVUZQUkN4TlFVRlFPMEZCUTBRN096czdSVUZxUm1sQ05VTXNUVHM3UVVGdlJuQkNjRU1zVDBGQlQwTXNUMEZCVUN4SFFVRnBRalpFTEV0QlFXcENMRU03T3pzN096czdPenRCUXpkSVFTeEpRVUZOYkVRc1YwRkJWMVlzVDBGQlQxY3NUVUZCVUN4RFFVRmpPMEZCUXpkQ1dTeFBRVUZMTEVWQlFVVkRMRWRCUVVjc1EwRkJUQ3hGUVVGUlJTeEhRVUZITEVOQlFWZ3NSVUZFZDBJN1FVRkZOMEp6UkN4WFFVRlRMRVZCUVVWNFJDeEhRVUZITEVOQlFVd3NSVUZCVVVVc1IwRkJSeXhEUVVGWUxFVkJSbTlDTzBGQlJ6ZENUeXhUUVVGUExFVkJRVVZVTEVkQlFVY3NRMEZCVEN4RlFVRlJSU3hIUVVGSExFTkJRVmdzUlVGSWMwSTdRVUZKTjBKMVJDeFpRVUZWTEVWQlFVVjZSQ3hIUVVGSExFTkJRVXdzUlVGQlVVVXNSMEZCUnl4RFFVRllMRVZCU20xQ08wRkJTemRDZVVNc1VVRkJUVHRCUVV4MVFpeERRVUZrTEVOQlFXcENPenRCUVZGQkxFbEJRVTFsTEZWQlFWVXNVMEZCVmtFc1QwRkJWVHRCUVVGQkxGTkJRVTBzUlVGQlJURkVMRWRCUVVjeVJDeEZRVUZGTTBRc1EwRkJVQ3hGUVVGVlJTeEhRVUZIZVVRc1JVRkJSWHBFTEVOQlFXWXNSVUZCVGp0QlFVRkJMRU5CUVdoQ08wRkJRMEVzU1VGQlRUQkVMRmRCUVZjc1UwRkJXRUVzVVVGQlZ5eERRVUZGUXl4SFFVRkdMRVZCUVU5RExFZEJRVkE3UVVGQlFTeFRRVUZuUWtRc1QwRkJUeXhKUVVGUUxFZEJRV05CTEVkQlFXUXNSMEZCYjBKRExFZEJRWEJETzBGQlFVRXNRMEZCYWtJN1FVRkRRU3hKUVVGTlF5eFRRVUZUTEZOQlFWUkJMRTFCUVZNc1EwRkJSVU1zUjBGQlJpeEZRVUZQUml4SFFVRlFPMEZCUVVFc1UwRkJaMEpLTEZGQlFWTkZMRk5CUVZWSkxFZEJRVllzUlVGQlpVWXNSMEZCWml4RFFVRlVMRU5CUVdoQ08wRkJRVUVzUTBGQlpqczdRVUZGUVN4VFFVRlRha1FzVVVGQlZDeERRVUZ0UW05RUxFbEJRVzVDTEVWQlFYbENPMEZCUTNaQ0xFMUJRVWxETEVsQlFVa3NSVUZCVWpzN1FVRkZRVUVzU1VGQlJXNUZMRWRCUVVZc1IwRkJVV2RGTEU5QlFWRkZMRXRCUVV0c1JTeEhRVUZpTEVWQlFXdENZaXhUUVVGVFlTeEhRVUV6UWl4RFFVRlNPMEZCUTBGdFJTeEpRVUZGVml4UFFVRkdMRWRCUVZsUExFOUJRVkZGTEV0QlFVdFVMRTlCUVdJc1JVRkJjMEpWTEVWQlFVVnVSU3hIUVVGNFFpeERRVUZhTzBGQlEwRnRSU3hKUVVGRmVrUXNTMEZCUml4SFFVRlZjMFFzVDBGQlVVVXNTMEZCUzNoRUxFdEJRV0lzUlVGQmIwSjJRaXhUUVVGVGRVSXNTMEZCTjBJc1EwRkJWanRCUVVOQmVVUXNTVUZCUlZRc1VVRkJSaXhIUVVGaFRTeFBRVUZSUlN4TFFVRkxVaXhSUVVGaUxFVkJRWFZDZGtVc1UwRkJVM1ZGTEZGQlFXaERMRU5CUVdJN1FVRkRRVk1zU1VGQlJYWkNMRWxCUVVZc1IwRkJVM05DTEV0QlFVdDBRaXhKUVVGTUxFbEJRV0VzU1VGQllpeEhRVUZ2UW5OQ0xFdEJRVXQwUWl4SlFVRjZRaXhIUVVGblEzcEVMRk5CUVZONVJDeEpRVUZzUkR0QlFVTkJkVUlzU1VGQlJUbERMRTFCUVVZc1IwRkJWelpETEV0QlFVczNReXhOUVVGb1FqczdRVUZGUVN4VFFVRlBPRU1zUTBGQlVEdEJRVU5FT3p0QlFVVkVOVVlzVDBGQlQwTXNUMEZCVUN4SFFVRnBRaXhGUVVGRmMwTXNhMEpCUVVZc1JVRkJha0lzUXpzN096czdPenM3TzBGRGVrSkJMRWxCUVUwelFpeFhRVUZYVml4UFFVRlBWeXhOUVVGUUxFTkJRV003UVVGRE4wSTdRVUZEUVR0QlFVTkJPMEZCUTBFNFJDeG5Ra0ZCWXp0QlFVRkJMRmRCUVZFc1JVRkJVanRCUVVGQkxFZEJTbVU3TzBGQlRUZENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEY2UXl4bFFVRmhPMEZCUVVFc1YwRkJVU3hOUVVGU08wRkJRVUVzUjBGV1owSTdPMEZCV1RkQ08wRkJRMEU3UVVGRFFXMURMRkZCUVUwN1FVRkJRU3hYUVVGUkxFTkJRVkk3UVVGQlFTeEhRV1IxUWpzN1FVRm5RamRDTzBGQlEwRTdRVUZEUVR0QlFVTkJkMElzVjBGQlV5eERRVUZETEVkQmJrSnRRanM3UVVGeFFqZENPMEZCUTBFN1FVRkRRVU1zVVVGQlRTeExRWFpDZFVJN08wRkJlVUkzUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQlF5eFRRVUZQTEV0Qk4wSnpRanM3UVVFclFqZENPMEZCUTBGRExHRkJRVmNzU1VGb1EydENPenRCUVd0RE4wSTdRVUZEUVdZc2NVSkJRVzFDTEVOQmJrTlZPenRCUVhGRE4wSTdRVUZEUVR0QlFVTkJPMEZCUTBGblFpeFpRVUZWTzBGQmVFTnRRaXhEUVVGa0xFTkJRV3BDT3p0QlFUSkRRV3BITEU5QlFVOURMRTlCUVZBc1IwRkJhVUpYTEZGQlFXcENMRU03T3pzN096czdPenRCUXpORFFTeEpRVUZOYzBZc1pVRkJaU3hKUVVGeVFqczdRVUZGUVN4VFFVRlRReXhUUVVGVUxFTkJRVzlDT1VNc1NVRkJjRUlzUlVGQk1FSXJReXhsUVVFeFFpeEZRVUV5UXp0QlFVTjZReXhOUVVGSlNpeHJRa0ZCU2pzN1FVRkZRU3hOUVVGSlNTeHRRa0ZCYlVJc1NVRkJka0lzUlVGQk5rSTdRVUZETTBKS0xHZENRVUZaU1N4bFFVRmFPMEZCUTBRc1IwRkdSQ3hOUVVWUExFbEJRVWt2UXl4TFFVRkxNa01zVTBGQlRDeEpRVUZyUWl4SlFVRjBRaXhGUVVFMFFqdEJRVU5xUTBFc1owSkJRVmt6UXl4TFFVRkxNa01zVTBGQmFrSTdRVUZEUkN4SFFVWk5MRTFCUlVFN1FVRkRURUVzWjBKQlFWbEZMRmxCUVZvN1FVRkRSRHM3UVVGRlJEZERMRTlCUVV0c1FpeExRVUZNTEVOQlFWZFVMRU5CUVZnc1NVRkJaMEp6UlN4WlFVRlpNME1zUzBGQlN6aENMRkZCUVV3c1EwRkJZM3BFTEVOQlFURkRPMEZCUTBFeVFpeFBRVUZMYkVJc1MwRkJUQ3hEUVVGWFVDeERRVUZZTEVsQlFXZENiMFVzV1VGQldUTkRMRXRCUVVzNFFpeFJRVUZNTEVOQlFXTjJSQ3hEUVVFeFF6dEJRVU5FT3p0QlFVVkVOVUlzVDBGQlQwTXNUMEZCVUN4SFFVRnBRaXhGUVVGRmEwY3NiMEpCUVVZc1JVRkJha0lzUXpzN096czdPenM3TzBGRGFrSkJPMEZCUTBFN1FVRkRRU3hUUVVGVFJTeFRRVUZVTEVOQlFXOUNiRU1zVFVGQmNFSXNSVUZCTkVJNFFpeFJRVUUxUWl4RlFVRnpRenRCUVVOd1F5eE5RVUZKZWtVc1MwRkJTeXhEUVVGVU8wRkJRVUVzVFVGQldUaEZMRXRCUVVzc1EwRkJha0k3UVVGQlFTeE5RVU5KTTBVc1MwRkJTeXhEUVVSVU8wRkJRVUVzVFVGRFdUUkZMRXRCUVVzc1EwRkVha0k3UVVGQlFTeE5RVVZKUXl4RFFVWktPMEZCUVVFc1RVRkhTVU1zVFVGQlRYUkRMRTlCUVU5dVJDeE5RVWhxUWpzN1FVRkxRU3hOUVVGSmVVWXNVVUZCVVN4RFFVRmFMRVZCUVdVN1FVRkRZaXhYUVVGUExFTkJRVkE3UVVGRFJEczdRVUZGUkN4UFFVRkxSQ3hKUVVGSkxFTkJRVlFzUlVGQldVRXNTVUZCU1VNc1IwRkJhRUlzUlVGQmNVSXNSVUZCUlVRc1EwRkJka0lzUlVGQk1FSTdRVUZEZUVJc1VVRkJTVzVFTEU5QlFVOWpMRTlCUVU5eFF5eERRVUZRTEVOQlFWZzdRVUZCUVN4UlFVTkpka1lzVVVGQlVXZEdMRmRCUVZjMVF5eExRVUZMWjBJc1NVRkVOVUk3TzBGQlIwRXNVVUZCU1doQ0xFdEJRVXR4UkN4UFFVRlVMRVZCUVd0Q08wRkJRVVU3UVVGQlZ6czdRVUZGTDBJc1VVRkJTWEpFTEV0QlFVdFFMRTFCUVZRc1JVRkJhVUk3UVVGRFprOHNWMEZCU3poQ0xGRkJRVXdzUTBGQlkzcEVMRU5CUVdRc1IwRkJhMElzUTBGQmJFSTdRVUZEUVRKQ0xGZEJRVXM0UWl4UlFVRk1MRU5CUVdOMlJDeERRVUZrTEVkQlFXdENMRU5CUVd4Q08wRkJRMFFzUzBGSVJDeE5RVWRQTzBGQlEweDVRaXhYUVVGTE9FSXNVVUZCVEN4RFFVRmpla1FzUTBGQlpDeEpRVUZ0UWxRc1VVRkJVVzlETEV0QlFVdHNRaXhMUVVGTUxFTkJRVmRVTEVOQlFYUkRPMEZCUTBFeVFpeFhRVUZMT0VJc1VVRkJUQ3hEUVVGamRrUXNRMEZCWkN4SlFVRnRRbGdzVVVGQlVXOURMRXRCUVV0c1FpeExRVUZNTEVOQlFWZFFMRU5CUVhSRE8wRkJRMFE3TzBGQlJVUXNVVUZCU1N0RkxFdEJRVXQwUkN4TFFVRkxPRUlzVVVGQlRDeERRVUZqZWtRc1EwRkJka0k3UVVGQlFTeFJRVU5KYTBZc1MwRkJTM1pFTEV0QlFVczRRaXhSUVVGTUxFTkJRV04yUkN4RFFVUjJRanRCUVVGQkxGRkJSVWw1UkN4SlFVRkpka1FzUzBGQlMwTXNTVUZCVEN4RFFVRlZORVVzUzBGQlMwRXNSVUZCVEN4SFFVRlZReXhMUVVGTFFTeEZRVUY2UWl4RFFVWlNPenRCUVVsQkxGRkJRVWwyUWl4SlFVRkpMRU5CUVZJc1JVRkJWenRCUVVOVWFFTXNWMEZCU3poQ0xGRkJRVXdzUTBGQlkzcEVMRU5CUVdRc1IwRkJhMEpwUml4TFFVRkxkRUlzUTBGQmRrSTdRVUZEUVdoRExGZEJRVXM0UWl4UlFVRk1MRU5CUVdOMlJDeERRVUZrTEVkQlFXdENaMFlzUzBGQlMzWkNMRU5CUVhaQ08wRkJRMFE3TzBGQlJVUTNSQ3hUUVVGTGVVVXNWMEZCVnpWRExFdEJRVXM0UWl4UlFVRk1MRU5CUVdONlJDeERRVUU1UWp0QlFVTkJReXhUUVVGTGMwVXNWMEZCVnpWRExFdEJRVXM0UWl4UlFVRk1MRU5CUVdOMlJDeERRVUU1UWpzN1FVRkZRWGxDTEZOQlFVczFRaXhIUVVGTUxFTkJRVk5ETEVOQlFWUXNTVUZCWTBZc1JVRkJaRHRCUVVOQk5rSXNVMEZCU3pWQ0xFZEJRVXdzUTBGQlUwY3NRMEZCVkN4SlFVRmpSQ3hGUVVGa096dEJRVVZCTWtVc1ZVRkJUWGhGTEV0QlFVc3JSU3hIUVVGTUxFTkJRVk55Uml4RlFVRlVMRU5CUVU0c1EwRkJiMElyUlN4TlFVRk5la1VzUzBGQlN5dEZMRWRCUVV3c1EwRkJVMnhHTEVWQlFWUXNRMEZCVGp0QlFVTnlRanM3UVVGRlJDeFRRVUZQTEVOQlFVTXlSU3hMUVVGTFFTeEZRVUZNTEVkQlFWVkRMRXRCUVV0QkxFVkJRV2hDTEVsQlFXOUNSU3hIUVVFelFqdEJRVU5FT3p0QlFVVkVla2NzVDBGQlQwTXNUMEZCVUN4SFFVRnBRaXhGUVVGRmIwY3NiMEpCUVVZc1JVRkJha0lzUXpzN096czdPenM3TzBGREwwTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeEpRVUZOVXl4UFFVRlBMRzFDUVVGQmJrY3NRMEZCVVN4RFFVRlNMRU5CUVdJN1FVRkRRU3hKUVVGTmIwY3NZMEZCWXl4dFFrRkJRWEJITEVOQlFWRXNRMEZCVWl4RFFVRndRanM3UVVGRlFTeEpRVUZOY1Vjc1YwRkJWeXhUUVVGWVFTeFJRVUZYTEVsQlFVczdRVUZCUlROQ0xFbEJRVVV6UkN4RFFVRkdMRWRCUVUwc1EwRkJUaXhEUVVGVE1rUXNSVUZCUlhwRUxFTkJRVVlzUjBGQlRTeERRVUZPTzBGQlFWVXNRMEZCTTBNN08wRkJSVUVzU1VGQlRYRkdMR2xDUVVGcFFpeFRRVUZxUWtFc1kwRkJhVUlzUTBGQlEwTXNSVUZCUkN4RlFVRkxReXhGUVVGTUxFVkJRVms3UVVGRGFrTXNUVUZCU1VNc1dVRkJXU3hKUVVGb1FqdEJRVU5CTEUxQlFVazFSaXhMUVVGTFRTeExRVUZMSzBVc1IwRkJUQ3hEUVVGVFN5eEhRVUZIZUVZc1EwRkJTQ3hIUVVGUGVVWXNSMEZCUjNwR0xFTkJRVzVDTEVOQlFWUTdRVUZEUVN4TlFVRkpReXhMUVVGTFJ5eExRVUZMSzBVc1IwRkJUQ3hEUVVGVFN5eEhRVUZIZEVZc1EwRkJTQ3hIUVVGUGRVWXNSMEZCUjNaR0xFTkJRVzVDTEVOQlFWUTdPMEZCUlVFc1UwRkJUMG9zUzBGQlN6UkdMRk5CUVV3c1NVRkJhMEo2Uml4TFFVRkxlVVlzVTBGQk9VSTdRVUZEUkN4RFFVNUVPenRCUVZGQkxGTkJRVk01UlN4WlFVRlVMRWRCUVhWQ08wRkJRM0pDTEUxQlFVa3JSU3hqUVVGakxFVkJRV3hDTzBGQlFVRXNUVUZEUlVNc1kwRkJZeXhKUVVGSlVDeFhRVUZLTEVWQlJHaENPMEZCUVVFc1RVRkZSVkVzWVVGQllTeEZRVVptTzBGQlFVRXNUVUZIUlVNc2FVSkJRV2xDTEVOQlNHNUNPMEZCUVVFc1RVRkpSVU1zVDBGQlQwTXNVMEZLVkRzN1FVRk5RU3hYUVVGVFFTeFBRVUZVTEVkQlFXMUNPMEZCUTJwQ08wRkJRMEVzVVVGQlNVTXNUMEZCVDBvc1YwRkJWME1zWTBGQldDeERRVUZZTzBGQlEwRXNVVUZCU1Vjc1NVRkJTaXhGUVVGVk8wRkJRMUpCTEZkQlFVdERMRXRCUVV3c1IwRkJZU3hKUVVGaU8wRkJRMEZFTEZkQlFVdEZMRXRCUVV3c1IwRkJZU3hKUVVGaU8wRkJRMEZHTEZkQlFVdEhMRXRCUVV3c1IwRkJZU3hKUVVGaU8wRkJRMEZJTEZkQlFVdEpMRXRCUVV3c1IwRkJZU3hKUVVGaU8wRkJRMEZLTEZkQlFVdDBSU3hKUVVGTUxFZEJRVmtzU1VGQldqdEJRVU5CYzBVc1YwRkJTM1JFTEVsQlFVd3NSMEZCV1hORUxFdEJRVXRMTEV0QlFVd3NSMEZCWVV3c1MwRkJTMDBzUzBGQlRDeEhRVUZoTEVOQlFYUkRPMEZCUTBGT0xGZEJRVXRQTEVsQlFVd3NSMEZCV1ZBc1MwRkJTMUVzUzBGQlRDeEhRVUZoVWl4TFFVRkxVeXhIUVVGTUxFZEJRVmRVTEV0QlFVdFZMRTFCUVV3c1IwRkJZeXhEUVVGc1JEdEJRVU5FTEV0QlVrUXNUVUZSVHp0QlFVTk1WaXhoUVVGUExFbEJRVWxpTEVsQlFVb3NSVUZCVUR0QlFVTkJVeXhwUWtGQlYwTXNZMEZCV0N4SlFVRTJRa2NzU1VGQk4wSTdRVUZEUkRzN1FVRkZSQ3hOUVVGRlNDeGpRVUZHTzBGQlEwRXNWMEZCVDBjc1NVRkJVRHRCUVVORU96dEJRVVZFTEZkQlFWTlhMRTFCUVZRc1EwRkJhVUpETEZWQlFXcENMRVZCUVRaQ01VTXNUMEZCTjBJc1JVRkJjME5GTEV0QlFYUkRMRVZCUVRaRFJDeEpRVUUzUXl4RlFVRnZSRHRCUVVOc1JDeFJRVUZKTUVNc1VVRkJVVzVDTEZkQlFWbzdRVUZCUVN4UlFVTkZhRU1zVlVGRVJqdEJRVUZCTEZGQlJVVTNSQ3hYUVVaR08wRkJRVUVzVVVGSFJVY3NWMEZJUmp0QlFVRkJMRkZCU1VWRkxGVkJTa1k3UVVGQlFTeFJRVWxMTkVjc1MwRkJTeXhEUVVwV08wRkJRVUVzVVVGTFJVTXNTMEZCU3l4RFFVeFFPMEZCUVVFc1VVRk5SVU1zWTBGQll5eERRVTVvUWp0QlFVRkJMRkZCVDBWRExGZEJRVmNzUTBGUVlqdEJRVUZCTEZGQlVVVkRMRlZCUVZVc1EwRlNXanM3UVVGVlFVd3NWVUZCVFN4RFFVRk9MRWxCUVZkbUxFbEJRVmc3TzBGQlJVRlVMR0ZCUVZWMVFpeFhRVUZYY0Vjc1MwRkJja0k3TzBGQlJVRXNVVUZCU1RKSExFdEJRVXNzUTBGQlExQXNWMEZCVnpsSExFZEJRVmdzUTBGQlpVTXNRMEZCZWtJN1FVRkRRU3hSUVVGSmNVZ3NTMEZCU3l4RFFVRkRVaXhYUVVGWE9VY3NSMEZCV0N4RFFVRmxSeXhEUVVGNlFqdEJRVU5CTEZGQlFVbHZTQ3hMUVVGTGJFZ3NTMEZCUzBNc1NVRkJUQ3hEUVVGVkswY3NTMEZCUzBFc1JVRkJUQ3hIUVVGVlF5eExRVUZMUVN4RlFVRjZRaXhEUVVGVU8wRkJRMEVzVVVGQlNVVXNTMEZCUzFZc1YwRkJWMnhGTEVsQlFWZ3NSMEZCYTBKNVFpeEpRVUZzUWl4SFFVRjVRbXRFTEVWQlFXeERPenRCUVVWQlVDeFZRVUZOVVN4TFFVRkxTQ3hGUVVGWU8wRkJRMEZLTEZWQlFVMVBMRXRCUVV0R0xFVkJRVmc3TzBGQlJVRXNWMEZCVDBvc1YwRkJVQ3hGUVVGdlFqdEJRVU5zUWl4VlFVRkphRUlzVDBGQlQyRXNUVUZCVFVrc1VVRkJUaXhEUVVGWU8wRkJRVUVzVlVGRFJYWkdMRTlCUVU5elJTeExRVUZMZEVVc1NVRkVaRHM3UVVGSFFYTkdMSEZDUVVGbExFTkJRV1k3UVVGRFFVTXNhMEpCUVZrc1EwRkJXanRCUVVOQkxGVkJRVWxOTEdkQ1FVRnBRamRHTEZOQlFWTnJSaXhWUVVFNVFqdEJRVU5CTEZWQlFVbHNSaXhSUVVGUk5rWXNZVUZCV2l4RlFVRXlRanRCUVVONlFqdEJRVU5CTzBGQlEwRTdRVUZEUVRGSUxHRkJRVXMyUWl4TFFVRkxOVUlzUjBGQlRDeERRVUZUUXl4RFFVRlVMRWRCUVdFMlJ5eFhRVUZYT1Vjc1IwRkJXQ3hEUVVGbFF5eERRVUZxUXp0QlFVTkJReXhoUVVGTE1FSXNTMEZCU3pWQ0xFZEJRVXdzUTBGQlUwY3NRMEZCVkN4SFFVRmhNa2NzVjBGQlZ6bEhMRWRCUVZnc1EwRkJaVWNzUTBGQmFrTTdRVUZEUVVNc1dVRkJTVU1zUzBGQlMwTXNTVUZCVEN4RFFVRlZVQ3hMUVVGTFFTeEZRVUZNTEVkQlFWVkhMRXRCUVV0QkxFVkJRWHBDTEVOQlFVbzdPMEZCUlVFc1dVRkJTVVVzVFVGQlRTeERRVUZXTEVWQlFXRTdRVUZEV0R0QlFVTkJUQ3hsUVVGTExFTkJRVU5OTEV0QlFVdEZMRTFCUVV3c1MwRkJaMElzUjBGQmFrSXNTVUZCZDBJc1JVRkJOMEk3UVVGRFFVd3NaVUZCU3l4RFFVRkRSeXhMUVVGTFJTeE5RVUZNTEV0QlFXZENMRWRCUVdwQ0xFbEJRWGRDTEVWQlFUZENPMEZCUTBGSUxHTkJRVWxETEV0QlFVdERMRWxCUVV3c1EwRkJWVkFzUzBGQlMwRXNSVUZCVEN4SFFVRlZSeXhMUVVGTFFTeEZRVUY2UWl4RFFVRktPMEZCUTBRN08wRkJSVVE3UVVGRFFUdEJRVU5CTUVRc1dVRkJTVkVzVlVGQlZYaERMRXRCUVV0blFpeEpRVUZtTEVkQlFYTkNhMFVzVjBGQlYyeEZMRWxCUVdwRExFbEJRWGxEZUVNc1NVRkJTVUVzUTBGQlNpeEhRVUZSUVN4RFFVRnFSQ3hEUVVGS08wRkJRMEUwUnl4alFVRk5jRVFzU1VGQlNUZEVMRVZCUVZZN1FVRkRRV3RJTEdOQlFVMXlSQ3hKUVVGSk1VUXNSVUZCVmp0QlFVTkVMRTlCY0VKRUxFMUJiMEpQTEVsQlFVbDFTQ3hoUVVGS0xFVkJRVzFDTzBGQlEzaENPMEZCUTBFN1FVRkRRVHRCUVVOQk1VZ3NZVUZCUzIxSExFdEJRVXRMTEV0QlFVd3NSMEZCWVV3c1MwRkJTM1JFTEVsQlFXeENMRWRCUVhsQ2EwVXNWMEZCVnpsSExFZEJRVmdzUTBGQlpVTXNRMEZCTjBNN1FVRkRRVU1zWVVGQlMyZEhMRXRCUVV0TkxFdEJRVXdzUjBGQllVNHNTMEZCUzNSRUxFbEJRV3hDTEVkQlFYbENhMFVzVjBGQlZ6bEhMRWRCUVZnc1EwRkJaVWNzUTBGQk4wTTdRVUZEUVVNc1dVRkJTVU1zUzBGQlMwTXNTVUZCVEN4RFFVRlZVQ3hMUVVGTFFTeEZRVUZNTEVkQlFWVkhMRXRCUVV0QkxFVkJRWHBDTEVOQlFVbzdPMEZCUlVFc1dVRkJTVVVzVFVGQlRTeERRVUZXTEVWQlFXRTdRVUZEV0R0QlFVTkJPMEZCUTBGTUxHVkJRVXNzUTBGQlEwMHNTMEZCUzBVc1RVRkJUQ3hMUVVGblFpeEhRVUZxUWl4SlFVRjNRaXhGUVVFM1FqdEJRVU5CVEN4bFFVRkxMRU5CUVVOSExFdEJRVXRGTEUxQlFVd3NTMEZCWjBJc1IwRkJha0lzU1VGQmQwSXNSVUZCTjBJN1FVRkRRVWdzWTBGQlNVTXNTMEZCUzBNc1NVRkJUQ3hEUVVGVlVDeExRVUZMUVN4RlFVRk1MRWRCUVZWSExFdEJRVXRCTEVWQlFYcENMRU5CUVVvN1FVRkRSRHRCUVVORU8wRkJRMEU3UVVGRFFTeFpRVUZKTEVOQlFVTm5SeXhMUVVGTFVTeExRVUZNTEVkQlFXRlNMRXRCUVV0UExFbEJRVzVDTEVsQlFUSkNja2NzUTBGQk0wSXNSMEZCSzBKclJTeExRVUZ1UXl4RlFVRXdRenRCUVVONFF6dEJRVU5CTzBGQlEwRTdRVUZEUVZZc1kwRkJTVkVzVlVGQlZUaENMRXRCUVV0MFJDeEpRVUZtTEVkQlFYTkNhMFVzVjBGQlYyeEZMRWxCUVdwRExFbEJRWGxEZUVNc1NVRkJTVUVzUTBGQlNpeEhRVUZSUVN4RFFVRnFSQ3hEUVVGS08wRkJRMEUwUnl4blFrRkJUWEJFTEVsQlFVazNSQ3hGUVVGV08wRkJRMEZyU0N4blFrRkJUWEpFTEVsQlFVa3hSQ3hGUVVGV08wRkJRMFFzVTBGUVJDeE5RVTlQTzBGQlEwdzdPMEZCUlVFN1FVRkRRU3hqUVVGSlowY3NTMEZCUzBNc1MwRkJWQ3hGUVVGblFqdEJRVU5rV1N4clFrRkJUVXNzVDBGQlRpeEpRVUZwUW14Q0xFdEJRVXRETEV0QlFYUkNPMEZCUTBGbExESkNRVUZsTEVOQlFXWTdRVUZEUVVVc2RVSkJRVmNzUTBGQldEdEJRVU5FTzBGQlEwUXNZMEZCU1d4Q0xFdEJRVXRGTEV0QlFWUXNSVUZCWjBJN1FVRkRaRmNzYTBKQlFVMUxMRTlCUVU0c1NVRkJhVUpzUWl4TFFVRkxSU3hMUVVGMFFqdEJRVU5CWXl3eVFrRkJaU3hEUVVGbU8wRkJRMEZGTEhWQ1FVRlhMRU5CUVZnN1FVRkRSRHRCUVVORUxHTkJRVWxzUWl4TFFVRkxSeXhMUVVGVUxFVkJRV2RDTzBGQlEyUlZMR3RDUVVGTlN5eFBRVUZPTEVsQlFXbENiRUlzUzBGQlMwY3NTMEZCZEVJN1FVRkRRV0VzTWtKQlFXVXNRMEZCWmp0QlFVTkJSU3gxUWtGQlZ5eERRVUZZTzBGQlEwUTdRVUZEUkN4alFVRkpiRUlzUzBGQlMwa3NTMEZCVkN4RlFVRm5RanRCUVVOa1V5eHJRa0ZCVFVzc1QwRkJUaXhKUVVGcFFteENMRXRCUVV0SkxFdEJRWFJDTzBGQlEwRlpMREpDUVVGbExFTkJRV1k3UVVGRFFVVXNkVUpCUVZjc1EwRkJXRHRCUVVORU8wRkJRMFk3UVVGRFJqdEJRVU5HT3p0QlFVVkVUaXhsUVVGWGNFY3NTMEZCV0N4RFFVRnBRbFFzUTBGQmFrSXNTVUZCYzBJclJ5eEZRVUYwUWp0QlFVTkJSaXhsUVVGWGNFY3NTMEZCV0N4RFFVRnBRbEFzUTBGQmFrSXNTVUZCYzBJNFJ5eEZRVUYwUWp0QlFVTkVPenRCUVVWRUxGZEJRVk5UTEZsQlFWUXNRMEZCYzBKb1JpeE5RVUYwUWl4RlFVRTRRanRCUVVNMVFpeFJRVUZKUVN4UFFVRlBia1FzVFVGQlVDeExRVUZyUWl4RFFVRjBRaXhGUVVGNVFqdEJRVUZGTzBGQlFWTTdPMEZCUlhCRExGRkJRVWx2U1N4TFFVRkxReXhQUVVGUFF5eFRRVUZvUWp0QlFVRkJMRkZCUTBWRExFdEJRVXRHTEU5QlFVOURMRk5CUkdRN1FVRkJRU3hSUVVWRlJTeExRVUZMU0N4UFFVRlBTU3hUUVVaa08wRkJRVUVzVVVGSFJVTXNTMEZCUzB3c1QwRkJUMGtzVTBGSVpEdEJRVUZCTEZGQlNVVnFSQ3hWUVVwR08wRkJRVUVzVVVGTFJVTXNUVUZCVFhSRExFOUJRVTl1UkN4TlFVeG1PenRCUVU5Qk8wRkJRMEYzUml4UlFVRkpReXhIUVVGS08wRkJRMEVzVjBGQlQwUXNSMEZCVUN4RlFVRlpPMEZCUTFZc1ZVRkJTVGxGTEVsQlFVbDVReXhQUVVGUGNVTXNRMEZCVUN4RlFVRlZMMFVzUjBGQlZpeERRVUZqUXl4RFFVRjBRanRCUVVOQkxGVkJRVWxGTEVsQlFVbDFReXhQUVVGUGNVTXNRMEZCVUN4RlFVRlZMMFVzUjBGQlZpeERRVUZqUnl4RFFVRjBRanRCUVVOQkxGVkJRVWxHTEVsQlFVa3dTQ3hGUVVGU0xFVkJRVms3UVVGRFZrRXNZVUZCU3pGSUxFTkJRVXc3UVVGRFJEdEJRVU5FTEZWQlFVbEJMRWxCUVVrNFNDeEZRVUZTTEVWQlFWazdRVUZEVmtFc1lVRkJTemxJTEVOQlFVdzdRVUZEUkR0QlFVTkVMRlZCUVVsRkxFbEJRVWt5U0N4RlFVRlNMRVZCUVZrN1FVRkRWa0VzWVVGQlN6TklMRU5CUVV3N1FVRkRSRHRCUVVORUxGVkJRVWxCTEVsQlFVazRTQ3hGUVVGU0xFVkJRVms3UVVGRFZrRXNZVUZCU3psSUxFTkJRVXc3UVVGRFJEdEJRVU5HT3p0QlFVVkVPMEZCUTBFc1VVRkJTVW9zUzBGQlMyZEpMRXRCUVV0S0xFVkJRV1E3UVVGQlFTeFJRVU5GZWtnc1MwRkJTeXRJTEV0QlFVdElMRVZCUkZvN1FVRkZRU3hSUVVGSkwwZ3NTMEZCUzBjc1JVRkJWQ3hGUVVGaE8wRkJRMWdyU0N4WFFVRkxTQ3hMUVVGTEwwZ3NSVUZCVmp0QlFVTkVMRXRCUmtRc1RVRkZUenRCUVVOTVowa3NWMEZCUzBvc1MwRkJTM3BJTEVWQlFWWTdRVUZEUkRzN1FVRkZSRFpHTEhGQ1FVRnBRaXhEUVVGcVFqdEJRVU5CUXl4WFFVRlBReXhUUVVGUU8wRkJRMEZFTEZOQlFVdFRMRWxCUVV3c1IwRkJXV3RDTEVWQlFWbzdRVUZEUVROQ0xGTkJRVXRWTEV0QlFVd3NSMEZCWVhGQ0xFVkJRV0k3UVVGRFFTOUNMRk5CUVV0WExFZEJRVXdzUjBGQlYyMUNMRVZCUVZnN1FVRkRRVGxDTEZOQlFVdFpMRTFCUVV3c1IwRkJZM0ZDTEVWQlFXUTdPMEZCUlVGc1JDeFJRVUZKUXl4TlFVRk5MRU5CUVZZN1FVRkRRU3hSUVVGSlJDeExRVUZMTEVOQlFWUXNSVUZCV1R0QlFVTldhVUlzVjBGQlMzQkZMRWxCUVV3c1IwRkJXV01zVDBGQlQzRkRMRU5CUVZBc1EwRkJXanRCUVVORU8wRkJRMFFzVjBGQlQwRXNSMEZCVUN4RlFVRlpPMEZCUTFadFJDeGhRVUZQZUVZc1QwRkJUM0ZETEVOQlFWQXNRMEZCVUN4RlFVRnJRbWxDTEVsQlFXeENPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFhRVUZUYTBNc1RVRkJWQ3hEUVVGblFrTXNUMEZCYUVJc1JVRkJlVUk3UVVGRGRrSjBReXhuUWtGQldYVkRMRXRCUVZvN1FVRkRRWFpETEdkQ1FVRlpPVU1zU1VGQldpeERRVUZwUW1sRUxFbEJRV3BDTEVWQlFYVkNiVU1zVDBGQmRrSTdPMEZCUlVFc1YwRkJUeXhEUVVGRGRFTXNXVUZCV1hkRExFOUJRVm9zUlVGQlVpeEZRVUVyUWp0QlFVTTNRaXhWUVVGSlF5eFpRVUZaZWtNc1dVRkJXVEJETEVkQlFWb3NSVUZCYUVJN1FVRkJRU3hWUVVORmNrTXNUMEZCVDI5RExGVkJRVlZ3UXl4SlFVUnVRanRCUVVGQkxGVkJSVVYwUlN4UFFVRlBNRWNzVlVGQlZURkhMRWxCUm01Q096dEJRVWxCTEZWQlFVa3NRMEZCUTNORkxFdEJRVXQwUlN4SlFVRldMRVZCUVdkQ08wRkJRMlE3UVVGRFFTeFpRVUZKTTBJc1NVRkJTVEpDTEV0QlFVczFRaXhIUVVGTUxFTkJRVk5ETEVOQlFXcENPMEZCUTBFc1dVRkJTVVVzU1VGQlNYbENMRXRCUVVzMVFpeEhRVUZNTEVOQlFWTkhMRU5CUVdwQ08wRkJRMEVyUml4aFFVRkxkRVFzU1VGQlRDeEhRVUZaYzBRc1MwRkJTM1JFTEVsQlFVd3NSMEZCV1doQ0xFdEJRVXRuUWl4SlFVRTNRanRCUVVOQmMwUXNZVUZCUzBzc1MwRkJUQ3hIUVVGaFRDeExRVUZMU3l4TFFVRk1MRWRCUVdFelJTeExRVUZMWjBJc1NVRkJUQ3hIUVVGWk0wTXNRMEZCZEVNN1FVRkRRV2xITEdGQlFVdE5MRXRCUVV3c1IwRkJZVTRzUzBGQlMwMHNTMEZCVEN4SFFVRmhOVVVzUzBGQlMyZENMRWxCUVV3c1IwRkJXWHBETEVOQlFYUkRPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFpRVUZKY1Vrc1ZVRkJWU3hEUVVGa08wRkJRVUVzV1VGQmFVSTdRVUZEWmk5Q0xHVkJRVTlRTEV0QlFVdFBMRWxCUkdRN1FVRkJRU3haUVVWRlF5eFJRVUZSTEVOQlFVTlNMRXRCUVV0UkxFdEJRVXdzUjBGQllVUXNTVUZCWkN4SlFVRnpRaXhEUVVab1F6dEJRVUZCTEZsQlIwVkZMRTFCUVUxVUxFdEJRVXRUTEVkQlNHSTdRVUZCUVN4WlFVbEZReXhUUVVGVExFTkJRVU5XTEV0QlFVdFZMRTFCUVV3c1IwRkJZMFFzUjBGQlppeEpRVUZ6UWl4RFFVcHFRenM3UVVGTlFTeFpRVUZKTVVjc1NVRkJTWGxITEV0QlFWSXNSVUZCWlR0QlFVRkZPMEZCUTJZNFFpeHZRa0ZCVlVFc1ZVRkJWU3hEUVVGd1FqdEJRVU5CTDBJc2FVSkJRVTlETEV0QlFWQTdRVUZEUVVFc2EwSkJRVkZTTEV0QlFVdFJMRXRCUVdJN1FVRkRSRHRCUVVORUxGbEJRVWwyUnl4SlFVRkplVWNzVFVGQlVpeEZRVUZuUWp0QlFVRkZPMEZCUTJoQ05FSXNiMEpCUVZWQkxGVkJRVlVzUTBGQmNFSTdRVUZEUVRkQ0xHZENRVUZOUXl4TlFVRk9PMEZCUTBGQkxHMUNRVUZUVml4TFFVRkxWU3hOUVVGa08wRkJRMFE3TzBGQlJVUXNXVUZCU1RaQ0xGRkJRVkZETEZOQlFWTjRReXhKUVVGVUxFVkJRV1Z6UXl4UFFVRm1MRU5CUVZvN1FVRkRRU3haUVVGSkxFTkJRVU5ETEV0QlFVd3NSVUZCV1R0QlFVTldPMEZCUTBFN1FVRkRRVUVzYTBKQlFWRjRReXhUUVVGU08wRkJRMEYzUXl4blFrRkJUV2hETEVsQlFVNHNSMEZCWVVFc1NVRkJZanRCUVVOQlowTXNaMEpCUVUwNVFpeEhRVUZPTEVkQlFWbEJMRWRCUVZvN1FVRkRRVGhDTEdkQ1FVRk5MMElzUzBGQlRpeEhRVUZqUVN4TFFVRmtPMEZCUTBFclFpeG5Ra0ZCVFRkQ0xFMUJRVTRzUjBGQlpVRXNUVUZCWmp0QlFVTkJOa0lzWjBKQlFVMDNSeXhKUVVGT0xFZEJRV0ZCTEVsQlFXSTdPMEZCUlVFclJ5eHRRa0ZCVTNwRExFbEJRVlFzUlVGQlpYTkRMRTlCUVdZc1JVRkJkMEpETEV0QlFYaENPMEZCUTBRc1UwRllSQ3hOUVZkUE8wRkJRMHc3UVVGRFFUVkRMSE5DUVVGWk9VTXNTVUZCV2l4RFFVRnBRakJHTEV0QlFXcENMRVZCUVhkQ04wY3NTVUZCZUVJN1FVRkRSRHRCUVVOR0xFOUJNME5FTEUxQk1rTlBPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQlNXZElMRlZCUVZVeFF5eExRVUZMZEVVc1NVRkJia0k3UVVGRFFYTkZMR0ZCUVV0MFJTeEpRVUZNTEVkQlFWa3NTVUZCV2l4RFFVeExMRU5CUzJFN08wRkJSV3hDTEZsQlFVazBSQ3hsUVVGbGIwUXNVVUZCVVRWSkxFZEJRWFpDTEVWQlFUUkNORUlzUzBGQlN6VkNMRWRCUVdwRExFTkJRVW9zUlVGQk1rTTdRVUZEZWtNN1FVRkRRVHRCUVVOQkxHTkJRVWsyU1N4bFFVRmxMRU5CUVc1Q08wRkJRMEVzWVVGQlJ6dEJRVU5FTEdkQ1FVRkpReXhUUVVGVGVra3NTMEZCUzBVc1RVRkJUQ3hGUVVGaU8wRkJRMEVzWjBKQlFVbFNMRXRCUVVzc1EwRkJRMjFITEV0QlFVdFJMRXRCUVV3c1IwRkJZVklzUzBGQlMwOHNTVUZCYmtJc1NVRkJNa0p4UXl4TlFVRndRenRCUVVOQkxHZENRVUZKTlVrc1MwRkJTeXhEUVVGRFowY3NTMEZCUzFVc1RVRkJUQ3hIUVVGalZpeExRVUZMVXl4SFFVRndRaXhKUVVFeVFtMURMRTFCUVhCRE96dEJRVVZCUml4dlFrRkJVVFZKTEVkQlFWSXNRMEZCV1VNc1EwRkJXaXhIUVVGblFtbEhMRXRCUVV0UExFbEJRVXdzUjBGQldURkhMRVZCUVRWQ08wRkJRMEUyU1N4dlFrRkJVVFZKTEVkQlFWSXNRMEZCV1Vjc1EwRkJXaXhIUVVGblFpdEdMRXRCUVV0VExFZEJRVXdzUjBGQlYzcEhMRVZCUVROQ08wRkJRMEV5U1N3MFFrRkJaMElzUTBGQmFFSTdRVUZEUVR0QlFVTkVMRmRCVkVRc1VVRlRVMEVzWlVGQlpTeERRVUZtTEVsQlFXOUNja1FzWlVGQlpXOUVMRkZCUVZFMVNTeEhRVUYyUWl4RlFVRTBRalJDTEV0QlFVczFRaXhIUVVGcVF5eERRVlEzUWpzN1FVRlhRU3hqUVVGSk5ra3NhVUpCUVdsQ0xFTkJRV3BDTEVsQlFYTkNja1FzWlVGQlpXOUVMRkZCUVZFMVNTeEhRVUYyUWl4RlFVRTBRalJDTEV0QlFVczFRaXhIUVVGcVF5eERRVUV4UWl4RlFVRnBSVHRCUVVNdlJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBRN1FVRkRSanRCUVVORU8wRkJRMEUyUml4dlFrRkJXVGxETEVsQlFWb3NRMEZCYVVKdFJDeEpRVUZxUWl4RlFVRjFRakJETEU5QlFYWkNPMEZCUTBFdlF5eHZRa0ZCV1RsRExFbEJRVm9zUTBGQmFVSnRSQ3hKUVVGcVFpeEZRVUYxUW5SRkxFbEJRWFpDTzBGQlEwUTdRVUZEUmp0QlFVTkdPenRCUVVWRUxGTkJRVTg3UVVGRFREaEdMR3RDUVVGalFTeFpRVVJVTzBGQlJVeHhRaXh4UWtGQmFVSnNRenRCUVVaYUxFZEJRVkE3UVVGSlJEczdRVUZGUkN4VFFVRlROa0lzVVVGQlZDeERRVUZyUW5oRExFbEJRV3hDTEVWQlFYZENPRU1zUjBGQmVFSXNSVUZCTmtJN1FVRkRNMElzVFVGQlNVRXNVVUZCVVN4RFFVRmFMRVZCUVdVc1QwRkJUemxETEV0QlFVdERMRXRCUVZvN1FVRkRaaXhOUVVGSk5rTXNVVUZCVVN4RFFVRmFMRVZCUVdVc1QwRkJUemxETEV0QlFVdEZMRXRCUVZvN1FVRkRaaXhOUVVGSk5FTXNVVUZCVVN4RFFVRmFMRVZCUVdVc1QwRkJUemxETEV0QlFVdEhMRXRCUVZvN1FVRkRaaXhOUVVGSk1rTXNVVUZCVVN4RFFVRmFMRVZCUVdVc1QwRkJUemxETEV0QlFVdEpMRXRCUVZvN1FVRkRaaXhUUVVGUExFbEJRVkE3UVVGRFJEczdRVUZGUkN4VFFVRlRjVU1zVVVGQlZDeERRVUZyUW5wRExFbEJRV3hDTEVWQlFYZENPRU1zUjBGQmVFSXNSVUZCTmtKUUxFdEJRVGRDTEVWQlFXOURPMEZCUTJ4RExFMUJRVWxQTEZGQlFWRXNRMEZCV2l4RlFVRmxPVU1zUzBGQlMwTXNTMEZCVEN4SFFVRmhjME1zUzBGQllpeERRVUZtTEV0QlEwc3NTVUZCU1U4c1VVRkJVU3hEUVVGYUxFVkJRV1U1UXl4TFFVRkxSU3hMUVVGTUxFZEJRV0Z4UXl4TFFVRmlMRU5CUVdZc1MwRkRRU3hKUVVGSlR5eFJRVUZSTEVOQlFWb3NSVUZCWlRsRExFdEJRVXRITEV0QlFVd3NSMEZCWVc5RExFdEJRV0lzUTBGQlppeExRVU5CTEVsQlFVbFBMRkZCUVZFc1EwRkJXaXhGUVVGbE9VTXNTMEZCUzBrc1MwRkJUQ3hIUVVGaGJVTXNTMEZCWWp0QlFVTnlRanM3UVVGRlJHeExMRTlCUVU5RExFOUJRVkFzUjBGQmFVSXNSVUZCUlhGRExEQkNRVUZHTEVWQlFXcENMRU03T3pzN096czdPenRCUXpGVVFYUkRMRTlCUVU5RExFOUJRVkFzUjBGQmFVSTRSeXhYUVVGcVFqczdRVUZGUVRzN096czdRVUZMUVN4VFFVRlRRU3hYUVVGVUxFZEJRWGRDTzBGQlEzQkNMRk5CUVVzeVJDeExRVUZNTEVkQlFXRXNSVUZCWWp0QlFVTkJMRk5CUVV0RExFMUJRVXdzUjBGQll5eERRVUZrTzBGQlEwZzdPMEZCUlVRMVJDeFpRVUZaTmtRc1UwRkJXaXhIUVVGM1FqdEJRVU53UW1Rc1lVRkJVeXh0UWtGQlZ6dEJRVU5vUWl4bFFVRlBMRXRCUVV0aExFMUJRVXdzUzBGQlowSXNRMEZCZGtJN1FVRkRTQ3hMUVVodFFqdEJRVWx3UW01SExGVkJRVTBzWTBGQlZXMUVMRWxCUVZZc1JVRkJaMEowUlN4SlFVRm9RaXhGUVVGelFqdEJRVU40UWl4WlFVRkpkMGdzVDBGQlR5eExRVUZMU0N4TFFVRk1MRU5CUVZjc1MwRkJTME1zVFVGQmFFSXNRMEZCV0R0QlFVTkJMRmxCUVVrc1EwRkJRMFVzU1VGQlRDeEZRVUZYTzBGQlExQTdRVUZEUVR0QlFVTkJMR2xDUVVGTFNDeExRVUZNTEVOQlFWY3NTMEZCUzBNc1RVRkJhRUlzU1VGQk1FSXNTVUZCU1Vjc2EwSkJRVW9zUTBGQmRVSnVSQ3hKUVVGMlFpeEZRVUUyUW5SRkxFbEJRVGRDTEVOQlFURkNPMEZCUTBnc1UwRktSQ3hOUVVsUE8wRkJRMGgzU0N4cFFrRkJTMnhFTEVsQlFVd3NSMEZCV1VFc1NVRkJXanRCUVVOQmEwUXNhVUpCUVV0NFNDeEpRVUZNTEVkQlFWbEJMRWxCUVZvN1FVRkRTRHRCUVVORUxGVkJRVVVzUzBGQlMzTklMRTFCUVZBN1FVRkRTQ3hMUVdadFFqdEJRV2RDY0VKWUxGTkJRVXNzWlVGQldUdEJRVU5pTEZsQlFVa3NTMEZCUzFjc1RVRkJUQ3hIUVVGakxFTkJRV3hDTEVWQlFYRkNPMEZCUTJwQ0xHMUNRVUZQTEV0QlFVdEVMRXRCUVV3c1EwRkJWeXhGUVVGRkxFdEJRVXRETEUxQlFXeENMRU5CUVZBN1FVRkRTRHRCUVVOS0xFdEJjRUp0UWp0QlFYRkNjRUprTEZkQlFVOHNhVUpCUVZrN1FVRkRaaXhoUVVGTFl5eE5RVUZNTEVkQlFXTXNRMEZCWkR0QlFVTklPMEZCZGtKdFFpeERRVUY0UWpzN1FVRXdRa0VzVTBGQlUwY3NhMEpCUVZRc1EwRkJORUp1UkN4SlFVRTFRaXhGUVVGclEzUkZMRWxCUVd4RExFVkJRWGRETzBGQlEzQkRMRk5CUVV0elJTeEpRVUZNTEVkQlFWbEJMRWxCUVZvc1EwRkViME1zUTBGRGJFSTdRVUZEYkVJc1UwRkJTM1JGTEVsQlFVd3NSMEZCV1VFc1NVRkJXaXhEUVVadlF5eERRVVZzUWp0QlFVTnlRaXhET3pzN096czdPenM3UVVONlEwUTdPenRCUVVkQmNrUXNUMEZCVDBNc1QwRkJVQ3hIUVVGcFFpeFRRVUZUTmtjc1NVRkJWQ3hIUVVGblFqdEJRVU12UWp0QlFVTkJPMEZCUTBFc1QwRkJTM3BFTEVsQlFVd3NSMEZCV1N4SlFVRmFPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCUzNWRkxFdEJRVXdzUjBGQllTeEpRVUZpTzBGQlEwRXNUMEZCUzBNc1MwRkJUQ3hIUVVGaExFbEJRV0k3UVVGRFFTeFBRVUZMUXl4TFFVRk1MRWRCUVdFc1NVRkJZanRCUVVOQkxFOUJRVXRETEV0QlFVd3NSMEZCWVN4SlFVRmlPenRCUVVWQk8wRkJRMEVzVDBGQlN6RkVMRWxCUVV3c1IwRkJXU3hEUVVGYU96dEJRVVZCTzBGQlEwRXNUMEZCU3pKRUxFdEJRVXdzUjBGQllTeERRVUZpTzBGQlEwRXNUMEZCUzBNc1MwRkJUQ3hIUVVGaExFTkJRV0k3TzBGQlJVRTdRVUZEUVN4UFFVRkxReXhKUVVGTUxFZEJRVmtzUTBGQldqdEJRVU5CTEU5QlFVdEZMRWRCUVV3c1IwRkJWeXhEUVVGWU8wRkJRMEVzVDBGQlMwTXNUVUZCVEN4SFFVRmpMRU5CUVdRN1FVRkRRU3hQUVVGTFJpeExRVUZNTEVkQlFXRXNRMEZCWWp0QlFVTkVMRU5CTVVKRUxFTTdPenM3T3pzN096dGxRMGh6UWl4dFFrRkJRWGhJTEVOQlFWRXNRMEZCVWl4RE8wbEJRV1F3Uml4VExGbEJRVUZCTEZNN08yZENRVU5qTEcxQ1FVRkJNVVlzUTBGQlVTeERRVUZTTEVNN1NVRkJaSGRHTEZNc1lVRkJRVUVzVXpzN1owSkJRMmRDTEcxQ1FVRkJlRVlzUTBGQlVTeERRVUZTTEVNN1NVRkJhRUpWTEZjc1lVRkJRVUVzVnpzN1FVRkZVaXhUUVVGVFowSXNTVUZCVkN4UFFVRjFSanRCUVVGQkxFMUJRWFpGT0VJc1RVRkJkVVVzVVVGQmRrVkJMRTFCUVhWRk8wRkJRVUVzVFVGQkwwUk5MRTlCUVN0RUxGRkJRUzlFUVN4UFFVRXJSRHRCUVVGQkxFMUJRWFJFVUN4UlFVRnpSQ3hSUVVGMFJFRXNVVUZCYzBRN1FVRkJRU3hOUVVFMVF5dENMRkZCUVRSRExGRkJRVFZEUVN4UlFVRTBRenRCUVVGQkxFMUJRV3hEU2l4UFFVRnJReXhSUVVGc1EwRXNUMEZCYTBNN1FVRkJRU3hOUVVGNlFrVXNTMEZCZVVJc1VVRkJla0pCTEV0QlFYbENPMEZCUVVFc1RVRkJiRUpETEZOQlFXdENMRkZCUVd4Q1FTeFRRVUZyUWp0QlFVRkJMRTFCUVZCR0xFbEJRVThzVVVGQlVFRXNTVUZCVHpzN1FVRkRja1k3UVVGRFFUTkNMRk5CUVU4MVJDeFBRVUZRTEVOQlFXZENMR2RDUVVGUk8wRkJRM1JDTEZGQlFVbDNTeXhKUVVGSk1VZ3NTMEZCUzJ0Q0xGRkJRV0k3TzBGQlJVRXNVVUZCU1N4RFFVRkRkMGNzUTBGQlRDeEZRVUZSTzBGQlFVVTdRVUZCVXpzN1FVRkZia0l4U0N4VFFVRkxVQ3hOUVVGTUxFZEJRV05wU1N4RlFVRkZha2tzVFVGQmFFSTdRVUZEUVU4c1UwRkJTM0ZFTEU5QlFVd3NSMEZCWlhGRkxFVkJRVVZ5UlN4UFFVRnFRanRCUVVOQmNrUXNVMEZCU3pWQ0xFZEJRVXdzUTBGQlUwTXNRMEZCVkN4SFFVRmhjVW9zUlVGQlJYSktMRU5CUVdZN1FVRkRRVEpDTEZOQlFVczFRaXhIUVVGTUxFTkJRVk5ITEVOQlFWUXNSMEZCWVcxS0xFVkJRVVZ1U2l4RFFVRm1PMEZCUTBRc1IwRlVSRHM3UVVGWFFYTkRMRmRCUVZOcFJpeFpRVUZVTEVOQlFYVkNhRVlzVFVGQmRrSTdPMEZCUlVFc1QwRkJTeXhKUVVGSmNVTXNTVUZCU1N4RFFVRmlMRVZCUVdkQ1FTeEpRVUZKY2tNc1QwRkJUMjVFTEUxQlFUTkNMRVZCUVcxRGQwWXNSMEZCYmtNc1JVRkJkME03UVVGRGRFTXNVVUZCU1c1RUxFOUJRVTlqTEU5QlFVOXhReXhEUVVGUUxFTkJRVmc3TzBGQlJVRjBReXhoUVVGVGMwY3NaVUZCVkN4RFFVRXdRbTVJTEVsQlFURkNMRVZCUVdkRGQwTXNUMEZCYUVNc1JVRkJlVU5GTEV0QlFYcERMRVZCUVdkRVJDeEpRVUZvUkR0QlFVTkJTeXhqUVVGWE9VTXNTVUZCV0N4RlFVRnBRakpETEZOQlFXcENPMEZCUTBRN08wRkJSVVFzVDBGQlN5eEpRVUZKVVN4TFFVRkpMRU5CUVdJc1JVRkJaMEpCTEV0QlFVa3ZRaXhSUVVGUmVrUXNUVUZCTlVJc1JVRkJiME4zUml4SlFVRndReXhGUVVGNVF6dEJRVU4yUXl4UlFVRkpjRVlzVTBGQlUzRkVMRkZCUVZFclFpeEZRVUZTTEVOQlFXSTdPMEZCUlVGdVJpeG5Ra0ZCWVVRc1RVRkJZanRCUVVORU96dEJRVVZFTEUxQlFVa3lSQ3hYUVVGWGMwSXNWVUZCVjJ4RExFMUJRVmdzUlVGQmJVSTRRaXhSUVVGdVFpeERRVUZtT3p0QlFVVkJPMEZCUTBFNVFpeFRRVUZQTlVRc1QwRkJVQ3hEUVVGblFpeG5Ra0ZCVVR0QlFVTjBRaXhSUVVGSmQwc3NTVUZCU1RGSUxFdEJRVXRyUWl4UlFVRmlPenRCUVVWQkxGRkJRVWtzUTBGQlEzZEhMRU5CUVV3c1JVRkJVVHRCUVVGRk8wRkJRVk03TzBGQlJXNUNRU3hOUVVGRmNrb3NRMEZCUml4SFFVRk5Na0lzUzBGQlN6VkNMRWRCUVV3c1EwRkJVME1zUTBGQlpqdEJRVU5CY1Vvc1RVRkJSVzVLTEVOQlFVWXNSMEZCVFhsQ0xFdEJRVXMxUWl4SFFVRk1MRU5CUVZOSExFTkJRV1k3UVVGRFJDeEhRVkJFT3p0QlFWTkJMRk5CUVU5dFJDeFJRVUZRTzBGQlEwUTdPMEZCUlVRdlJTeFBRVUZQUXl4UFFVRlFMRWRCUVdsQ0xFVkJRVVZ2UXl4VlFVRkdMRVZCUVdwQ0xFTTdPenM3T3pzN096dEJReTlEUVN4SlFVRk5lVUlzVVVGQlVTeHRRa0ZCUVc1RUxFTkJRVkVzUTBGQlVpeERRVUZrT3p0QlFVVkJPMEZCUTBFc1NVRkJTWEZMTEZkQlFWY3NVMEZCV0VFc1VVRkJWeXhEUVVGVlF5eFRRVUZXTEVWQlFYRkNPMEZCUTJ4RExFMUJRVWtzUTBGQlEwRXNVMEZCVEN4RlFVRm5RanRCUVVGRk8wRkJRVk1zUjBGRVR5eERRVU5PT3p0QlFVVTFRa0VzV1VGQlZ5eFJRVUZZTEVWQlFYRkNMRTlCUVhKQ0xFVkJRVGhDYmtnc1MwRkJPVUlzUlVGSWEwTXNRMEZIU3p0QlFVTjRReXhEUVVwRU96dEJRVTFCTEVsQlFVa3NUMEZCVDIxSUxGTkJRVkFzUzBGQmNVSXNWMEZCZWtJc1JVRkJjME03UVVGQlJUdEJRVU4wUTBRc1YwRkJWVU1zVTBGQlZqdEJRVU5FT3p0QlFVVkVha3dzVDBGQlQwTXNUMEZCVUN4SFFVRnBRaXRMTEZGQlFXcENMRU03T3pzN096czdPenRCUTJKQk96dEJRVVZCYUV3c1QwRkJUME1zVDBGQlVDeEhRVUZwUWtNc1QwRkJUMWNzVFVGQlVDeERRVUZqTzBGQlF6ZENjVXNzVjBGQlV5eEpRVVJ2UWl4RlFVTmtPMEZCUTJaRExGZEJRVk1zUlVGR2IwSXNSVUZGYUVJN1FVRkRZa01zYVVKQlFXVXNTVUZJWXl4RlFVZFNPMEZCUTNKQ1F5eHhRa0ZCYlVJc1NVRktWU3hGUVVsS08wRkJRM3BDUXl3MFFrRkJNRUlzUzBGTVJ5eEZRVXRKTzBGQlEycERReXhQUVVGTExFbEJUbmRDTEVWQlRXeENPMEZCUTFoRExGZEJRVk1zUlVGUWIwSXNSVUZQYUVJN1FVRkRZa01zWlVGQllVTXNVMEZTWjBJc1JVRlJURHM3UVVGRmVFSTdRVUZEUVVNc1UwRkJUeXhwUWtGQlZTeERRVUZGTEVOQldGVXNSVUZYVWp0QlFVTnlRa01zVVVGQlRTeG5Ra0ZCVlN4RFFVRkZMRU5CV2xjc1JVRlpWRHM3UVVGRmNFSTdRVUZEUVVNc1lVRkJWeXhMUVdaclFpeEZRV1ZZT3p0QlFVVnNRanRCUVVOQlF5eFpRVUZWTEV0QmJFSnRRaXhEUVd0Q1lqdEJRV3hDWVN4RFFVRmtMRU5CUVdwQ0xFTTdPenM3T3pzN096czdPenM3UVVOR1FUczdPenRCUVVsQkxFbEJRVTB6VEN4VFFVRlRMRzFDUVVGQlVTeERRVUZSTEVOQlFWSXNRMEZCWmp0QlFVTkJMRWxCUVUxRExGZEJRVmNzYlVKQlFVRkVMRU5CUVZFc1JVRkJVaXhEUVVGcVFqdEJRVU5CTEVsQlFVMXZUQ3hyUWtGQmEwSXNiVUpCUVVGd1RDeERRVUZSTEVWQlFWSXNRMEZCZUVJN08yVkJRekpGTEcxQ1FVRkJRU3hEUVVGUkxFVkJRVklzUXp0SlFVRnVSWEZNTEhWQ0xGbEJRVUZCTEhWQ08wbEJRWGxDUXl4blFpeFpRVUZCUVN4blFqdEpRVUZyUWtNc2JVSXNXVUZCUVVFc2JVSTdPMmRDUVVNM1FpeHRRa0ZCUVhaTUxFTkJRVkVzUlVGQlVpeERPMGxCUVdSM1RDeFRMR0ZCUVVGQkxGTTdPMGxCUlVZdlNpeE5PMEZCUTBvc2EwSkJRV0V5UWl4UFFVRmlMRVZCUVhOQ08wRkJRVUU3TzBGQlEzQkNMRkZCUVVseFNTeEpRVUZKTEV0QlFVdHlTU3hQUVVGTUxFZEJRV1UxUkN4UFFVRlJMRVZCUVZJc1JVRkJXVk1zVVVGQldpeEZRVUZ6UW0xRUxFOUJRWFJDTEVOQlFYWkNPenRCUVVWQkxGRkJRVWxGTEVsQlFVa3NTMEZCUzBRc1MwRkJUQ3hIUVVGaE4wUXNUMEZCVVN4RlFVRlNMRVZCUVZscFRTeERRVUZhTEVWQlFXVTdRVUZEYkVORExHTkJRVkVzU1VGRU1FSTdRVUZGYkVOcVNTeGhRVUZQWjBrc1JVRkJSVVVzU1VGQlJpeERRVUZQYkVrc1MwRkJVQ3hGUVVZeVFqdEJRVWRzUTAwc1lVRkJUekJJTEVWQlFVVkZMRWxCUVVZc1EwRkJUelZJTEV0QlFWQXNSVUZJTWtJN1FVRkpiRU0yU0N4cFFrRkJWeXhEUVVwMVFqdEJRVXRzUTBNc2JVSkJRV0U3UVVGTWNVSXNTMEZCWml4RFFVRnlRanM3UVVGUlFYWkpMRTFCUVVWM1NTeFZRVUZHTEVkQlFXVk1MRVZCUVVWc1FpeFBRVUZHTEVsQlFXRnJRaXhGUVVGRmJFSXNUMEZCUml4TFFVRmpMRXRCUVRGRE8wRkJRMEZxU0N4TlFVRkZlVWtzYlVKQlFVWXNSMEZCZDBKT0xFVkJRVVZzUWl4UFFVRkdMRWxCUVdFc1EwRkJRMnBJTEVWQlFVVjNTU3hWUVVGNFF6dEJRVU5FT3pzN096QkNRVVZKTzBGQlEwZ3NWVUZCU1VVc1NVRkJTU3hKUVVGU08wRkJRMEVzVlVGQlNURkpMRWxCUVVrc1MwRkJTMFFzUzBGQllqczdRVUZGUVVNc1VVRkJSWE5KTEZOQlFVWXNSMEZCWXl4RFFVRmtPMEZCUTBGMFNTeFJRVUZGZFVrc1YwRkJSaXhIUVVGblFpeEpRVUZvUWp0QlFVTkJka2tzVVVGQlJUSkpMRk5CUVVZc1IwRkJZME1zUzBGQlMwTXNSMEZCVEN4RlFVRmtPMEZCUTBFM1NTeFJRVUZGT0Vrc1QwRkJSaXhIUVVGWkxFbEJRVm83TzBGQlJVRTVTU3hSUVVGRkswa3NhMEpCUVVZc1IwRkJkVUpxUWl4blFrRkJhVUk1U0N4RlFVRkZkMGdzVjBGQmJrSXNSVUZCWjBONFNDeEZRVUZGWjBvc1JVRkJiRU1zUTBGQmRrSTdPMEZCUlVFc1ZVRkJTV2hLTEVWQlFVVXdTQ3hMUVVGT0xFVkJRV0U3UVVGQlJXZENMRlZCUVVWUExFZEJRVVlzUTBGQlR5eFBRVUZRTEVWQlFXZENha29zUlVGQlJUQklMRXRCUVd4Q08wRkJRVFJDTzBGQlF6TkRMRlZCUVVreFNDeEZRVUZGTWtnc1NVRkJUaXhGUVVGWk8wRkJRVVZsTEZWQlFVVlBMRWRCUVVZc1EwRkJUeXhOUVVGUUxFVkJRV1ZxU2l4RlFVRkZNa2dzU1VGQmFrSTdRVUZCTUVJN08wRkJSWGhETTBnc1VVRkJSVWNzUzBGQlJpeERRVUZSTjBRc1QwRkJVaXhEUVVGcFFqdEJRVUZCTEdWQlFVdDVUQ3gzUWtGQmVVSnlTaXhEUVVGNlFpeEZRVUUwUW5OQ0xFTkJRVFZDTEVOQlFVdzdRVUZCUVN4UFFVRnFRanM3UVVGRlFUQkpMRkZCUVVWUkxFMUJRVVlzUTBGQlZXeEtMRU5CUVZZN08wRkJSVUVzVlVGQlNVRXNSVUZCUlhsSkxHMUNRVUZPTEVWQlFUSkNPMEZCUTNwQ0xGbEJRVWxWTEZsQlFWa3NVMEZCV2tFc1UwRkJXU3hQUVVGUk8wRkJRM1JDTEdOQlFVa3NRMEZCUTI1S0xFVkJRVVZ4U0N4M1FrRkJVQ3hGUVVGcFF6dEJRVUZGTzBGQlFWTTdPMEZCUlRWRExHTkJRVWtyUWl4WlFVRlpia0lzYjBKQlFYRkNka1VzU1VGQmNrSXNSVUZCTWtJeFJDeERRVUV6UWl4RlFVRXJRbTlLTEZOQlFTOUNMRWRCUVRKRE1VWXNTMEZCU3pCR0xGTkJRVXdzUlVGQk0wUTdPMEZCUlVFc1kwRkJTVUVzVTBGQlNpeEZRVUZsTzBGQlEySXhSaXhwUWtGQlMzbEdMRk5CUVV3N1FVRkRSRHRCUVVOR0xGTkJVa1E3TzBGQlZVRXNXVUZCU1VVc1dVRkJXU3hUUVVGYVFTeFRRVUZaTEU5QlFWRTdRVUZEZEVJc1kwRkJTU3hEUVVGRGNrb3NSVUZCUlhGSUxIZENRVUZRTEVWQlFXbERPMEZCUVVVN1FVRkJVenM3UVVGRk5VTXNZMEZCU1N0Q0xGbEJRVmx1UWl4dlFrRkJjVUoyUlN4SlFVRnlRaXhGUVVFeVFqRkVMRU5CUVROQ0xFVkJRU3RDYjBvc1UwRkJMME03TzBGQlJVRXNZMEZCU1VFc1UwRkJTaXhGUVVGbE8wRkJRMkl4Uml4cFFrRkJTelJHTEU5QlFVdzdRVUZEUkR0QlFVTkdMRk5CVWtRN08wRkJWVUVzV1VGQlNVTXNhMEpCUVd0Q0xGTkJRV3hDUVN4bFFVRnJRanRCUVVGQkxHbENRVUZSZEVJc2IwSkJRWEZDZGtVc1NVRkJja0lzUlVGQk1rSXhSQ3hEUVVFelFpeEZRVUVyUW5sRExFOUJRUzlDTEVkQlFYbERhVUlzUzBGQlMycENMRTlCUVV3c1JVRkJha1E3UVVGQlFTeFRRVUYwUWpzN1FVRkZRU3haUVVGSkswY3NVMEZCVXl4VFFVRlVRU3hOUVVGVExFOUJRVzlDTzBGQlFVRXNZMEZCVkRGTkxFMUJRVk1zVVVGQlZFRXNUVUZCVXpzN1FVRkRMMEo1VFN3d1FrRkJhVUo2VFN4TlFVRnFRanRCUVVORUxGTkJSa1E3TzBGQlNVRXNXVUZCU1RKTkxGTkJRVk5FTEUxQlFXSTdPMEZCUlVFc1dVRkJTVVVzVTBGQlV5eFRRVUZVUVN4TlFVRlRMRkZCUVc5Q08wRkJRVUVzWTBGQlZEVk5MRTFCUVZNc1UwRkJWRUVzVFVGQlV6czdRVUZETDBJc1kwRkJTV2RMTEVsQlFVbHRRaXh2UWtGQmNVSnVUQ3hOUVVGeVFpeEZRVUUyUW10RUxFTkJRVGRDTEVOQlFWSTdRVUZEUVN4alFVRkpNa29zUzBGQlN6ZE5MRTlCUVU4NFRTeFJRVUZRTEVWQlFWUTdPMEZCUlVFNVF5eFpRVUZGY2tvc1EwRkJSaXhIUVVGTmEwMHNSMEZCUjJ4TkxFTkJRVlE3UVVGRFFYRktMRmxCUVVWdVNpeERRVUZHTEVkQlFVMW5UU3hIUVVGSGFFMHNRMEZCVkR0QlFVTkVMRk5CVGtRN08wRkJVVUVzV1VGQlNXdE5MR1ZCUVdVc1UwRkJaa0VzV1VGQlpTeFBRVUZSTzBGQlEzcENia2NzWlVGQlMyOUhMRVZCUVV3c1EwRkJVU3hOUVVGU0xFVkJRV2RDVGl4TlFVRm9RanRCUVVOQk9VWXNaVUZCUzI5SExFVkJRVXdzUTBGQlVTeE5RVUZTTEVWQlFXZENUQ3hOUVVGb1FqdEJRVU5CTDBZc1pVRkJTMjlITEVWQlFVd3NRMEZCVVN4TlFVRlNMRVZCUVdkQ1NpeE5RVUZvUWp0QlFVTkVMRk5CU2tRN08wRkJUVUVzV1VGQlNVc3NhVUpCUVdsQ0xGTkJRV3BDUVN4alFVRnBRaXhQUVVGUk8wRkJRek5DY2tjc1pVRkJTM05ITEdOQlFVd3NRMEZCYjBJc1RVRkJjRUlzUlVGQk5FSlNMRTFCUVRWQ08wRkJRMEU1Uml4bFFVRkxjMGNzWTBGQlRDeERRVUZ2UWl4TlFVRndRaXhGUVVFMFFsQXNUVUZCTlVJN1FVRkRRUzlHTEdWQlFVdHpSeXhqUVVGTUxFTkJRVzlDTEUxQlFYQkNMRVZCUVRSQ1RpeE5RVUUxUWp0QlFVTkVMRk5CU2tRN08wRkJUVUVzV1VGQlNYQkRMRTFCUVUwc1UwRkJUa0VzUjBGQlRTeEhRVUZOTzBGQlEyUXNZMEZCU1hSSUxFVkJRVVZ6U0N4SFFVRkdMRWxCUVZOMFNDeEZRVUZGZVVrc2JVSkJRV1lzUlVGQmIwTTdRVUZEYkVONlNTeGpRVUZGWjBvc1JVRkJSaXhEUVVGTE1VSXNSMEZCVEN4RFFVRlZkRWdzUlVGQlJYVklMRTlCUVZvN1FVRkRSRHRCUVVOR0xGTkJTa1E3TzBGQlRVRXNXVUZCU1RCRExGbEJRVmtzVTBGQldrRXNVMEZCV1N4SFFVRk5PMEZCUTNCQ2FrTXNNa0pCUVd0Q2FFa3NSVUZCUlVjc1MwRkJjRUlzUlVGQk1rSklMRU5CUVROQ08wRkJRMEZ6U0RzN1FVRkZRVFJETEdkRFFVRjFRa01zVFVGQmRrSTdRVUZEUkN4VFFVeEVPenRCUVU5QkxGbEJRVWxCTEZOQlFWRXNVMEZCVWtFc1RVRkJVU3hIUVVGVk8wRkJRM0JDYWtNc2IwSkJRVmRzU1N4RFFVRllMRVZCUVdOcFN5eFRRVUZrTEVWQlFYbENSeXhQUVVGNlFqdEJRVU5FTEZOQlJrUTdPMEZCU1VFc1dVRkJTVUVzVlVGQlV5eFRRVUZVUVN4UFFVRlRMRWRCUVUwN1FVRkRha0p3UXl3eVFrRkJhMEpvU1N4RlFVRkZSeXhMUVVGd1FpeEZRVUV5UWtnc1EwRkJNMEk3UVVGRFFYTklPenRCUVVWQmRFZ3NXVUZCUlVjc1MwRkJSaXhEUVVGUk4wUXNUMEZCVWl4RFFVRnBRaXhoUVVGTE8wRkJRM0JDSzAwc2MwSkJRVmN6U3l4RFFVRllPMEZCUTBGeFRDd3lRa0ZCWjBKeVRDeERRVUZvUWp0QlFVTkVMRmRCU0VRN08wRkJTMEZ6UWl4WlFVRkZPRWtzVDBGQlJpeEhRVUZaTEV0QlFWbzdPMEZCUlVGS0xGbEJRVVV5UWl4SlFVRkdMRU5CUVU4c1dVRkJVRHRCUVVORUxGTkJXa1E3TzBGQlkwRXpRaXhWUVVGRk1rSXNTVUZCUml4RFFVRlBMR0ZCUVZBN08wRkJSVUZ5U3l4VlFVRkZSeXhMUVVGR0xFTkJRVkUzUkN4UFFVRlNMRU5CUVdsQ0xHRkJRVXM3UVVGRGNFSTJUU3h2UWtGQlYzcExMRU5CUVZnN1FVRkRRVzFNTEhWQ1FVRmpia3dzUTBGQlpEdEJRVU5FTEZOQlNFUTdPMEZCUzBGNVRDeHBRa0YyUm5sQ0xFTkJkVVpvUWp0QlFVTldMRTlCZUVaRUxFMUJkMFpQTzBGQlEwd3NXVUZCU1Vjc1QwRkJUeXhMUVVGWU8wRkJRMEVzV1VGQlNVd3NZVUZCV1N4VFFVRmFRU3hWUVVGWkxFZEJRVTBzUTBGQlJTeERRVUY0UWp0QlFVTkJMRmxCUVVsSExGZEJRVk1zVTBGQlZFRXNVVUZCVXp0QlFVRkJMR2xDUVVGTlJTeFBRVUZQTEVsQlFXSTdRVUZCUVN4VFFVRmlPenRCUVVWQkxHVkJRVThzUTBGQlEwRXNTVUZCVWl4RlFVRmpPMEZCUTFwd1F5eHZRa0ZCVjJ4SkxFTkJRVmdzUlVGQlkybExMRlZCUVdRc1JVRkJlVUpITEZGQlFYcENPMEZCUTBRN08wRkJSVVJ3U3l4VlFVRkZjVWtzU1VGQlJpeERRVUZQYTBNc1pVRkJVQ3hEUVVGM1FpeEpRVUY0UWl4RlFVRTRRblpMTEVOQlFUbENMRVZCUVdsRExHZENRVUZSTzBGQlEzWkRMR05CUVVsM1N5eExRVUZMZGtNc2IwSkJRWEZDZGtVc1NVRkJja0lzUlVGQk1rSXhSQ3hEUVVFelFpeERRVUZVT3p0QlFVVkJMR2xDUVVGUExFVkJRVVYyUXl4SFFVRkhLMDBzUjBGQlJ5OU5MRU5CUVZJc1JVRkJWMFVzUjBGQlJ6Wk5MRWRCUVVjM1RTeERRVUZxUWl4RlFVRlFPMEZCUTBRc1UwRktSRHRCUVV0RU96dEJRVVZFSzBzc1VVRkJSU3RDTEU5QlFVWXNRMEZCVjNwTExFTkJRVmc3TzBGQlJVRXNZVUZCVHl4SlFVRlFMRU5CTlVoSExFTkJORWhWTzBGQlEyUTdPenMyUWtGRlR5eERRVUZGT3pzN09FSkJRMFFzUTBGQlJUczdPekpDUVVOTUxFTkJRVVU3T3pzeVFrRkZSanRCUVVOS0xGZEJRVXRFTEV0QlFVd3NRMEZCVnl0SkxFOUJRVmdzUjBGQmNVSXNTMEZCY2tJN08wRkJSVUVzWVVGQlR5eEpRVUZRTEVOQlNFa3NRMEZIVXp0QlFVTmtPenM3T0VKQlJWRTdRVUZEVUN4aFFVRlBMRWxCUVZBc1EwRkVUeXhEUVVOTk8wRkJRMlE3T3pzN096dEJRVWRJTDAwc1QwRkJUME1zVDBGQlVDeEhRVUZwUW0xRExFMUJRV3BDTEVNN096czdPenM3T3p0QlEzaExRWEJETEU5QlFVOURMRTlCUVZBc1IwRkJhVUlzVlVGQlZUQlBMRVZCUVZZc1JVRkJZekZDTEVWQlFXUXNSVUZCYTBJN1FVRkRha01zVFVGQlNUQkNMRTFCUVUwc1NVRkJWaXhGUVVGblFqdEJRVU5rUVN4VFFVRkxMRVZCUVVWMlJpeEpRVUZKTEVOQlFVNHNSVUZCVTBjc1NVRkJTU3hEUVVGaUxFVkJRV2RDY1VZc1IwRkJSek5DTEVkQlFVYzBRaXhMUVVGSUxFVkJRVzVDTEVWQlFTdENReXhIUVVGSE4wSXNSMEZCUnpoQ0xFMUJRVWdzUlVGQmJFTXNSVUZCVER0QlFVTkVMRWRCUmtRc1RVRkZUenRCUVVGRk8wRkJRMUJLTEZOQlFVc3NSVUZCUlhaR0xFbEJRVWwxUml4SFFVRkhka1lzUlVGQlZDeEZRVUZoU1N4SlFVRkpiVVlzUjBGQlIyNUdMRVZCUVhCQ0xFVkJRWGRDUkN4SlFVRkpiMFlzUjBGQlIzQkdMRVZCUVM5Q0xFVkJRVzFEUnl4SlFVRkphVVlzUjBGQlIycEdMRVZCUVRGRExFVkJRVGhEYTBZc1IwRkJSMFFzUjBGQlIwTXNRMEZCY0VRc1JVRkJkVVJGTEVkQlFVZElMRWRCUVVkSExFTkJRVGRFTEVWQlFVdzdRVUZEUkRzN1FVRkZSQ3hOUVVGSlNDeEhRVUZIYmtZc1JVRkJTQ3hKUVVGVExFbEJRV0lzUlVGQmJVSTdRVUZCUlcxR0xFOUJRVWR1Uml4RlFVRklMRWRCUVZGdFJpeEhRVUZIZGtZc1JVRkJTQ3hIUVVGUmRVWXNSMEZCUjBNc1EwRkJia0k3UVVGQmRVSTdRVUZETlVNc1RVRkJTVVFzUjBGQlIwTXNRMEZCU0N4SlFVRlJMRWxCUVZvc1JVRkJhMEk3UVVGQlJVUXNUMEZCUjBNc1EwRkJTQ3hIUVVGUFJDeEhRVUZIYmtZc1JVRkJTQ3hIUVVGUmJVWXNSMEZCUjNaR0xFVkJRV3hDTzBGQlFYVkNPMEZCUXpORExFMUJRVWwxUml4SFFVRkhha1lzUlVGQlNDeEpRVUZUTEVsQlFXSXNSVUZCYlVJN1FVRkJSV2xHTEU5QlFVZHFSaXhGUVVGSUxFZEJRVkZwUml4SFFVRkhjRVlzUlVGQlNDeEhRVUZSYjBZc1IwRkJSMGNzUTBGQmJrSTdRVUZCZFVJN1FVRkROVU1zVFVGQlNVZ3NSMEZCUjBjc1EwRkJTQ3hKUVVGUkxFbEJRVm9zUlVGQmEwSTdRVUZCUlVnc1QwRkJSMGNzUTBGQlNDeEhRVUZQU0N4SFFVRkhha1lzUlVGQlNDeEhRVUZSYVVZc1IwRkJSM0JHTEVWQlFXeENPMEZCUVhWQ096dEJRVVV6UXl4VFFVRlBiMFlzUlVGQlVEdEJRVU5FTEVOQllrUXNRenM3T3pzN096czdPMEZEUVVFc1NVRkJUWGhQTEZOQlFWTXNiVUpCUVVGUkxFTkJRVkVzUTBGQlVpeERRVUZtT3p0QlFVVkJMRWxCUVVseFRDd3dRa0ZCTUVJc1UwRkJNVUpCTEhWQ1FVRXdRaXhEUVVGVmNrVXNTVUZCVml4RlFVRm5Rak5FTEV0QlFXaENMRVZCUVhWQ08wRkJRMjVFTEUxQlFVa3JSeXhKUVVGSmNFUXNTMEZCUzJ0SExGRkJRVXdzUlVGQlVqdEJRVU5CTEUxQlFVbGpMRXRCUVVzelN5eE5RVUZOWjBvc2EwSkJRV1k3UVVGRFFTeE5RVUZKTlVvc1ZVRkJWWFZGTEV0QlFVdDJSU3hQUVVGTUxFTkJRV05aTEUxQlFVMW5UQ3hKUVVGd1FpeERRVUZrT3p0QlFVVkJMRTFCUVVrMVRDeFhRVUZYTEVsQlFXWXNSVUZCY1VJN1FVRkRia0pCTEdOQlFWVXNSVUZCVmpzN1FVRkZRWFZGTEZOQlFVdDJSU3hQUVVGTUxFTkJRV05aTEUxQlFVMW5UQ3hKUVVGd1FpeEZRVUV3UWpWTUxFOUJRVEZDTzBGQlEwUTdPMEZCUlVScVJDeFRRVUZSYVVRc1QwRkJVaXhGUVVGcFFsa3NUVUZCVFRaSUxGTkJRVTRzUjBGQmEwSTdRVUZEYWtOdVN5eFBRVUZIYVU0c1IwRkJSM1pHTEVWQlFVZ3NSMEZCVVhSSUxFdEJRVXRGTEUxQlFVd3NTMEZCWjBJeVRTeEhRVUZIUXl4RFFVUkhPMEZCUldwRGFFNHNUMEZCUnl0TkxFZEJRVWR3Uml4RlFVRklMRWRCUVZGNlNDeExRVUZMUlN4TlFVRk1MRXRCUVdkQ01rMHNSMEZCUjBjN1FVRkdSeXhIUVVGc1FpeEhRVWRpTzBGQlEwWndUaXhQUVVGSGNVb3NSVUZCUlhKS0xFTkJSRWc3UVVGRlJrVXNUMEZCUjIxS0xFVkJRVVZ1U2p0QlFVWklMRWRCU0VvN08wRkJVVUYzUWl4VlFVRlJUaXhOUVVGU0xFZEJRV2xDTmtVc1MwRkJTemRGTEUxQlFVd3NSVUZCYWtJN1FVRkRSQ3hEUVhCQ1JEczdRVUZ6UWtFc1NVRkJTVzlLTEhOQ1FVRnpRaXhUUVVGMFFrRXNiVUpCUVhOQ0xFTkJRVlYyUlN4SlFVRldMRVZCUVdkQ00wUXNTMEZCYUVJc1JVRkJkVUk3UVVGREwwTXNVMEZCVHpKRUxFdEJRVXQyUlN4UFFVRk1MRU5CUVdOWkxFMUJRVTFuVEN4SlFVRndRaXhEUVVGUU8wRkJRMFFzUTBGR1JEczdRVUZKUVN4SlFVRkpMME1zYlVKQlFXMUNMRk5CUVc1Q1FTeG5Ra0ZCYlVJc1EwRkJWVGRJTEV0QlFWWXNSVUZCYVVKS0xFdEJRV3BDTEVWQlFYZENPMEZCUXpkRFNTeFJRVUZOTmtzc1UwRkJUaXhEUVVGblFpeFZRVUZWZEVnc1NVRkJWaXhGUVVGblFqdEJRVU01UWl4UlFVRkpka1VzVlVGQlZYVkZMRXRCUVV0MlJTeFBRVUZNTEVOQlFXTlpMRTFCUVUxblRDeEpRVUZ3UWl4RFFVRmtPenRCUVVWQkxGZEJRVTg3UVVGRFRIUk9MRk5CUVVjd1FpeFJRVUZSTVVJc1EwRkVUanRCUVVWTVJTeFRRVUZIZDBJc1VVRkJVWGhDTzBGQlJrNHNTMEZCVUR0QlFVbEVMRWRCVUVRN1FVRlJSQ3hEUVZSRU96dEJRVmRCTlVJc1QwRkJUME1zVDBGQlVDeEhRVUZwUWl4RlFVRkZLMHdzWjBSQlFVWXNSVUZCTWtKRkxIZERRVUV6UWl4RlFVRm5SRVFzYTBOQlFXaEVMRVZCUVdwQ0xFTTdPenM3T3pzN096dEJRM1pEUVN4SlFVRk5hVVFzVFVGQlRTeFRRVUZPUVN4SFFVRk5MRWRCUVZVc1EwRkJSU3hEUVVGNFFqczdRVUZGUVN4SlFVRkpOMDBzVDBGQlR5eFRRVUZRUVN4SlFVRlBMRU5CUVZVeVFpeExRVUZXTEVWQlFXbENPMEZCUXpGQ0xFMUJRVWxETEVsQlFVbEVMRXRCUVZJN1FVRkRRU3hOUVVGSk1ra3NTVUZCU1ROSkxFMUJRVTF4U1N4TlFVRmtPenRCUVVWQkxFMUJRVWs0UXl4dlFrRkJiMEo0UXl4RlFVRkZkRXNzU1VGQlJpeERRVUZSTkVJc1EwRkJVaXhEUVVGNFFqczdRVUZGUVN4TlFVRkpRU3hGUVVGRmRVa3NWMEZCVGl4RlFVRnRRanRCUVVOcVFpeFJRVUZKZGtrc1JVRkJSWGxKTEcxQ1FVRk9MRVZCUVRKQ08wRkJRVVU3UVVGRE0wSjZTU3hSUVVGRmIwa3NUVUZCUml4RFFVRlRhVU1zU1VGQlZDeERRVUZqTEdGQlFXUTdRVUZEUkR0QlFVTkVja3NzVFVGQlJYVkpMRmRCUVVZc1IwRkJaMElzUzBGQmFFSTdRVUZEUkRzN1FVRkZSSFpKTEVsQlFVVnpTU3hUUVVGR096dEJRVVZCTEUxQlFVazJReXhYUVVGWGRrTXNTMEZCUzBNc1IwRkJUQ3hMUVVGaE4wa3NSVUZCUlRKSkxGTkJRVGxDT3p0QlFVVkJMRk5CUVU4c1EwRkJRek5KTEVWQlFVVTJTQ3hSUVVGSUxFdEJRV2xDY1VRc2NVSkJRWEZDYkV3c1JVRkJSWE5KTEZOQlFVWXNTVUZCWlhSSkxFVkJRVVZ0U0N4aFFVRjBReXhKUVVGMVJHZEZMRmxCUVZsdVRDeEZRVUZGYjBnc2FVSkJRWFJHTEVOQlFWQTdRVUZEUkN4RFFXeENSRHM3UVVGdlFrRXNTVUZCU1dNc1dVRkJXU3hUUVVGYVFTeFRRVUZaTEVOQlFWVnVTU3hMUVVGV0xFVkJRV2RFTzBGQlFVRXNUVUZCTDBKclN5eFRRVUVyUWl4MVJVRkJia0puUWl4SFFVRnRRanRCUVVGQkxFMUJRV1JpTEUxQlFXTXNkVVZCUVV4aExFZEJRVXM3TzBGQlF6bEVMRTFCUVVsWUxFOUJRVThzUzBGQldEdEJRVU5CTEUxQlFVbDBTeXhKUVVGSlJDeExRVUZTT3p0QlFVVkJMRTlCUVVzc1NVRkJTWGRETEVsQlFVa3NRMEZCWWl4RlFVRm5Ra0VzU1VGQlNYWkRMRVZCUVVWclNDeFBRVUYwUWl4RlFVRXJRak5GTEVkQlFTOUNMRVZCUVc5RE8wRkJRMnhESzBnc1YwRkJUeXhEUVVGRGRFc3NSVUZCUlRoSkxFOUJRVWdzU1VGQll6RkxMRXRCUVUwMFFpeERRVUZPTEVOQlFYSkNPenRCUVVWQkxGRkJRVWx6U3l4SlFVRktMRVZCUVZVN1FVRkJSVHRCUVVGUk8wRkJRM0pDT3p0QlFVVkVMRTFCUVVrc1EwRkJRMEVzU1VGQlRDeEZRVUZYTzBGQlExUk1PMEZCUTBRc1IwRkdSQ3hOUVVWUE8wRkJRMHhITzBGQlEwUTdRVUZEUml4RFFXWkVPenRCUVdsQ1FYSlBMRTlCUVU5RExFOUJRVkFzUjBGQmFVSXNSVUZCUlc5RExGVkJRVVlzUlVGQlVUaEtMRzlDUVVGU0xFVkJRV3BDTEVNaUxDSm1hV3hsSWpvaVkzbDBiM05qWVhCbExXVjFiR1Z5TG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lLR1oxYm1OMGFXOXVJSGRsWW5CaFkydFZibWwyWlhKellXeE5iMlIxYkdWRVpXWnBibWwwYVc5dUtISnZiM1FzSUdaaFkzUnZjbmtwSUh0Y2JseDBhV1lvZEhsd1pXOW1JR1Y0Y0c5eWRITWdQVDA5SUNkdlltcGxZM1FuSUNZbUlIUjVjR1Z2WmlCdGIyUjFiR1VnUFQwOUlDZHZZbXBsWTNRbktWeHVYSFJjZEcxdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm1GamRHOXllU2dwTzF4dVhIUmxiSE5sSUdsbUtIUjVjR1Z2WmlCa1pXWnBibVVnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnWkdWbWFXNWxMbUZ0WkNsY2JseDBYSFJrWldacGJtVW9XMTBzSUdaaFkzUnZjbmtwTzF4dVhIUmxiSE5sSUdsbUtIUjVjR1Z2WmlCbGVIQnZjblJ6SUQwOVBTQW5iMkpxWldOMEp5bGNibHgwWEhSbGVIQnZjblJ6VzF3aVkzbDBiM05qWVhCbFJYVnNaWEpjSWwwZ1BTQm1ZV04wYjNKNUtDazdYRzVjZEdWc2MyVmNibHgwWEhSeWIyOTBXMXdpWTNsMGIzTmpZWEJsUlhWc1pYSmNJbDBnUFNCbVlXTjBiM0o1S0NrN1hHNTlLU2gwYUdsekxDQm1kVzVqZEdsdmJpZ3BJSHRjYm5KbGRIVnliaUJjYmx4dVhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVpQXZMMXh1THk4Z2QyVmljR0ZqYXk5MWJtbDJaWEp6WVd4TmIyUjFiR1ZFWldacGJtbDBhVzl1SWl3aUlGeDBMeThnVkdobElHMXZaSFZzWlNCallXTm9aVnh1SUZ4MGRtRnlJR2x1YzNSaGJHeGxaRTF2WkhWc1pYTWdQU0I3ZlR0Y2JseHVJRngwTHk4Z1ZHaGxJSEpsY1hWcGNtVWdablZ1WTNScGIyNWNiaUJjZEdaMWJtTjBhVzl1SUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4b2JXOWtkV3hsU1dRcElIdGNibHh1SUZ4MFhIUXZMeUJEYUdWamF5QnBaaUJ0YjJSMWJHVWdhWE1nYVc0Z1kyRmphR1ZjYmlCY2RGeDBhV1lvYVc1emRHRnNiR1ZrVFc5a2RXeGxjMXR0YjJSMWJHVkpaRjBwSUh0Y2JpQmNkRngwWEhSeVpYUjFjbTRnYVc1emRHRnNiR1ZrVFc5a2RXeGxjMXR0YjJSMWJHVkpaRjB1Wlhod2IzSjBjenRjYmlCY2RGeDBmVnh1SUZ4MFhIUXZMeUJEY21WaGRHVWdZU0J1WlhjZ2JXOWtkV3hsSUNoaGJtUWdjSFYwSUdsMElHbHVkRzhnZEdobElHTmhZMmhsS1Z4dUlGeDBYSFIyWVhJZ2JXOWtkV3hsSUQwZ2FXNXpkR0ZzYkdWa1RXOWtkV3hsYzF0dGIyUjFiR1ZKWkYwZ1BTQjdYRzRnWEhSY2RGeDBhVG9nYlc5a2RXeGxTV1FzWEc0Z1hIUmNkRngwYkRvZ1ptRnNjMlVzWEc0Z1hIUmNkRngwWlhod2IzSjBjem9nZTMxY2JpQmNkRngwZlR0Y2JseHVJRngwWEhRdkx5QkZlR1ZqZFhSbElIUm9aU0J0YjJSMWJHVWdablZ1WTNScGIyNWNiaUJjZEZ4MGJXOWtkV3hsYzF0dGIyUjFiR1ZKWkYwdVkyRnNiQ2h0YjJSMWJHVXVaWGh3YjNKMGN5d2diVzlrZFd4bExDQnRiMlIxYkdVdVpYaHdiM0owY3l3Z1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5azdYRzVjYmlCY2RGeDBMeThnUm14aFp5QjBhR1VnYlc5a2RXeGxJR0Z6SUd4dllXUmxaRnh1SUZ4MFhIUnRiMlIxYkdVdWJDQTlJSFJ5ZFdVN1hHNWNiaUJjZEZ4MEx5OGdVbVYwZFhKdUlIUm9aU0JsZUhCdmNuUnpJRzltSUhSb1pTQnRiMlIxYkdWY2JpQmNkRngwY21WMGRYSnVJRzF2WkhWc1pTNWxlSEJ2Y25Sek8xeHVJRngwZlZ4dVhHNWNiaUJjZEM4dklHVjRjRzl6WlNCMGFHVWdiVzlrZFd4bGN5QnZZbXBsWTNRZ0tGOWZkMlZpY0dGamExOXRiMlIxYkdWelgxOHBYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtMGdQU0J0YjJSMWJHVnpPMXh1WEc0Z1hIUXZMeUJsZUhCdmMyVWdkR2hsSUcxdlpIVnNaU0JqWVdOb1pWeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1aklEMGdhVzV6ZEdGc2JHVmtUVzlrZFd4bGN6dGNibHh1SUZ4MEx5OGdhV1JsYm5ScGRIa2dablZ1WTNScGIyNGdabTl5SUdOaGJHeHBibWNnYUdGeWJXOXVlU0JwYlhCdmNuUnpJSGRwZEdnZ2RHaGxJR052Y25KbFkzUWdZMjl1ZEdWNGRGeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1cElEMGdablZ1WTNScGIyNG9kbUZzZFdVcElIc2djbVYwZFhKdUlIWmhiSFZsT3lCOU8xeHVYRzRnWEhRdkx5QmtaV1pwYm1VZ1oyVjBkR1Z5SUdaMWJtTjBhVzl1SUdadmNpQm9ZWEp0YjI1NUlHVjRjRzl5ZEhOY2JpQmNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1WkNBOUlHWjFibU4wYVc5dUtHVjRjRzl5ZEhNc0lHNWhiV1VzSUdkbGRIUmxjaWtnZTF4dUlGeDBYSFJwWmlnaFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NXZLR1Y0Y0c5eWRITXNJRzVoYldVcEtTQjdYRzRnWEhSY2RGeDBUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0dWNGNHOXlkSE1zSUc1aGJXVXNJSHRjYmlCY2RGeDBYSFJjZEdOdmJtWnBaM1Z5WVdKc1pUb2dabUZzYzJVc1hHNGdYSFJjZEZ4MFhIUmxiblZ0WlhKaFlteGxPaUIwY25WbExGeHVJRngwWEhSY2RGeDBaMlYwT2lCblpYUjBaWEpjYmlCY2RGeDBYSFI5S1R0Y2JpQmNkRngwZlZ4dUlGeDBmVHRjYmx4dUlGeDBMeThnWjJWMFJHVm1ZWFZzZEVWNGNHOXlkQ0JtZFc1amRHbHZiaUJtYjNJZ1kyOXRjR0YwYVdKcGJHbDBlU0IzYVhSb0lHNXZiaTFvWVhKdGIyNTVJRzF2WkhWc1pYTmNiaUJjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dWJpQTlJR1oxYm1OMGFXOXVLRzF2WkhWc1pTa2dlMXh1SUZ4MFhIUjJZWElnWjJWMGRHVnlJRDBnYlc5a2RXeGxJQ1ltSUcxdlpIVnNaUzVmWDJWelRXOWtkV3hsSUQ5Y2JpQmNkRngwWEhSbWRXNWpkR2x2YmlCblpYUkVaV1poZFd4MEtDa2dleUJ5WlhSMWNtNGdiVzlrZFd4bFd5ZGtaV1poZFd4MEoxMDdJSDBnT2x4dUlGeDBYSFJjZEdaMWJtTjBhVzl1SUdkbGRFMXZaSFZzWlVWNGNHOXlkSE1vS1NCN0lISmxkSFZ5YmlCdGIyUjFiR1U3SUgwN1hHNGdYSFJjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dVpDaG5aWFIwWlhJc0lDZGhKeXdnWjJWMGRHVnlLVHRjYmlCY2RGeDBjbVYwZFhKdUlHZGxkSFJsY2p0Y2JpQmNkSDA3WEc1Y2JpQmNkQzh2SUU5aWFtVmpkQzV3Y205MGIzUjVjR1V1YUdGelQzZHVVSEp2Y0dWeWRIa3VZMkZzYkZ4dUlGeDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTV2SUQwZ1puVnVZM1JwYjI0b2IySnFaV04wTENCd2NtOXdaWEowZVNrZ2V5QnlaWFIxY200Z1QySnFaV04wTG5CeWIzUnZkSGx3WlM1b1lYTlBkMjVRY205d1pYSjBlUzVqWVd4c0tHOWlhbVZqZEN3Z2NISnZjR1Z5ZEhrcE95QjlPMXh1WEc0Z1hIUXZMeUJmWDNkbFluQmhZMnRmY0hWaWJHbGpYM0JoZEdoZlgxeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1d0lEMGdYQ0pjSWp0Y2JseHVJRngwTHk4Z1RHOWhaQ0JsYm5SeWVTQnRiMlIxYkdVZ1lXNWtJSEpsZEhWeWJpQmxlSEJ2Y25SelhHNGdYSFJ5WlhSMWNtNGdYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeWhmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG5NZ1BTQXhNU2s3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdkMlZpY0dGamF5OWliMjkwYzNSeVlYQWdOakJoWVRjNFpUa3lPRFEzTlRFNFptUXdaak1pTENKdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUU5aWFtVmpkQzVoYzNOcFoyNGdJVDBnYm5Wc2JDQS9JRTlpYW1WamRDNWhjM05wWjI0dVltbHVaQ2dnVDJKcVpXTjBJQ2tnT2lCbWRXNWpkR2x2YmlnZ2RHZDBMQ0F1TGk1emNtTnpJQ2w3WEc0Z0lITnlZM011Wm05eVJXRmphQ2dnYzNKaklEMCtJSHRjYmlBZ0lDQlBZbXBsWTNRdWEyVjVjeWdnYzNKaklDa3VabTl5UldGamFDZ2dheUE5UGlCMFozUmJhMTBnUFNCemNtTmJhMTBnS1R0Y2JpQWdmU0FwTzF4dVhHNGdJSEpsZEhWeWJpQjBaM1E3WEc1OU8xeHVYRzVjYmx4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZJZ0x5OWNiaTh2SUM0dmMzSmpMMkZ6YzJsbmJpNXFjeUlzSW1OdmJuTjBJR0Z6YzJsbmJpQTlJSEpsY1hWcGNtVW9KeTR1TDJGemMybG5iaWNwTzF4dVhHNWpiMjV6ZENCa1pXWmhkV3gwY3lBOUlFOWlhbVZqZEM1bWNtVmxlbVVvZTF4dUlDQnpiM1Z5WTJVNklHNTFiR3dzWEc0Z0lIUmhjbWRsZERvZ2JuVnNiQ3hjYmlBZ2JHVnVaM1JvT2lBNE1DeGNiaUFnWTI5bFptWTZJREF1TURBd01peGNiaUFnZDJWcFoyaDBPaUF4WEc1OUtUdGNibHh1Wm5WdVkzUnBiMjRnYldGclpWTndjbWx1WnlnZ2MzQnlhVzVuSUNsN1hHNGdJSEpsZEhWeWJpQmhjM05wWjI0b0lIdDlMQ0JrWldaaGRXeDBjeXdnYzNCeWFXNW5JQ2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR0Z3Y0d4NVUzQnlhVzVuS0NCemNISnBibWNnS1h0Y2JpQWdiR1YwSUdKdlpIa3hJRDBnYzNCeWFXNW5Mbk52ZFhKalpTeGNiaUFnSUNBZ0lHSnZaSGt5SUQwZ2MzQnlhVzVuTG5SaGNtZGxkQ3hjYmlBZ0lDQWdJR3hsYm1kMGFDQTlJSE53Y21sdVp5NXNaVzVuZEdnZ1BDQXdJRDhnWkdWbVlYVnNkSE11YkdWdVozUm9JRG9nYzNCeWFXNW5MbXhsYm1kMGFDeGNiaUFnSUNBZ0lHUjRJRDBnWW05a2VUSXVjRzl6TG5nZ0xTQmliMlI1TVM1d2IzTXVlQ3hjYmlBZ0lDQWdJR1I1SUQwZ1ltOWtlVEl1Y0c5ekxua2dMU0JpYjJSNU1TNXdiM011ZVN4Y2JpQWdJQ0FnSUhJZ1BTQk5ZWFJvTG5OeGNuUW9aSGdnS2lCa2VDQXJJR1I1SUNvZ1pIa3BPMXh1WEc0Z0lHbG1JQ2h5SUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0JrZUNBOUlDaE5ZWFJvTG5KaGJtUnZiU2dwSUMwZ01DNDFLU0F2SURVd08xeHVJQ0FnSUNBZ1pIa2dQU0FvVFdGMGFDNXlZVzVrYjIwb0tTQXRJREF1TlNrZ0x5QTFNRHRjYmlBZ0lDQWdJSElnUFNCTllYUm9Mbk54Y25Rb1pIZ2dLaUJrZUNBcklHUjVJQ29nWkhrcE8xeHVJQ0I5WEc1Y2JpQWdiR1YwSUdRZ1BTQnlJQzBnYkdWdVozUm9PMXh1SUNCc1pYUWdZMjlsWm1ZZ1BTQW9LQ0Z6Y0hKcGJtY3VZMjlsWm1ZZ2ZId2djM0J5YVc1bkxtTnZaV1ptSUR3Z01Da2dQeUJrWldaaGRXeDBjeTV6Y0hKcGJtZERiMlZtWmlBNklITndjbWx1Wnk1amIyVm1aaWtnS2lCa0lDOGdjaUFxSUhOd2NtbHVaeTUzWldsbmFIUTdYRzVjYmlBZ1ltOWtlVEV1Wm05eVkyVXVlQ0FyUFNCamIyVm1aaUFxSUdSNE8xeHVJQ0JpYjJSNU1TNW1iM0pqWlM1NUlDczlJR052WldabUlDb2daSGs3WEc1Y2JpQWdZbTlrZVRJdVptOXlZMlV1ZUNBdFBTQmpiMlZtWmlBcUlHUjRPMXh1SUNCaWIyUjVNaTVtYjNKalpTNTVJQzA5SUdOdlpXWm1JQ29nWkhrN1hHNTlYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZXlCdFlXdGxVM0J5YVc1bkxDQmhjSEJzZVZOd2NtbHVaeUI5TzF4dVhHNWNibHh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVklnTHk5Y2JpOHZJQzR2YzNKakwyVjFiR1Z5TDNOd2NtbHVaeTVxY3lJc0lpOHFLbHh1VkdobElHbHRjR3hsYldWdWRHRjBhVzl1SUc5bUlIUm9aU0JGZFd4bGNpQnNZWGx2ZFhRZ1lXeG5iM0pwZEdodFhHNHFMMXh1WEc1amIyNXpkQ0JNWVhsdmRYUWdQU0J5WlhGMWFYSmxLQ2N1TGk5c1lYbHZkWFFuS1R0Y2JtTnZibk4wSUdGemMybG5iaUE5SUhKbGNYVnBjbVVvSnk0dUwyRnpjMmxuYmljcE8xeHVZMjl1YzNRZ1pHVm1ZWFZzZEhNZ1BTQnlaWEYxYVhKbEtDY3VMMlJsWm1GMWJIUnpKeWs3WEc1amIyNXpkQ0I3SUhScFkyc2dmU0E5SUhKbGNYVnBjbVVvSnk0dmRHbGpheWNwTzF4dVkyOXVjM1FnZXlCdFlXdGxVWFZoWkhSeVpXVWdmU0E5SUhKbGNYVnBjbVVvSnk0dmNYVmhaSFJ5WldVbktUdGNibU52Ym5OMElIc2diV0ZyWlVKdlpIa2dmU0E5SUhKbGNYVnBjbVVvSnk0dlltOWtlU2NwTzF4dVkyOXVjM1FnZXlCdFlXdGxVM0J5YVc1bklIMGdQU0J5WlhGMWFYSmxLQ2N1TDNOd2NtbHVaeWNwTzF4dVkyOXVjM1FnYVhOR2JpQTlJR1p1SUQwK0lIUjVjR1Z2WmlCbWJpQTlQVDBnSjJaMWJtTjBhVzl1Snp0Y2JtTnZibk4wSUdselVHRnlaVzUwSUQwZ2JpQTlQaUJ1TG1selVHRnlaVzUwS0NrN1hHNWpiMjV6ZENCdWIzUkpjMUJoY21WdWRDQTlJRzRnUFQ0Z0lXbHpVR0Z5Wlc1MEtHNHBPMXh1WTI5dWMzUWdhWE5NYjJOclpXUWdQU0J1SUQwK0lHNHViRzlqYTJWa0tDazdYRzVqYjI1emRDQnViM1JKYzB4dlkydGxaQ0E5SUc0Z1BUNGdJV2x6VEc5amEyVmtLRzRwTzF4dVkyOXVjM1FnYVhOUVlYSmxiblJGWkdkbElEMGdaU0E5UGlCcGMxQmhjbVZ1ZENnZ1pTNXpiM1Z5WTJVb0tTQXBJSHg4SUdselVHRnlaVzUwS0NCbExuUmhjbWRsZENncElDazdYRzVqYjI1emRDQnViM1JKYzFCaGNtVnVkRVZrWjJVZ1BTQmxJRDArSUNGcGMxQmhjbVZ1ZEVWa1oyVW9aU2s3WEc1amIyNXpkQ0JuWlhSQ2IyUjVJRDBnYmlBOVBpQnVMbk5qY21GMFkyZ29KMlYxYkdWeUp5a3VZbTlrZVR0Y2JtTnZibk4wSUdkbGRFNXZibEJoY21WdWRFUmxjMk5sYm1SaGJuUnpJRDBnYmlBOVBpQnBjMUJoY21WdWRDaHVLU0EvSUc0dVpHVnpZMlZ1WkdGdWRITW9LUzVtYVd4MFpYSW9JRzV2ZEVselVHRnlaVzUwSUNrZ09pQnVPMXh1WEc1amIyNXpkQ0JuWlhSVFkzSmhkR05vSUQwZ1pXd2dQVDRnZTF4dUlDQnNaWFFnYzJOeVlYUmphQ0E5SUdWc0xuTmpjbUYwWTJnb0oyVjFiR1Z5SnlrN1hHNWNiaUFnYVdZb0lDRnpZM0poZEdOb0lDbDdYRzRnSUNBZ2MyTnlZWFJqYUNBOUlIdDlPMXh1WEc0Z0lDQWdaV3d1YzJOeVlYUmphQ2duWlhWc1pYSW5MQ0J6WTNKaGRHTm9LVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ6WTNKaGRHTm9PMXh1ZlR0Y2JseHVZMjl1YzNRZ2IzQjBSbTRnUFNBb0lHOXdkQ3dnWld4bElDa2dQVDRnZTF4dUlDQnBaaWdnYVhOR2JpZ2diM0IwSUNrZ0tYdGNiaUFnSUNCeVpYUjFjbTRnYjNCMEtDQmxiR1VnS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnYjNCME8xeHVJQ0I5WEc1OU8xeHVYRzVqYkdGemN5QkZkV3hsY2lCbGVIUmxibVJ6SUV4aGVXOTFkQ0I3WEc0Z0lHTnZibk4wY25WamRHOXlLQ0J2Y0hScGIyNXpJQ2w3WEc0Z0lDQWdjM1Z3WlhJb0lHRnpjMmxuYmlnZ2UzMHNJR1JsWm1GMWJIUnpMQ0J2Y0hScGIyNXpJQ2tnS1R0Y2JpQWdmVnh1WEc0Z0lIQnlaWEoxYmlnZ2MzUmhkR1VnS1h0Y2JpQWdJQ0JzWlhRZ2N5QTlJSE4wWVhSbE8xeHVYRzRnSUNBZ2N5NXhkV0ZrZEhKbFpTQTlJRzFoYTJWUmRXRmtkSEpsWlNncE8xeHVYRzRnSUNBZ2JHVjBJR0p2WkdsbGN5QTlJSE11WW05a2FXVnpJRDBnVzEwN1hHNWNiaUFnSUNBdkx5QnlaV2QxYkdGeUlHNXZaR1Z6WEc0Z0lDQWdjeTV1YjJSbGN5NW1hV3gwWlhJb0lHNGdQVDRnYm05MFNYTlFZWEpsYm5Rb2Jpa2dLUzVtYjNKRllXTm9LQ0J1SUQwK0lIdGNiaUFnSUNBZ0lHeGxkQ0J6WTNKaGRHTm9JRDBnWjJWMFUyTnlZWFJqYUNnZ2JpQXBPMXh1WEc0Z0lDQWdJQ0JzWlhRZ1ltOWtlU0E5SUcxaGEyVkNiMlI1S0h0Y2JpQWdJQ0FnSUNBZ2NHOXpPaUI3SUhnNklITmpjbUYwWTJndWVDd2dlVG9nYzJOeVlYUmphQzU1SUgwc1hHNGdJQ0FnSUNBZ0lHMWhjM002SUc5d2RFWnVLQ0J6TG0xaGMzTXNJRzRnS1N4Y2JpQWdJQ0FnSUNBZ2JHOWphMlZrT2lCelkzSmhkR05vTG14dlkydGxaRnh1SUNBZ0lDQWdmU2s3WEc1Y2JpQWdJQ0FnSUdKdlpIa3VYMk41VG05a1pTQTlJRzQ3WEc1Y2JpQWdJQ0FnSUhOamNtRjBZMmd1WW05a2VTQTlJR0p2WkhrN1hHNWNiaUFnSUNBZ0lHSnZaSGt1WDNOamNtRjBZMmdnUFNCelkzSmhkR05vTzF4dVhHNGdJQ0FnSUNCaWIyUnBaWE11Y0hWemFDZ2dZbTlrZVNBcE8xeHVJQ0FnSUgwZ0tUdGNibHh1SUNBZ0lHeGxkQ0J6Y0hKcGJtZHpJRDBnY3k1emNISnBibWR6SUQwZ1cxMDdYRzVjYmlBZ0lDQXZMeUJ5WldkMWJHRnlJR1ZrWjJVZ2MzQnlhVzVuYzF4dUlDQWdJSE11WldSblpYTXVabWxzZEdWeUtDQnViM1JKYzFCaGNtVnVkRVZrWjJVZ0tTNW1iM0pGWVdOb0tDQmxJRDArSUh0Y2JpQWdJQ0FnSUd4bGRDQnpjSEpwYm1jZ1BTQnRZV3RsVTNCeWFXNW5LSHRjYmlBZ0lDQWdJQ0FnYzI5MWNtTmxPaUJuWlhSQ2IyUjVLQ0JsTG5OdmRYSmpaU2dwSUNrc1hHNGdJQ0FnSUNBZ0lIUmhjbWRsZERvZ1oyVjBRbTlrZVNnZ1pTNTBZWEpuWlhRb0tTQXBMRnh1SUNBZ0lDQWdJQ0JzWlc1bmRHZzZJRzl3ZEVadUtDQnpMbk53Y21sdVoweGxibWQwYUN3Z1pTQXBMRnh1SUNBZ0lDQWdJQ0JqYjJWbVpqb2diM0IwUm00b0lITXVjM0J5YVc1blEyOWxabVlzSUdVZ0tWeHVJQ0FnSUNBZ2ZTazdYRzVjYmlBZ0lDQWdJSE53Y21sdVp5NWZZM2xGWkdkbElEMGdaVHRjYmx4dUlDQWdJQ0FnYkdWMElITmpjbUYwWTJnZ1BTQm5aWFJUWTNKaGRHTm9LQ0JsSUNrN1hHNWNiaUFnSUNBZ0lITndjbWx1Wnk1ZmMyTnlZWFJqYUNBOUlITmpjbUYwWTJnN1hHNWNiaUFnSUNBZ0lITmpjbUYwWTJndWMzQnlhVzVuSUQwZ2MzQnlhVzVuTzF4dVhHNGdJQ0FnSUNCemNISnBibWR6TG5CMWMyZ29JSE53Y21sdVp5QXBPMXh1SUNBZ0lIMGdLVHRjYmx4dUlDQWdJQzh2SUdOdmJYQnZkVzVrSUdWa1oyVWdjM0J5YVc1bmMxeHVJQ0FnSUhNdVpXUm5aWE11Wm1sc2RHVnlLQ0JwYzFCaGNtVnVkRVZrWjJVZ0tTNW1iM0pGWVdOb0tDQmxJRDArSUh0Y2JpQWdJQ0FnSUd4bGRDQnpiM1Z5WTJWeklEMGdaMlYwVG05dVVHRnlaVzUwUkdWelkyVnVaR0Z1ZEhNb0lHVXVjMjkxY21ObEtDa2dLVHRjYmlBZ0lDQWdJR3hsZENCMFlYSm5aWFJ6SUQwZ1oyVjBUbTl1VUdGeVpXNTBSR1Z6WTJWdVpHRnVkSE1vSUdVdWRHRnlaMlYwS0NrZ0tUdGNibHh1SUNBZ0lDQWdMeThnYW5WemRDQmhaR1FnYjI1bElITndjbWx1WnlCbWIzSWdjR1Z5Wmx4dUlDQWdJQ0FnYzI5MWNtTmxjeUE5SUZzZ2MyOTFjbU5sYzFzd1hTQmRPMXh1SUNBZ0lDQWdkR0Z5WjJWMGN5QTlJRnNnZEdGeVoyVjBjMXN3WFNCZE8xeHVYRzRnSUNBZ0lDQnpiM1Z5WTJWekxtWnZja1ZoWTJnb0lITnlZeUE5UGlCN1hHNGdJQ0FnSUNBZ0lIUmhjbWRsZEhNdVptOXlSV0ZqYUNnZ2RHZDBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQnpjSEpwYm1kekxuQjFjMmdvSUcxaGEyVlRjSEpwYm1jb2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYzI5MWNtTmxPaUJuWlhSQ2IyUjVLQ0J6Y21NZ0tTeGNiaUFnSUNBZ0lDQWdJQ0FnSUhSaGNtZGxkRG9nWjJWMFFtOWtlU2dnZEdkMElDa3NYRzRnSUNBZ0lDQWdJQ0FnSUNCc1pXNW5kR2c2SUc5d2RFWnVLQ0J6TG5Od2NtbHVaMHhsYm1kMGFDd2daU0FwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZMjlsWm1ZNklHOXdkRVp1S0NCekxuTndjbWx1WjBOdlpXWm1MQ0JsSUNsY2JpQWdJQ0FnSUNBZ0lDQjlLU0FwTzF4dUlDQWdJQ0FnSUNCOUlDazdYRzRnSUNBZ0lDQjlJQ2s3WEc0Z0lDQWdmU0FwTzF4dUlDQjlYRzVjYmlBZ2RHbGpheWdnYzNSaGRHVWdLWHRjYmlBZ0lDQnNaWFFnYlc5MlpXMWxiblFnUFNCMGFXTnJLQ0J6ZEdGMFpTQXBPMXh1WEc0Z0lDQWdiR1YwSUdselJHOXVaU0E5SUcxdmRtVnRaVzUwSUR3OUlITjBZWFJsTG0xdmRtVnRaVzUwVkdoeVpYTm9iMnhrTzF4dVhHNGdJQ0FnY21WMGRYSnVJR2x6Ukc5dVpUdGNiaUFnZlZ4dWZWeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRVYxYkdWeU8xeHVYRzVjYmx4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZJZ0x5OWNiaTh2SUM0dmMzSmpMMlYxYkdWeUwybHVaR1Y0TG1weklpd2lZMjl1YzNRZ1pHVm1ZWFZzZEhNZ1BTQlBZbXBsWTNRdVpuSmxaWHBsS0h0Y2JpQWdjRzl6T2lCN0lIZzZJREFzSUhrNklEQWdmU3hjYmlBZ2NISmxkbEJ2Y3pvZ2V5QjRPaUF3TENCNU9pQXdJSDBzWEc0Z0lHWnZjbU5sT2lCN0lIZzZJREFzSUhrNklEQWdmU3hjYmlBZ2RtVnNiMk5wZEhrNklIc2dlRG9nTUN3Z2VUb2dNQ0I5TEZ4dUlDQnRZWE56T2lBeFhHNTlLVHRjYmx4dVkyOXVjM1FnWTI5d2VWWmxZeUE5SUhZZ1BUNGdLSHNnZURvZ2RpNTRMQ0I1T2lCMkxua2dmU2s3WEc1amIyNXpkQ0JuWlhSV1lXeDFaU0E5SUNnZ2RtRnNMQ0JrWldZZ0tTQTlQaUIyWVd3Z0lUMGdiblZzYkNBL0lIWmhiQ0E2SUdSbFpqdGNibU52Ym5OMElHZGxkRlpsWXlBOUlDZ2dkbVZqTENCa1pXWWdLU0E5UGlCamIzQjVWbVZqS0NCblpYUldZV3gxWlNnZ2RtVmpMQ0JrWldZZ0tTQXBPMXh1WEc1bWRXNWpkR2x2YmlCdFlXdGxRbTlrZVNnZ2IzQjBjeUFwZTF4dUlDQnNaWFFnWWlBOUlIdDlPMXh1WEc0Z0lHSXVjRzl6SUQwZ1oyVjBWbVZqS0NCdmNIUnpMbkJ2Y3l3Z1pHVm1ZWFZzZEhNdWNHOXpJQ2s3WEc0Z0lHSXVjSEpsZGxCdmN5QTlJR2RsZEZabFl5Z2diM0IwY3k1d2NtVjJVRzl6TENCaUxuQnZjeUFwTzF4dUlDQmlMbVp2Y21ObElEMGdaMlYwVm1WaktDQnZjSFJ6TG1admNtTmxMQ0JrWldaaGRXeDBjeTVtYjNKalpTQXBPMXh1SUNCaUxuWmxiRzlqYVhSNUlEMGdaMlYwVm1WaktDQnZjSFJ6TG5abGJHOWphWFI1TENCa1pXWmhkV3gwY3k1MlpXeHZZMmwwZVNBcE8xeHVJQ0JpTG0xaGMzTWdQU0J2Y0hSekxtMWhjM01nSVQwZ2JuVnNiQ0EvSUc5d2RITXViV0Z6Y3lBNklHUmxabUYxYkhSekxtMWhjM003WEc0Z0lHSXViRzlqYTJWa0lEMGdiM0IwY3k1c2IyTnJaV1E3WEc1Y2JpQWdjbVYwZFhKdUlHSTdYRzU5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2V5QnRZV3RsUW05a2VTQjlPMXh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDJWMWJHVnlMMkp2WkhrdWFuTWlMQ0pqYjI1emRDQmtaV1poZFd4MGN5QTlJRTlpYW1WamRDNW1jbVZsZW1Vb2UxeHVJQ0F2THlCVWFHVWdhV1JsWVd3Z2JHVm5kR2dnYjJZZ1lTQnpjSEpwYm1kY2JpQWdMeThnTFNCVWFHbHpJR0ZqZEhNZ1lYTWdZU0JvYVc1MElHWnZjaUIwYUdVZ1pXUm5aU0JzWlc1bmRHaGNiaUFnTHk4Z0xTQlVhR1VnWldSblpTQnNaVzVuZEdnZ1kyRnVJR0psSUd4dmJtZGxjaUJ2Y2lCemFHOXlkR1Z5SUdsbUlIUm9aU0JtYjNKalpYTWdZWEpsSUhObGRDQjBieUJsZUhSeVpXMWxJSFpoYkhWbGMxeHVJQ0J6Y0hKcGJtZE1aVzVuZEdnNklHVmtaMlVnUFQ0Z09EQXNYRzVjYmlBZ0x5OGdTRzl2YTJVbmN5QnNZWGNnWTI5bFptWnBZMmxsYm5SY2JpQWdMeThnTFNCVWFHVWdkbUZzZFdVZ2NtRnVaMlZ6SUc5dUlGc3dMQ0F4WFZ4dUlDQXZMeUF0SUV4dmQyVnlJSFpoYkhWbGN5Qm5hWFpsSUd4dmIzTmxjaUJ6Y0hKcGJtZHpYRzRnSUM4dklDMGdTR2xuYUdWeUlIWmhiSFZsY3lCbmFYWmxJSFJwWjJoMFpYSWdjM0J5YVc1bmMxeHVJQ0J6Y0hKcGJtZERiMlZtWmpvZ1pXUm5aU0E5UGlBd0xqQXdNRGdzWEc1Y2JpQWdMeThnVkdobElHMWhjM01nYjJZZ2RHaGxJRzV2WkdVZ2FXNGdkR2hsSUhCb2VYTnBZM01nYzJsdGRXeGhkR2x2Ymx4dUlDQXZMeUF0SUZSb1pTQnRZWE56SUdGbVptVmpkSE1nZEdobElHZHlZWFpwZEhrZ2JtOWtaU0J5WlhCMWJITnBiMjR2WVhSMGNtRmpkR2x2Ymx4dUlDQnRZWE56T2lCdWIyUmxJRDArSURRc1hHNWNiaUFnTHk4Z1EyOTFiRzl0WWlkeklHeGhkeUJqYjJWbVptbGphV1Z1ZEZ4dUlDQXZMeUF0SUUxaGEyVnpJSFJvWlNCdWIyUmxjeUJ5WlhCbGJDQmxZV05vSUc5MGFHVnlJR1p2Y2lCdVpXZGhkR2wyWlNCMllXeDFaWE5jYmlBZ0x5OGdMU0JOWVd0bGN5QjBhR1VnYm05a1pYTWdZWFIwY21GamRDQmxZV05vSUc5MGFHVnlJR1p2Y2lCd2IzTnBkR2wyWlNCMllXeDFaWE5jYmlBZ1ozSmhkbWwwZVRvZ0xURXVNaXhjYmx4dUlDQXZMeUJCSUdadmNtTmxJSFJvWVhRZ2NIVnNiSE1nYm05a1pYTWdkRzkzWVhKa2N5QjBhR1VnYjNKcFoybHVJQ2d3TENBd0tWeHVJQ0F2THlCSWFXZG9aWElnZG1Gc2RXVnpJR3RsWlhBZ2RHaGxJR052YlhCdmJtVnVkSE1nYkdWemN5QnpjSEpsWVdRZ2IzVjBYRzRnSUhCMWJHdzZJREF1TURBeExGeHVYRzRnSUM4dklGUm9aWFJoSUdOdlpXWm1hV05wWlc1MElHWnliMjBnUW1GeWJtVnpMVWgxZENCemFXMTFiR0YwYVc5dVhHNGdJQzh2SUMwZ1ZtRnNkV1VnY21GdVoyVnpJRzl1SUZzd0xDQXhYVnh1SUNBdkx5QXRJRkJsY21admNtMWhibU5sSUdseklHSmxkSFJsY2lCM2FYUm9JSE50WVd4c1pYSWdkbUZzZFdWelhHNGdJQzh2SUMwZ1ZtVnllU0J6YldGc2JDQjJZV3gxWlhNZ2JXRjVJRzV2ZENCamNtVmhkR1VnWlc1dmRXZG9JR1p2Y21ObElIUnZJR2RwZG1VZ1lTQm5iMjlrSUhKbGMzVnNkRnh1SUNCMGFHVjBZVG9nTUM0Mk5qWXNYRzVjYmlBZ0x5OGdSbkpwWTNScGIyNGdMeUJrY21GbklHTnZaV1ptYVdOcFpXNTBJSFJ2SUcxaGEyVWdkR2hsSUhONWMzUmxiU0J6ZEdGaWFXeHBjMlVnYjNabGNpQjBhVzFsWEc0Z0lHUnlZV2REYjJWbVpqb2dNQzR3TWl4Y2JseHVJQ0F2THlCWGFHVnVJSFJvWlNCMGIzUmhiQ0J2WmlCMGFHVWdjM0YxWVhKbFpDQndiM05wZEdsdmJpQmtaV3gwWVhNZ2FYTWdiR1Z6Y3lCMGFHRnVJSFJvYVhNZ2RtRnNkV1VzSUhSb1pTQnphVzExYkdGMGFXOXVJR1Z1WkhOY2JpQWdiVzkyWlcxbGJuUlVhSEpsYzJodmJHUTZJREVzWEc1Y2JpQWdMeThnVkdobElHRnRiM1Z1ZENCdlppQjBhVzFsSUhCaGMzTmxaQ0J3WlhJZ2RHbGphMXh1SUNBdkx5QXRJRXhoY21kbGNpQjJZV3gxWlhNZ2NtVnpkV3gwSUdsdUlHWmhjM1JsY2lCeWRXNTBhVzFsY3lCaWRYUWdiV2xuYUhRZ2MzQnlaV0ZrSUhSb2FXNW5jeUJ2ZFhRZ2RHOXZJR1poY2x4dUlDQXZMeUF0SUZOdFlXeHNaWElnZG1Gc2RXVnpJSEJ5YjJSMVkyVWdiVzl5WlNCaFkyTjFjbUYwWlNCeVpYTjFiSFJ6WEc0Z0lIUnBiV1ZUZEdWd09pQXlNRnh1ZlNrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdaR1ZtWVhWc2RITTdYRzVjYmx4dVhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVpQXZMMXh1THk4Z0xpOXpjbU12WlhWc1pYSXZaR1ZtWVhWc2RITXVhbk1pTENKamIyNXpkQ0JrWldaaGRXeDBRMjlsWm1ZZ1BTQXdMakF5TzF4dVhHNW1kVzVqZEdsdmJpQmhjSEJzZVVSeVlXY29JR0p2Wkhrc0lHMWhiblZoYkVSeVlXZERiMlZtWmlBcGUxeHVJQ0JzWlhRZ1pISmhaME52WldabU8xeHVYRzRnSUdsbUtDQnRZVzUxWVd4RWNtRm5RMjlsWm1ZZ0lUMGdiblZzYkNBcGUxeHVJQ0FnSUdSeVlXZERiMlZtWmlBOUlHMWhiblZoYkVSeVlXZERiMlZtWmp0Y2JpQWdmU0JsYkhObElHbG1LQ0JpYjJSNUxtUnlZV2REYjJWbVppQWhQU0J1ZFd4c0lDbDdYRzRnSUNBZ1pISmhaME52WldabUlEMGdZbTlrZVM1a2NtRm5RMjlsWm1ZN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ1pISmhaME52WldabUlEMGdaR1ZtWVhWc2RFTnZaV1ptTzF4dUlDQjlYRzVjYmlBZ1ltOWtlUzVtYjNKalpTNTRJQzA5SUdSeVlXZERiMlZtWmlBcUlHSnZaSGt1ZG1Wc2IyTnBkSGt1ZUR0Y2JpQWdZbTlrZVM1bWIzSmpaUzU1SUMwOUlHUnlZV2REYjJWbVppQXFJR0p2WkhrdWRtVnNiMk5wZEhrdWVUdGNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN0lHRndjR3g1UkhKaFp5QjlPMXh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDJWMWJHVnlMMlJ5WVdjdWFuTWlMQ0l2THlCMWMyVWdaWFZzWlhJZ2JXVjBhRzlrSUdadmNpQm1iM0pqWlNCcGJuUmxaM0poZEdsdmJpQm9kSFJ3T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMMFYxYkdWeVgyMWxkR2h2WkZ4dUx5OGdjbVYwZFhKdUlITjFiU0J2WmlCemNYVmhjbVZrSUhCdmMybDBhVzl1SUdSbGJIUmhjMXh1Wm5WdVkzUnBiMjRnYVc1MFpXZHlZWFJsS0NCaWIyUnBaWE1zSUhScGJXVlRkR1Z3SUNsN1hHNGdJSFpoY2lCa2VDQTlJREFzSUhSNElEMGdNQ3hjYmlBZ0lDQWdJR1I1SUQwZ01Dd2dkSGtnUFNBd0xGeHVJQ0FnSUNBZ2FTeGNiaUFnSUNBZ0lHMWhlQ0E5SUdKdlpHbGxjeTVzWlc1bmRHZzdYRzVjYmlBZ2FXWWdLRzFoZUNBOVBUMGdNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQXdPMXh1SUNCOVhHNWNiaUFnWm05eUlDaHBJRDBnTURzZ2FTQThJRzFoZURzZ0t5dHBLU0I3WEc0Z0lDQWdkbUZ5SUdKdlpIa2dQU0JpYjJScFpYTmJhVjBzWEc0Z0lDQWdJQ0FnSUdOdlpXWm1JRDBnZEdsdFpWTjBaWEFnTHlCaWIyUjVMbTFoYzNNN1hHNWNiaUFnSUNCcFppZ2dZbTlrZVM1bmNtRmlZbVZrSUNsN0lHTnZiblJwYm5WbE95QjlYRzVjYmlBZ0lDQnBaaWdnWW05a2VTNXNiMk5yWldRZ0tYdGNiaUFnSUNBZ0lHSnZaSGt1ZG1Wc2IyTnBkSGt1ZUNBOUlEQTdYRzRnSUNBZ0lDQmliMlI1TG5abGJHOWphWFI1TG5rZ1BTQXdPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCaWIyUjVMblpsYkc5amFYUjVMbmdnS3owZ1kyOWxabVlnS2lCaWIyUjVMbVp2Y21ObExuZzdYRzRnSUNBZ0lDQmliMlI1TG5abGJHOWphWFI1TG5rZ0t6MGdZMjlsWm1ZZ0tpQmliMlI1TG1admNtTmxMbms3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdkbUZ5SUhaNElEMGdZbTlrZVM1MlpXeHZZMmwwZVM1NExGeHVJQ0FnSUNBZ0lDQjJlU0E5SUdKdlpIa3VkbVZzYjJOcGRIa3VlU3hjYmlBZ0lDQWdJQ0FnZGlBOUlFMWhkR2d1YzNGeWRDaDJlQ0FxSUhaNElDc2dkbmtnS2lCMmVTazdYRzVjYmlBZ0lDQnBaaUFvZGlBK0lERXBJSHRjYmlBZ0lDQWdJR0p2WkhrdWRtVnNiMk5wZEhrdWVDQTlJSFo0SUM4Z2RqdGNiaUFnSUNBZ0lHSnZaSGt1ZG1Wc2IyTnBkSGt1ZVNBOUlIWjVJQzhnZGp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JrZUNBOUlIUnBiV1ZUZEdWd0lDb2dZbTlrZVM1MlpXeHZZMmwwZVM1NE8xeHVJQ0FnSUdSNUlEMGdkR2x0WlZOMFpYQWdLaUJpYjJSNUxuWmxiRzlqYVhSNUxuazdYRzVjYmlBZ0lDQmliMlI1TG5CdmN5NTRJQ3M5SUdSNE8xeHVJQ0FnSUdKdlpIa3VjRzl6TG5rZ0t6MGdaSGs3WEc1Y2JpQWdJQ0IwZUNBclBTQk5ZWFJvTG1GaWN5aGtlQ2s3SUhSNUlDczlJRTFoZEdndVlXSnpLR1I1S1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlBb2RIZ2dLaUIwZUNBcklIUjVJQ29nZEhrcEwyMWhlRHRjYm4xY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdJR2x1ZEdWbmNtRjBaU0I5TzF4dVhHNWNibHh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVklnTHk5Y2JpOHZJQzR2YzNKakwyVjFiR1Z5TDJsdWRHVm5jbUYwWlM1cWN5SXNJaTh2SUdsdGNHd2diMllnWW1GeWJtVnpJR2gxZEZ4dUx5OGdhSFIwY0RvdkwzZDNkeTVsWldOekxtSmxjbXRsYkdWNUxtVmtkUzkrWkdWdGJXVnNMMk56TWpZM0wyeGxZM1IxY21VeU5pOXNaV04wZFhKbE1qWXVhSFJ0YkZ4dUx5OGdhSFIwY0RvdkwyVnVMbmRwYTJsd1pXUnBZUzV2Y21jdmQybHJhUzlDWVhKdVpYTWxSVElsT0RBbE9UTklkWFJmYzJsdGRXeGhkR2x2Ymx4dVhHNWpiMjV6ZENCT2IyUmxJRDBnY21WeGRXbHlaU2duTGk5dWIyUmxKeWs3WEc1amIyNXpkQ0JKYm5ObGNuUlRkR0ZqYXlBOUlISmxjWFZwY21Vb0p5NHZhVzV6WlhKMFUzUmhZMnNuS1R0Y2JseHVZMjl1YzNRZ2NtVnpaWFJXWldNZ1BTQjJJRDArSUhzZ2RpNTRJRDBnTURzZ2RpNTVJRDBnTURzZ2ZUdGNibHh1WTI5dWMzUWdhWE5UWVcxbFVHOXphWFJwYjI0Z1BTQW9jREVzSUhBeUtTQTlQaUI3WEc0Z0lHeGxkQ0IwYUhKbGMyaHZiR1FnUFNBeFpTMDRPMXh1SUNCc1pYUWdaSGdnUFNCTllYUm9MbUZpY3lod01TNTRJQzBnY0RJdWVDazdYRzRnSUd4bGRDQmtlU0E5SUUxaGRHZ3VZV0p6S0hBeExua2dMU0J3TWk1NUtUdGNibHh1SUNCeVpYUjFjbTRnWkhnZ1BDQjBhSEpsYzJodmJHUWdKaVlnWkhrZ1BDQjBhSEpsYzJodmJHUTdYRzU5TzF4dVhHNW1kVzVqZEdsdmJpQnRZV3RsVVhWaFpIUnlaV1VvS1h0Y2JpQWdiR1YwSUhWd1pHRjBaVkYxWlhWbElEMGdXMTBzWEc0Z0lDQWdhVzV6WlhKMFUzUmhZMnNnUFNCdVpYY2dTVzV6WlhKMFUzUmhZMnNvS1N4Y2JpQWdJQ0J1YjJSbGMwTmhZMmhsSUQwZ1cxMHNYRzRnSUNBZ1kzVnljbVZ1ZEVsdVEyRmphR1VnUFNBd0xGeHVJQ0FnSUhKdmIzUWdQU0J1WlhkT2IyUmxLQ2s3WEc1Y2JpQWdablZ1WTNScGIyNGdibVYzVG05a1pTZ3BJSHRjYmlBZ0lDQXZMeUJVYnlCaGRtOXBaQ0J3Y21WemMzVnlaU0J2YmlCSFF5QjNaU0J5WlhWelpTQnViMlJsY3k1Y2JpQWdJQ0JzWlhRZ2JtOWtaU0E5SUc1dlpHVnpRMkZqYUdWYlkzVnljbVZ1ZEVsdVEyRmphR1ZkTzF4dUlDQWdJR2xtSUNodWIyUmxLU0I3WEc0Z0lDQWdJQ0J1YjJSbExuRjFZV1F3SUQwZ2JuVnNiRHRjYmlBZ0lDQWdJRzV2WkdVdWNYVmhaREVnUFNCdWRXeHNPMXh1SUNBZ0lDQWdibTlrWlM1eGRXRmtNaUE5SUc1MWJHdzdYRzRnSUNBZ0lDQnViMlJsTG5GMVlXUXpJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lHNXZaR1V1WW05a2VTQTlJRzUxYkd3N1hHNGdJQ0FnSUNCdWIyUmxMbTFoYzNNZ1BTQnViMlJsTG0xaGMzTllJRDBnYm05a1pTNXRZWE56V1NBOUlEQTdYRzRnSUNBZ0lDQnViMlJsTG14bFpuUWdQU0J1YjJSbExuSnBaMmgwSUQwZ2JtOWtaUzUwYjNBZ1BTQnViMlJsTG1KdmRIUnZiU0E5SURBN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJRzV2WkdVZ1BTQnVaWGNnVG05a1pTZ3BPMXh1SUNBZ0lDQWdibTlrWlhORFlXTm9aVnRqZFhKeVpXNTBTVzVEWVdOb1pWMGdQU0J1YjJSbE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUNzclkzVnljbVZ1ZEVsdVEyRmphR1U3WEc0Z0lDQWdjbVYwZFhKdUlHNXZaR1U3WEc0Z0lIMWNibHh1SUNCbWRXNWpkR2x2YmlCMWNHUmhkR1VvSUhOdmRYSmpaVUp2Wkhrc0lHZHlZWFpwZEhrc0lIUm9aWFJoTENCd2RXeHNJQ2tnZTF4dUlDQWdJR3hsZENCeGRXVjFaU0E5SUhWd1pHRjBaVkYxWlhWbExGeHVJQ0FnSUNBZ2RpeGNiaUFnSUNBZ0lHUjRMRnh1SUNBZ0lDQWdaSGtzWEc0Z0lDQWdJQ0J5TENCbWVDQTlJREFzWEc0Z0lDQWdJQ0JtZVNBOUlEQXNYRzRnSUNBZ0lDQnhkV1YxWlV4bGJtZDBhQ0E5SURFc1hHNGdJQ0FnSUNCemFHbG1kRWxrZUNBOUlEQXNYRzRnSUNBZ0lDQndkWE5vU1dSNElEMGdNVHRjYmx4dUlDQWdJSEYxWlhWbFd6QmRJRDBnY205dmREdGNibHh1SUNBZ0lISmxjMlYwVm1WaktDQnpiM1Z5WTJWQ2IyUjVMbVp2Y21ObElDazdYRzVjYmlBZ0lDQnNaWFFnY0hnZ1BTQXRjMjkxY21ObFFtOWtlUzV3YjNNdWVEdGNiaUFnSUNCc1pYUWdjSGtnUFNBdGMyOTFjbU5sUW05a2VTNXdiM011ZVR0Y2JpQWdJQ0JzWlhRZ2NISWdQU0JOWVhSb0xuTnhjblFvY0hnZ0tpQndlQ0FySUhCNUlDb2djSGtwTzF4dUlDQWdJR3hsZENCd2RpQTlJSE52ZFhKalpVSnZaSGt1YldGemN5QXFJSEIxYkd3Z0x5QndjanRjYmx4dUlDQWdJR1o0SUNzOUlIQjJJQ29nY0hnN1hHNGdJQ0FnWm5rZ0t6MGdjSFlnS2lCd2VUdGNibHh1SUNBZ0lIZG9hV3hsSUNoeGRXVjFaVXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdiR1YwSUc1dlpHVWdQU0J4ZFdWMVpWdHphR2xtZEVsa2VGMHNYRzRnSUNBZ0lDQWdJR0p2WkhrZ1BTQnViMlJsTG1KdlpIazdYRzVjYmlBZ0lDQWdJSEYxWlhWbFRHVnVaM1JvSUMwOUlERTdYRzRnSUNBZ0lDQnphR2xtZEVsa2VDQXJQU0F4TzF4dUlDQWdJQ0FnYkdWMElHUnBabVpsY21WdWRFSnZaSGtnUFNBb1ltOWtlU0FoUFQwZ2MyOTFjbU5sUW05a2VTazdYRzRnSUNBZ0lDQnBaaUFvWW05a2VTQW1KaUJrYVdabVpYSmxiblJDYjJSNUtTQjdYRzRnSUNBZ0lDQWdJQzh2SUVsbUlIUm9aU0JqZFhKeVpXNTBJRzV2WkdVZ2FYTWdZU0JzWldGbUlHNXZaR1VnS0dGdVpDQnBkQ0JwY3lCdWIzUWdjMjkxY21ObElHSnZaSGtwTEZ4dUlDQWdJQ0FnSUNBdkx5QmpZV3hqZFd4aGRHVWdkR2hsSUdadmNtTmxJR1Y0WlhKMFpXUWdZbmtnZEdobElHTjFjbkpsYm5RZ2JtOWtaU0J2YmlCaWIyUjVMQ0JoYm1RZ1lXUmtJSFJvYVhOY2JpQWdJQ0FnSUNBZ0x5OGdZVzF2ZFc1MElIUnZJR0p2WkhrbmN5QnVaWFFnWm05eVkyVXVYRzRnSUNBZ0lDQWdJR1I0SUQwZ1ltOWtlUzV3YjNNdWVDQXRJSE52ZFhKalpVSnZaSGt1Y0c5ekxuZzdYRzRnSUNBZ0lDQWdJR1I1SUQwZ1ltOWtlUzV3YjNNdWVTQXRJSE52ZFhKalpVSnZaSGt1Y0c5ekxuazdYRzRnSUNBZ0lDQWdJSElnUFNCTllYUm9Mbk54Y25Rb1pIZ2dLaUJrZUNBcklHUjVJQ29nWkhrcE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNoeUlEMDlQU0F3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnVUc5dmNpQnRZVzRuY3lCd2NtOTBaV04wYVc5dUlHRm5ZV2x1YzNRZ2VtVnlieUJrYVhOMFlXNWpaUzVjYmlBZ0lDQWdJQ0FnSUNCa2VDQTlJQ2hOWVhSb0xuSmhibVJ2YlNncElDMGdNQzQxS1NBdklEVXdPMXh1SUNBZ0lDQWdJQ0FnSUdSNUlEMGdLRTFoZEdndWNtRnVaRzl0S0NrZ0xTQXdMalVwSUM4Z05UQTdYRzRnSUNBZ0lDQWdJQ0FnY2lBOUlFMWhkR2d1YzNGeWRDaGtlQ0FxSUdSNElDc2daSGtnS2lCa2VTazdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBdkx5QlVhR2x6SUdseklITjBZVzVrWVhKa0lHZHlZWFpwZEdsdmJpQm1iM0pqWlNCallXeGpkV3hoZEdsdmJpQmlkWFFnZDJVZ1pHbDJhV1JsWEc0Z0lDQWdJQ0FnSUM4dklHSjVJSEplTXlCMGJ5QnpZWFpsSUhSM2J5QnZjR1Z5WVhScGIyNXpJSGRvWlc0Z2JtOXliV0ZzYVhwcGJtY2dabTl5WTJVZ2RtVmpkRzl5TGx4dUlDQWdJQ0FnSUNCMklEMGdaM0poZG1sMGVTQXFJR0p2WkhrdWJXRnpjeUFxSUhOdmRYSmpaVUp2WkhrdWJXRnpjeUF2SUNoeUlDb2djaUFxSUhJcE8xeHVJQ0FnSUNBZ0lDQm1lQ0FyUFNCMklDb2daSGc3WEc0Z0lDQWdJQ0FnSUdaNUlDczlJSFlnS2lCa2VUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9aR2xtWm1WeVpXNTBRbTlrZVNrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUJQZEdobGNuZHBjMlVzSUdOaGJHTjFiR0YwWlNCMGFHVWdjbUYwYVc4Z2N5QXZJSElzSUNCM2FHVnlaU0J6SUdseklIUm9aU0IzYVdSMGFDQnZaaUIwYUdVZ2NtVm5hVzl1WEc0Z0lDQWdJQ0FnSUM4dklISmxjSEpsYzJWdWRHVmtJR0o1SUhSb1pTQnBiblJsY201aGJDQnViMlJsTENCaGJtUWdjaUJwY3lCMGFHVWdaR2x6ZEdGdVkyVWdZbVYwZDJWbGJpQjBhR1VnWW05a2VWeHVJQ0FnSUNBZ0lDQXZMeUJoYm1RZ2RHaGxJRzV2WkdVbmN5QmpaVzUwWlhJdGIyWXRiV0Z6YzF4dUlDQWdJQ0FnSUNCa2VDQTlJRzV2WkdVdWJXRnpjMWdnTHlCdWIyUmxMbTFoYzNNZ0xTQnpiM1Z5WTJWQ2IyUjVMbkJ2Y3k1NE8xeHVJQ0FnSUNBZ0lDQmtlU0E5SUc1dlpHVXViV0Z6YzFrZ0x5QnViMlJsTG0xaGMzTWdMU0J6YjNWeVkyVkNiMlI1TG5CdmN5NTVPMXh1SUNBZ0lDQWdJQ0J5SUQwZ1RXRjBhQzV6Y1hKMEtHUjRJQ29nWkhnZ0t5QmtlU0FxSUdSNUtUdGNibHh1SUNBZ0lDQWdJQ0JwWmlBb2NpQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUZOdmNuSjVJR0ZpYjNWMElHTnZaR1VnWkhWd2JIVmpZWFJwYjI0dUlFa2daRzl1SjNRZ2QyRnVkQ0IwYnlCamNtVmhkR1VnYldGdWVTQm1kVzVqZEdsdmJuTmNiaUFnSUNBZ0lDQWdJQ0F2THlCeWFXZG9kQ0JoZDJGNUxpQktkWE4wSUhkaGJuUWdkRzhnYzJWbElIQmxjbVp2Y20xaGJtTmxJR1pwY25OMExseHVJQ0FnSUNBZ0lDQWdJR1I0SUQwZ0tFMWhkR2d1Y21GdVpHOXRLQ2tnTFNBd0xqVXBJQzhnTlRBN1hHNGdJQ0FnSUNBZ0lDQWdaSGtnUFNBb1RXRjBhQzV5WVc1a2IyMG9LU0F0SURBdU5Ta2dMeUExTUR0Y2JpQWdJQ0FnSUNBZ0lDQnlJRDBnVFdGMGFDNXpjWEowS0dSNElDb2daSGdnS3lCa2VTQXFJR1I1S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQXZMeUJKWmlCeklDOGdjaUE4SU02NExDQjBjbVZoZENCMGFHbHpJR2x1ZEdWeWJtRnNJRzV2WkdVZ1lYTWdZU0J6YVc1bmJHVWdZbTlrZVN3Z1lXNWtJR05oYkdOMWJHRjBaU0IwYUdWY2JpQWdJQ0FnSUNBZ0x5OGdabTl5WTJVZ2FYUWdaWGhsY25SeklHOXVJSE52ZFhKalpVSnZaSGtzSUdGdVpDQmhaR1FnZEdocGN5QmhiVzkxYm5RZ2RHOGdjMjkxY21ObFFtOWtlU2R6SUc1bGRDQm1iM0pqWlM1Y2JpQWdJQ0FnSUNBZ2FXWWdLQ2h1YjJSbExuSnBaMmgwSUMwZ2JtOWtaUzVzWldaMEtTQXZJSElnUENCMGFHVjBZU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDOHZJR2x1SUhSb1pTQnBaaUJ6ZEdGMFpXMWxiblFnWVdKdmRtVWdkMlVnWTI5dWMybGtaWElnYm05a1pTZHpJSGRwWkhSb0lHOXViSGxjYmlBZ0lDQWdJQ0FnSUNBdkx5QmlaV05oZFhObElIUm9aU0J5WldkcGIyNGdkMkZ6SUhOeGRXRnlhV1pwWldRZ1pIVnlhVzVuSUhSeVpXVWdZM0psWVhScGIyNHVYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1ZHaDFjeUIwYUdWeVpTQnBjeUJ1YnlCa2FXWm1aWEpsYm1ObElHSmxkSGRsWlc0Z2RYTnBibWNnZDJsa2RHZ2diM0lnYUdWcFoyaDBMbHh1SUNBZ0lDQWdJQ0FnSUhZZ1BTQm5jbUYyYVhSNUlDb2dibTlrWlM1dFlYTnpJQ29nYzI5MWNtTmxRbTlrZVM1dFlYTnpJQzhnS0hJZ0tpQnlJQ29nY2lrN1hHNGdJQ0FnSUNBZ0lDQWdabmdnS3owZ2RpQXFJR1I0TzF4dUlDQWdJQ0FnSUNBZ0lHWjVJQ3M5SUhZZ0tpQmtlVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QlBkR2hsY25kcGMyVXNJSEoxYmlCMGFHVWdjSEp2WTJWa2RYSmxJSEpsWTNWeWMybDJaV3g1SUc5dUlHVmhZMmdnYjJZZ2RHaGxJR04xY25KbGJuUWdibTlrWlNkeklHTm9hV3hrY21WdUxseHVYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1NTQnBiblJsYm5ScGIyNWhiR3g1SUhWdVptOXNaR1ZrSUhSb2FYTWdiRzl2Y0N3Z2RHOGdjMkYyWlNCelpYWmxjbUZzSUVOUVZTQmplV05zWlhNdVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0c1dlpHVXVjWFZoWkRBcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhGMVpYVmxXM0IxYzJoSlpIaGRJRDBnYm05a1pTNXhkV0ZrTUR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEYxWlhWbFRHVnVaM1JvSUNzOUlERTdYRzRnSUNBZ0lDQWdJQ0FnSUNCd2RYTm9TV1I0SUNzOUlERTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h1YjJSbExuRjFZV1F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J4ZFdWMVpWdHdkWE5vU1dSNFhTQTlJRzV2WkdVdWNYVmhaREU3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnhkV1YxWlV4bGJtZDBhQ0FyUFNBeE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY0hWemFFbGtlQ0FyUFNBeE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCcFppQW9ibTlrWlM1eGRXRmtNaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjWFZsZFdWYmNIVnphRWxrZUYwZ1BTQnViMlJsTG5GMVlXUXlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NYVmxkV1ZNWlc1bmRHZ2dLejBnTVR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEIxYzJoSlpIZ2dLejBnTVR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHNXZaR1V1Y1hWaFpETXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIRjFaWFZsVzNCMWMyaEpaSGhkSUQwZ2JtOWtaUzV4ZFdGa016dGNiaUFnSUNBZ0lDQWdJQ0FnSUhGMVpYVmxUR1Z1WjNSb0lDczlJREU3WEc0Z0lDQWdJQ0FnSUNBZ0lDQndkWE5vU1dSNElDczlJREU3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2MyOTFjbU5sUW05a2VTNW1iM0pqWlM1NElDczlJR1o0TzF4dUlDQWdJSE52ZFhKalpVSnZaSGt1Wm05eVkyVXVlU0FyUFNCbWVUdGNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJR2x1YzJWeWRFSnZaR2xsY3loaWIyUnBaWE1wSUh0Y2JpQWdJQ0JwWmlnZ1ltOWthV1Z6TG14bGJtZDBhQ0E5UFQwZ01DQXBleUJ5WlhSMWNtNDdJSDFjYmx4dUlDQWdJR3hsZENCNE1TQTlJRTUxYldKbGNpNU5RVmhmVmtGTVZVVXNYRzRnSUNBZ0lDQjVNU0E5SUU1MWJXSmxjaTVOUVZoZlZrRk1WVVVzWEc0Z0lDQWdJQ0I0TWlBOUlFNTFiV0psY2k1TlNVNWZWa0ZNVlVVc1hHNGdJQ0FnSUNCNU1pQTlJRTUxYldKbGNpNU5TVTVmVmtGTVZVVXNYRzRnSUNBZ0lDQnBMRnh1SUNBZ0lDQWdiV0Y0SUQwZ1ltOWthV1Z6TG14bGJtZDBhRHRjYmx4dUlDQWdJQzh2SUZSdklISmxaSFZqWlNCeGRXRmtJSFJ5WldVZ1pHVndkR2dnZDJVZ1lYSmxJR3h2YjJ0cGJtY2dabTl5SUdWNFlXTjBJR0p2ZFc1a2FXNW5JR0p2ZUNCdlppQmhiR3dnY0dGeWRHbGpiR1Z6TGx4dUlDQWdJR2tnUFNCdFlYZzdYRzRnSUNBZ2QyaHBiR1VnS0drdExTa2dlMXh1SUNBZ0lDQWdiR1YwSUhnZ1BTQmliMlJwWlhOYmFWMHVjRzl6TG5nN1hHNGdJQ0FnSUNCc1pYUWdlU0E5SUdKdlpHbGxjMXRwWFM1d2IzTXVlVHRjYmlBZ0lDQWdJR2xtSUNoNElEd2dlREVwSUh0Y2JpQWdJQ0FnSUNBZ2VERWdQU0I0TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYVdZZ0tIZ2dQaUI0TWlrZ2UxeHVJQ0FnSUNBZ0lDQjRNaUE5SUhnN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppQW9lU0E4SUhreEtTQjdYRzRnSUNBZ0lDQWdJSGt4SUQwZ2VUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHbG1JQ2g1SUQ0Z2VUSXBJSHRjYmlBZ0lDQWdJQ0FnZVRJZ1BTQjVPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRk54ZFdGeWFXWjVJSFJvWlNCaWIzVnVaSE11WEc0Z0lDQWdiR1YwSUdSNElEMGdlRElnTFNCNE1TeGNiaUFnSUNBZ0lHUjVJRDBnZVRJZ0xTQjVNVHRjYmlBZ0lDQnBaaUFvWkhnZ1BpQmtlU2tnZTF4dUlDQWdJQ0FnZVRJZ1BTQjVNU0FySUdSNE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0I0TWlBOUlIZ3hJQ3NnWkhrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWTNWeWNtVnVkRWx1UTJGamFHVWdQU0F3TzF4dUlDQWdJSEp2YjNRZ1BTQnVaWGRPYjJSbEtDazdYRzRnSUNBZ2NtOXZkQzVzWldaMElEMGdlREU3WEc0Z0lDQWdjbTl2ZEM1eWFXZG9kQ0E5SUhneU8xeHVJQ0FnSUhKdmIzUXVkRzl3SUQwZ2VURTdYRzRnSUNBZ2NtOXZkQzVpYjNSMGIyMGdQU0I1TWp0Y2JseHVJQ0FnSUdrZ1BTQnRZWGdnTFNBeE8xeHVJQ0FnSUdsbUlDaHBJRDQ5SURBcElIdGNiaUFnSUNBZ0lISnZiM1F1WW05a2VTQTlJR0p2WkdsbGMxdHBYVHRjYmlBZ0lDQjlYRzRnSUNBZ2QyaHBiR1VnS0drdExTa2dlMXh1SUNBZ0lDQWdhVzV6WlhKMEtHSnZaR2xsYzF0cFhTd2djbTl2ZENrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z2FXNXpaWEowS0c1bGQwSnZaSGtwSUh0Y2JpQWdJQ0JwYm5ObGNuUlRkR0ZqYXk1eVpYTmxkQ2dwTzF4dUlDQWdJR2x1YzJWeWRGTjBZV05yTG5CMWMyZ29jbTl2ZEN3Z2JtVjNRbTlrZVNrN1hHNWNiaUFnSUNCM2FHbHNaU0FvSVdsdWMyVnlkRk4wWVdOckxtbHpSVzF3ZEhrb0tTa2dlMXh1SUNBZ0lDQWdiR1YwSUhOMFlXTnJTWFJsYlNBOUlHbHVjMlZ5ZEZOMFlXTnJMbkJ2Y0NncExGeHVJQ0FnSUNBZ0lDQnViMlJsSUQwZ2MzUmhZMnRKZEdWdExtNXZaR1VzWEc0Z0lDQWdJQ0FnSUdKdlpIa2dQU0J6ZEdGamEwbDBaVzB1WW05a2VUdGNibHh1SUNBZ0lDQWdhV1lnS0NGdWIyUmxMbUp2WkhrcElIdGNiaUFnSUNBZ0lDQWdMeThnVkdocGN5QnBjeUJwYm5SbGNtNWhiQ0J1YjJSbExpQlZjR1JoZEdVZ2RHaGxJSFJ2ZEdGc0lHMWhjM01nYjJZZ2RHaGxJRzV2WkdVZ1lXNWtJR05sYm5SbGNpMXZaaTF0WVhOekxseHVJQ0FnSUNBZ0lDQnNaWFFnZUNBOUlHSnZaSGt1Y0c5ekxuZzdYRzRnSUNBZ0lDQWdJR3hsZENCNUlEMGdZbTlrZVM1d2IzTXVlVHRjYmlBZ0lDQWdJQ0FnYm05a1pTNXRZWE56SUQwZ2JtOWtaUzV0WVhOeklDc2dZbTlrZVM1dFlYTnpPMXh1SUNBZ0lDQWdJQ0J1YjJSbExtMWhjM05ZSUQwZ2JtOWtaUzV0WVhOeldDQXJJR0p2WkhrdWJXRnpjeUFxSUhnN1hHNGdJQ0FnSUNBZ0lHNXZaR1V1YldGemMxa2dQU0J1YjJSbExtMWhjM05aSUNzZ1ltOWtlUzV0WVhOeklDb2dlVHRjYmx4dUlDQWdJQ0FnSUNBdkx5QlNaV04xY25OcGRtVnNlU0JwYm5ObGNuUWdkR2hsSUdKdlpIa2dhVzRnZEdobElHRndjSEp2Y0hKcFlYUmxJSEYxWVdSeVlXNTBMbHh1SUNBZ0lDQWdJQ0F2THlCQ2RYUWdabWx5YzNRZ1ptbHVaQ0IwYUdVZ1lYQndjbTl3Y21saGRHVWdjWFZoWkhKaGJuUXVYRzRnSUNBZ0lDQWdJR3hsZENCeGRXRmtTV1I0SUQwZ01Dd2dMeThnUVhOemRXMWxJSGRsSUdGeVpTQnBiaUIwYUdVZ01DZHpJSEYxWVdRdVhHNGdJQ0FnSUNBZ0lDQWdiR1ZtZENBOUlHNXZaR1V1YkdWbWRDeGNiaUFnSUNBZ0lDQWdJQ0J5YVdkb2RDQTlJQ2h1YjJSbExuSnBaMmgwSUNzZ2JHVm1kQ2tnTHlBeUxGeHVJQ0FnSUNBZ0lDQWdJSFJ2Y0NBOUlHNXZaR1V1ZEc5d0xGeHVJQ0FnSUNBZ0lDQWdJR0p2ZEhSdmJTQTlJQ2h1YjJSbExtSnZkSFJ2YlNBcklIUnZjQ2tnTHlBeU8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNoNElENGdjbWxuYUhRcElIc2dMeThnYzI5dFpYZG9aWEpsSUdsdUlIUm9aU0JsWVhOMFpYSnVJSEJoY25RdVhHNGdJQ0FnSUNBZ0lDQWdjWFZoWkVsa2VDQTlJSEYxWVdSSlpIZ2dLeUF4TzF4dUlDQWdJQ0FnSUNBZ0lHeGxablFnUFNCeWFXZG9kRHRjYmlBZ0lDQWdJQ0FnSUNCeWFXZG9kQ0E5SUc1dlpHVXVjbWxuYUhRN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdhV1lnS0hrZ1BpQmliM1IwYjIwcElIc2dMeThnWVc1a0lHbHVJSE52ZFhSb0xseHVJQ0FnSUNBZ0lDQWdJSEYxWVdSSlpIZ2dQU0J4ZFdGa1NXUjRJQ3NnTWp0Y2JpQWdJQ0FnSUNBZ0lDQjBiM0FnUFNCaWIzUjBiMjA3WEc0Z0lDQWdJQ0FnSUNBZ1ltOTBkRzl0SUQwZ2JtOWtaUzVpYjNSMGIyMDdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCc1pYUWdZMmhwYkdRZ1BTQm5aWFJEYUdsc1pDaHViMlJsTENCeGRXRmtTV1I0S1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZqYUdsc1pDa2dlMXh1SUNBZ0lDQWdJQ0FnSUM4dklGUm9aU0J1YjJSbElHbHpJR2x1ZEdWeWJtRnNJR0oxZENCMGFHbHpJSEYxWVdSeVlXNTBJR2x6SUc1dmRDQjBZV3RsYmk0Z1FXUmtYRzRnSUNBZ0lDQWdJQ0FnTHk4Z2MzVmlibTlrWlNCMGJ5QnBkQzVjYmlBZ0lDQWdJQ0FnSUNCamFHbHNaQ0E5SUc1bGQwNXZaR1VvS1R0Y2JpQWdJQ0FnSUNBZ0lDQmphR2xzWkM1c1pXWjBJRDBnYkdWbWREdGNiaUFnSUNBZ0lDQWdJQ0JqYUdsc1pDNTBiM0FnUFNCMGIzQTdYRzRnSUNBZ0lDQWdJQ0FnWTJocGJHUXVjbWxuYUhRZ1BTQnlhV2RvZER0Y2JpQWdJQ0FnSUNBZ0lDQmphR2xzWkM1aWIzUjBiMjBnUFNCaWIzUjBiMjA3WEc0Z0lDQWdJQ0FnSUNBZ1kyaHBiR1F1WW05a2VTQTlJR0p2WkhrN1hHNWNiaUFnSUNBZ0lDQWdJQ0J6WlhSRGFHbHNaQ2h1YjJSbExDQnhkV0ZrU1dSNExDQmphR2xzWkNrN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnWTI5dWRHbHVkV1VnYzJWaGNtTm9hVzVuSUdsdUlIUm9hWE1nY1hWaFpISmhiblF1WEc0Z0lDQWdJQ0FnSUNBZ2FXNXpaWEowVTNSaFkyc3VjSFZ6YUNoamFHbHNaQ3dnWW05a2VTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQzh2SUZkbElHRnlaU0IwY25scGJtY2dkRzhnWVdSa0lIUnZJSFJvWlNCc1pXRm1JRzV2WkdVdVhHNGdJQ0FnSUNBZ0lDOHZJRmRsSUdoaGRtVWdkRzhnWTI5dWRtVnlkQ0JqZFhKeVpXNTBJR3hsWVdZZ2FXNTBieUJwYm5SbGNtNWhiQ0J1YjJSbFhHNGdJQ0FnSUNBZ0lDOHZJR0Z1WkNCamIyNTBhVzUxWlNCaFpHUnBibWNnZEhkdklHNXZaR1Z6TGx4dUlDQWdJQ0FnSUNCc1pYUWdiMnhrUW05a2VTQTlJRzV2WkdVdVltOWtlVHRjYmlBZ0lDQWdJQ0FnYm05a1pTNWliMlI1SUQwZ2JuVnNiRHNnTHk4Z2FXNTBaWEp1WVd3Z2JtOWtaWE1nWkc4Z2JtOTBJR05oY25rZ1ltOWthV1Z6WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR2x6VTJGdFpWQnZjMmwwYVc5dUtHOXNaRUp2WkhrdWNHOXpMQ0JpYjJSNUxuQnZjeWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJRY21WMlpXNTBJR2x1Wm1sdWFYUmxJSE4xWW1ScGRtbHphVzl1SUdKNUlHSjFiWEJwYm1jZ2IyNWxJRzV2WkdWY2JpQWdJQ0FnSUNBZ0lDQXZMeUJoYm5sM2FHVnlaU0JwYmlCMGFHbHpJSEYxWVdSeVlXNTBYRzRnSUNBZ0lDQWdJQ0FnYkdWMElISmxkSEpwWlhORGIzVnVkQ0E5SURNN1hHNGdJQ0FnSUNBZ0lDQWdaRzhnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdiR1YwSUc5bVpuTmxkQ0E5SUUxaGRHZ3VjbUZ1Wkc5dEtDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdaSGdnUFNBb2JtOWtaUzV5YVdkb2RDQXRJRzV2WkdVdWJHVm1kQ2tnS2lCdlptWnpaWFE3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaWFFnWkhrZ1BTQW9ibTlrWlM1aWIzUjBiMjBnTFNCdWIyUmxMblJ2Y0NrZ0tpQnZabVp6WlhRN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnSUc5c1pFSnZaSGt1Y0c5ekxuZ2dQU0J1YjJSbExteGxablFnS3lCa2VEdGNiaUFnSUNBZ0lDQWdJQ0FnSUc5c1pFSnZaSGt1Y0c5ekxua2dQU0J1YjJSbExuUnZjQ0FySUdSNU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGNtbGxjME52ZFc1MElDMDlJREU3WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJOWVd0bElITjFjbVVnZDJVZ1pHOXVKM1FnWW5WdGNDQnBkQ0J2ZFhRZ2IyWWdkR2hsSUdKdmVDNGdTV1lnZDJVZ1pHOHNJRzVsZUhRZ2FYUmxjbUYwYVc5dUlITm9iM1ZzWkNCbWFYZ2dhWFJjYmlBZ0lDQWdJQ0FnSUNCOUlIZG9hV3hsSUNoeVpYUnlhV1Z6UTI5MWJuUWdQaUF3SUNZbUlHbHpVMkZ0WlZCdmMybDBhVzl1S0c5c1pFSnZaSGt1Y0c5ekxDQmliMlI1TG5CdmN5a3BPMXh1WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSEpsZEhKcFpYTkRiM1Z1ZENBOVBUMGdNQ0FtSmlCcGMxTmhiV1ZRYjNOcGRHbHZiaWh2YkdSQ2IyUjVMbkJ2Y3l3Z1ltOWtlUzV3YjNNcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBdkx5QlVhR2x6SUdseklIWmxjbmtnWW1Ga0xDQjNaU0J5WVc0Z2IzVjBJRzltSUhCeVpXTnBjMmx2Ymk1Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUdsbUlIZGxJR1J2SUc1dmRDQnlaWFIxY200Z1puSnZiU0IwYUdVZ2JXVjBhRzlrSUhkbEoyeHNJR2RsZENCcGJuUnZYRzRnSUNBZ0lDQWdJQ0FnSUNBdkx5QnBibVpwYm1sMFpTQnNiMjl3SUdobGNtVXVJRk52SUhkbElITmhZM0pwWm1salpTQmpiM0p5WldOMGJtVnpjeUJ2WmlCc1lYbHZkWFFzSUdGdVpDQnJaV1Z3SUhSb1pTQmhjSEFnY25WdWJtbHVaMXh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdUbVY0ZENCc1lYbHZkWFFnYVhSbGNtRjBhVzl1SUhOb2IzVnNaQ0JuWlhRZ2JHRnlaMlZ5SUdKdmRXNWthVzVuSUdKdmVDQnBiaUIwYUdVZ1ptbHljM1FnYzNSbGNDQmhibVFnWm1sNElIUm9hWE5jYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnTHk4Z1RtVjRkQ0JwZEdWeVlYUnBiMjRnYzJodmRXeGtJSE4xWW1ScGRtbGtaU0J1YjJSbElHWjFjblJvWlhJdVhHNGdJQ0FnSUNBZ0lHbHVjMlZ5ZEZOMFlXTnJMbkIxYzJnb2JtOWtaU3dnYjJ4a1FtOWtlU2s3WEc0Z0lDQWdJQ0FnSUdsdWMyVnlkRk4wWVdOckxuQjFjMmdvYm05a1pTd2dZbTlrZVNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0JwYm5ObGNuUkNiMlJwWlhNNklHbHVjMlZ5ZEVKdlpHbGxjeXhjYmlBZ0lDQjFjR1JoZEdWQ2IyUjVSbTl5WTJVNklIVndaR0YwWlZ4dUlDQjlPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJEYUdsc1pDaHViMlJsTENCcFpIZ3BJSHRjYmlBZ2FXWWdLR2xrZUNBOVBUMGdNQ2tnY21WMGRYSnVJRzV2WkdVdWNYVmhaREE3WEc0Z0lHbG1JQ2hwWkhnZ1BUMDlJREVwSUhKbGRIVnliaUJ1YjJSbExuRjFZV1F4TzF4dUlDQnBaaUFvYVdSNElEMDlQU0F5S1NCeVpYUjFjbTRnYm05a1pTNXhkV0ZrTWp0Y2JpQWdhV1lnS0dsa2VDQTlQVDBnTXlrZ2NtVjBkWEp1SUc1dlpHVXVjWFZoWkRNN1hHNGdJSEpsZEhWeWJpQnVkV3hzTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ6WlhSRGFHbHNaQ2h1YjJSbExDQnBaSGdzSUdOb2FXeGtLU0I3WEc0Z0lHbG1JQ2hwWkhnZ1BUMDlJREFwSUc1dlpHVXVjWFZoWkRBZ1BTQmphR2xzWkR0Y2JpQWdaV3h6WlNCcFppQW9hV1I0SUQwOVBTQXhLU0J1YjJSbExuRjFZV1F4SUQwZ1kyaHBiR1E3WEc0Z0lHVnNjMlVnYVdZZ0tHbGtlQ0E5UFQwZ01pa2dibTlrWlM1eGRXRmtNaUE5SUdOb2FXeGtPMXh1SUNCbGJITmxJR2xtSUNocFpIZ2dQVDA5SURNcElHNXZaR1V1Y1hWaFpETWdQU0JqYUdsc1pEdGNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN0lHMWhhMlZSZFdGa2RISmxaU0I5TzF4dVhHNWNibHh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVklnTHk5Y2JpOHZJQzR2YzNKakwyVjFiR1Z5TDNGMVlXUjBjbVZsTDJsdVpHVjRMbXB6SWl3aWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCSmJuTmxjblJUZEdGamF6dGNibHh1THlvcVhHNGdLaUJQZFhJZ2FXMXdiRzFsYm5SaGRHbHZiaUJ2WmlCUmRXRmtWSEpsWlNCcGN5QnViMjR0Y21WamRYSnphWFpsSUhSdklHRjJiMmxrSUVkRElHaHBkRnh1SUNvZ1ZHaHBjeUJrWVhSaElITjBjblZqZEhWeVpTQnlaWEJ5WlhObGJuUWdjM1JoWTJzZ2IyWWdaV3hsYldWdWRITmNiaUFxSUhkb2FXTm9JSGRsSUdGeVpTQjBjbmxwYm1jZ2RHOGdhVzV6WlhKMElHbHVkRzhnY1hWaFpDQjBjbVZsTGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJKYm5ObGNuUlRkR0ZqYXlBb0tTQjdYRzRnSUNBZ2RHaHBjeTV6ZEdGamF5QTlJRnRkTzF4dUlDQWdJSFJvYVhNdWNHOXdTV1I0SUQwZ01EdGNibjFjYmx4dVNXNXpaWEowVTNSaFkyc3VjSEp2ZEc5MGVYQmxJRDBnZTF4dUlDQWdJR2x6Ulcxd2RIazZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXdiM0JKWkhnZ1BUMDlJREE3WEc0Z0lDQWdmU3hjYmlBZ0lDQndkWE5vT2lCbWRXNWpkR2x2YmlBb2JtOWtaU3dnWW05a2VTa2dlMXh1SUNBZ0lDQWdJQ0JzWlhRZ2FYUmxiU0E5SUhSb2FYTXVjM1JoWTJ0YmRHaHBjeTV3YjNCSlpIaGRPMXh1SUNBZ0lDQWdJQ0JwWmlBb0lXbDBaVzBwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUhkbElHRnlaU0IwY25scGJtY2dkRzhnWVhadmFXUWdiV1Z0YjNKNUlIQnlaWE56ZFdVNklHTnlaV0YwWlNCdVpYY2daV3hsYldWdWRGeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2IyNXNlU0IzYUdWdUlHRmljMjlzZFhSbGJIa2dibVZqWlhOellYSjVYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbk4wWVdOclczUm9hWE11Y0c5d1NXUjRYU0E5SUc1bGR5Qkpibk5sY25SVGRHRmphMFZzWlcxbGJuUW9ibTlrWlN3Z1ltOWtlU2s3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBkR1Z0TG01dlpHVWdQU0J1YjJSbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVhSbGJTNWliMlI1SUQwZ1ltOWtlVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBckszUm9hWE11Y0c5d1NXUjRPMXh1SUNBZ0lIMHNYRzRnSUNBZ2NHOXdPaUJtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxuQnZjRWxrZUNBK0lEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbk4wWVdOcld5MHRkR2hwY3k1d2IzQkpaSGhkTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnZlN4Y2JpQWdJQ0J5WlhObGREb2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y0Vsa2VDQTlJREE3WEc0Z0lDQWdmVnh1ZlR0Y2JseHVablZ1WTNScGIyNGdTVzV6WlhKMFUzUmhZMnRGYkdWdFpXNTBLRzV2WkdVc0lHSnZaSGtwSUh0Y2JpQWdJQ0IwYUdsekxtNXZaR1VnUFNCdWIyUmxPeUF2THlCUmRXRmtWSEpsWlNCdWIyUmxYRzRnSUNBZ2RHaHBjeTVpYjJSNUlEMGdZbTlrZVRzZ0x5OGdjR2g1YzJsallXd2dZbTlrZVNCM2FHbGphQ0J1WldWa2N5QjBieUJpWlNCcGJuTmxjblJsWkNCMGJ5QnViMlJsWEc1OVhHNWNibHh1WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWlBdkwxeHVMeThnTGk5emNtTXZaWFZzWlhJdmNYVmhaSFJ5WldVdmFXNXpaWEowVTNSaFkyc3Vhbk1pTENJdktpcGNiaUFxSUVsdWRHVnlibUZzSUdSaGRHRWdjM1J5ZFdOMGRYSmxJSFJ2SUhKbGNISmxjMlZ1ZENBeVJDQlJkV0ZrVkhKbFpTQnViMlJsWEc0Z0tpOWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdUbTlrWlNncElIdGNiaUFnTHk4Z1ltOWtlU0J6ZEc5eVpXUWdhVzV6YVdSbElIUm9hWE1nYm05a1pTNGdTVzRnY1hWaFpDQjBjbVZsSUc5dWJIa2diR1ZoWmlCdWIyUmxjeUFvWW5rZ1kyOXVjM1J5ZFdOMGFXOXVLVnh1SUNBdkx5QmpiMjUwWVdsdUlHSnZhV1JsY3pwY2JpQWdkR2hwY3k1aWIyUjVJRDBnYm5Wc2JEdGNibHh1SUNBdkx5QkRhR2xzWkNCdWIyUmxjeUJoY21VZ2MzUnZjbVZrSUdsdUlIRjFZV1J6TGlCRllXTm9JSEYxWVdRZ2FYTWdjSEpsYzJWdWRHVmtJR0o1SUc1MWJXSmxjanBjYmlBZ0x5OGdNQ0I4SURGY2JpQWdMeThnTFMwdExTMWNiaUFnTHk4Z01pQjhJRE5jYmlBZ2RHaHBjeTV4ZFdGa01DQTlJRzUxYkd3N1hHNGdJSFJvYVhNdWNYVmhaREVnUFNCdWRXeHNPMXh1SUNCMGFHbHpMbkYxWVdReUlEMGdiblZzYkR0Y2JpQWdkR2hwY3k1eGRXRmtNeUE5SUc1MWJHdzdYRzVjYmlBZ0x5OGdWRzkwWVd3Z2JXRnpjeUJ2WmlCamRYSnlaVzUwSUc1dlpHVmNiaUFnZEdocGN5NXRZWE56SUQwZ01EdGNibHh1SUNBdkx5QkRaVzUwWlhJZ2IyWWdiV0Z6Y3lCamIyOXlaR2x1WVhSbGMxeHVJQ0IwYUdsekxtMWhjM05ZSUQwZ01EdGNiaUFnZEdocGN5NXRZWE56V1NBOUlEQTdYRzVjYmlBZ0x5OGdZbTkxYm1ScGJtY2dZbTk0SUdOdmIzSmthVzVoZEdWelhHNGdJSFJvYVhNdWJHVm1kQ0E5SURBN1hHNGdJSFJvYVhNdWRHOXdJRDBnTUR0Y2JpQWdkR2hwY3k1aWIzUjBiMjBnUFNBd08xeHVJQ0IwYUdsekxuSnBaMmgwSUQwZ01EdGNibjA3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdMaTl6Y21NdlpYVnNaWEl2Y1hWaFpIUnlaV1V2Ym05a1pTNXFjeUlzSW1OdmJuTjBJSHNnYVc1MFpXZHlZWFJsSUgwZ1BTQnlaWEYxYVhKbEtDY3VMMmx1ZEdWbmNtRjBaU2NwTzF4dVkyOXVjM1FnZXlCaGNIQnNlVVJ5WVdjZ2ZTQTlJSEpsY1hWcGNtVW9KeTR2WkhKaFp5Y3BPMXh1WTI5dWMzUWdleUJoY0hCc2VWTndjbWx1WnlCOUlEMGdjbVZ4ZFdseVpTZ25MaTl6Y0hKcGJtY25LVHRjYmx4dVpuVnVZM1JwYjI0Z2RHbGpheWg3SUdKdlpHbGxjeXdnYzNCeWFXNW5jeXdnY1hWaFpIUnlaV1VzSUhScGJXVlRkR1Z3TENCbmNtRjJhWFI1TENCMGFHVjBZU3dnWkhKaFowTnZaV1ptTENCd2RXeHNJSDBwZTF4dUlDQXZMeUIxY0dSaGRHVWdZbTlrZVNCbWNtOXRJSE5qY21GMFkyZ2dhVzRnWTJGelpTQnZaaUJoYm5rZ1kyaGhibWRsYzF4dUlDQmliMlJwWlhNdVptOXlSV0ZqYUNnZ1ltOWtlU0E5UGlCN1hHNGdJQ0FnYkdWMElIQWdQU0JpYjJSNUxsOXpZM0poZEdOb08xeHVYRzRnSUNBZ2FXWW9JQ0Z3SUNsN0lISmxkSFZ5YmpzZ2ZWeHVYRzRnSUNBZ1ltOWtlUzVzYjJOclpXUWdQU0J3TG14dlkydGxaRHRjYmlBZ0lDQmliMlI1TG1keVlXSmlaV1FnUFNCd0xtZHlZV0ppWldRN1hHNGdJQ0FnWW05a2VTNXdiM011ZUNBOUlIQXVlRHRjYmlBZ0lDQmliMlI1TG5CdmN5NTVJRDBnY0M1NU8xeHVJQ0I5SUNrN1hHNWNiaUFnY1hWaFpIUnlaV1V1YVc1elpYSjBRbTlrYVdWektDQmliMlJwWlhNZ0tUdGNibHh1SUNCbWIzSW9JR3hsZENCcElEMGdNRHNnYVNBOElHSnZaR2xsY3k1c1pXNW5kR2c3SUdrckt5QXBlMXh1SUNBZ0lHeGxkQ0JpYjJSNUlEMGdZbTlrYVdWelcybGRPMXh1WEc0Z0lDQWdjWFZoWkhSeVpXVXVkWEJrWVhSbFFtOWtlVVp2Y21ObEtDQmliMlI1TENCbmNtRjJhWFI1TENCMGFHVjBZU3dnY0hWc2JDQXBPMXh1SUNBZ0lHRndjR3g1UkhKaFp5Z2dZbTlrZVN3Z1pISmhaME52WldabUlDazdYRzRnSUgxY2JseHVJQ0JtYjNJb0lHeGxkQ0JwSUQwZ01Ec2dhU0E4SUhOd2NtbHVaM011YkdWdVozUm9PeUJwS3lzZ0tYdGNiaUFnSUNCc1pYUWdjM0J5YVc1bklEMGdjM0J5YVc1bmMxdHBYVHRjYmx4dUlDQWdJR0Z3Y0d4NVUzQnlhVzVuS0NCemNISnBibWNnS1R0Y2JpQWdmVnh1WEc0Z0lHeGxkQ0J0YjNabGJXVnVkQ0E5SUdsdWRHVm5jbUYwWlNnZ1ltOWthV1Z6TENCMGFXMWxVM1JsY0NBcE8xeHVYRzRnSUM4dklIVndaR0YwWlNCelkzSmhkR05vSUhCdmMybDBhVzl1Y3lCbWNtOXRJR0p2WkhrZ2NHOXphWFJwYjI1elhHNGdJR0p2WkdsbGN5NW1iM0pGWVdOb0tDQmliMlI1SUQwK0lIdGNiaUFnSUNCc1pYUWdjQ0E5SUdKdlpIa3VYM05qY21GMFkyZzdYRzVjYmlBZ0lDQnBaaWdnSVhBZ0tYc2djbVYwZFhKdU95QjlYRzVjYmlBZ0lDQndMbmdnUFNCaWIyUjVMbkJ2Y3k1NE8xeHVJQ0FnSUhBdWVTQTlJR0p2WkhrdWNHOXpMbms3WEc0Z0lIMGdLVHRjYmx4dUlDQnlaWFIxY200Z2JXOTJaVzFsYm5RN1hHNTlYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZXlCMGFXTnJJSDA3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdMaTl6Y21NdlpYVnNaWEl2ZEdsamF5NXFjeUlzSW1OdmJuTjBJRVYxYkdWeUlEMGdjbVZ4ZFdseVpTZ25MaTlsZFd4bGNpY3BPMXh1WEc0dkx5QnlaV2RwYzNSbGNuTWdkR2hsSUdWNGRHVnVjMmx2YmlCdmJpQmhJR041ZEc5elkyRndaU0JzYVdJZ2NtVm1YRzVzWlhRZ2NtVm5hWE4wWlhJZ1BTQm1kVzVqZEdsdmJpZ2dZM2wwYjNOallYQmxJQ2w3WEc0Z0lHbG1LQ0FoWTNsMGIzTmpZWEJsSUNsN0lISmxkSFZ5YmpzZ2ZTQXZMeUJqWVc0bmRDQnlaV2RwYzNSbGNpQnBaaUJqZVhSdmMyTmhjR1VnZFc1emNHVmphV1pwWldSY2JseHVJQ0JqZVhSdmMyTmhjR1VvSUNkc1lYbHZkWFFuTENBblpYVnNaWEluTENCRmRXeGxjaUFwT3lBdkx5QnlaV2RwYzNSbGNpQjNhWFJvSUdONWRHOXpZMkZ3WlM1cWMxeHVmVHRjYmx4dWFXWW9JSFI1Y0dWdlppQmplWFJ2YzJOaGNHVWdJVDA5SUNkMWJtUmxabWx1WldRbklDbDdJQzh2SUdWNGNHOXpaU0IwYnlCbmJHOWlZV3dnWTNsMGIzTmpZWEJsSUNocExtVXVJSGRwYm1SdmR5NWplWFJ2YzJOaGNHVXBYRzRnSUhKbFoybHpkR1Z5S0NCamVYUnZjMk5oY0dVZ0tUdGNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCeVpXZHBjM1JsY2p0Y2JseHVYRzVjYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTSUM4dlhHNHZMeUF1TDNOeVl5OXBibVJsZUM1cWN5SXNJaTh2SUdkbGJtVnlZV3dnWkdWbVlYVnNkQ0J2Y0hScGIyNXpJR1p2Y2lCbWIzSmpaUzFrYVhKbFkzUmxaQ0JzWVhsdmRYUmNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JQWW1wbFkzUXVabkpsWlhwbEtIdGNiaUFnWVc1cGJXRjBaVG9nZEhKMVpTd2dMeThnZDJobGRHaGxjaUIwYnlCemFHOTNJSFJvWlNCc1lYbHZkWFFnWVhNZ2FYUW5jeUJ5ZFc1dWFXNW5PeUJ6Y0dWamFXRnNJQ2RsYm1RbklIWmhiSFZsSUcxaGEyVnpJSFJvWlNCc1lYbHZkWFFnWVc1cGJXRjBaU0JzYVd0bElHRWdaR2x6WTNKbGRHVWdiR0Y1YjNWMFhHNGdJSEpsWm5KbGMyZzZJREV3TENBdkx5QnVkVzFpWlhJZ2IyWWdkR2xqYTNNZ2NHVnlJR1p5WVcxbE95Qm9hV2RvWlhJZ2FYTWdabUZ6ZEdWeUlHSjFkQ0J0YjNKbElHcGxjbXQ1WEc0Z0lHMWhlRWwwWlhKaGRHbHZibk02SURFd01EQXNJQzh2SUcxaGVDQnBkR1Z5WVhScGIyNXpJR0psWm05eVpTQjBhR1VnYkdGNWIzVjBJSGRwYkd3Z1ltRnBiQ0J2ZFhSY2JpQWdiV0Y0VTJsdGRXeGhkR2x2YmxScGJXVTZJRFF3TURBc0lDOHZJRzFoZUNCc1pXNW5kR2dnYVc0Z2JYTWdkRzhnY25WdUlIUm9aU0JzWVhsdmRYUmNiaUFnZFc1bmNtRmlhV1o1VjJocGJHVlRhVzExYkdGMGFXNW5PaUJtWVd4elpTd2dMeThnYzI4Z2VXOTFJR05oYmlkMElHUnlZV2NnYm05a1pYTWdaSFZ5YVc1bklHeGhlVzkxZEZ4dUlDQm1hWFE2SUhSeWRXVXNJQzh2SUc5dUlHVjJaWEo1SUd4aGVXOTFkQ0J5WlhCdmMybDBhVzl1SUc5bUlHNXZaR1Z6TENCbWFYUWdkR2hsSUhacFpYZHdiM0owWEc0Z0lIQmhaR1JwYm1jNklETXdMQ0F2THlCd1lXUmthVzVuSUdGeWIzVnVaQ0IwYUdVZ2MybHRkV3hoZEdsdmJseHVJQ0JpYjNWdVpHbHVaMEp2ZURvZ2RXNWtaV1pwYm1Wa0xDQXZMeUJqYjI1emRISmhhVzRnYkdGNWIzVjBJR0p2ZFc1a2N6c2dleUI0TVN3Z2VURXNJSGd5TENCNU1pQjlJRzl5SUhzZ2VERXNJSGt4TENCM0xDQm9JSDFjYmx4dUlDQXZMeUJzWVhsdmRYUWdaWFpsYm5RZ1kyRnNiR0poWTJ0elhHNGdJSEpsWVdSNU9pQm1kVzVqZEdsdmJpZ3BlMzBzSUM4dklHOXVJR3hoZVc5MWRISmxZV1I1WEc0Z0lITjBiM0E2SUdaMWJtTjBhVzl1S0NsN2ZTd2dMeThnYjI0Z2JHRjViM1YwYzNSdmNGeHVYRzRnSUM4dklIQnZjMmwwYVc5dWFXNW5JRzl3ZEdsdmJuTmNiaUFnY21GdVpHOXRhWHBsT2lCbVlXeHpaU3dnTHk4Z2RYTmxJSEpoYm1SdmJTQnViMlJsSUhCdmMybDBhVzl1Y3lCaGRDQmlaV2RwYm01cGJtY2diMllnYkdGNWIzVjBYRzRnSUZ4dUlDQXZMeUJwYm1acGJtbDBaU0JzWVhsdmRYUWdiM0IwYVc5dWMxeHVJQ0JwYm1acGJtbDBaVG9nWm1Gc2MyVWdMeThnYjNabGNuSnBaR1Z6SUdGc2JDQnZkR2hsY2lCdmNIUnBiMjV6SUdadmNpQmhJR1p2Y21ObGN5MWhiR3d0ZEdobExYUnBiV1VnYlc5a1pWeHVmU2s3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdMaTl6Y21NdmJHRjViM1YwTDJSbFptRjFiSFJ6TG1weklpd2lMeW9xWEc1QklHZGxibVZ5YVdNZ1kyOXVkR2x1ZFc5MWN5QnNZWGx2ZFhRZ1kyeGhjM05jYmlvdlhHNWNibU52Ym5OMElHRnpjMmxuYmlBOUlISmxjWFZwY21Vb0p5NHVMMkZ6YzJsbmJpY3BPMXh1WTI5dWMzUWdaR1ZtWVhWc2RITWdQU0J5WlhGMWFYSmxLQ2N1TDJSbFptRjFiSFJ6SnlrN1hHNWpiMjV6ZENCdFlXdGxRbTkxYm1ScGJtZENiM2dnUFNCeVpYRjFhWEpsS0NjdUwyMWhhMlV0WW1JbktUdGNibU52Ym5OMElIc2djMlYwU1c1cGRHbGhiRkJ2YzJsMGFXOXVVM1JoZEdVc0lISmxabkpsYzJoUWIzTnBkR2x2Ym5Nc0lHZGxkRTV2WkdWUWIzTnBkR2x2YmtSaGRHRWdmU0E5SUhKbGNYVnBjbVVvSnk0dmNHOXphWFJwYjI0bktUdGNibU52Ym5OMElIc2diWFZzZEdsMGFXTnJJSDBnUFNCeVpYRjFhWEpsS0NjdUwzUnBZMnNuS1R0Y2JseHVZMnhoYzNNZ1RHRjViM1YwSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvSUc5d2RHbHZibk1nS1h0Y2JpQWdJQ0JzWlhRZ2J5QTlJSFJvYVhNdWIzQjBhVzl1Y3lBOUlHRnpjMmxuYmlnZ2UzMHNJR1JsWm1GMWJIUnpMQ0J2Y0hScGIyNXpJQ2s3WEc1Y2JpQWdJQ0JzWlhRZ2N5QTlJSFJvYVhNdWMzUmhkR1VnUFNCaGMzTnBaMjRvSUh0OUxDQnZMQ0I3WEc0Z0lDQWdJQ0JzWVhsdmRYUTZJSFJvYVhNc1hHNGdJQ0FnSUNCdWIyUmxjem9nYnk1bGJHVnpMbTV2WkdWektDa3NYRzRnSUNBZ0lDQmxaR2RsY3pvZ2J5NWxiR1Z6TG1Wa1oyVnpLQ2tzWEc0Z0lDQWdJQ0IwYVdOclNXNWtaWGc2SURBc1hHNGdJQ0FnSUNCbWFYSnpkRlZ3WkdGMFpUb2dkSEoxWlZ4dUlDQWdJSDBnS1R0Y2JseHVJQ0FnSUhNdVlXNXBiV0YwWlVWdVpDQTlJRzh1WVc1cGJXRjBaU0FtSmlCdkxtRnVhVzFoZEdVZ1BUMDlJQ2RsYm1Rbk8xeHVJQ0FnSUhNdVlXNXBiV0YwWlVOdmJuUnBiblZ2ZFhOc2VTQTlJRzh1WVc1cGJXRjBaU0FtSmlBaGN5NWhibWx0WVhSbFJXNWtPMXh1SUNCOVhHNWNiaUFnY25WdUtDbDdYRzRnSUNBZ2JHVjBJR3dnUFNCMGFHbHpPMXh1SUNBZ0lHeGxkQ0J6SUQwZ2RHaHBjeTV6ZEdGMFpUdGNibHh1SUNBZ0lITXVkR2xqYTBsdVpHVjRJRDBnTUR0Y2JpQWdJQ0J6TG1acGNuTjBWWEJrWVhSbElEMGdkSEoxWlR0Y2JpQWdJQ0J6TG5OMFlYSjBWR2x0WlNBOUlFUmhkR1V1Ym05M0tDazdYRzRnSUNBZ2N5NXlkVzV1YVc1bklEMGdkSEoxWlR0Y2JseHVJQ0FnSUhNdVkzVnljbVZ1ZEVKdmRXNWthVzVuUW05NElEMGdiV0ZyWlVKdmRXNWthVzVuUW05NEtDQnpMbUp2ZFc1a2FXNW5RbTk0TENCekxtTjVJQ2s3WEc1Y2JpQWdJQ0JwWmlnZ2N5NXlaV0ZrZVNBcGV5QnNMbTl1WlNnZ0ozSmxZV1I1Snl3Z2N5NXlaV0ZrZVNBcE95QjlYRzRnSUNBZ2FXWW9JSE11YzNSdmNDQXBleUJzTG05dVpTZ2dKM04wYjNBbkxDQnpMbk4wYjNBZ0tUc2dmVnh1WEc0Z0lDQWdjeTV1YjJSbGN5NW1iM0pGWVdOb0tDQnVJRDArSUhObGRFbHVhWFJwWVd4UWIzTnBkR2x2YmxOMFlYUmxLQ0J1TENCeklDa2dLVHRjYmx4dUlDQWdJR3d1Y0hKbGNuVnVLQ0J6SUNrN1hHNWNiaUFnSUNCcFppZ2djeTVoYm1sdFlYUmxRMjl1ZEdsdWRXOTFjMng1SUNsN1hHNGdJQ0FnSUNCc1pYUWdkVzVuY21GaWFXWjVJRDBnYm05a1pTQTlQaUI3WEc0Z0lDQWdJQ0FnSUdsbUtDQWhjeTUxYm1keVlXSnBabmxYYUdsc1pWTnBiWFZzWVhScGJtY2dLWHNnY21WMGRYSnVPeUI5WEc1Y2JpQWdJQ0FnSUNBZ2JHVjBJR2R5WVdKaVlXSnNaU0E5SUdkbGRFNXZaR1ZRYjNOcGRHbHZia1JoZEdFb0lHNXZaR1VzSUhNZ0tTNW5jbUZpWW1GaWJHVWdQU0J1YjJSbExtZHlZV0ppWVdKc1pTZ3BPMXh1WEc0Z0lDQWdJQ0FnSUdsbUtDQm5jbUZpWW1GaWJHVWdLWHRjYmlBZ0lDQWdJQ0FnSUNCdWIyUmxMblZ1WjNKaFltbG1lU2dwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQnNaWFFnY21WbmNtRmlhV1o1SUQwZ2JtOWtaU0E5UGlCN1hHNGdJQ0FnSUNBZ0lHbG1LQ0FoY3k1MWJtZHlZV0pwWm5sWGFHbHNaVk5wYlhWc1lYUnBibWNnS1hzZ2NtVjBkWEp1T3lCOVhHNWNiaUFnSUNBZ0lDQWdiR1YwSUdkeVlXSmlZV0pzWlNBOUlHZGxkRTV2WkdWUWIzTnBkR2x2YmtSaGRHRW9JRzV2WkdVc0lITWdLUzVuY21GaVltRmliR1U3WEc1Y2JpQWdJQ0FnSUNBZ2FXWW9JR2R5WVdKaVlXSnNaU0FwZTF4dUlDQWdJQ0FnSUNBZ0lHNXZaR1V1WjNKaFltbG1lU2dwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQnNaWFFnZFhCa1lYUmxSM0poWWxOMFlYUmxJRDBnYm05a1pTQTlQaUJuWlhST2IyUmxVRzl6YVhScGIyNUVZWFJoS0NCdWIyUmxMQ0J6SUNrdVozSmhZbUpsWkNBOUlHNXZaR1V1WjNKaFltSmxaQ2dwTzF4dVhHNGdJQ0FnSUNCc1pYUWdiMjVIY21GaUlEMGdablZ1WTNScGIyNG9leUIwWVhKblpYUWdmU2w3WEc0Z0lDQWdJQ0FnSUhWd1pHRjBaVWR5WVdKVGRHRjBaU2dnZEdGeVoyVjBJQ2s3WEc0Z0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNCc1pYUWdiMjVHY21WbElEMGdiMjVIY21GaU8xeHVYRzRnSUNBZ0lDQnNaWFFnYjI1RWNtRm5JRDBnWm5WdVkzUnBiMjRvZXlCMFlYSm5aWFFnZlNsN1hHNGdJQ0FnSUNBZ0lHeGxkQ0J3SUQwZ1oyVjBUbTlrWlZCdmMybDBhVzl1UkdGMFlTZ2dkR0Z5WjJWMExDQnpJQ2s3WEc0Z0lDQWdJQ0FnSUd4bGRDQjBjQ0E5SUhSaGNtZGxkQzV3YjNOcGRHbHZiaWdwTzF4dVhHNGdJQ0FnSUNBZ0lIQXVlQ0E5SUhSd0xuZzdYRzRnSUNBZ0lDQWdJSEF1ZVNBOUlIUndMbms3WEc0Z0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNCc1pYUWdiR2x6ZEdWdVZHOUhjbUZpSUQwZ2JtOWtaU0E5UGlCN1hHNGdJQ0FnSUNBZ0lHNXZaR1V1YjI0b0oyZHlZV0luTENCdmJrZHlZV0lwTzF4dUlDQWdJQ0FnSUNCdWIyUmxMbTl1S0NkbWNtVmxKeXdnYjI1R2NtVmxLVHRjYmlBZ0lDQWdJQ0FnYm05a1pTNXZiaWduWkhKaFp5Y3NJRzl1UkhKaFp5azdYRzRnSUNBZ0lDQjlPMXh1WEc0Z0lDQWdJQ0JzWlhRZ2RXNXNhWE4wWlc1VWIwZHlZV0lnUFNCdWIyUmxJRDArSUh0Y2JpQWdJQ0FnSUNBZ2JtOWtaUzV5WlcxdmRtVk1hWE4wWlc1bGNpZ25aM0poWWljc0lHOXVSM0poWWlrN1hHNGdJQ0FnSUNBZ0lHNXZaR1V1Y21WdGIzWmxUR2x6ZEdWdVpYSW9KMlp5WldVbkxDQnZia1p5WldVcE8xeHVJQ0FnSUNBZ0lDQnViMlJsTG5KbGJXOTJaVXhwYzNSbGJtVnlLQ2RrY21Gbkp5d2diMjVFY21GbktUdGNiaUFnSUNBZ0lIMDdYRzVjYmlBZ0lDQWdJR3hsZENCbWFYUWdQU0FvS1NBOVBpQjdYRzRnSUNBZ0lDQWdJR2xtS0NCekxtWnBkQ0FtSmlCekxtRnVhVzFoZEdWRGIyNTBhVzUxYjNWemJIa2dLWHRjYmlBZ0lDQWdJQ0FnSUNCekxtTjVMbVpwZENnZ2N5NXdZV1JrYVc1bklDazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDA3WEc1Y2JpQWdJQ0FnSUd4bGRDQnZiazV2ZEVSdmJtVWdQU0FvS1NBOVBpQjdYRzRnSUNBZ0lDQWdJSEpsWm5KbGMyaFFiM05wZEdsdmJuTW9JSE11Ym05a1pYTXNJSE1nS1R0Y2JpQWdJQ0FnSUNBZ1ptbDBLQ2s3WEc1Y2JpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEVGdWFXMWhkR2x2YmtaeVlXMWxLQ0JtY21GdFpTQXBPMXh1SUNBZ0lDQWdmVHRjYmx4dUlDQWdJQ0FnYkdWMElHWnlZVzFsSUQwZ1puVnVZM1JwYjI0b0tYdGNiaUFnSUNBZ0lDQWdiWFZzZEdsMGFXTnJLQ0J6TENCdmJrNXZkRVJ2Ym1Vc0lHOXVSRzl1WlNBcE8xeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdiR1YwSUc5dVJHOXVaU0E5SUNncElEMCtJSHRjYmlBZ0lDQWdJQ0FnY21WbWNtVnphRkJ2YzJsMGFXOXVjeWdnY3k1dWIyUmxjeXdnY3lBcE8xeHVJQ0FnSUNBZ0lDQm1hWFFvS1R0Y2JseHVJQ0FnSUNBZ0lDQnpMbTV2WkdWekxtWnZja1ZoWTJnb0lHNGdQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lISmxaM0poWW1sbWVTZ2diaUFwTzF4dUlDQWdJQ0FnSUNBZ0lIVnViR2x6ZEdWdVZHOUhjbUZpS0NCdUlDazdYRzRnSUNBZ0lDQWdJSDBnS1R0Y2JseHVJQ0FnSUNBZ0lDQnpMbkoxYm01cGJtY2dQU0JtWVd4elpUdGNibHh1SUNBZ0lDQWdJQ0JzTG1WdGFYUW9KMnhoZVc5MWRITjBiM0FuS1R0Y2JpQWdJQ0FnSUgwN1hHNWNiaUFnSUNBZ0lHd3VaVzFwZENnbmJHRjViM1YwYzNSaGNuUW5LVHRjYmx4dUlDQWdJQ0FnY3k1dWIyUmxjeTVtYjNKRllXTm9LQ0J1SUQwK0lIdGNiaUFnSUNBZ0lDQWdkVzVuY21GaWFXWjVLQ0J1SUNrN1hHNGdJQ0FnSUNBZ0lHeHBjM1JsYmxSdlIzSmhZaWdnYmlBcE8xeHVJQ0FnSUNBZ2ZTQXBPMXh1WEc0Z0lDQWdJQ0JtY21GdFpTZ3BPeUF2THlCcmFXTnJJRzltWmx4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnNaWFFnWkc5dVpTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ2JHVjBJRzl1VG05MFJHOXVaU0E5SUNncElEMCtJSHQ5TzF4dUlDQWdJQ0FnYkdWMElHOXVSRzl1WlNBOUlDZ3BJRDArSUdSdmJtVWdQU0IwY25WbE8xeHVYRzRnSUNBZ0lDQjNhR2xzWlNnZ0lXUnZibVVnS1h0Y2JpQWdJQ0FnSUNBZ2JYVnNkR2wwYVdOcktDQnpMQ0J2Yms1dmRFUnZibVVzSUc5dVJHOXVaU0FwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCekxtVnNaWE11YkdGNWIzVjBVRzl6YVhScGIyNXpLQ0IwYUdsekxDQnpMQ0J1YjJSbElEMCtJSHRjYmlBZ0lDQWdJQ0FnYkdWMElIQmtJRDBnWjJWMFRtOWtaVkJ2YzJsMGFXOXVSR0YwWVNnZ2JtOWtaU3dnY3lBcE8xeHVYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjdJSGc2SUhCa0xuZ3NJSGs2SUhCa0xua2dmVHRjYmlBZ0lDQWdJSDBnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzTG5CdmMzUnlkVzRvSUhNZ0tUdGNibHh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpPeUF2THlCamFHRnBibWx1WjF4dUlDQjlYRzVjYmlBZ2NISmxjblZ1S0NsN2ZWeHVJQ0J3YjNOMGNuVnVLQ2w3ZlZ4dUlDQjBhV05yS0NsN2ZWeHVYRzRnSUhOMGIzQW9LWHRjYmlBZ0lDQjBhR2x6TG5OMFlYUmxMbkoxYm01cGJtY2dQU0JtWVd4elpUdGNibHh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpPeUF2THlCamFHRnBibWx1WjF4dUlDQjlYRzVjYmlBZ1pHVnpkSEp2ZVNncGUxeHVJQ0FnSUhKbGRIVnliaUIwYUdsek95QXZMeUJqYUdGcGJtbHVaMXh1SUNCOVhHNTlYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVEdGNWIzVjBPMXh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDJ4aGVXOTFkQzlwYm1SbGVDNXFjeUlzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvSUdKaUxDQmplU0FwZTF4dUlDQnBaaWdnWW1JZ1BUMGdiblZzYkNBcGUxeHVJQ0FnSUdKaUlEMGdleUI0TVRvZ01Dd2dlVEU2SURBc0lIYzZJR041TG5kcFpIUm9LQ2tzSUdnNklHTjVMbWhsYVdkb2RDZ3BJSDA3WEc0Z0lIMGdaV3h6WlNCN0lDOHZJR052Y0hsY2JpQWdJQ0JpWWlBOUlIc2dlREU2SUdKaUxuZ3hMQ0I0TWpvZ1ltSXVlRElzSUhreE9pQmlZaTU1TVN3Z2VUSTZJR0ppTG5reUxDQjNPaUJpWWk1M0xDQm9PaUJpWWk1b0lIMDdYRzRnSUgxY2JseHVJQ0JwWmlnZ1ltSXVlRElnUFQwZ2JuVnNiQ0FwZXlCaVlpNTRNaUE5SUdKaUxuZ3hJQ3NnWW1JdWR6c2dmVnh1SUNCcFppZ2dZbUl1ZHlBOVBTQnVkV3hzSUNsN0lHSmlMbmNnUFNCaVlpNTRNaUF0SUdKaUxuZ3hPeUI5WEc0Z0lHbG1LQ0JpWWk1NU1pQTlQU0J1ZFd4c0lDbDdJR0ppTG5reUlEMGdZbUl1ZVRFZ0t5QmlZaTVvT3lCOVhHNGdJR2xtS0NCaVlpNW9JRDA5SUc1MWJHd2dLWHNnWW1JdWFDQTlJR0ppTG5reUlDMGdZbUl1ZVRFN0lIMWNibHh1SUNCeVpYUjFjbTRnWW1JN1hHNTlPMXh1WEc1Y2JseHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSWdMeTljYmk4dklDNHZjM0pqTDJ4aGVXOTFkQzl0WVd0bExXSmlMbXB6SWl3aVkyOXVjM1FnWVhOemFXZHVJRDBnY21WeGRXbHlaU2duTGk0dllYTnphV2R1SnlrN1hHNWNibXhsZENCelpYUkpibWwwYVdGc1VHOXphWFJwYjI1VGRHRjBaU0E5SUdaMWJtTjBhVzl1S0NCdWIyUmxMQ0J6ZEdGMFpTQXBlMXh1SUNCc1pYUWdjQ0E5SUc1dlpHVXVjRzl6YVhScGIyNG9LVHRjYmlBZ2JHVjBJR0ppSUQwZ2MzUmhkR1V1WTNWeWNtVnVkRUp2ZFc1a2FXNW5RbTk0TzF4dUlDQnNaWFFnYzJOeVlYUmphQ0E5SUc1dlpHVXVjMk55WVhSamFDZ2djM1JoZEdVdWJtRnRaU0FwTzF4dVhHNGdJR2xtS0NCelkzSmhkR05vSUQwOUlHNTFiR3dnS1h0Y2JpQWdJQ0J6WTNKaGRHTm9JRDBnZTMwN1hHNWNiaUFnSUNCdWIyUmxMbk5qY21GMFkyZ29JSE4wWVhSbExtNWhiV1VzSUhOamNtRjBZMmdnS1R0Y2JpQWdmVnh1WEc0Z0lHRnpjMmxuYmlnZ2MyTnlZWFJqYUN3Z2MzUmhkR1V1Y21GdVpHOXRhWHBsSUQ4Z2UxeHVJQ0FnSUhnNklHSmlMbmd4SUNzZ1RXRjBhQzV5WVc1a2IyMG9LU0FxSUdKaUxuY3NYRzRnSUNBZ2VUb2dZbUl1ZVRFZ0t5Qk5ZWFJvTG5KaGJtUnZiU2dwSUNvZ1ltSXVhRnh1SUNCOUlEb2dlMXh1SUNBZ0lIZzZJSEF1ZUN4Y2JpQWdJQ0I1T2lCd0xubGNiaUFnZlNBcE8xeHVYRzRnSUhOamNtRjBZMmd1Ykc5amEyVmtJRDBnYm05a1pTNXNiMk5yWldRb0tUdGNibjA3WEc1Y2JteGxkQ0JuWlhST2IyUmxVRzl6YVhScGIyNUVZWFJoSUQwZ1puVnVZM1JwYjI0b0lHNXZaR1VzSUhOMFlYUmxJQ2w3WEc0Z0lISmxkSFZ5YmlCdWIyUmxMbk5qY21GMFkyZ29JSE4wWVhSbExtNWhiV1VnS1R0Y2JuMDdYRzVjYm14bGRDQnlaV1p5WlhOb1VHOXphWFJwYjI1eklEMGdablZ1WTNScGIyNG9JRzV2WkdWekxDQnpkR0YwWlNBcGUxeHVJQ0J1YjJSbGN5NXdiM05wZEdsdmJuTW9ablZ1WTNScGIyNG9JRzV2WkdVZ0tYdGNiaUFnSUNCc1pYUWdjMk55WVhSamFDQTlJRzV2WkdVdWMyTnlZWFJqYUNnZ2MzUmhkR1V1Ym1GdFpTQXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lIZzZJSE5qY21GMFkyZ3VlQ3hjYmlBZ0lDQWdJSGs2SUhOamNtRjBZMmd1ZVZ4dUlDQWdJSDA3WEc0Z0lIMHBPMXh1ZlR0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdJSE5sZEVsdWFYUnBZV3hRYjNOcGRHbHZibE4wWVhSbExDQm5aWFJPYjJSbFVHOXphWFJwYjI1RVlYUmhMQ0J5WldaeVpYTm9VRzl6YVhScGIyNXpJSDA3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdMaTl6Y21NdmJHRjViM1YwTDNCdmMybDBhVzl1TG1weklpd2lZMjl1YzNRZ2JtOXdJRDBnWm5WdVkzUnBiMjRvS1h0OU8xeHVYRzVzWlhRZ2RHbGpheUE5SUdaMWJtTjBhVzl1S0NCemRHRjBaU0FwZTF4dUlDQnNaWFFnY3lBOUlITjBZWFJsTzF4dUlDQnNaWFFnYkNBOUlITjBZWFJsTG14aGVXOTFkRHRjYmx4dUlDQnNaWFFnZEdsamEwbHVaR2xqWVhSbGMwUnZibVVnUFNCc0xuUnBZMnNvSUhNZ0tUdGNibHh1SUNCcFppZ2djeTVtYVhKemRGVndaR0YwWlNBcGUxeHVJQ0FnSUdsbUtDQnpMbUZ1YVcxaGRHVkRiMjUwYVc1MWIzVnpiSGtnS1hzZ0x5OGdhVzVrYVdOaGRHVWdkR2hsSUdsdWFYUnBZV3dnY0c5emFYUnBiMjV6SUdoaGRtVWdZbVZsYmlCelpYUmNiaUFnSUNBZ0lITXViR0Y1YjNWMExtVnRhWFFvSjJ4aGVXOTFkSEpsWVdSNUp5azdYRzRnSUNBZ2ZWeHVJQ0FnSUhNdVptbHljM1JWY0dSaGRHVWdQU0JtWVd4elpUdGNiaUFnZlZ4dVhHNGdJSE11ZEdsamEwbHVaR1Y0S3lzN1hHNWNiaUFnYkdWMElHUjFjbUYwYVc5dUlEMGdSR0YwWlM1dWIzY29LU0F0SUhNdWMzUmhjblJVYVcxbE8xeHVYRzRnSUhKbGRIVnliaUFoY3k1cGJtWnBibWwwWlNBbUppQW9JSFJwWTJ0SmJtUnBZMkYwWlhORWIyNWxJSHg4SUhNdWRHbGphMGx1WkdWNElENDlJSE11YldGNFNYUmxjbUYwYVc5dWN5QjhmQ0JrZFhKaGRHbHZiaUErUFNCekxtMWhlRk5wYlhWc1lYUnBiMjVVYVcxbElDazdYRzU5TzF4dVhHNXNaWFFnYlhWc2RHbDBhV05ySUQwZ1puVnVZM1JwYjI0b0lITjBZWFJsTENCdmJrNXZkRVJ2Ym1VZ1BTQnViM0FzSUc5dVJHOXVaU0E5SUc1dmNDQXBlMXh1SUNCc1pYUWdaRzl1WlNBOUlHWmhiSE5sTzF4dUlDQnNaWFFnY3lBOUlITjBZWFJsTzF4dVhHNGdJR1p2Y2lnZ2JHVjBJR2tnUFNBd095QnBJRHdnY3k1eVpXWnlaWE5vT3lCcEt5c2dLWHRjYmlBZ0lDQmtiMjVsSUQwZ0lYTXVjblZ1Ym1sdVp5QjhmQ0IwYVdOcktDQnpJQ2s3WEc1Y2JpQWdJQ0JwWmlnZ1pHOXVaU0FwZXlCaWNtVmhhenNnZlZ4dUlDQjlYRzVjYmlBZ2FXWW9JQ0ZrYjI1bElDbDdYRzRnSUNBZ2IyNU9iM1JFYjI1bEtDazdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdiMjVFYjI1bEtDazdYRzRnSUgxY2JuMDdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZXlCMGFXTnJMQ0J0ZFd4MGFYUnBZMnNnZlR0Y2JseHVYRzVjYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTSUM4dlhHNHZMeUF1TDNOeVl5OXNZWGx2ZFhRdmRHbGpheTVxY3lKZExDSnpiM1Z5WTJWU2IyOTBJam9pSW4wPSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTksIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgdXRpbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKSk7XG52YXIgSGVhcCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdoZWFwJykpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxudmFyIHdpbmRvdyQxID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLm5hdmlnYXRvciA6IG51bGw7XG52YXIgZG9jdW1lbnQkMSA9IHdpbmRvdyQxID8gd2luZG93JDEuZG9jdW1lbnQgOiBudWxsO1xuXG52YXIgdHlwZW9mc3RyID0gX3R5cGVvZignJyk7XG5cbnZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcblxudmFyIHR5cGVvZmZuID0gX3R5cGVvZihmdW5jdGlvbiAoKSB7fSk7XG5cbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoSFRNTEVsZW1lbnQpO1xuXG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiBpbnN0YW5jZVN0cihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaW5zdGFuY2VTdHJpbmcgJiYgZm4ob2JqLmluc3RhbmNlU3RyaW5nKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT0gdHlwZW9mc3RyO1xufTtcbnZhciBmbiA9IGZ1bmN0aW9uIGZuKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2Zmbjtcbn07XG52YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbn07XG52YXIgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiBwbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqICYmICFhcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iajtcbn07XG52YXIgbnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBfdHlwZW9mKDEpICYmICFpc05hTihvYmopO1xufTtcbnZhciBpbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihvYmopIHtcbiAgcmV0dXJuIG51bWJlcihvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xufTtcbnZhciBodG1sRWxlbWVudCA9IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBlbGVtZW50T3JDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWxlbWVudE9yQ29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGVsZW1lbnQob2JqKSB8fCBjb2xsZWN0aW9uKG9iaik7XG59O1xudmFyIGVsZW1lbnQgPSBmdW5jdGlvbiBlbGVtZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb3JlID0gZnVuY3Rpb24gY29yZShvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbn07XG52YXIgc3R5bGVzaGVldCA9IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG59O1xudmFyIGV2ZW50ID0gZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xufTtcbnZhciBlbXB0eVN0cmluZyA9IGZ1bmN0aW9uIGVtcHR5U3RyaW5nKG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgfVxuXG4gIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG59O1xudmFyIGRvbUVsZW1lbnQgPSBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBib3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94KG9iaikge1xuICByZXR1cm4gcGxhaW5PYmplY3Qob2JqKSAmJiBudW1iZXIob2JqLngxKSAmJiBudW1iZXIob2JqLngyKSAmJiBudW1iZXIob2JqLnkxKSAmJiBudW1iZXIob2JqLnkyKTtcbn07XG52YXIgcHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XG4gIHJldHVybiBvYmplY3Qob2JqKSAmJiBmbihvYmoudGhlbik7XG59O1xudmFyIG1zID0gZnVuY3Rpb24gbXMoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZXx0cmlkZW50fGVkZ2UvaSk7XG59OyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cblxudmFyIG1lbW9pemUgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICBpZiAoIWtleUZuKSB7XG4gICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cblxuICB2YXIgbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uIG1lbW9pemVkRm4oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB2YXIgY2FjaGUgPSBtZW1vaXplZEZuLmNhY2hlO1xuXG4gICAgaWYgKCEocmV0ID0gY2FjaGVba10pKSB7XG4gICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn07XG5cbnZhciBjYW1lbDJkYXNoID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgZGFzaDJjYW1lbCA9IG1lbW9pemUoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgcHJlcGVuZENhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn0sIGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgJyQnICsgc3RyO1xufSk7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIGlmIChlbXB0eVN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudmFyIG51bWJlciQxID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIkMSArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpKT9cXFxcKSc7XG52YXIgcmdiYU5vQmFja1JlZnMgPSAncmdiW2FdP1xcXFwoKD86JyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyJDEgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJykpP1xcXFwpJztcbnZhciBoc2xhID0gJ2hzbFthXT9cXFxcKCgnICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICdbJV0pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICcpKT9cXFxcKSc7XG52YXIgaGV4MyA9ICdcXFxcI1swLTlhLWZBLUZdezN9JztcbnZhciBoZXg2ID0gJ1xcXFwjWzAtOWEtZkEtRl17Nn0nO1xuXG52YXIgYXNjZW5kaW5nID0gZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gLTEgKiBhc2NlbmRpbmcoYSwgYik7XG59O1xuXG52YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBhcmdzW2ldO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgIHRndFtrXSA9IG9ialtrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGd0O1xufTtcblxudmFyIGhleDJ0dXBsZSA9IGZ1bmN0aW9uIGhleDJ0dXBsZShoZXgpIHtcbiAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gIHZhciByLCBnLCBiO1xuICB2YXIgYmFzZSA9IDE2O1xuXG4gIGlmIChzaG9ydEhleCkge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMV0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbMl0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbM10gKyBoZXhbM10sIGJhc2UpO1xuICB9IGVsc2Uge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbM10gKyBoZXhbNF0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbNV0gKyBoZXhbNl0sIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuXG52YXIgaHNsMnR1cGxlID0gZnVuY3Rpb24gaHNsMnR1cGxlKGhzbCkge1xuICB2YXIgcmV0O1xuICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcblxuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgaHNsYSArICckJykuZXhlYyhoc2wpO1xuXG4gIGlmIChtKSB7XG4gICAgLy8gZ2V0IGh1ZVxuICAgIGggPSBwYXJzZUludChtWzFdKTtcblxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCA9ICgzNjAgLSAtMSAqIGggJSAzNjApICUgMzYwO1xuICAgIH0gZWxzZSBpZiAoaCA+IDM2MCkge1xuICAgICAgaCA9IGggJSAzNjA7XG4gICAgfVxuXG4gICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIHMgPSBwYXJzZUZsb2F0KG1bMl0pO1xuXG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cblxuXG4gICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGwgPSBwYXJzZUZsb2F0KG1bM10pO1xuXG4gICAgaWYgKGwgPCAwIHx8IGwgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuXG5cbiAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgYSA9IG1bNF07XG5cbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgICAgaWYgKGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYWxwaGEgaXMgWzAsIDFdXG5cbiAgICB9IC8vIG5vdywgY29udmVydCB0byByZ2JcbiAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuXG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICBnID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGgpKTtcbiAgICAgIGIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSk7XG4gICAgfVxuXG4gICAgcmV0ID0gW3IsIGcsIGIsIGFdO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuXG52YXIgcmdiMnR1cGxlID0gZnVuY3Rpb24gcmdiMnR1cGxlKHJnYikge1xuICB2YXIgcmV0O1xuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgcmdiYSArICckJykuZXhlYyhyZ2IpO1xuXG4gIGlmIChtKSB7XG4gICAgcmV0ID0gW107XG4gICAgdmFyIGlzUGN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgaWYgKGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG4gICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoY2hhbm5lbCk7XG5cbiAgICAgIGlmIChpc1BjdFtpXSkge1xuICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cblxuICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgfVxuXG4gICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcblxuICAgIGlmIChhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cblxuICAgIHZhciBhbHBoYSA9IG1bNF07XG5cbiAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcblxuICAgICAgaWYgKGFscGhhIDwgMCB8fCBhbHBoYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cblxuICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xudmFyIGNvbG9ybmFtZTJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9ybmFtZTJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gY29sb3JzW2NvbG9yLnRvTG93ZXJDYXNlKCldO1xufTtcbnZhciBjb2xvcjJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9yMnR1cGxlKGNvbG9yKSB7XG4gIHJldHVybiAoYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsKSB8fCBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHx8IGhleDJ0dXBsZShjb2xvcikgfHwgcmdiMnR1cGxlKGNvbG9yKSB8fCBoc2wydHVwbGUoY29sb3IpO1xufTtcbnZhciBjb2xvcnMgPSB7XG4gIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sXG4gIC8vIE5CIGFscGhhID09PSAwXG4gIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxufTtcblxudmFyIHNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgfVxufTsgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcblxudmFyIGdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpba2V5XTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuXG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLnBlcmZvcm1hbmNlIDogbnVsbDtcbnZhciBwbm93ID0gcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbnZhciByYWYgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh3aW5kb3ckMSkge1xuICAgIGlmICh3aW5kb3ckMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbihwbm93KCkpO1xuICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICB9XG4gIH07XG59KCk7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgcmV0dXJuIHJhZihmbik7XG59O1xudmFyIHBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxudmFyIERFRkFVTFRfU0VFRCA9IDUzODE7XG52YXIgaGFzaEl0ZXJhYmxlSW50cyA9IGZ1bmN0aW9uIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IpIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfU0VFRDtcbiAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICB2YXIgaGFzaCA9IHNlZWQ7XG4gIHZhciBlbnRyeTtcblxuICBmb3IgKDs7KSB7XG4gICAgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzaCA9IChoYXNoIDw8IDUpICsgaGFzaCArIGVudHJ5LnZhbHVlIHwgMDtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcbnZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfU0VFRDtcbiAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICByZXR1cm4gKHNlZWQgPDwgNSkgKyBzZWVkICsgbnVtIHwgMDtcbn07XG52YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5nID0gZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIsIHNlZWQpIHtcbiAgdmFyIGVudHJ5ID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZ3MgPSBmdW5jdGlvbiBoYXNoU3RyaW5ncygpIHtcbiAgcmV0dXJuIGhhc2hTdHJpbmdzQXJyYXkoYXJndW1lbnRzKTtcbn07XG52YXIgaGFzaFN0cmluZ3NBcnJheSA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzQXJyYXkoc3Rycykge1xuICB2YXIgaGFzaDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RyID0gc3Ryc1tpXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIsIGhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuLypnbG9iYWwgY29uc29sZSAqL1xudmFyIHdhcm5pbmdzRW5hYmxlZCA9IHRydWU7XG52YXIgd2FyblN1cHBvcnRlZCA9IGNvbnNvbGUud2FybiAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIHRydWVpZnkgPSBmdW5jdGlvbiB0cnVlaWZ5KCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZmFsc2lmeSA9IGZ1bmN0aW9uIGZhbHNpZnkoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgemVyb2lmeSA9IGZ1bmN0aW9uIHplcm9pZnkoKSB7XG4gIHJldHVybiAwO1xufTtcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufTtcbnZhciB3YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKGVuYWJsZWQpIHtcbiAgaWYgKGVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdhcm5pbmdzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2FybmluZ3NFbmFibGVkO1xuICB9XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICghd2FybmluZ3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh3YXJuU3VwcG9ydGVkKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobXNnKTtcblxuICAgIGlmICh0cmFjZVN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBleHRlbmQoe30sIG9iaik7XG59OyAvLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxuXG52YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoYXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcbnZhciBjb3B5QXJyYXkgPSBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIuc2xpY2UoKTtcbn07XG52YXIgdXVpZCA9IGZ1bmN0aW9uIHV1aWQoYSwgYlxuLyogcGxhY2Vob2xkZXJzICovXG4pIHtcbiAgZm9yICggLy8gbG9vcCA6KVxuICBiID0gYSA9ICcnOyAvLyBiIC0gcmVzdWx0ICwgYSAtIG51bWVyaWMgbGV0aWFibGVcbiAgYSsrIDwgMzY7IC8vXG4gIGIgKz0gYSAqIDUxICYgNTIgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgPyAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gID8gLy8gZ2VuZXRhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICA4IF4gTWF0aC5yYW5kb20oKSAqIChhIF4gMjAgPyAxNiA6IDQpIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgKS50b1N0cmluZygxNikgOiAnLScgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgKSB7XG4gIH1cblxuICByZXR1cm4gYjtcbn07XG52YXIgX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG52YXIgc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbiBzdGF0aWNFbXB0eU9iamVjdCgpIHtcbiAgcmV0dXJuIF9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG52YXIgZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBvcHRWYWwgPSBvcHRzID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRzW2tleV07XG4gICAgICBmaWxsZWRPcHRzW2tleV0gPSBvcHRWYWwgPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0c1trZXldIDogb3B0VmFsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWRPcHRzO1xuICB9O1xufTtcbnZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBlbGUsIG1hbnlDb3BpZXMpIHtcbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWxlKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuXG4gICAgICBpZiAoIW1hbnlDb3BpZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xufTtcbnZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICBhcnIucHVzaChlbCk7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG52YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xufTtcblxuLyogZ2xvYmFsIE1hcCAqL1xudmFyIE9iamVjdE1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcblxuICAgIHRoaXMuX29iaiA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9iamVjdE1hcCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgdGhpcy5fb2JqW2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iamVjdE1hcDtcbn0oKTtcblxudmFyIE1hcCQxID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5cbi8qIGdsb2JhbCBTZXQgKi9cbnZhciB1bmRlZiA9ICBcInVuZGVmaW5lZFwiIDtcblxudmFyIE9iamVjdFNldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFNldChhcnJheU9yT2JqZWN0U2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFNldCk7XG5cbiAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICBpZiAoYXJyYXlPck9iamVjdFNldCAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0U2V0LCBbe1xuICAgIGtleTogXCJpbnN0YW5jZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnc2V0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICBpZiAob1t2YWxdICE9PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDE7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICBpZiAob1t2YWxdID09PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXModmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW3ZhbF0gPT09IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXMoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JqZWN0U2V0O1xufSgpO1xuXG52YXIgU2V0JDEgPSAodHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFNldCkpICE9PSB1bmRlZiA/IFNldCA6IE9iamVjdFNldDtcblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KGN5LCBwYXJhbXMsIHJlc3RvcmUpIHtcbiAgcmVzdG9yZSA9IHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlID8gdHJ1ZSA6IGZhbHNlO1xuXG4gIGlmIChjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDsgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG5cbiAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgIH1cbiAgfSAvLyB2YWxpZGF0ZSBncm91cFxuXG5cbiAgaWYgKGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICByZXR1cm47XG4gIH0gLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG5cblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzOyAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgc2luZ2xlOiB0cnVlLFxuICAgIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSxcbiAgICAvLyBkYXRhIG9iamVjdFxuICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBhdXRvUGFkZGluZzogdW5kZWZpbmVkLFxuICAgIGNvbXBvdW5kQm91bmRzQ2xlYW46IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGNvbXBvdW5kIGRpbWVuc2lvbnMgbmVlZCB0byBiZSByZWNhbGN1bGF0ZWQgdGhlIG5leHQgdGltZSBkaW1lbnNpb25zIGFyZSByZWFkXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICBncm91cDogZ3JvdXAsXG4gICAgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgcnN0eWxlOiB7fSxcbiAgICAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgc3R5bGVDeHRzOiBbXSxcbiAgICAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHN0eWxlS2V5czoge30sXG4gICAgLy8gcGVyLWdyb3VwIGtleXMgb2Ygc3R5bGUgcHJvcGVydHkgdmFsdWVzXG4gICAgcmVtb3ZlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5zZWxlY3RhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RhYmxlXG4gICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBncmFiYmVkIGJ5IHRoZSBtb3VzZTsgcmVuZGVyZXIgc2V0cyB0aGlzIHByaXZhdGVseVxuICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIHBhbm5hYmxlOiBwYXJhbXMucGFubmFibGUgPT09IHVuZGVmaW5lZCA/IGdyb3VwID09PSAnZWRnZXMnID8gdHJ1ZSA6IGZhbHNlIDogcGFyYW1zLnBhbm5hYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHBhc3N0aHJvdWdoIHBhbm5pbmcgZW5hYmxlZFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgY2xhc3NlczogbmV3IFNldCQxKCksXG4gICAgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgcnNjcmF0Y2g6IHt9LFxuICAgIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sXG4gICAgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLFxuICAgIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIHBhcmVudDogbnVsbCxcbiAgICAvLyBwYXJlbnQgcmVmXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9LFxuICAgIC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gICAgYmFja2dyb3VuZGluZzogZmFsc2UsXG4gICAgLy8gd2hldGhlciBiYWNrZ3JvdW5kIGltYWdlcyBhcmUgbG9hZGluZ1xuICAgIGJiQ2FjaGU6IG51bGwsXG4gICAgLy8gY2FjaGUgb2YgdGhlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgYmJDYWNoZVNoaWZ0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gc2hpZnQgYXBwbGllZCB0byBjYWNoZWQgYmIgdG8gYmUgYXBwbGllZCBvbiBuZXh0IGdldFxuICAgIGJvZHlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgdy9vIG92ZXJsYXlcbiAgICBvdmVybGF5Qm91bmRzOiBudWxsLFxuICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIGluY2x1ZGluZyBvdmVybGF5XG4gICAgbGFiZWxCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBsYWJlbHNcbiAgICAgIGFsbDogbnVsbCxcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIG1haW46IG51bGxcbiAgICB9LFxuICAgIGFycm93Qm91bmRzOiB7XG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWRnZSBhcnJvd3NcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICdtaWQtc291cmNlJzogbnVsbCxcbiAgICAgICdtaWQtdGFyZ2V0JzogbnVsbFxuICAgIH1cbiAgfTtcblxuICBpZiAoX3AucG9zaXRpb24ueCA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueCA9IDA7XG4gIH1cblxuICBpZiAoX3AucG9zaXRpb24ueSA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueSA9IDA7XG4gIH0gLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG5cblxuICBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24pIHtcbiAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBfcC5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICBpZiAoYXJyYXkocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICB9IGVsc2UgaWYgKHN0cmluZyhwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcblxuICAgIGlmICghY2xzIHx8IGNscyA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIF9wLmNsYXNzZXMuYWRkKGNscyk7XG4gIH1cblxuICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgdmFyIGJ5cGFzcyA9IHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzO1xuXG4gIGlmIChieXBhc3MpIHtcbiAgICB3YXJuKCdTZXR0aW5nIGEgYHN0eWxlYCBieXBhc3MgYXQgZWxlbWVudCBjcmVhdGlvbiBpcyBkZXByZWNhdGVkJyk7XG4gICAgdGhpcy5zdHlsZShieXBhc3MpO1xuICB9XG5cbiAgaWYgKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlKSB7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbnZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiBkZWZpbmVTZWFyY2gocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHtcbiAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gIH07IC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcblxuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4ocm9vdHMsIGZuJDEsIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuJDEgPSBvcHRpb25zLnZpc2l0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH1cblxuICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhZm4oZm4kMSkgPyBmbiQxIDogZGlyZWN0ZWQ7XG4gICAgZm4kMSA9IGZuKGZuJDEpID8gZm4kMSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IHN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcblxuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzOyAvLyBlbnF1ZXVlIHZcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmkgPSB2W2ldO1xuICAgICAgdmFyIHZpSWQgPSB2aS5pZCgpO1xuXG4gICAgICBpZiAodmkuaXNOb2RlKCkpIHtcbiAgICAgICAgUS51bnNoaWZ0KHZpKTtcblxuICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgIFZbdmlJZF0gPSB0cnVlO1xuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godmkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWQyZGVwdGhbdmlJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuICAgICAgdmFyIHZJZCA9IHYuaWQoKTtcblxuICAgICAgaWYgKHBhcmFtcy5kZnMpIHtcbiAgICAgICAgaWYgKFZbdklkXSkge1xuICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBWW3ZJZF0gPSB0cnVlO1xuICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFt2SWRdO1xuICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbdklkXTtcbiAgICAgIHZhciBzcmMgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2Uuc291cmNlKCkgOiBudWxsO1xuICAgICAgdmFyIHRndCA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS50YXJnZXQoKSA6IG51bGw7XG4gICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogdi5zYW1lKHNyYykgPyB0Z3RbMF0gOiBzcmNbMF07XG4gICAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgICAgcmV0ID0gZm4kMSh2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuXG4gICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiAoIWRpcmVjdGVkIHx8IGUuc291cmNlKCkuc2FtZSh2KSkgJiYgZWRnZXMuaGFzKGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcblxuICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbd0lkXSkge1xuICAgICAgICAgIHcgPSB3WzBdO1xuICAgICAgICAgIFEucHVzaCh3KTtcblxuICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICBWW3dJZF0gPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh3KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX2xvb3A6IHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcDIoKTtcblxuICAgICAgc3dpdGNoIChfcmV0KSB7XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgXCJicmVha1wiOlxuICAgICAgICAgIGJyZWFrIF9sb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb25uZWN0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tfaV07XG4gICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5W25vZGUuaWQoKV07XG5cbiAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgY29ubmVjdGVkRWxlcy5tZXJnZShlZGdlKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkRWxlcy5tZXJnZShub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogY3kuY29sbGVjdGlvbihjb25uZWN0ZWRFbGVzKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKGZvdW5kKVxuICAgIH07XG4gIH07XG59OyAvLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcblxuXG52YXIgZWxlc2ZuID0ge1xuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgYmZzOiB0cnVlXG4gIH0pLFxuICBkZXB0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgIGRmczogdHJ1ZVxuICB9KVxufTsgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuXG5lbGVzZm4uYmZzID0gZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbi5kZnMgPSBlbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcblxudmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kMSA9IHtcbiAgZGlqa3N0cmE6IGZ1bmN0aW9uIGRpamtzdHJhKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIHdlaWdodDogYXJnc1sxXSxcbiAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9kaWprc3RyYURlZmF1bHRzID0gZGlqa3N0cmFEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgcm9vdCA9IF9kaWprc3RyYURlZmF1bHRzLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9kaWprc3RyYURlZmF1bHRzLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGlqa3N0cmFEZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIHNvdXJjZSA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICB2YXIgZGlzdCA9IHt9O1xuICAgIHZhciBwcmV2ID0ge307XG4gICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChub2RlKSB7XG4gICAgICByZXR1cm4gZGlzdFtub2RlLmlkKCldO1xuICAgIH07XG5cbiAgICB2YXIgc2V0RGlzdCA9IGZ1bmN0aW9uIHNldERpc3Qobm9kZSwgZCkge1xuICAgICAgZGlzdFtub2RlLmlkKCldID0gZDtcbiAgICAgIFEudXBkYXRlSXRlbShub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tfaV07XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICBpZiAoX3dlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSkge1xuICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBfd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXRzRGlzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcbiAgICAgICAgICBwcmV2W3ZpZF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG5cbiAgICB9IC8vIHdoaWxlXG5cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcbiAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuXG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFMudW5zaGlmdCh0YXJnZXQpO1xuXG4gICAgICAgICAgd2hpbGUgKHByZXZbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2W3VpZF07XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5lZGdlKTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLm5vZGUpO1xuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJDIgPSB7XG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgZm9yZXN0ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgQSA9IG5vZGVzOyAvLyBhc3N1bWVzIGJ5R3JvdXAoKSBjcmVhdGVzIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgbXV0YXRlZFxuXG4gICAgdmFyIGZpbmRTZXRJbmRleCA9IGZ1bmN0aW9uIGZpbmRTZXRJbmRleChlbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgIGlmIChlbGVzLmhhcyhlbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3Jlc3RbaV0gPSB0aGlzLnNwYXduKG5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IFNbX2ldO1xuICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHNldFVJbmRleCA9IGZpbmRTZXRJbmRleCh1KTtcbiAgICAgIHZhciBzZXRWSW5kZXggPSBmaW5kU2V0SW5kZXgodik7XG4gICAgICB2YXIgc2V0VSA9IGZvcmVzdFtzZXRVSW5kZXhdO1xuICAgICAgdmFyIHNldFYgPSBmb3Jlc3Rbc2V0VkluZGV4XTtcblxuICAgICAgaWYgKHNldFVJbmRleCAhPT0gc2V0VkluZGV4KSB7XG4gICAgICAgIEEubWVyZ2UoZWRnZSk7IC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuXG4gICAgICAgIHNldFUubWVyZ2Uoc2V0Vik7XG4gICAgICAgIGZvcmVzdC5zcGxpY2Uoc2V0VkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQTtcbiAgfVxufTtcblxudmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIGdvYWw6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgaGV1cmlzdGljOiBmdW5jdGlvbiBoZXVyaXN0aWMoZWRnZSkge1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQzID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYVN0YXI6IGZ1bmN0aW9uIGFTdGFyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgX2FTdGFyRGVmYXVsdHMgPSBhU3RhckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2FTdGFyRGVmYXVsdHMucm9vdCxcbiAgICAgICAgZ29hbCA9IF9hU3RhckRlZmF1bHRzLmdvYWwsXG4gICAgICAgIGhldXJpc3RpYyA9IF9hU3RhckRlZmF1bHRzLmhldXJpc3RpYyxcbiAgICAgICAgZGlyZWN0ZWQgPSBfYVN0YXJEZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgd2VpZ2h0ID0gX2FTdGFyRGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgZ29hbCA9IGN5LmNvbGxlY3Rpb24oZ29hbClbMF07XG4gICAgdmFyIHNpZCA9IHJvb3QuaWQoKTtcbiAgICB2YXIgdGlkID0gZ29hbC5pZCgpO1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG4gICAgdmFyIGNsb3NlZFNldElkcyA9IHt9O1xuICAgIHZhciBvcGVuU2V0ID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgIH0pO1xuICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuXG4gICAgdmFyIGFkZFRvT3BlblNldCA9IGZ1bmN0aW9uIGFkZFRvT3BlblNldChlbGUsIGlkKSB7XG4gICAgICBvcGVuU2V0LnB1c2goZWxlKTtcbiAgICAgIG9wZW5TZXRJZHMuYWRkKGlkKTtcbiAgICB9O1xuXG4gICAgdmFyIGNNaW4sIGNNaW5JZDtcblxuICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgfTtcblxuICAgIHZhciBpc0luT3BlblNldCA9IGZ1bmN0aW9uIGlzSW5PcGVuU2V0KGlkKSB7XG4gICAgICByZXR1cm4gb3BlblNldElkcy5oYXMoaWQpO1xuICAgIH07XG5cbiAgICBhZGRUb09wZW5TZXQocm9vdCwgc2lkKTtcbiAgICBnU2NvcmVbc2lkXSA9IDA7XG4gICAgZlNjb3JlW3NpZF0gPSBoZXVyaXN0aWMocm9vdCk7IC8vIENvdW50ZXJcblxuICAgIHZhciBzdGVwcyA9IDA7IC8vIE1haW4gbG9vcFxuXG4gICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgIHN0ZXBzKys7IC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgIGlmIChjTWluSWQgPT09IHRpZCkge1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB2YXIgcGF0aE5vZGUgPSBnb2FsO1xuICAgICAgICB2YXIgcGF0aE5vZGVJZCA9IHRpZDtcbiAgICAgICAgdmFyIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aE5vZGUgPSBjYW1lRnJvbVtwYXRoTm9kZUlkXTtcblxuICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVtjTWluSWRdLFxuICAgICAgICAgIHBhdGg6IHRoaXMuc3Bhd24ocGF0aCksXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuXG5cbiAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTsgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuXG4gICAgICB2YXIgdndFZGdlcyA9IGNNaW4uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07IC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZS5pZCgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcblxuXG4gICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3U3JjID0gZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHdUZ3QgPSBlLnRhcmdldCgpO1xuICAgICAgICB2YXIgdyA9IHdTcmMuaWQoKSAhPT0gY01pbklkID8gd1NyYyA6IHdUZ3Q7XG4gICAgICAgIHZhciB3aWQgPSB3LmlkKCk7IC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQod2lkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcblxuXG4gICAgICAgIGlmIChjbG9zZWRTZXRJZHNbd2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuXG5cbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpOyAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuXG4gICAgICAgIGlmICghaXNJbk9wZW5TZXQod2lkKSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGFkZFRvT3BlblNldCh3LCB3aWQpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcblxuXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICB9XG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQ0ID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24gZmxveWRXYXJzaGFsbChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgd2VpZ2h0ID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBOID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBOc3EgPSBOICogTjtcblxuICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9OyAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuXG5cbiAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOc3E7IG4rKykge1xuICAgICAgdmFyIGogPSBuICUgTjtcbiAgICAgIHZhciBpID0gKG4gLSBqKSAvIE47XG5cbiAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgIGRpc3Rbbl0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdFtuXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH0gLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgIHZhciBuZXh0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgdmFyIGVkZ2VOZXh0ID0gbmV3IEFycmF5KE5zcSk7IC8vIFByb2Nlc3MgZWRnZXNcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBleGNsdWRlIGxvb3BzXG5cblxuICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuXG4gICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpOyAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG5cblxuICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgIH0gLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcblxuXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciB0cyA9IHQgKiBOICsgczsgLy8gdGFyZ2V0IHRvIHNvdXJjZSBpbmRleFxuXG4gICAgICAgIGlmICghZGlyZWN0ZWQgJiYgZGlzdFt0c10gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFt0c10gPSBfd2VpZ2h0O1xuICAgICAgICAgIG5leHRbdHNdID0gcztcbiAgICAgICAgICBlZGdlTmV4dFt0c10gPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBNYWluIGxvb3BcblxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBOOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47IF9pMisrKSB7XG4gICAgICAgIHZhciBpayA9IF9pMiAqIE4gKyBrO1xuXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG5cbiAgICAgICAgICBpZiAoZGlzdFtpa10gKyBkaXN0W2tqXSA8IGRpc3RbaWpdKSB7XG4gICAgICAgICAgICBkaXN0W2lqXSA9IGRpc3RbaWtdICsgZGlzdFtral07XG4gICAgICAgICAgICBuZXh0W2lqXSA9IG5leHRbaWtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRBcmdFbGUgPSBmdW5jdGlvbiBnZXRBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyhlbGUpID8gY3kuZmlsdGVyKGVsZSkgOiBlbGUpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICByZXR1cm4gZGlzdFtpICogTiArIGpdO1xuICAgICAgfSxcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBhdEluZGV4KGkpO1xuXG4gICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21Ob2RlLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHByZXYgPSBpO1xuICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgcGF0aC5tZXJnZShmcm9tTm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKGkgIT09IGopIHtcbiAgICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgICBpID0gbmV4dFtpICogTiArIGpdO1xuICAgICAgICAgIGVkZ2UgPSBlZGdlTmV4dFtwcmV2ICogTiArIGldO1xuICAgICAgICAgIHBhdGgubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgcGF0aC5tZXJnZShhdEluZGV4KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbn07IC8vIGVsZXNmblxuXG52YXIgYmVsbG1hbkZvcmREZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiQ1ID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uIGJlbGxtYW5Gb3JkKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9iZWxsbWFuRm9yZERlZmF1bHRzID0gYmVsbG1hbkZvcmREZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgd2VpZ2h0ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICByb290ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMucm9vdDtcblxuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXM7XG5cbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZm9NYXAgPSBuZXcgTWFwJDEoKTtcbiAgICB2YXIgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IGZhbHNlO1xuICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlcyA9IFtdO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdOyAvLyBpbiBjYXNlIHNlbGVjdG9yIHBhc3NlZFxuXG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICB2YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8obm9kZSkge1xuICAgICAgdmFyIG9iaiA9IGluZm9NYXAuZ2V0KG5vZGUuaWQoKSk7XG5cbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpbmZvTWFwLnNldChub2RlLmlkKCksIG9iaik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBnZXROb2RlRnJvbVRvID0gZnVuY3Rpb24gZ2V0Tm9kZUZyb21Ubyh0bykge1xuICAgICAgcmV0dXJuIChzdHJpbmcodG8pID8gY3kuJCh0bykgOiB0bylbMF07XG4gICAgfTtcblxuICAgIHZhciBkaXN0YW5jZVRvID0gZnVuY3Rpb24gZGlzdGFuY2VUbyh0bykge1xuICAgICAgcmV0dXJuIGdldEluZm8oZ2V0Tm9kZUZyb21Ubyh0bykpLmRpc3Q7XG4gICAgfTtcblxuICAgIHZhciBwYXRoVG8gPSBmdW5jdGlvbiBwYXRoVG8odG8pIHtcbiAgICAgIHZhciB0aGlzU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJvb3Q7XG4gICAgICB2YXIgZW5kID0gZ2V0Tm9kZUZyb21Ubyh0byk7XG4gICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgdmFyIG5vZGUgPSBlbmQ7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zcGF3bigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhub2RlKSxcbiAgICAgICAgICAgIGVkZ2UgPSBfZ2V0SW5mby5lZGdlLFxuICAgICAgICAgICAgcHJlZCA9IF9nZXRJbmZvLnByZWQ7XG5cbiAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGVbMF0pO1xuXG4gICAgICAgIGlmIChub2RlLnNhbWUodGhpc1N0YXJ0KSAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoZWRnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcHJlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocGF0aCk7XG4gICAgfTsgLy8gSW5pdGlhbGl6YXRpb25zIHsgZGlzdCwgcHJlZCwgZWRnZSB9XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBpbmZvID0gZ2V0SW5mbyhub2RlKTtcblxuICAgICAgaWYgKG5vZGUuc2FtZShyb290KSkge1xuICAgICAgICBpbmZvLmRpc3QgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby5kaXN0ID0gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGluZm8ucHJlZCA9IG51bGw7XG4gICAgICBpbmZvLmVkZ2UgPSBudWxsO1xuICAgIH0gLy8gRWRnZXMgcmVsYXhhdGlvblxuXG5cbiAgICB2YXIgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICB2YXIgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChub2RlMSwgbm9kZTIsIGVkZ2UsIGluZm8xLCBpbmZvMiwgd2VpZ2h0KSB7XG4gICAgICB2YXIgZGlzdCA9IGluZm8xLmRpc3QgKyB3ZWlnaHQ7XG5cbiAgICAgIGlmIChkaXN0IDwgaW5mbzIuZGlzdCAmJiAhZWRnZS5zYW1lKGluZm8xLmVkZ2UpKSB7XG4gICAgICAgIGluZm8yLmRpc3QgPSBkaXN0O1xuICAgICAgICBpbmZvMi5wcmVkID0gbm9kZTE7XG4gICAgICAgIGluZm8yLmVkZ2UgPSBlZGdlO1xuICAgICAgICByZXBsYWNlZEVkZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG51bUVkZ2VzOyBlKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG5cbiAgICAgICAgdmFyIHNyY0luZm8gPSBnZXRJbmZvKHNyYyk7XG4gICAgICAgIHZhciB0Z3RJbmZvID0gZ2V0SW5mbyh0Z3QpO1xuICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChzcmMsIHRndCwgZWRnZSwgc3JjSW5mbywgdGd0SW5mbywgX3dlaWdodCk7IC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHRndCwgc3JjLCBlZGdlLCB0Z3RJbmZvLCBzcmNJbmZvLCBfd2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlcGxhY2VkRWRnZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZWRFZGdlKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgZm9yICh2YXIgX2UgPSAwOyBfZSA8IG51bUVkZ2VzOyBfZSsrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19lXTtcblxuICAgICAgICB2YXIgX3NyYyA9IF9lZGdlLnNvdXJjZSgpO1xuXG4gICAgICAgIHZhciBfdGd0ID0gX2VkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIF93ZWlnaHQyID0gd2VpZ2h0Rm4oX2VkZ2UpO1xuXG4gICAgICAgIHZhciBzcmNEaXN0ID0gZ2V0SW5mbyhfc3JjKS5kaXN0O1xuICAgICAgICB2YXIgdGd0RGlzdCA9IGdldEluZm8oX3RndCkuZGlzdDtcblxuICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCB8fCAhZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgIHdhcm4oJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnKTtcbiAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBkaXN0YW5jZVRvLFxuICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlLFxuICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXM6IG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzXG4gICAgfTtcbiAgfSAvLyBiZWxsbWFuRm9yZFxuXG59OyAvLyBlbGVzZm5cblxudmFyIHNxcnQyID0gTWF0aC5zcXJ0KDIpOyAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbi8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcblxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgfVxuXG4gIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcbiAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7IC8vIHJlLXVzZSBhcnJheVxuICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuXG4gIGZvciAodmFyIGkgPSBuZXdFZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgdmFyIHNyYyA9IGVkZ2VbMV07XG4gICAgdmFyIHRndCA9IGVkZ2VbMl07XG5cbiAgICBpZiAobm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMiB8fCBub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICBuZXdFZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9IC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcblxuICAgIGlmIChfZWRnZVsxXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgc291cmNlXG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgfSBlbHNlIGlmIChfZWRnZVsyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9IC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlTWFwLmxlbmd0aDsgX2kyKyspIHtcbiAgICBpZiAobm9kZU1hcFtfaTJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICBub2RlTWFwW19pMl0gPSBwYXJ0aXRpb24xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdFZGdlcztcbn07IC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuXG5cbnZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICB3aGlsZSAoc2l6ZSA+IHNpemVMaW1pdCkge1xuICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCk7IC8vIENvbGxhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcblxuICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgIHNpemUtLTtcbiAgfVxuXG4gIHJldHVybiByZW1haW5pbmdFZGdlcztcbn07XG5cbnZhciBlbGVzZm4kNiA9IHtcbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbigpIHtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBzcXJ0Mik7XG5cbiAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICBlcnJvcignQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcblxuXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBub2Rlcy5pbmRleE9mKGUuc291cmNlKCkpLCBub2Rlcy5pbmRleE9mKGUudGFyZ2V0KCkpXSk7XG4gICAgfSAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG5cblxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dEVkZ2VJbmRleGVzID0gW107XG4gICAgdmFyIG1pbkN1dE5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpOyAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cblxuICAgIHZhciBtZXRhTm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIG1ldGFOb2RlTWFwMiA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG5cbiAgICB2YXIgY29weU5vZGVzTWFwID0gZnVuY3Rpb24gY29weU5vZGVzTWFwKGZyb20sIHRvKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgdG9bX2kzXSA9IGZyb21bX2kzXTtcbiAgICAgIH1cbiAgICB9OyAvLyBNYWluIGxvb3BcblxuXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAvLyBSZXNldCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgbWV0YU5vZGVNYXBbX2k0XSA9IF9pNDtcbiAgICAgIH0gLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG5cblxuICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcy5zbGljZSgpLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgdmFyIGVkZ2VzU3RhdGUyID0gZWRnZXNTdGF0ZS5zbGljZSgpOyAvLyBjb3B5XG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuXG4gICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1ldGFOb2RlTWFwMik7IC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcblxuICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlMiwgc3RvcFNpemUsIDIpOyAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuXG4gICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMxO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczI7XG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcDIsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgdmFyIGN1dCA9IHRoaXMuc3Bhd24obWluQ3V0RWRnZUluZGV4ZXMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZWRnZXNbZVswXV07XG4gICAgfSkpO1xuICAgIHZhciBwYXJ0aXRpb24xID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBwYXJ0aXRpb24yID0gdGhpcy5zcGF3bigpOyAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcblxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dE5vZGVNYXBbMF07XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBtaW5DdXROb2RlTWFwLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dE5vZGVNYXBbX2k1XTtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbX2k1XTtcblxuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLm1lcmdlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5tZXJnZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBjdXQsXG4gICAgICBwYXJ0aXRpb24xOiBwYXJ0aXRpb24xLFxuICAgICAgcGFydGl0aW9uMjogcGFydGl0aW9uMlxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTsgLy8gZWxlc2ZuXG5cbnZhciBjb3B5UG9zaXRpb24gPSBmdW5jdGlvbiBjb3B5UG9zaXRpb24ocCkge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCxcbiAgICB5OiBwLnlcbiAgfTtcbn07XG52YXIgbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwLnggKiB6b29tICsgcGFuLngsXG4gICAgeTogcC55ICogem9vbSArIHBhbi55XG4gIH07XG59O1xudmFyIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uID0gZnVuY3Rpb24gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogKHAueCAtIHBhbi54KSAvIHpvb20sXG4gICAgeTogKHAueSAtIHBhbi55KSAvIHpvb21cbiAgfTtcbn07XG52YXIgYXJyYXkycG9pbnQgPSBmdW5jdGlvbiBhcnJheTJwb2ludChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhcnJbMF0sXG4gICAgeTogYXJyWzFdXG4gIH07XG59O1xudmFyIG1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcbnZhciBtYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgodmFsLCBtYXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59O1xudmFyIG1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG4gIHZhciBuID0gMDtcblxuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgdG90YWwgKz0gdmFsO1xuICAgICAgbisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b3RhbCAvIG47XG59O1xudmFyIG1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgY29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBpbmNsdWRlSG9sZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG5cbiAgaWYgKGNvcHkpIHtcbiAgICBhcnIgPSBhcnIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGFyci5zcGxpY2UoZW5kLCBhcnIubGVuZ3RoIC0gZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoYmVnaW4gPiAwKSB7XG4gICAgICBhcnIuc3BsaWNlKDAsIGJlZ2luKTtcbiAgICB9XG4gIH0gLy8gYWxsIG5vbiBmaW5pdGUgKGUuZy4gSW5maW5pdHksIE5hTikgZWxlbWVudHMgbXVzdCBiZSAtSW5maW5pdHkgc28gdGhleSBnbyB0byB0aGUgc3RhcnRcblxuXG4gIHZhciBvZmYgPSAwOyAvLyBvZmZzZXQgZnJvbSBub24tZmluaXRlIHZhbHVlc1xuXG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdiA9IGFycltpXTtcblxuICAgIGlmIChpbmNsdWRlSG9sZXMpIHtcbiAgICAgIGlmICghaXNGaW5pdGUodikpIHtcbiAgICAgICAgYXJyW2ldID0gLUluZmluaXR5O1xuICAgICAgICBvZmYrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZW1vdmUgaXQgaWYgd2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBob2xlc1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7IC8vIHJlcXVpcmVzIGNvcHkgPSB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb3JpZ1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgcmV0dXJuIGFyclttaWQgKyAxICsgb2ZmXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGFyclttaWQgLSAxICsgb2ZmXSArIGFyclttaWQgKyBvZmZdKSAvIDI7XG4gIH1cbn07XG52YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcbnZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoZGlzcFksIGRpc3BYKSAtIE1hdGguUEkgLyAyO1xufTtcbnZhciBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLmxvZyhuKSAvIE1hdGgubG9nKDIpO1xufTtcbnZhciBzaWdudW0gPSBmdW5jdGlvbiBzaWdudW0oeCkge1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcWRpc3QocDEsIHAyKSk7XG59O1xudmFyIHNxZGlzdCA9IGZ1bmN0aW9uIHNxZGlzdChwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xudmFyIGluUGxhY2VTdW1Ob3JtYWxpemUgPSBmdW5jdGlvbiBpblBsYWNlU3VtTm9ybWFsaXplKHYpIHtcbiAgdmFyIGxlbmd0aCA9IHYubGVuZ3RoOyAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcblxuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSB2W2ldO1xuICB9IC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcblxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICB2W19pXSA9IHZbX2ldIC8gdG90YWw7XG4gIH1cblxuICByZXR1cm4gdjtcbn07XG5cbnZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbn07XG52YXIgcWJlemllclB0QXQgPSBmdW5jdGlvbiBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiB7XG4gICAgeDogcWJlemllckF0KHAwLngsIHAxLngsIHAyLngsIHQpLFxuICAgIHk6IHFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICB9O1xufTtcbnZhciBsaW5lQXQgPSBmdW5jdGlvbiBsaW5lQXQocDAsIHAxLCB0LCBkKSB7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcbiAgdmFyIHZlY0Rpc3QgPSBkaXN0KHAwLCBwMSk7XG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcbiAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuICBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xudmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQobWluLCB2YWwsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xufTsgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcblxudmFyIG1ha2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIG1ha2VCb3VuZGluZ0JveChiYikge1xuICBpZiAoYmIgPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB4MjogLUluZmluaXR5LFxuICAgICAgeTI6IC1JbmZpbml0eSxcbiAgICAgIHc6IDAsXG4gICAgICBoOiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwpIHtcbiAgICBpZiAoYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICB5MjogYmIueTIsXG4gICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICB3OiBiYi53LFxuICAgICAgICBoOiBiYi5oXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBjb3B5Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjb3B5Qm91bmRpbmdCb3goYmIpIHtcbiAgcmV0dXJuIHtcbiAgICB4MTogYmIueDEsXG4gICAgeDI6IGJiLngyLFxuICAgIHc6IGJiLncsXG4gICAgeTE6IGJiLnkxLFxuICAgIHkyOiBiYi55MixcbiAgICBoOiBiYi5oXG4gIH07XG59O1xudmFyIGNsZWFyQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjbGVhckJvdW5kaW5nQm94KGJiKSB7XG4gIGJiLngxID0gSW5maW5pdHk7XG4gIGJiLnkxID0gSW5maW5pdHk7XG4gIGJiLngyID0gLUluZmluaXR5O1xuICBiYi55MiA9IC1JbmZpbml0eTtcbiAgYmIudyA9IDA7XG4gIGJiLmggPSAwO1xufTtcbnZhciB1cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG4gIGJiMS54MSA9IE1hdGgubWluKGJiMS54MSwgYmIyLngxKTtcbiAgYmIxLngyID0gTWF0aC5tYXgoYmIxLngyLCBiYjIueDIpO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLnkxID0gTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpO1xuICBiYjEueTIgPSBNYXRoLm1heChiYjEueTIsIGJiMi55Mik7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHgsIHkpIHtcbiAgYmIueDEgPSBNYXRoLm1pbihiYi54MSwgeCk7XG4gIGJiLngyID0gTWF0aC5tYXgoYmIueDIsIHgpO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIueTEgPSBNYXRoLm1pbihiYi55MSwgeSk7XG4gIGJiLnkyID0gTWF0aC5tYXgoYmIueTIsIHkpO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveChiYikge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgYmIueDEgLT0gcGFkZGluZztcbiAgYmIueDIgKz0gcGFkZGluZztcbiAgYmIueTEgLT0gcGFkZGluZztcbiAgYmIueTIgKz0gcGFkZGluZztcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMF07XG4gIHZhciB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQ7XG5cbiAgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gcGFkZGluZ1swXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMikge1xuICAgIHRvcCA9IGJvdHRvbSA9IHBhZGRpbmdbMF07XG4gICAgbGVmdCA9IHJpZ2h0ID0gcGFkZGluZ1sxXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBfcGFkZGluZyA9IF9zbGljZWRUb0FycmF5KHBhZGRpbmcsIDQpO1xuXG4gICAgdG9wID0gX3BhZGRpbmdbMF07XG4gICAgcmlnaHQgPSBfcGFkZGluZ1sxXTtcbiAgICBib3R0b20gPSBfcGFkZGluZ1syXTtcbiAgICBsZWZ0ID0gX3BhZGRpbmdbM107XG4gIH1cblxuICBiYi54MSAtPSBsZWZ0O1xuICBiYi54MiArPSByaWdodDtcbiAgYmIueTEgLT0gdG9wO1xuICBiYi55MiArPSBib3R0b207XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgcmV0dXJuIGJiO1xufTtcblxudmFyIGFzc2lnbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYXNzaWduQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgYmIxLngxID0gYmIyLngxO1xuICBiYjEueTEgPSBiYjIueTE7XG4gIGJiMS54MiA9IGJiMi54MjtcbiAgYmIxLnkyID0gYmIyLnkyO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGFzc2lnblNoaWZ0VG9Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnblNoaWZ0VG9Cb3VuZGluZ0JveChiYiwgZGVsdGEpIHtcbiAgYmIueDEgKz0gZGVsdGEueDtcbiAgYmIueDIgKz0gZGVsdGEueDtcbiAgYmIueTEgKz0gZGVsdGEueTtcbiAgYmIueTIgKz0gZGVsdGEueTtcbn07XG52YXIgYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIxLCBiYjIpIHtcbiAgLy8gY2FzZTogb25lIGJiIHRvIHJpZ2h0IG9mIG90aGVyXG4gIGlmIChiYjEueDEgPiBiYjIueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLngxID4gYmIxLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG5cblxuICBpZiAoYmIxLngyIDwgYmIyLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJiMi54MiA8IGJiMS54MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcblxuXG4gIGlmIChiYjEueTIgPCBiYjIueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLnkyIDwgYmIxLnkxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuXG5cbiAgaWYgKGJiMS55MSA+IGJiMi55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueTEgPiBiYjEueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG5cblxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGluQm91bmRpbmdCb3goYmIsIHgsIHkpIHtcbiAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG59O1xudmFyIHBvaW50SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZGluZ0JveChiYiwgcHQpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIsIHB0LngsIHB0LnkpO1xufTtcbnZhciBib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveEluQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDEsIGJiMi55MSkgJiYgaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MiwgYmIyLnkyKTtcbn07XG52YXIgcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjsgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcblxuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9uczsgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcblxuICB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9IC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gIHtcbiAgICB2YXIgYm90dG9tU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRZID0gYm90dG9tU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG5cbiAge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zOyAvLyBUb3AgTGVmdFxuXG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcExlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfSAvLyBUb3AgUmlnaHRcblxuICB7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH0gLy8gQm90dG9tIFJpZ2h0XG5cbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9IC8vIEJvdHRvbSBMZWZ0XG5cbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcbnZhciBpbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uIGluTGluZVZpY2luaXR5KHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKSB7XG4gIHZhciB0ID0gdG9sZXJhbmNlO1xuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdCAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG52YXIgaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uIGluQmV6aWVyVmljaW5pdHkoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgfTsgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG5cbiAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgc29sdmVRdWFkcmF0aWMgPSBmdW5jdGlvbiBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCB2YWwpIHtcbiAgYyAtPSB2YWw7XG4gIHZhciByID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYgKHIgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNxcnRSID0gTWF0aC5zcXJ0KHIpO1xuICB2YXIgZGVub20gPSAyICogYTtcbiAgdmFyIHJvb3QxID0gKC1iICsgc3FydFIpIC8gZGVub207XG4gIHZhciByb290MiA9ICgtYiAtIHNxcnRSKSAvIGRlbm9tO1xuICByZXR1cm4gW3Jvb3QxLCByb290Ml07XG59O1xudmFyIHNvbHZlQ3ViaWMgPSBmdW5jdGlvbiBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJlc3VsdCkge1xuICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcbiAgdmFyIGVwc2lsb24gPSAwLjAwMDAxOyAvLyBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoaWxlIGtlZXBpbmcgdGhlIG92ZXJhbGwgZXhwcmVzc2lvbiBjbG9zZSBpbiB2YWx1ZVxuXG4gIGlmIChhID09PSAwKSB7XG4gICAgYSA9IGVwc2lsb247XG4gIH1cblxuICBiIC89IGE7XG4gIGMgLz0gYTtcbiAgZCAvPSBhO1xuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuICBxID0gKDMuMCAqIGMgLSBiICogYikgLyA5LjA7XG4gIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICByIC89IDU0LjA7XG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IGIgLyAzLjA7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHMgPSBzIDwgMCA/IC1NYXRoLnBvdygtcywgMS4wIC8gMy4wKSA6IE1hdGgucG93KHMsIDEuMCAvIDMuMCk7XG4gICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICB0ID0gdCA8IDAgPyAtTWF0aC5wb3coLXQsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyh0LCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgcmVzdWx0WzVdID0gLXRlcm0xO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgIHIxMyA9IHIgPCAwID8gLU1hdGgucG93KC1yLCAxLjAgLyAzLjApIDogTWF0aC5wb3cociwgMS4wIC8gMy4wKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLShyMTMgKyB0ZXJtMSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcSA9IC1xO1xuICBkdW0xID0gcSAqIHEgKiBxO1xuICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gIHJlc3VsdFswXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKGR1bTEgLyAzLjApO1xuICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gIHJldHVybjtcbn07XG52YXIgc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbiBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG4gIHZhciBhID0gMS4wICogeDEgKiB4MSAtIDQgKiB4MSAqIHgyICsgMiAqIHgxICogeDMgKyA0ICogeDIgKiB4MiAtIDQgKiB4MiAqIHgzICsgeDMgKiB4MyArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG4gIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHggKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcbiAgdmFyIGQgPSAxLjAgKiB4MSAqIHgyIC0geDEgKiB4MSArIHgxICogeCAtIHgyICogeCArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5OyAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107IC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cblxuICBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG4gIHZhciBwYXJhbXMgPSBbXTtcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMucHVzaCgxLjApO1xuICBwYXJhbXMucHVzaCgwLjApO1xuICB2YXIgbWluRGlzdGFuY2VTcXVhcmVkID0gLTE7XG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIGN1clggPSBNYXRoLnBvdygxLjAgLSBwYXJhbXNbaV0sIDIuMCkgKiB4MSArIDIuMCAqICgxIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHgyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeDM7XG4gICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MSArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeTM7XG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyhjdXJYIC0geCwgMikgKyBNYXRoLnBvdyhjdXJZIC0geSwgMik7IC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuXG4gICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICBpZiAoZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xudmFyIHNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uIHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG4gIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcbnZhciBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSB7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzOyAvLyBJbnRlcnNlY3Qgd2l0aCB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggKHgsIHkpXG5cbiAgdmFyIHVwID0gMDsgLy8gbGV0IGRvd24gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgIH1cblxuICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIDsgZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9IC8vIGlmKCB5MyA8IHkgKXtcbiAgICAgIC8vIGRvd24rKztcbiAgICAgIC8vIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTsgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcblxuICB2YXIgYW5nbGU7XG5cbiAgaWYgKGRpcmVjdGlvblswXSAhPSBudWxsKSB7XG4gICAgYW5nbGUgPSBNYXRoLmF0YW4oZGlyZWN0aW9uWzFdIC8gZGlyZWN0aW9uWzBdKTtcblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpOyAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3MgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChwYWRkaW5nID4gMCkge1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cblxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG59O1xudmFyIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgY3V0UG9seWdvblBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHNxdWFyZWRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgKiBjb3JuZXJSYWRpdXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlUG9pbnRzLmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHNvdXJjZVV2ID0gYmFzZVBvaW50cy5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VVdiA9IGkgKiA0IC0gMjtcbiAgICB9XG5cbiAgICBkZXN0VXYgPSBpICogNCArIDI7XG4gICAgdmFyIHB4ID0gY2VudGVyWCArIGhhbGZXICogYmFzZVBvaW50c1tpICogNF07XG4gICAgdmFyIHB5ID0gY2VudGVyWSArIGhhbGZIICogYmFzZVBvaW50c1tpICogNCArIDFdO1xuICAgIHZhciBjb3NUaGV0YSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XSAqIGJhc2VQb2ludHNbZGVzdFV2XSAtIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgY3AxeCA9IHB4ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXZdO1xuICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDRdID0gY3AweDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMV0gPSBjcDB5O1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAyXSA9IGNwMXg7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDNdID0gY3AxeTtcbiAgICB2YXIgb3J0aHggPSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgdmFyIG9ydGh5ID0gLWJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgIHZhciBjb3NBbHBoYSA9IG9ydGh4ICogYmFzZVBvaW50c1tkZXN0VXZdICsgb3J0aHkgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgaWYgKGNvc0FscGhhIDwgMCkge1xuICAgICAgb3J0aHggKj0gLTE7XG4gICAgICBvcnRoeSAqPSAtMTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSBjcDB4ICsgb3J0aHggKiBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGN5ID0gY3AweSArIG9ydGh5ICogY29ybmVyUmFkaXVzO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhjeCAtIHgsIDIpICsgTWF0aC5wb3coY3kgLSB5LCAyKTtcblxuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gc3F1YXJlZENvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRQb2x5Z29uUG9pbnRzKTtcbn07XG52YXIgam9pbkxpbmVzID0gZnVuY3Rpb24gam9pbkxpbmVzKGxpbmVTZXQpIHtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuXG4gICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLCBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLCB0cnVlKTtcbiAgICB2ZXJ0aWNlc1tpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn07XG52YXIgZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uIGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpIHtcbiAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbaSAqIDJdO1xuICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgfSAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cbiAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG5cbiAgICB2YXIgb2Zmc2V0WCA9IG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZO1xuICAgIHZhciBvZmZzZXRZID0gLShuZXh0UG9pbnRYIC0gY3VycmVudFBvaW50WCk7IC8vIE5vcm1hbGl6ZVxuXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xudmFyIGludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcbiAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKTtcbiAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG5cbiAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcbiAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG59O1xudmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICB4IC09IGNlbnRlclg7XG4gIHkgLT0gY2VudGVyWTtcbiAgeCAvPSB3aWR0aCAvIDIgKyBwYWRkaW5nO1xuICB5IC89IGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xufTsgLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcblxudmFyIGludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZCA9IFt4MiAtIHgxLCB5MiAtIHkxXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG5cbiAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gIHZhciBiID0gMiAqIChmWzBdICogZFswXSArIGZbMV0gKiBkWzFdKTtcbiAgdmFyIGMgPSBmWzBdICogZlswXSArIGZbMV0gKiBmWzFdIC0gcmFkaXVzICogcmFkaXVzO1xuICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gIHZhciB0TWF4ID0gTWF0aC5tYXgodDEsIHQyKTtcbiAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcblxuICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgfVxuXG4gIGlmICh0TWF4ID49IDAgJiYgdE1heCA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICB9XG5cbiAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgfVxufTtcbnZhciBtaWRPZlRocmVlID0gZnVuY3Rpb24gbWlkT2ZUaHJlZShhLCBiLCBjKSB7XG4gIGlmIChiIDw9IGEgJiYgYSA8PSBjIHx8IGMgPD0gYSAmJiBhIDw9IGIpIHtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmIChhIDw9IGIgJiYgYiA8PSBjIHx8IGMgPD0gYiAmJiBiIDw9IGEpIHtcbiAgICByZXR1cm4gYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYztcbiAgfVxufTsgLy8gKHgxLHkxKT0+KHgyLHkyKSBpbnRlcnNlY3Qgd2l0aCAoeDMseTMpPT4oeDQseTQpXG5cbnZhciBmaW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICB2YXIgZHgxMyA9IHgxIC0geDM7XG4gIHZhciBkeDIxID0geDIgLSB4MTtcbiAgdmFyIGR4NDMgPSB4NCAtIHgzO1xuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuICB2YXIgdWFfdCA9IGR4NDMgKiBkeTEzIC0gZHk0MyAqIGR4MTM7XG4gIHZhciB1Yl90ID0gZHgyMSAqIGR5MTMgLSBkeTIxICogZHgxMztcbiAgdmFyIHVfYiA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG5cbiAgaWYgKHVfYiAhPT0gMCkge1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICB2YXIgZmxwdFRocmVzaG9sZCA9IDAuMDAxO1xuXG4gICAgdmFyIF9taW4gPSAwIC0gZmxwdFRocmVzaG9sZDtcblxuICAgIHZhciBfbWF4ID0gMSArIGZscHRUaHJlc2hvbGQ7XG5cbiAgICBpZiAoX21pbiA8PSB1YSAmJiB1YSA8PSBfbWF4ICYmIF9taW4gPD0gdWIgJiYgdWIgPD0gX21heCkge1xuICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuICAgICAgLy8gQ2hlY2sgZW5kcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDQpID09PSB4NCkge1xuICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICB9IC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG5cblxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4MykgPT09IHgzKSB7XG4gICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgIH0gLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuXG5cbiAgICAgIGlmIChtaWRPZlRocmVlKHgzLCB4NCwgeDIpID09PSB4Mikge1xuICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59OyAvLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nIClcbi8vIGludGVyc2VjdCBhIG5vZGUgcG9seWdvbiAocHRzIHRyYW5zZm9ybWVkKVxuLy9cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclkgKVxuLy8gaW50ZXJzZWN0IHRoZSBwb2ludHMgKG5vIHRyYW5zZm9ybSlcblxudmFyIHBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICB2YXIgZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgZG9UcmFuc2Zvcm0gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKGRvVHJhbnNmb3JtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuXG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBiYXNlUG9pbnRzO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvaW50cy5sZW5ndGggLyAyOyBfaTIrKykge1xuICAgIGN1cnJlbnRYID0gcG9pbnRzW19pMiAqIDJdO1xuICAgIGN1cnJlbnRZID0gcG9pbnRzW19pMiAqIDIgKyAxXTtcblxuICAgIGlmIChfaTIgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWyhfaTIgKyAxKSAqIDJdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbKF9pMiArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciBsaW5lcyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgIH1cblxuICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbGluZXNbYmFzZVBvaW50cy5sZW5ndGggLSAyXSA9IGNwMHg7XG4gICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDFdID0gY3AweTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXNbaSAqIDQgLSAyXSA9IGNwMHg7XG4gICAgICBsaW5lc1tpICogNCAtIDFdID0gY3AweTtcbiAgICB9XG5cbiAgICBsaW5lc1tpICogNF0gPSBjcDF4O1xuICAgIGxpbmVzW2kgKiA0ICsgMV0gPSBjcDF5O1xuICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICBvcnRoeCAqPSAtMTtcbiAgICAgIG9ydGh5ICo9IC0xO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjeCwgY3ksIGNvcm5lclJhZGl1cyk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsaW5lcy5sZW5ndGggLyA0OyBfaTMrKykge1xuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGxpbmVzW19pMyAqIDRdLCBsaW5lc1tfaTMgKiA0ICsgMV0sIGxpbmVzW19pMyAqIDQgKyAyXSwgbGluZXNbX2kzICogNCArIDNdLCBmYWxzZSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAyKSB7XG4gICAgdmFyIGxvd2VzdEludGVyc2VjdGlvbiA9IFtpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB2YXIgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzBdIC0geCwgMikgKyBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMV0gLSB5LCAyKTtcblxuICAgIGZvciAodmFyIF9pNCA9IDE7IF9pNCA8IGludGVyc2VjdGlvbnMubGVuZ3RoIC8gMjsgX2k0KyspIHtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDJdIC0geCwgMikgKyBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXSAtIHksIDIpO1xuXG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IGxvd2VzdFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMF0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDJdO1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMV0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXTtcbiAgICAgICAgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsb3dlc3RJbnRlcnNlY3Rpb247XG4gIH1cblxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG52YXIgc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICB2YXIgZGlzcCA9IFtpbnRlcnNlY3Rpb25bMF0gLSBvZmZzZXRbMF0sIGludGVyc2VjdGlvblsxXSAtIG9mZnNldFsxXV07XG4gIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuXG4gIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cblxuICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIHBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gIHBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuICByZXR1cm4gcG9pbnRzO1xufTtcbnZhciBmaXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbiBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKSB7XG4gIHZhciB4LCB5O1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gIH0gLy8gc3RyZXRjaCBmYWN0b3JzXG5cblxuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgc2lkZXM7IF9pNSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogX2k1XSA9IHBvaW50c1syICogX2k1XSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIF9pNSArIDFdID0gcG9pbnRzWzIgKiBfaTUgKyAxXSAqIHN5O1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuXG4gIGlmIChtaW5ZIDwgLTEpIHtcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBzaWRlczsgX2k2KyspIHtcbiAgICAgIHkgPSBwb2ludHNbMiAqIF9pNiArIDFdID0gcG9pbnRzWzIgKiBfaTYgKyAxXSArICgtMSAtIG1pblkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gIHN0YXJ0QW5nbGUgKz0gcm90YXRpb25SYWRpYW5zO1xuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG4gIHZhciBjdXJyZW50QW5nbGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7IC8vIHhcblxuICAgIHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oLWN1cnJlbnRBbmdsZSk7IC8vIHlcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59OyAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcblxudmFyIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbn07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXNcblxudmFyIGdldFJvdW5kUG9seWdvblJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDEwLCBoZWlnaHQgLyAxMCwgOCk7XG59O1xudmFyIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCA9IGZ1bmN0aW9uIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIHtcbiAgcmV0dXJuIDg7XG59O1xudmFyIGJlemllclB0c1RvUXVhZENvZWZmID0gZnVuY3Rpb24gYmV6aWVyUHRzVG9RdWFkQ29lZmYocDAsIHAxLCBwMikge1xuICByZXR1cm4gW3AwIC0gMiAqIHAxICsgcDIsIDIgKiAocDEgLSBwMCksIHAwXTtcbn07IC8vIGdldCBjdXJ2ZSB3aWR0aCwgaGVpZ2h0LCBhbmQgY29udHJvbCBwb2ludCBwb3NpdGlvbiBvZmZzZXRzIGFzIGEgcGVyY2VudGFnZSBvZiBub2RlIGhlaWdodCAvIHdpZHRoXG5cbnZhciBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGZ1bmN0aW9uIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHRPZmZzZXQ6IE1hdGgubWluKDE1LCAwLjA1ICogaGVpZ2h0KSxcbiAgICB3aWR0aE9mZnNldDogTWF0aC5taW4oMTAwLCAwLjI1ICogd2lkdGgpLFxuICAgIGN0cmxQdE9mZnNldFBjdDogMC4wNVxuICB9O1xufTtcblxudmFyIHBhZ2VSYW5rRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIGRhbXBpbmdGYWN0b3I6IDAuOCxcbiAgcHJlY2lzaW9uOiAwLjAwMDAwMSxcbiAgaXRlcmF0aW9uczogMjAwLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pO1xudmFyIGVsZXNmbiQ3ID0ge1xuICBwYWdlUmFuazogZnVuY3Rpb24gcGFnZVJhbmsob3B0aW9ucykge1xuICAgIHZhciBfcGFnZVJhbmtEZWZhdWx0cyA9IHBhZ2VSYW5rRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgIGRhbXBpbmdGYWN0b3IgPSBfcGFnZVJhbmtEZWZhdWx0cy5kYW1waW5nRmFjdG9yLFxuICAgICAgICBwcmVjaXNpb24gPSBfcGFnZVJhbmtEZWZhdWx0cy5wcmVjaXNpb24sXG4gICAgICAgIGl0ZXJhdGlvbnMgPSBfcGFnZVJhbmtEZWZhdWx0cy5pdGVyYXRpb25zLFxuICAgICAgICB3ZWlnaHQgPSBfcGFnZVJhbmtEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bU5vZGVzU3FkID0gbnVtTm9kZXMgKiBudW1Ob2RlcztcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7IC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cblxuICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkobnVtTm9kZXNTcWQpO1xuICAgIHZhciBjb2x1bW5TdW0gPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlczsgLy8gQ3JlYXRlIG51bGwgbWF0cml4XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbiA9IGkgKiBudW1Ob2RlcyArIGo7XG4gICAgICAgIG1hdHJpeFtuXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbHVtblN1bVtpXSA9IDA7XG4gICAgfSAvLyBOb3csIHByb2Nlc3MgZWRnZXNcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUVkZ2VzOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmNJZCA9IGVkZ2UuZGF0YSgnc291cmNlJyk7XG4gICAgICB2YXIgdGd0SWQgPSBlZGdlLmRhdGEoJ3RhcmdldCcpOyAvLyBEb24ndCBpbmNsdWRlIGxvb3BzIGluIHRoZSBtYXRyaXhcblxuICAgICAgaWYgKHNyY0lkID09PSB0Z3RJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHMgPSBub2Rlcy5pbmRleE9mSWQoc3JjSWQpO1xuICAgICAgdmFyIHQgPSBub2Rlcy5pbmRleE9mSWQodGd0SWQpO1xuICAgICAgdmFyIHcgPSB3ZWlnaHQoZWRnZSk7XG5cbiAgICAgIHZhciBfbiA9IHQgKiBudW1Ob2RlcyArIHM7IC8vIFVwZGF0ZSBtYXRyaXhcblxuXG4gICAgICBtYXRyaXhbX25dICs9IHc7IC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG5cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH0gLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG5cblxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtTm9kZXM7IF9qKyspIHtcbiAgICAgIGlmIChjb2x1bW5TdW1bX2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bU5vZGVzOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbjIgPSBfaTIgKiBudW1Ob2RlcyArIF9qO1xuXG4gICAgICAgICAgbWF0cml4W19uMl0gPSBwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9uMyA9IF9pMyAqIG51bU5vZGVzICsgX2o7XG5cbiAgICAgICAgICBtYXRyaXhbX24zXSA9IG1hdHJpeFtfbjNdIC8gY29sdW1uU3VtW19qXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuXG5cbiAgICB2YXIgZWlnZW52ZWN0b3IgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciB0ZW1wID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgcHJldmlvdXM7IC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgIGVpZ2VudmVjdG9yW19pNF0gPSAxO1xuICAgIH1cblxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAvLyBUZW1wIGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbnVtTm9kZXM7IF9pNSsrKSB7XG4gICAgICAgIHRlbXBbX2k1XSA9IDA7XG4gICAgICB9IC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuXG5cbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG51bU5vZGVzOyBfaTYrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBudW1Ob2RlczsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX240ID0gX2k2ICogbnVtTm9kZXMgKyBfajI7XG5cbiAgICAgICAgICB0ZW1wW19pNl0gKz0gbWF0cml4W19uNF0gKiBlaWdlbnZlY3RvcltfajJdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluUGxhY2VTdW1Ob3JtYWxpemUodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuICAgICAgdGVtcCA9IHByZXZpb3VzO1xuICAgICAgdmFyIGRpZmYgPSAwOyAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcblxuICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgbnVtTm9kZXM7IF9pNysrKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHByZXZpb3VzW19pN10gLSBlaWdlbnZlY3RvcltfaTddO1xuICAgICAgICBkaWZmICs9IGRlbHRhICogZGVsdGE7XG4gICAgICB9IC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcblxuXG4gICAgICBpZiAoZGlmZiA8IHByZWNpc2lvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHJhbms6IGZ1bmN0aW9uIHJhbmsobm9kZSkge1xuICAgICAgICBub2RlID0gY3kuY29sbGVjdGlvbihub2RlKVswXTtcbiAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW25vZGVzLmluZGV4T2Yobm9kZSldO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xuXG59OyAvLyBlbGVzZm5cblxudmFyIGRlZmF1bHRzJDEgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICBhbHBoYTogMFxufSk7XG52YXIgZWxlc2ZuJDggPSB7XG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJDEob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIW9wdGlvbnMuZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07IC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuXG4gICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkge1xuICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhEZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgdmFyIG1heE91dGRlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICAgICAgdmFyIGlkID0gX25vZGUuaWQoKTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cblxuICAgICAgICBvcHRpb25zLnJvb3QgPSBfbm9kZTtcblxuICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgX2N1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPCBfY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgaW5kZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBvdXRkZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIGluZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJDEob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9vcHRpb25zLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcblxuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDsgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgKz0gd2VpZ2h0KGNvbm5FZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDsgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY29taW5nLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgc19pbiArPSB3ZWlnaHQoaW5jb21pbmdbX2kyXSk7XG4gICAgICB9IC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuXG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufTsgLy8gZWxlc2ZuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5cbmVsZXNmbiQ4LmRjID0gZWxlc2ZuJDguZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbiQ4LmRjbiA9IGVsZXNmbiQ4LmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJDguZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyQyID0gZGVmYXVsdHMoe1xuICBoYXJtb25pYzogdHJ1ZSxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJDkgPSB7XG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJDIob3B0aW9ucyksXG4gICAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzLmhhcm1vbmljLFxuICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHtcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSk7IC8vIENvbXB1dGUgY2xvc2VuZXNzIGZvciBldmVyeSBub2RlIGFuZCBmaW5kIHRoZSBtYXhpbXVtIGNsb3NlbmVzc1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgdmFyIG5vZGVfaSA9IG5vZGVzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZShub2RlX2ksIG5vZGVzW2pdKTtcblxuICAgICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm1vbmljKSB7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3MpIHtcbiAgICAgICAgbWF4Q2xvc2VuZXNzID0gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgY2xvc2VuZXNzZXNbbm9kZV9pLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1tub2RlXSAvIG1heENsb3NlbmVzcztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0czIgPSBkZWZhdWx0cyQyKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2RlZmF1bHRzMi5yb290LFxuICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMyLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMyLmRpcmVjdGVkLFxuICAgICAgICBoYXJtb25pYyA9IF9kZWZhdWx0czIuaGFybW9uaWM7XG5cbiAgICByb290ID0gdGhpcy5maWx0ZXIocm9vdClbMF07IC8vIHdlIG5lZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gZXZlcnkgb3RoZXIgbm9kZVxuXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICByb290OiByb290LFxuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKCFuLnNhbWUocm9vdCkpIHtcbiAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG4pO1xuXG4gICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhcm1vbmljID8gdG90YWxEaXN0YW5jZSA6IDEgLyB0b3RhbERpc3RhbmNlO1xuICB9IC8vIGNsb3NlbmVzc0NlbnRyYWxpdHlcblxufTsgLy8gZWxlc2ZuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5cbmVsZXNmbiQ5LmNjID0gZWxlc2ZuJDkuY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbiQ5LmNjbiA9IGVsZXNmbiQ5LmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJDkuY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyQzID0gZGVmYXVsdHMoe1xuICB3ZWlnaHQ6IG51bGwsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGEgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkMyhvcHRpb25zKSxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICB2YXIgd2VpZ2h0ZWQgPSB3ZWlnaHQgIT0gbnVsbDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIHN0YXJ0aW5nXG5cbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBfQyA9IHt9O1xuICAgIHZhciBtYXggPSAwO1xuICAgIHZhciBDID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgX0Nba2V5XSA9IHZhbDtcblxuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgfVxuICAgIH07IC8vIEEgY29udGFpbnMgdGhlIG5laWdoYm9yaG9vZHMgb2YgZXZlcnkgbm9kZVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdiA9IFZbaV07XG4gICAgICB2YXIgdmlkID0gdi5pZCgpO1xuXG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgQVt2aWRdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBW3ZpZF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH1cblxuICAgICAgQy5zZXQodmlkLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChzKSB7XG4gICAgICB2YXIgc2lkID0gVltzXS5pZCgpO1xuICAgICAgdmFyIFMgPSBbXTsgLy8gc3RhY2tcblxuICAgICAgdmFyIFAgPSB7fTtcbiAgICAgIHZhciBnID0ge307XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICB9KTsgLy8gcXVldWVcbiAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBWLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3ZpZCA9IFZbX2ldLmlkKCk7XG5cbiAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuXG4gICAgICBkW3NpZF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEucHVzaChzaWQpO1xuXG4gICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuXG4gICAgICAgIFMucHVzaChfdik7XG5cbiAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBBW192XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBW192XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoX3YpO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICB3ID0gdy5pZCgpO1xuXG4gICAgICAgICAgICBpZiAoZFt3XSA+IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3ddID0gZFtfdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnW3ddID0gMDtcbiAgICAgICAgICAgICAgUFt3XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZFt3XSA9PSBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW192XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IEFbX3ZdLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgdmFyIF93ID0gQVtfdl1bX2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRbX3ddID09IGRbX3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW193XSA9IGdbX3ddICsgZ1tfdl07XG5cbiAgICAgICAgICAgICAgUFtfd10ucHVzaChfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0ge307XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFYubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBlW1ZbX2kyXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF93MiA9IFMucG9wKCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuXG4gICAgICAgICAgaWYgKF93MiAhPSBWW3NdLmlkKCkpIHtcbiAgICAgICAgICAgIEMuc2V0KF93MiwgQy5nZXQoX3cyKSArIGVbX3cyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgX2xvb3Aocyk7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgIH0sXG4gICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpIC8gbWF4O1xuICAgICAgfVxuICAgIH07IC8vIGFsaWFzXG5cbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG59OyAvLyBlbGVzZm5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcblxuZWxlc2ZuJGEuYmMgPSBlbGVzZm4kYS5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxudmFyIGRlZmF1bHRzJDQgPSBkZWZhdWx0cyh7XG4gIGV4cGFuZEZhY3RvcjogMixcbiAgLy8gYWZmZWN0cyB0aW1lIG9mIGNvbXB1dGF0aW9uIGFuZCBjbHVzdGVyIGdyYW51bGFyaXR5IHRvIHNvbWUgZXh0ZW50OiBNICogTVxuICBpbmZsYXRlRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgKHRoZSBncmVhdGVyIHRoZSB2YWx1ZSwgdGhlIG1vcmUgY2x1c3RlcnMpOiBNKGksaikgLyBFKGopXG4gIG11bHRGYWN0b3I6IDEsXG4gIC8vIG9wdGlvbmFsIHNlbGYgbG9vcHMgZm9yIGVhY2ggbm9kZS4gVXNlIGEgbmV1dHJhbCB2YWx1ZSB0byBpbXByb3ZlIGNsdXN0ZXIgY29tcHV0YXRpb25zLlxuICBtYXhJdGVyYXRpb25zOiAyMCxcbiAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgTUNMIGFsZ29yaXRobSBpbiBhIHNpbmdsZSBydW5cbiAgYXR0cmlidXRlczogWy8vIGF0dHJpYnV0ZXMvZmVhdHVyZXMgdXNlZCB0byBncm91cCBub2RlcywgaWUuIHNpbWlsYXJpdHkgdmFsdWVzIGJldHdlZW4gbm9kZXNcbiAgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfV1cbn0pO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkNChvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KGVkZ2UsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSBhdHRyaWJ1dGVzW2ldKGVkZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxudmFyIGFkZExvb3BzID0gZnVuY3Rpb24gYWRkTG9vcHMoTSwgbiwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgTVtpICogbiArIGldID0gdmFsO1xuICB9XG59O1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKE0sIG4pIHtcbiAgdmFyIHN1bTtcblxuICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBuOyBjb2wrKykge1xuICAgIHN1bSA9IDA7XG5cbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuOyByb3crKykge1xuICAgICAgc3VtICs9IE1bcm93ICogbiArIGNvbF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3JvdyA9IDA7IF9yb3cgPCBuOyBfcm93KyspIHtcbiAgICAgIE1bX3JvdyAqIG4gKyBjb2xdID0gTVtfcm93ICogbiArIGNvbF0gLyBzdW07XG4gICAgfVxuICB9XG59OyAvLyBUT0RPOiBibG9ja2VkIG1hdHJpeCBtdWx0aXBsaWNhdGlvbj9cblxuXG52YXIgbW11bHQgPSBmdW5jdGlvbiBtbXVsdChBLCBCLCBuKSB7XG4gIHZhciBDID0gbmV3IEFycmF5KG4gKiBuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBDW2kgKiBuICsgal0gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBDW2kgKiBuICsgX2pdICs9IEFbaSAqIG4gKyBrXSAqIEJbayAqIG4gKyBfal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKE0sIG4sIGV4cGFuZEZhY3RvclxuLyoqIHBvd2VyICoqL1xuKSB7XG4gIHZhciBfTSA9IE0uc2xpY2UoMCk7XG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBleHBhbmRGYWN0b3I7IHArKykge1xuICAgIE0gPSBtbXVsdChNLCBfTSwgbik7XG4gIH1cblxuICByZXR1cm4gTTtcbn07XG5cbnZhciBpbmZsYXRlID0gZnVuY3Rpb24gaW5mbGF0ZShNLCBuLCBpbmZsYXRlRmFjdG9yXG4vKiogciAqKi9cbikge1xuICB2YXIgX00gPSBuZXcgQXJyYXkobiAqIG4pOyAvLyBNKGksaikgXiBpbmZsYXRlUG93ZXJcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbiAqIG47IGkrKykge1xuICAgIF9NW2ldID0gTWF0aC5wb3coTVtpXSwgaW5mbGF0ZUZhY3Rvcik7XG4gIH1cblxuICBub3JtYWxpemUoX00sIG4pO1xuICByZXR1cm4gX007XG59O1xuXG52YXIgaGFzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgcm91bmRGYWN0b3IpIHtcbiAgLy8gQ2hlY2sgdGhhdCBib3RoIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgKGksailcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgdmFyIHYxID0gTWF0aC5yb3VuZChNW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpOyAvLyB0cnVuY2F0ZSB0byAncm91bmRGYWN0b3InIGRlY2ltYWwgcGxhY2VzXG5cbiAgICB2YXIgdjIgPSBNYXRoLnJvdW5kKF9NW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpO1xuXG4gICAgaWYgKHYxICE9PSB2Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihNLCBuLCBub2RlcywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY2x1c3RlciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIC8vIFJvdy13aXNlIGF0dHJhY3RvcnMgYW5kIGVsZW1lbnRzIHRoYXQgdGhleSBhdHRyYWN0IGJlbG9uZyBpbiBzYW1lIGNsdXN0ZXJcbiAgICAgIGlmIChNYXRoLnJvdW5kKE1baSAqIG4gKyBqXSAqIDEwMDApIC8gMTAwMCA+IDApIHtcbiAgICAgICAgY2x1c3Rlci5wdXNoKG5vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2x1c3Rlci5sZW5ndGggIT09IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goY3kuY29sbGVjdGlvbihjbHVzdGVyKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGlzRHVwbGljYXRlID0gZnVuY3Rpb24gaXNEdXBsaWNhdGUoYzEsIGMyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYzEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWMyW2ldIHx8IGMxW2ldLmlkKCkgIT09IGMyW2ldLmlkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgIT0gaiAmJiBpc0R1cGxpY2F0ZShjbHVzdGVyc1tpXSwgY2x1c3RlcnNbal0pKSB7XG4gICAgICAgIGNsdXN0ZXJzLnNwbGljZShqLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgbWFya292Q2x1c3RlcmluZyA9IGZ1bmN0aW9uIG1hcmtvdkNsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06XG5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBHZW5lcmF0ZSBzdG9jaGFzdGljIG1hdHJpeCBNIGZyb20gaW5wdXQgZ3JhcGggRyAoc2hvdWxkIGJlIHN5bW1ldHJpYy91bmRpcmVjdGVkKVxuXG5cbiAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBuMiA9IG4gKiBuO1xuXG4gIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICAgIF9NO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgIE1bX2ldID0gMDtcbiAgfVxuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eShlZGdlLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIE1bX2kyICogbiArIGpdICs9IHNpbTsgLy8gRyBzaG91bGQgYmUgc3ltbWV0cmljIGFuZCB1bmRpcmVjdGVkXG5cbiAgICBNW2ogKiBuICsgX2kyXSArPSBzaW07XG4gIH0gLy8gQmVnaW4gTWFya292IGNsdXN0ZXIgYWxnb3JpdGhtXG4gIC8vIFN0ZXAgMTogQWRkIHNlbGYgbG9vcHMgdG8gZWFjaCBub2RlLCBpZS4gYWRkIG11bHRGYWN0b3IgdG8gbWF0cml4IGRpYWdvbmFsXG5cblxuICBhZGRMb29wcyhNLCBuLCBvcHRzLm11bHRGYWN0b3IpOyAvLyBTdGVwIDI6IE0gPSBub3JtYWxpemUoIE0gKTtcblxuICBub3JtYWxpemUoTSwgbik7XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzpcblxuICAgIF9NID0gZXhwYW5kKE0sIG4sIG9wdHMuZXhwYW5kRmFjdG9yKTsgLy8gU3RlcCA0OlxuXG4gICAgTSA9IGluZmxhdGUoX00sIG4sIG9wdHMuaW5mbGF0ZUZhY3Rvcik7IC8vIFN0ZXAgNTogY2hlY2sgdG8gc2VlIGlmIH5zdGVhZHkgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZFxuXG4gICAgaWYgKCFoYXNDb252ZXJnZWQoTSwgX00sIG4yLCA0KSkge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9IC8vIEJ1aWxkIGNsdXN0ZXJzIGZyb20gbWF0cml4XG5cblxuICB2YXIgY2x1c3RlcnMgPSBhc3NpZ24oTSwgbiwgbm9kZXMsIGN5KTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBjbHVzdGVycyBkdWUgdG8gc3ltbWV0cnkgb2YgZ3JhcGggYW5kIE0gbWF0cml4XG5cbiAgY2x1c3RlcnMgPSByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIG1hcmtvdkNsdXN0ZXJpbmckMSA9IHtcbiAgbWFya292Q2x1c3RlcmluZzogbWFya292Q2x1c3RlcmluZyxcbiAgbWNsOiBtYXJrb3ZDbHVzdGVyaW5nXG59O1xuXG4vLyBDb21tb24gZGlzdGFuY2UgbWV0cmljcyBmb3IgY2x1c3RlcmluZyBhbGdvcml0aG1zXG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgYWJzRGlmZiA9IGZ1bmN0aW9uIGFic0RpZmYocCwgcSkge1xuICByZXR1cm4gTWF0aC5hYnMocSAtIHApO1xufTtcblxudmFyIGFkZEFic0RpZmYgPSBmdW5jdGlvbiBhZGRBYnNEaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIGFic0RpZmYocCwgcSk7XG59O1xuXG52YXIgYWRkU3F1YXJlZERpZmYgPSBmdW5jdGlvbiBhZGRTcXVhcmVkRGlmZih0b3RhbCwgcCwgcSkge1xuICByZXR1cm4gdG90YWwgKyBNYXRoLnBvdyhxIC0gcCwgMik7XG59O1xuXG52YXIgc3FydCA9IGZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHgpO1xufTtcblxudmFyIG1heEFic0RpZmYgPSBmdW5jdGlvbiBtYXhBYnNEaWZmKGN1cnJlbnRNYXgsIHAsIHEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRNYXgsIGFic0RpZmYocCwgcSkpO1xufTtcblxudmFyIGdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCBpbml0LCB2aXNpdCkge1xuICB2YXIgcG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogaWRlbnRpdHk7XG4gIHZhciByZXQgPSBpbml0O1xuICB2YXIgcCwgcTtcblxuICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBsZW5ndGg7IGRpbSsrKSB7XG4gICAgcCA9IGdldFAoZGltKTtcbiAgICBxID0gZ2V0UShkaW0pO1xuICAgIHJldCA9IHZpc2l0KHJldCwgcCwgcSk7XG4gIH1cblxuICByZXR1cm4gcG9zdChyZXQpO1xufTtcblxudmFyIGRpc3RhbmNlcyA9IHtcbiAgZXVjbGlkZWFuOiBmdW5jdGlvbiBldWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZiwgc3FydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBzaW5nbGUgYXR0ciBjYXNlLCBtb3JlIGVmZmljaWVudCB0byBhdm9pZCBzcXJ0XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgICB9XG4gIH0sXG4gIHNxdWFyZWRFdWNsaWRlYW46IGZ1bmN0aW9uIHNxdWFyZWRFdWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYpO1xuICB9LFxuICBtYW5oYXR0YW46IGZ1bmN0aW9uIG1hbmhhdHRhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgobGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgLUluZmluaXR5LCBtYXhBYnNEaWZmKTtcbiAgfVxufTsgLy8gaW4gY2FzZSB0aGUgdXNlciBhY2NpZGVudGFsbHkgZG9lc24ndCB1c2UgY2FtZWwgY2FzZVxuXG5kaXN0YW5jZXNbJ3NxdWFyZWQtZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmRpc3RhbmNlc1snc3F1YXJlZGV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG5mdW5jdGlvbiBjbHVzdGVyaW5nRGlzdGFuY2UgKG1ldGhvZCwgbGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpIHtcbiAgdmFyIGltcGw7XG5cbiAgaWYgKGZuKG1ldGhvZCkpIHtcbiAgICBpbXBsID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGltcGwgPSBkaXN0YW5jZXNbbWV0aG9kXSB8fCBkaXN0YW5jZXMuZXVjbGlkZWFuO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbihtZXRob2QpKSB7XG4gICAgcmV0dXJuIGltcGwobm9kZVAsIG5vZGVRKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW1wbChsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzJDUgPSBkZWZhdWx0cyh7XG4gIGs6IDIsXG4gIG06IDIsXG4gIHNlbnNpdGl2aXR5VGhyZXNob2xkOiAwLjAwMDEsXG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgbWF4SXRlcmF0aW9uczogMTAsXG4gIGF0dHJpYnV0ZXM6IFtdLFxuICB0ZXN0TW9kZTogZmFsc2UsXG4gIHRlc3RDZW50cm9pZHM6IG51bGxcbn0pO1xuXG52YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyQ1KG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG52YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QodHlwZSwgbm9kZSwgY2VudHJvaWQsIGF0dHJpYnV0ZXMsIG1vZGUpIHtcbiAgdmFyIG5vTm9kZVAgPSBtb2RlICE9PSAna01lZG9pZHMnO1xuICB2YXIgZ2V0UCA9IG5vTm9kZVAgPyBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBjZW50cm9pZFtpXTtcbiAgfSA6IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0oY2VudHJvaWQpO1xuICB9O1xuXG4gIHZhciBnZXRRID0gZnVuY3Rpb24gZ2V0UShpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obm9kZSk7XG4gIH07XG5cbiAgdmFyIG5vZGVQID0gY2VudHJvaWQ7XG4gIHZhciBub2RlUSA9IG5vZGU7XG4gIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG59O1xuXG52YXIgcmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBrLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuZGltID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gIHZhciBtaW4gPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBtYXggPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBjZW50cm9pZHMgPSBuZXcgQXJyYXkoayk7XG4gIHZhciBjZW50cm9pZCA9IG51bGw7IC8vIEZpbmQgbWluLCBtYXggdmFsdWVzIGZvciBlYWNoIGF0dHJpYnV0ZSBkaW1lbnNpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5kaW07IGkrKykge1xuICAgIG1pbltpXSA9IG5vZGVzLm1pbihhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICBtYXhbaV0gPSBub2Rlcy5tYXgoYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gIH0gLy8gQnVpbGQgayBjZW50cm9pZHMsIGVhY2ggcmVwcmVzZW50ZWQgYXMgYW4gbi1kaW0gZmVhdHVyZSB2ZWN0b3JcblxuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgY2VudHJvaWQgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZGltOyBfaSsrKSB7XG4gICAgICBjZW50cm9pZFtfaV0gPSBNYXRoLnJhbmRvbSgpICogKG1heFtfaV0gLSBtaW5bX2ldKSArIG1pbltfaV07IC8vIHJhbmRvbSBpbml0aWFsIHZhbHVlXG4gICAgfVxuXG4gICAgY2VudHJvaWRzW2NdID0gY2VudHJvaWQ7XG4gIH1cblxuICByZXR1cm4gY2VudHJvaWRzO1xufTtcblxudmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBkaXN0YW5jZSwgYXR0cmlidXRlcywgdHlwZSkge1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzdCA9IGdldERpc3QoZGlzdGFuY2UsIG5vZGUsIGNlbnRyb2lkc1tpXSwgYXR0cmlidXRlcywgdHlwZSk7XG5cbiAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgbWluID0gZGlzdDtcbiAgICAgIGluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG52YXIgYnVpbGRDbHVzdGVyID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyKGNlbnRyb2lkLCBub2RlcywgYXNzaWdubWVudCkge1xuICB2YXIgY2x1c3RlciA9IFtdO1xuICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIG5vZGUgPSBub2Rlc1tuXTtcblxuICAgIGlmIChhc3NpZ25tZW50W25vZGUuaWQoKV0gPT09IGNlbnRyb2lkKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiTm9kZSBcIiArIG5vZGUuaWQoKSArIFwiIGlzIGFzc29jaWF0ZWQgd2l0aCBtZWRvaWQgIzogXCIgKyBtKTtcbiAgICAgIGNsdXN0ZXIucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3Rlcjtcbn07XG5cbnZhciBoYXZlVmFsdWVzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZVZhbHVlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIHJldHVybiBNYXRoLmFicyh2MiAtIHYxKSA8PSBzZW5zaXRpdml0eVRocmVzaG9sZDtcbn07XG5cbnZhciBoYXZlTWF0cmljZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlTWF0cmljZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB2MVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2MVtpXVtqXSAtIHYyW2ldW2pdKTtcblxuICAgICAgaWYgKGRpZmYgPiBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2VlbkJlZm9yZSA9IGZ1bmN0aW9uIHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChub2RlID09PSBtZWRvaWRzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciByYW5kb21NZWRvaWRzID0gZnVuY3Rpb24gcmFuZG9tTWVkb2lkcyhub2Rlcywgaykge1xuICB2YXIgbWVkb2lkcyA9IG5ldyBBcnJheShrKTsgLy8gRm9yIHNtYWxsIGRhdGEgc2V0cywgdGhlIHByb2JhYmlsaXR5IG9mIG1lZG9pZCBjb25mbGljdCBpcyBncmVhdGVyLFxuICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gb3IgY2hvc2UgdGhpcyBub2RlIGJlZm9yZS5cblxuICBpZiAobm9kZXMubGVuZ3RoIDwgNTApIHtcbiAgICAvLyBSYW5kb21seSBzZWxlY3QgayBtZWRvaWRzIGZyb20gdGhlIG4gbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTsgLy8gSWYgd2UndmUgYWxyZWFkeSBjaG9zZW4gdGhpcyBub2RlIHRvIGJlIGEgbWVkb2lkLCBkb24ndCBjaG9vc2UgaXQgYWdhaW4gKGZvciBzbWFsbCBkYXRhIHNldHMpLlxuICAgICAgLy8gSW5zdGVhZCBjaG9vc2UgYSBkaWZmZXJlbnQgcmFuZG9tIG5vZGUuXG5cbiAgICAgIHdoaWxlIChzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIGkpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICAgIH1cblxuICAgICAgbWVkb2lkc1tpXSA9IG5vZGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbGF0aXZlbHkgbGFyZ2UgZGF0YSBzZXQsIHNvIHByZXR0eSBzYWZlIHRvIG5vdCBjaGVjayBhbmQganVzdCBzZWxlY3QgcmFuZG9tIG5vZGVzXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgazsgX2kyKyspIHtcbiAgICAgIG1lZG9pZHNbX2kyXSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRvaWRzO1xufTtcblxudmFyIGZpbmRDb3N0ID0gZnVuY3Rpb24gZmluZENvc3QocG90ZW50aWFsTmV3TWVkb2lkLCBjbHVzdGVyLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBjb3N0ID0gMDtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXIubGVuZ3RoOyBuKyspIHtcbiAgICBjb3N0ICs9IGdldERpc3QoJ21hbmhhdHRhbicsIGNsdXN0ZXJbbl0sIHBvdGVudGlhbE5ld01lZG9pZCwgYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gIH1cblxuICByZXR1cm4gY29zdDtcbn07XG5cbnZhciBrTWVhbnMgPSBmdW5jdGlvbiBrTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06ICMgb2YgY2x1c3RlcnMsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpOyAvLyBCZWdpbiBrLW1lYW5zIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY2VudHJvaWRzOyAvLyBTdGVwIDE6IEluaXRpYWxpemUgY2VudHJvaWQgcG9zaXRpb25zXG5cbiAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgY2VudHJvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gIH1cblxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcblxuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgY2VudHJvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuXG4gICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWFucycpO1xuICAgIH0gLy8gU3RlcCAzOiBGb3IgZWFjaCBvZiB0aGUgayBjbHVzdGVycywgdXBkYXRlIGl0cyBjZW50cm9pZFxuXG5cbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9wdHMuazsgYysrKSB7XG4gICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgY2x1c3RlclxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIoYywgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFVwZGF0ZSBjZW50cm9pZHMgYnkgY2FsY3VsYXRpbmcgYXZnIG9mIGFsbCBub2RlcyB3aXRoaW4gdGhlIGNsdXN0ZXIuXG5cblxuICAgICAgdmFyIG5kaW0gPSBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2NdOyAvLyBbIGRpbV8xLCBkaW1fMiwgZGltXzMsIC4uLiAsIGRpbV9uIF1cblxuICAgICAgdmFyIG5ld0NlbnRyb2lkID0gbmV3IEFycmF5KG5kaW0pO1xuICAgICAgdmFyIHN1bSA9IG5ldyBBcnJheShuZGltKTtcblxuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBuZGltOyBkKyspIHtcbiAgICAgICAgc3VtW2RdID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBjbHVzdGVyW2ldO1xuICAgICAgICAgIHN1bVtkXSArPSBvcHRzLmF0dHJpYnV0ZXNbZF0obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdDZW50cm9pZFtkXSA9IHN1bVtkXSAvIGNsdXN0ZXIubGVuZ3RoOyAvLyBDaGVjayB0byBzZWUgaWYgYWxnb3JpdGhtIGhhcyBjb252ZXJnZWQsIGkuZS4gd2hlbiBjZW50cm9pZHMgbm8gbG9uZ2VyIGNoYW5nZVxuXG4gICAgICAgIGlmICghaGF2ZVZhbHVlc0NvbnZlcmdlZChuZXdDZW50cm9pZFtkXSwgY2VudHJvaWRbZF0sIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzW2NdID0gbmV3Q2VudHJvaWQ7XG4gICAgICBjbHVzdGVyc1tjXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGtNZWRvaWRzID0gZnVuY3Rpb24ga01lZG9pZHMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMShvcHRpb25zKTsgLy8gQmVnaW4gay1tZWRvaWRzIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgbWVkb2lkcztcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGN1ckNvc3Q7XG4gIHZhciBtaW5Db3N0cyA9IG5ldyBBcnJheShvcHRzLmspOyAvLyBtaW5pbXVtIGNvc3QgY29uZmlndXJhdGlvbiBmb3IgZWFjaCBjbHVzdGVyXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBrIG1lZG9pZHNcblxuICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykgOyBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICBtZWRvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gIH1cblxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcblxuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgbWVkb2lkXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcblxuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgbWVkb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICB9XG5cbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzogRm9yIGVhY2ggbWVkb2lkIG0sIGFuZCBmb3IgZWFjaCBub2RlIGFzc2NpYXRlZCB3aXRoIG1lZGlvZCBtLFxuICAgIC8vIHNlbGVjdCB0aGUgbm9kZSB3aXRoIHRoZSBsb3dlc3QgY29uZmlndXJhdGlvbiBjb3N0IGFzIG5ldyBtZWRvaWQuXG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lZG9pZHMubGVuZ3RoOyBtKyspIHtcbiAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBtZWRvaWRcbiAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKG0sIG5vZGVzLCBhc3NpZ25tZW50KTtcblxuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBtaW5Db3N0c1ttXSA9IGZpbmRDb3N0KG1lZG9pZHNbbV0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7IC8vIG9yaWdpbmFsIGNvc3RcbiAgICAgIC8vIFNlbGVjdCBkaWZmZXJlbnQgbWVkb2lkIGlmIGl0cyBjb25maWd1cmF0aW9uIGhhcyB0aGUgbG93ZXN0IGNvc3RcblxuICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXIubGVuZ3RoOyBfbisrKSB7XG4gICAgICAgIGN1ckNvc3QgPSBmaW5kQ29zdChjbHVzdGVyW19uXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICBpZiAoY3VyQ29zdCA8IG1pbkNvc3RzW21dKSB7XG4gICAgICAgICAgbWluQ29zdHNbbV0gPSBjdXJDb3N0O1xuICAgICAgICAgIG1lZG9pZHNbbV0gPSBjbHVzdGVyW19uXTtcbiAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbHVzdGVyc1ttXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIHVwZGF0ZUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpIHtcbiAgdmFyIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgICB3ZWlnaHRbbl1bY10gPSBNYXRoLnBvdyhVW25dW2NdLCBvcHRzLm0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBjZW50cm9pZHMubGVuZ3RoOyBfYysrKSB7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIG51bWVyYXRvciA9IDA7XG4gICAgICBkZW5vbWluYXRvciA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG5vZGVzLmxlbmd0aDsgX24yKyspIHtcbiAgICAgICAgbnVtZXJhdG9yICs9IHdlaWdodFtfbjJdW19jXSAqIG9wdHMuYXR0cmlidXRlc1tkaW1dKG5vZGVzW19uMl0pO1xuICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRbX24yXVtfY107XG4gICAgICB9XG5cbiAgICAgIGNlbnRyb2lkc1tfY11bZGltXSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVwZGF0ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbiB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKSB7XG4gIC8vIFNhdmUgcHJldmlvdXMgc3RlcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IFUubGVuZ3RoOyBpKyspIHtcbiAgICBfVVtpXSA9IFVbaV0uc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBzdW0sIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIHZhciBwb3cgPSAyIC8gKG9wdHMubSAtIDEpO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjZW50cm9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgLy8gYWdhaW5zdCBhbGwgb3RoZXIgY2VudHJvaWRzXG4gICAgICAgIG51bWVyYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1tjXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgIGRlbm9taW5hdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2tdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgc3VtICs9IE1hdGgucG93KG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCBwb3cpO1xuICAgICAgfVxuXG4gICAgICBVW25dW2NdID0gMSAvIHN1bTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBhc3NpZ24kMSA9IGZ1bmN0aW9uIGFzc2lnbihub2RlcywgVSwgb3B0cywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgIGNsdXN0ZXJzW2NdID0gW107XG4gIH1cblxuICB2YXIgbWF4O1xuICB2YXIgaW5kZXg7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBVLmxlbmd0aDsgbisrKSB7XG4gICAgLy8gZm9yIGVhY2ggbm9kZSAoVSBpcyBOIHggQyBtYXRyaXgpXG4gICAgbWF4ID0gLUluZmluaXR5O1xuICAgIGluZGV4ID0gLTE7IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoZSBub2RlIGlzIG1vc3QgbGlrZWx5IHRvIGJlbG9uZyBpblxuXG4gICAgZm9yICh2YXIgX2MyID0gMDsgX2MyIDwgVVswXS5sZW5ndGg7IF9jMisrKSB7XG4gICAgICBpZiAoVVtuXVtfYzJdID4gbWF4KSB7XG4gICAgICAgIG1heCA9IFVbbl1bX2MyXTtcbiAgICAgICAgaW5kZXggPSBfYzI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2x1c3RlcnNbaW5kZXhdLnB1c2gobm9kZXNbbl0pO1xuICB9IC8vIFR1cm4gZXZlcnkgYXJyYXkgaW50byBhIGNvbGxlY3Rpb24gb2Ygbm9kZXNcblxuXG4gIGZvciAodmFyIF9jMyA9IDA7IF9jMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2MzKyspIHtcbiAgICBjbHVzdGVyc1tfYzNdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tfYzNdKTtcbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBmdXp6eUNNZWFucyA9IGZ1bmN0aW9uIGZ1enp5Q01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpOyAvLyBCZWdpbiBmdXp6eSBjLW1lYW5zIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycztcbiAgdmFyIGNlbnRyb2lkcztcbiAgdmFyIFU7XG5cbiAgdmFyIF9VO1xuXG4gIHZhciB3ZWlnaHQ7IC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBsZXRpYWJsZXMuXG5cbiAgX1UgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgX1VbaV0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuXG4gIFUgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgVVtfaTNdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIH1cblxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0cy5rOyBqKyspIHtcbiAgICAgIFVbX2k0XVtqXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0b3RhbCArPSBVW19pNF1bal07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG9wdHMuazsgX2orKykge1xuICAgICAgVVtfaTRdW19qXSA9IFVbX2k0XVtfal0gLyB0b3RhbDtcbiAgICB9XG4gIH1cblxuICBjZW50cm9pZHMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBvcHRzLms7IF9pNSsrKSB7XG4gICAgY2VudHJvaWRzW19pNV0gPSBuZXcgQXJyYXkob3B0cy5hdHRyaWJ1dGVzLmxlbmd0aCk7XG4gIH1cblxuICB3ZWlnaHQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgd2VpZ2h0W19pNl0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfSAvLyBlbmQgaW5pdCBGQ01cblxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMjogQ2FsY3VsYXRlIHRoZSBjZW50cm9pZHMgZm9yIGVhY2ggc3RlcC5cblxuICAgIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpOyAvLyBTdGVwIDM6IFVwZGF0ZSB0aGUgcGFydGl0aW9uIG1hdHJpeCBVLlxuXG4gICAgdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cyk7IC8vIFN0ZXAgNDogQ2hlY2sgZm9yIGNvbnZlcmdlbmNlLlxuXG4gICAgaWYgKCFoYXZlTWF0cmljZXNDb252ZXJnZWQoVSwgX1UsIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH0gLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzIHdpdGggaGlnaGVzdCBwcm9iYWJpbGl0eS5cblxuXG4gIGNsdXN0ZXJzID0gYXNzaWduJDEobm9kZXMsIFUsIG9wdHMsIGN5KTtcbiAgcmV0dXJuIHtcbiAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgZGVncmVlT2ZNZW1iZXJzaGlwOiBVXG4gIH07XG59O1xuXG52YXIga0NsdXN0ZXJpbmcgPSB7XG4gIGtNZWFuczoga01lYW5zLFxuICBrTWVkb2lkczoga01lZG9pZHMsXG4gIGZ1enp5Q01lYW5zOiBmdXp6eUNNZWFucyxcbiAgZmNtOiBmdXp6eUNNZWFuc1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG52YXIgZGVmYXVsdHMkNiA9IGRlZmF1bHRzKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBub2Rlc1xuICBsaW5rYWdlOiAnbWluJyxcbiAgLy8gbGlua2FnZSBjcml0ZXJpb24gOiBob3cgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNsdXN0ZXJzIG9mIG5vZGVzXG4gIG1vZGU6ICd0aHJlc2hvbGQnLFxuICAvLyBtb2RlOid0aHJlc2hvbGQnID0+IGNsdXN0ZXJzIG11c3QgYmUgdGhyZXNob2xkIGRpc3RhbmNlIGFwYXJ0XG4gIHRocmVzaG9sZDogSW5maW5pdHksXG4gIC8vIHRoZSBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgLy8gbW9kZTonZGVuZHJvZ3JhbScgPT4gdGhlIG5vZGVzIGFyZSBvcmdhbmlzZWQgYXMgbGVhdmVzIGluIGEgdHJlZSAoc2libGluZ3MgYXJlIGNsb3NlKSwgbWVyZ2luZyBtYWtlcyBjbHVzdGVyc1xuICBhZGREZW5kcm9ncmFtOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBhZGQgdGhlIGRlbmRyb2dyYW0gdG8gdGhlIGdyYXBoIGZvciB2aXpcbiAgZGVuZHJvZ3JhbURlcHRoOiAwLFxuICAvLyBkZXB0aCBhdCB3aGljaCBkZW5kcm9ncmFtIGJyYW5jaGVzIGFyZSBtZXJnZWQgaW50byB0aGUgcmV0dXJuZWQgY2x1c3RlcnNcbiAgYXR0cmlidXRlczogW10gLy8gYXJyYXkgb2YgYXR0ciBmdW5jdGlvbnNcblxufSk7XG52YXIgbGlua2FnZUFsaWFzZXMgPSB7XG4gICdzaW5nbGUnOiAnbWluJyxcbiAgJ2NvbXBsZXRlJzogJ21heCdcbn07XG5cbnZhciBzZXRPcHRpb25zJDIgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBkZWZhdWx0cyQ2KG9wdGlvbnMpO1xuICB2YXIgcHJlZmVycmVkQWxpYXMgPSBsaW5rYWdlQWxpYXNlc1tvcHRzLmxpbmthZ2VdO1xuXG4gIGlmIChwcmVmZXJyZWRBbGlhcyAhPSBudWxsKSB7XG4gICAgb3B0cy5saW5rYWdlID0gcHJlZmVycmVkQWxpYXM7XG4gIH1cblxuICByZXR1cm4gb3B0cztcbn07XG5cbnZhciBtZXJnZUNsb3Nlc3QgPSBmdW5jdGlvbiBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cykge1xuICAvLyBGaW5kIHR3byBjbG9zZXN0IGNsdXN0ZXJzIGZyb20gY2FjaGVkIG1pbnNcbiAgdmFyIG1pbktleSA9IDA7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgdmFyIGRpc3Q7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjbHVzdGVyc1tpXS5rZXk7XG4gICAgdmFyIF9kaXN0ID0gZGlzdHNba2V5XVttaW5zW2tleV1dO1xuXG4gICAgaWYgKF9kaXN0IDwgbWluKSB7XG4gICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICBtaW4gPSBfZGlzdDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tb2RlID09PSAndGhyZXNob2xkJyAmJiBtaW4gPj0gb3B0cy50aHJlc2hvbGQgfHwgb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgJiYgY2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGMxID0gaW5kZXhbbWluS2V5XTtcbiAgdmFyIGMyID0gaW5kZXhbbWluc1ttaW5LZXldXTtcbiAgdmFyIG1lcmdlZDsgLy8gTWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcblxuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICBsZWZ0OiBjMSxcbiAgICAgIHJpZ2h0OiBjMixcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICB2YWx1ZTogYzEudmFsdWUuY29uY2F0KGMyLnZhbHVlKSxcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfVxuXG4gIGNsdXN0ZXJzW2MxLmluZGV4XSA9IG1lcmdlZDtcbiAgY2x1c3RlcnMuc3BsaWNlKGMyLmluZGV4LCAxKTtcbiAgaW5kZXhbYzEua2V5XSA9IG1lcmdlZDsgLy8gVXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBjbHVzdGVycy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgY3VyID0gY2x1c3RlcnNbX2ldO1xuXG4gICAgaWYgKGMxLmtleSA9PT0gY3VyLmtleSkge1xuICAgICAgZGlzdCA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWluJykge1xuICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG5cbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldID4gZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21heCcpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuXG4gICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA8IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtZWFuJykge1xuICAgICAgZGlzdCA9IChkaXN0c1tjMS5rZXldW2N1ci5rZXldICogYzEuc2l6ZSArIGRpc3RzW2MyLmtleV1bY3VyLmtleV0gKiBjMi5zaXplKSAvIChjMS5zaXplICsgYzIuc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlLCBjMS52YWx1ZSk7ZWxzZSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWVbMF0sIGMxLnZhbHVlWzBdKTtcbiAgICB9XG5cbiAgICBkaXN0c1tjMS5rZXldW2N1ci5rZXldID0gZGlzdHNbY3VyLmtleV1bYzEua2V5XSA9IGRpc3Q7IC8vIGRpc3RhbmNlIG1hdHJpeCBpcyBzeW1tZXRyaWNcbiAgfSAvLyBVcGRhdGUgY2FjaGVkIG1pbnNcblxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIga2V5MSA9IGNsdXN0ZXJzW19pMl0ua2V5O1xuXG4gICAgaWYgKG1pbnNba2V5MV0gPT09IGMxLmtleSB8fCBtaW5zW2tleTFdID09PSBjMi5rZXkpIHtcbiAgICAgIHZhciBfbWluID0ga2V5MTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5MiA9IGNsdXN0ZXJzW2pdLmtleTtcblxuICAgICAgICBpZiAoZGlzdHNba2V5MV1ba2V5Ml0gPCBkaXN0c1trZXkxXVtfbWluXSkge1xuICAgICAgICAgIF9taW4gPSBrZXkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1pbnNba2V5MV0gPSBfbWluO1xuICAgIH1cblxuICAgIGNsdXN0ZXJzW19pMl0uaW5kZXggPSBfaTI7XG4gIH0gLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcblxuXG4gIGMxLmtleSA9IGMyLmtleSA9IGMxLmluZGV4ID0gYzIuaW5kZXggPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBnZXRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKHJvb3QsIGFyciwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm47XG5cbiAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICBhcnIucHVzaChyb290LnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGFycik7XG4gICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIGFycik7XG4gIH1cbn07XG5cbnZhciBidWlsZERlbmRyb2dyYW0gPSBmdW5jdGlvbiBidWlsZERlbmRyb2dyYW0ocm9vdCwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJyc7XG5cbiAgaWYgKHJvb3QubGVmdCAmJiByb290LnJpZ2h0KSB7XG4gICAgdmFyIGxlZnRTdHIgPSBidWlsZERlbmRyb2dyYW0ocm9vdC5sZWZ0LCBjeSk7XG4gICAgdmFyIHJpZ2h0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QucmlnaHQsIGN5KTtcbiAgICB2YXIgbm9kZSA9IGN5LmFkZCh7XG4gICAgICBncm91cDogJ25vZGVzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGxlZnRTdHIgKyAnLCcgKyByaWdodFN0clxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiBsZWZ0U3RyLFxuICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiByaWdodFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZS5pZCgpO1xuICB9IGVsc2UgaWYgKHJvb3QudmFsdWUpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZS5pZCgpO1xuICB9XG59O1xuXG52YXIgYnVpbGRDbHVzdGVyc0Zyb21UcmVlID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QsIGssIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuIFtdO1xuICB2YXIgbGVmdCA9IFtdLFxuICAgICAgcmlnaHQgPSBbXSxcbiAgICAgIGxlYXZlcyA9IFtdO1xuXG4gIGlmIChrID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgY3V0IHRyZWUsIHNpbXBseSByZXR1cm4gYWxsIG5vZGVzIGFzIDEgc2luZ2xlIGNsdXN0ZXJcbiAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgbGVhdmVzID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWF2ZXMpXTtcbiAgfSBlbHNlIGlmIChrID09PSAxKSB7XG4gICAgLy8gY3V0IGF0IHJvb3RcbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgLy8gbGVhZiBub2RlXG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWZ0KSwgY3kuY29sbGVjdGlvbihyaWdodCldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgbGVmdCA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LmxlZnQsIGsgLSAxLCBjeSk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgcmlnaHQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5yaWdodCwgayAtIDEsIGN5KTtcbiAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgfVxuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24gaGllcmFyY2hpY2FsQ2x1c3RlcmluZyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06IGxpbmthZ2UgdHlwZSwgZGlzdGFuY2UgbWV0cmljLCBldGMuXG5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07IC8vIEJlZ2luIGhpZXJhcmNoaWNhbCBhbGdvcml0aG1cblxuXG4gIHZhciBjbHVzdGVycyA9IFtdO1xuICB2YXIgZGlzdHMgPSBbXTsgLy8gZGlzdGFuY2VzIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG5cbiAgdmFyIG1pbnMgPSBbXTsgLy8gY2xvc2VzdCBjbHVzdGVyIGZvciBlYWNoIGNsdXN0ZXJcblxuICB2YXIgaW5kZXggPSBbXTsgLy8gaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG4gIC8vIEluIGFnZ2xvbWVyYXRpdmUgKGJvdHRvbS11cCkgY2x1c3RlcmluZywgZWFjaCBub2RlIHN0YXJ0cyBhcyBpdHMgb3duIGNsdXN0ZXJcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICB2YWx1ZTogb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgPyBub2Rlc1tuXSA6IFtub2Rlc1tuXV0sXG4gICAgICBrZXk6IG4sXG4gICAgICBpbmRleDogblxuICAgIH07XG4gICAgY2x1c3RlcnNbbl0gPSBjbHVzdGVyO1xuICAgIGluZGV4W25dID0gY2x1c3RlcjtcbiAgICBkaXN0c1tuXSA9IFtdO1xuICAgIG1pbnNbbl0gPSAwO1xuICB9IC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgIHZhciBkaXN0ID0gdm9pZCAwO1xuXG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgICAgLy8gbW9kZXMgc3RvcmUgY2x1c3RlciB2YWx1ZXMgZGlmZmVyZW50bHlcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWUsIGNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlWzBdLCBjbHVzdGVyc1tqXS52YWx1ZVswXSk7XG4gICAgICB9XG5cbiAgICAgIGRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgIGRpc3RzW2pdW2ldID0gZGlzdDtcblxuICAgICAgaWYgKGRpc3QgPCBkaXN0c1tpXVttaW5zW2ldXSkge1xuICAgICAgICBtaW5zW2ldID0gajsgLy8gQ2FjaGUgbWluczogY2xvc2VzdCBjbHVzdGVyIHRvIGNsdXN0ZXIgaSBpcyBjbHVzdGVyIGpcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gRmluZCB0aGUgY2xvc2VzdCBwYWlyIG9mIGNsdXN0ZXJzIGFuZCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgY2x1c3Rlci5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG5ldyBjbHVzdGVyIGFuZCBlYWNoIG9mIHRoZSBvbGQgY2x1c3RlcnMsIGFuZCBsb29wIHVudGlsIHRocmVzaG9sZCByZWFjaGVkLlxuXG5cbiAgdmFyIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcblxuICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB9XG5cbiAgdmFyIHJldENsdXN0ZXJzOyAvLyBEZW5kcm9ncmFtIG1vZGUgYnVpbGRzIHRoZSBoaWVyYXJjaHkgYW5kIGFkZHMgaW50ZXJtZWRpYXJ5IG5vZGVzICsgZWRnZXNcbiAgLy8gaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nIHRoZSBjbHVzdGVycy5cblxuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICByZXRDbHVzdGVycyA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShjbHVzdGVyc1swXSwgb3B0cy5kZW5kcm9ncmFtRGVwdGgsIGN5KTtcbiAgICBpZiAob3B0cy5hZGREZW5kcm9ncmFtKSBidWlsZERlbmRyb2dyYW0oY2x1c3RlcnNbMF0sIGN5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWd1bGFyIG1vZGUgc2ltcGx5IHJldHVybnMgdGhlIGNsdXN0ZXJzXG4gICAgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoY2x1c3RlcnMubGVuZ3RoKTtcbiAgICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBpKSB7XG4gICAgICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgY2x1c3Rlci5rZXkgPSBjbHVzdGVyLmluZGV4ID0gbnVsbDtcbiAgICAgIHJldENsdXN0ZXJzW2ldID0gY3kuY29sbGVjdGlvbihjbHVzdGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG5cbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEgPSB7XG4gIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmc6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcsXG4gIGhjYTogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG52YXIgZGVmYXVsdHMkNyA9IGRlZmF1bHRzKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBhdHRyaWJ1dGVzIGJldHdlZW4gdHdvIG5vZGVzXG4gIHByZWZlcmVuY2U6ICdtZWRpYW4nLFxuICAvLyBzdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgZGFtcGluZzogMC44LFxuICAvLyBkYW1waW5nIGZhY3RvciBiZXR3ZWVuIFswLjUsIDEpXG4gIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gIC8vIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW5cbiAgbWluSXRlcmF0aW9uczogMTAwLFxuICAvLyBtaW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuIGluIG9yZGVyIGZvciBjbHVzdGVyaW5nIHRvIHN0b3BcbiAgYXR0cmlidXRlczogWy8vIGZ1bmN0aW9ucyB0byBxdWFudGlmeSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzXG4gICAgLy8gZS5nLiBub2RlID0+IG5vZGUuZGF0YSgnd2VpZ2h0JylcbiAgXVxufSk7XG5cbnZhciBzZXRPcHRpb25zJDMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIGRtcCA9IG9wdGlvbnMuZGFtcGluZztcbiAgdmFyIHByZWYgPSBvcHRpb25zLnByZWZlcmVuY2U7XG5cbiAgaWYgKCEoMC41IDw9IGRtcCAmJiBkbXAgPCAxKSkge1xuICAgIGVycm9yKFwiRGFtcGluZyBtdXN0IHJhbmdlIG9uIFswLjUsIDEpLiAgR290OiBcIi5jb25jYXQoZG1wKSk7XG4gIH1cblxuICB2YXIgdmFsaWRQcmVmcyA9IFsnbWVkaWFuJywgJ21lYW4nLCAnbWluJywgJ21heCddO1xuXG4gIGlmICghKHZhbGlkUHJlZnMuc29tZShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ID09PSBwcmVmO1xuICB9KSB8fCBudW1iZXIocHJlZikpKSB7XG4gICAgZXJyb3IoXCJQcmVmZXJlbmNlIG11c3QgYmUgb25lIG9mIFtcIi5jb25jYXQodmFsaWRQcmVmcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBcIidcIi5jb25jYXQocCwgXCInXCIpO1xuICAgIH0pLmpvaW4oJywgJyksIFwiXSBvciBhIG51bWJlci4gIEdvdDogXCIpLmNvbmNhdChwcmVmKSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHMkNyhvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkodHlwZSwgbjEsIG4yLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihuLCBpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obik7XG4gIH07IC8vIG5iIG5lZ2F0aXZlIGJlY2F1c2Ugc2ltaWxhcml0eSBzaG91bGQgaGF2ZSBhbiBpbnZlcnNlIHJlbGF0aW9uc2hpcCB0byBkaXN0YW5jZVxuXG5cbiAgcmV0dXJuIC1jbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjEsIGkpO1xuICB9LCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4yLCBpKTtcbiAgfSwgbjEsIG4yKTtcbn07XG5cbnZhciBnZXRQcmVmZXJlbmNlID0gZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZShTLCBwcmVmZXJlbmNlKSB7XG4gIC8vIGxhcmdlciBwcmVmZXJlbmNlID0gZ3JlYXRlciAjIG9mIGNsdXN0ZXJzXG4gIHZhciBwID0gbnVsbDtcblxuICBpZiAocHJlZmVyZW5jZSA9PT0gJ21lZGlhbicpIHtcbiAgICBwID0gbWVkaWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtZWFuJykge1xuICAgIHAgPSBtZWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtaW4nKSB7XG4gICAgcCA9IG1pbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWF4Jykge1xuICAgIHAgPSBtYXgoUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3VzdG9tIHByZWZlcmVuY2UgbnVtYmVyLCBhcyBzZXQgYnkgdXNlclxuICAgIHAgPSBwcmVmZXJlbmNlO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59O1xuXG52YXIgZmluZEV4ZW1wbGFycyA9IGZ1bmN0aW9uIGZpbmRFeGVtcGxhcnMobiwgUiwgQSkge1xuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKFJbaSAqIG4gKyBpXSArIEFbaSAqIG4gKyBpXSA+IDApIHtcbiAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kaWNlcztcbn07XG5cbnZhciBhc3NpZ25DbHVzdGVycyA9IGZ1bmN0aW9uIGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycykge1xuICB2YXIgY2x1c3RlcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgdmFyIGUgPSBleGVtcGxhcnNbZWldO1xuXG4gICAgICBpZiAoU1tpICogbiArIGVdID4gbWF4KSB7XG4gICAgICAgIGluZGV4ID0gZTtcbiAgICAgICAgbWF4ID0gU1tpICogbiArIGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9laSA9IDA7IF9laSA8IGV4ZW1wbGFycy5sZW5ndGg7IF9laSsrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzW19laV1dID0gZXhlbXBsYXJzW19laV07XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgYXNzaWduJDIgPSBmdW5jdGlvbiBhc3NpZ24obiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG5cbiAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICB2YXIgaWkgPSBbXTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGlmIChjbHVzdGVyc1tjXSA9PT0gZXhlbXBsYXJzW2VpXSkge1xuICAgICAgICBpaS5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhJID0gLTE7XG4gICAgdmFyIG1heFN1bSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBTW2lpW2pdICogbiArIGlpW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1bSA+IG1heFN1bSkge1xuICAgICAgICBtYXhJID0gaTtcbiAgICAgICAgbWF4U3VtID0gc3VtO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4ZW1wbGFyc1tlaV0gPSBpaVttYXhJXTtcbiAgfVxuXG4gIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGFmZmluaXR5UHJvcGFnYXRpb24gPSBmdW5jdGlvbiBhZmZpbml0eVByb3BhZ2F0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQzKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBCZWdpbiBhZmZpbml0eSBwcm9wYWdhdGlvbiBhbGdvcml0aG1cblxuXG4gIHZhciBuOyAvLyBudW1iZXIgb2YgZGF0YSBwb2ludHNcblxuICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcblxuICB2YXIgUzsgLy8gc2ltaWxhcml0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBwOyAvLyBwcmVmZXJlbmNlL3N1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuXG4gIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBBOyAvLyBhdmFpbGFiaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICBuID0gbm9kZXMubGVuZ3RoO1xuICBuMiA9IG4gKiBuOyAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG5cbiAgUyA9IG5ldyBBcnJheShuMik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgU1tfaV0gPSAtSW5maW5pdHk7IC8vIGZvciBjYXNlcyB3aGVyZSB0d28gZGF0YSBwb2ludHMgc2hvdWxkbid0IGJlIGxpbmtlZCB0b2dldGhlclxuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKF9pMiAhPT0gaikge1xuICAgICAgICBTW19pMiAqIG4gKyBqXSA9IGdldFNpbWlsYXJpdHkkMShvcHRzLmRpc3RhbmNlLCBub2Rlc1tfaTJdLCBub2Rlc1tqXSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUGxhY2UgcHJlZmVyZW5jZXMgb24gdGhlIGRpYWdvbmFsIG9mIFNcblxuXG4gIHAgPSBnZXRQcmVmZXJlbmNlKFMsIG9wdHMucHJlZmVyZW5jZSk7XG5cbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbjsgX2kzKyspIHtcbiAgICBTW19pMyAqIG4gKyBfaTNdID0gcDtcbiAgfSAvLyBJbml0aWFsaXplIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG5cblxuICBSID0gbmV3IEFycmF5KG4yKTtcblxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuMjsgX2k0KyspIHtcbiAgICBSW19pNF0gPSAwLjA7XG4gIH0gLy8gSW5pdGlhbGl6ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcblxuXG4gIEEgPSBuZXcgQXJyYXkobjIpO1xuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG4yOyBfaTUrKykge1xuICAgIEFbX2k1XSA9IDAuMDtcbiAgfVxuXG4gIHZhciBvbGQgPSBuZXcgQXJyYXkobik7XG4gIHZhciBScCA9IG5ldyBBcnJheShuKTtcbiAgdmFyIHNlID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG47IF9pNisrKSB7XG4gICAgb2xkW19pNl0gPSAwLjA7XG4gICAgUnBbX2k2XSA9IDAuMDtcbiAgICBzZVtfaTZdID0gMDtcbiAgfVxuXG4gIHZhciBlID0gbmV3IEFycmF5KG4gKiBvcHRzLm1pbkl0ZXJhdGlvbnMpO1xuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGUubGVuZ3RoOyBfaTcrKykge1xuICAgIGVbX2k3XSA9IDA7XG4gIH1cblxuICB2YXIgaXRlcjtcblxuICBmb3IgKGl0ZXIgPSAwOyBpdGVyIDwgb3B0cy5tYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAvLyBtYWluIGFsZ29yaXRobWljIGxvb3BcbiAgICAvLyBVcGRhdGUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBuOyBfaTgrKykge1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgICBtYXgyID0gLUluZmluaXR5LFxuICAgICAgICAgIG1heEkgPSAtMSxcbiAgICAgICAgICBBUyA9IDAuMDtcblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgb2xkW19qXSA9IFJbX2k4ICogbiArIF9qXTtcbiAgICAgICAgQVMgPSBBW19pOCAqIG4gKyBfal0gKyBTW19pOCAqIG4gKyBfal07XG5cbiAgICAgICAgaWYgKEFTID49IG1heCkge1xuICAgICAgICAgIG1heDIgPSBtYXg7XG4gICAgICAgICAgbWF4ID0gQVM7XG4gICAgICAgICAgbWF4SSA9IF9qO1xuICAgICAgICB9IGVsc2UgaWYgKEFTID4gbWF4Mikge1xuICAgICAgICAgIG1heDIgPSBBUztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBuOyBfajIrKykge1xuICAgICAgICBSW19pOCAqIG4gKyBfajJdID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIF9qMl0gLSBtYXgpICsgb3B0cy5kYW1waW5nICogb2xkW19qMl07XG4gICAgICB9XG5cbiAgICAgIFJbX2k4ICogbiArIG1heEldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIG1heEldIC0gbWF4MikgKyBvcHRzLmRhbXBpbmcgKiBvbGRbbWF4SV07XG4gICAgfSAvLyBVcGRhdGUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG5cblxuICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG47IF9pOSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbjsgX2ozKyspIHtcbiAgICAgICAgb2xkW19qM10gPSBBW19qMyAqIG4gKyBfaTldO1xuICAgICAgICBScFtfajNdID0gTWF0aC5tYXgoMCwgUltfajMgKiBuICsgX2k5XSk7XG4gICAgICAgIHN1bSArPSBScFtfajNdO1xuICAgICAgfVxuXG4gICAgICBzdW0gLT0gUnBbX2k5XTtcbiAgICAgIFJwW19pOV0gPSBSW19pOSAqIG4gKyBfaTldO1xuICAgICAgc3VtICs9IFJwW19pOV07XG5cbiAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47IF9qNCsrKSB7XG4gICAgICAgIEFbX2o0ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiBNYXRoLm1pbigwLCBzdW0gLSBScFtfajRdKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajRdO1xuICAgICAgfVxuXG4gICAgICBBW19pOSAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKHN1bSAtIFJwW19pOV0pICsgb3B0cy5kYW1waW5nICogb2xkW19pOV07XG4gICAgfSAvLyBDaGVjayBmb3IgY29udmVyZ2VuY2VcblxuXG4gICAgdmFyIEsgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBuOyBfaTEwKyspIHtcbiAgICAgIHZhciBFID0gQVtfaTEwICogbiArIF9pMTBdICsgUltfaTEwICogbiArIF9pMTBdID4gMCA/IDEgOiAwO1xuICAgICAgZVtpdGVyICUgb3B0cy5taW5JdGVyYXRpb25zICogbiArIF9pMTBdID0gRTtcbiAgICAgIEsgKz0gRTtcbiAgICB9XG5cbiAgICBpZiAoSyA+IDAgJiYgKGl0ZXIgPj0gb3B0cy5taW5JdGVyYXRpb25zIC0gMSB8fCBpdGVyID09IG9wdHMubWF4SXRlcmF0aW9ucyAtIDEpKSB7XG4gICAgICB2YXIgX3N1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbjsgX2kxMSsrKSB7XG4gICAgICAgIHNlW19pMTFdID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBvcHRzLm1pbkl0ZXJhdGlvbnM7IF9qNSsrKSB7XG4gICAgICAgICAgc2VbX2kxMV0gKz0gZVtfajUgKiBuICsgX2kxMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VbX2kxMV0gPT09IDAgfHwgc2VbX2kxMV0gPT09IG9wdHMubWluSXRlcmF0aW9ucykge1xuICAgICAgICAgIF9zdW0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoX3N1bSA9PT0gbikge1xuICAgICAgICAvLyB0aGVuIHdlIGhhdmUgY29udmVyZ2VuY2VcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElkZW50aWZ5IGV4ZW1wbGFycyAoY2x1c3RlciBjZW50ZXJzKVxuXG5cbiAgdmFyIGV4ZW1wbGFyc0luZGljZXMgPSBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpOyAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnNcblxuICB2YXIgY2x1c3RlckluZGljZXMgPSBhc3NpZ24kMihuLCBTLCBleGVtcGxhcnNJbmRpY2VzKTtcbiAgdmFyIGNsdXN0ZXJzID0ge307XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tjXV0gPSBbXTtcbiAgfVxuXG4gIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZXMubGVuZ3RoOyBfaTEyKyspIHtcbiAgICB2YXIgcG9zID0gaWQycG9zaXRpb25bbm9kZXNbX2kxMl0uaWQoKV07XG5cbiAgICB2YXIgY2x1c3RlckluZGV4ID0gY2x1c3RlckluZGljZXNbcG9zXTtcblxuICAgIGlmIChjbHVzdGVySW5kZXggIT0gbnVsbCkge1xuICAgICAgLy8gdGhlIG5vZGUgbWF5IGhhdmUgbm90IGJlZW4gYXNzaWduZWQgYSBjbHVzdGVyIGlmIG5vIHZhbGlkIGF0dHJpYnV0ZXMgd2VyZSBzcGVjaWZpZWRcbiAgICAgIGNsdXN0ZXJzW2NsdXN0ZXJJbmRleF0ucHVzaChub2Rlc1tfaTEyXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICByZXRDbHVzdGVyc1tfY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbX2NdXSk7XG4gIH1cblxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xuXG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiQxID0ge1xuICBhZmZpbml0eVByb3BhZ2F0aW9uOiBhZmZpbml0eVByb3BhZ2F0aW9uLFxuICBhcDogYWZmaW5pdHlQcm9wYWdhdGlvblxufTtcblxudmFyIGhpZXJob2x6ZXJEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgcm9vdDogdW5kZWZpbmVkLFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRiID0ge1xuICBoaWVyaG9semVyOiBmdW5jdGlvbiBoaWVyaG9semVyKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIGRpcmVjdGVkOiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfaGllcmhvbHplckRlZmF1bHRzID0gaGllcmhvbHplckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5yb290LFxuICAgICAgICBkaXJlY3RlZCA9IF9oaWVyaG9semVyRGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGRmbGFnID0gZmFsc2U7XG4gICAgdmFyIG9kZEluO1xuICAgIHZhciBvZGRPdXQ7XG4gICAgdmFyIHN0YXJ0VmVydGV4O1xuICAgIGlmIChyb290KSBzdGFydFZlcnRleCA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdLmlkKCkgOiByb290WzBdLmlkKCk7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgaW5kID0gZWxlLmluZGVncmVlKHRydWUpO1xuICAgICAgICAgIHZhciBvdXRkID0gZWxlLm91dGRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgZDEgPSBpbmQgLSBvdXRkO1xuICAgICAgICAgIHZhciBkMiA9IG91dGQgLSBpbmQ7XG5cbiAgICAgICAgICBpZiAoZDEgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZEluKSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRJbiA9IGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZE91dCkgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkT3V0ID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA+IDEgfHwgZDEgPiAxKSB7XG4gICAgICAgICAgICBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLm91dGdvZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNFZGdlKCkpIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW3VuZGVmaW5lZCwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHZhciBkID0gZWxlLmRlZ3JlZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChkICUgMikge1xuICAgICAgICAgICAgaWYgKCFvZGRJbikgb2RkSW4gPSBpZDtlbHNlIGlmICghb2RkT3V0KSBvZGRPdXQgPSBpZDtlbHNlIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbZWxlLnNvdXJjZSgpLmlkKCksIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIHRyYWlsOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChkZmxhZykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChvZGRPdXQgJiYgb2RkSW4pIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCAmJiBvZGRJbiAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzdGFydFZlcnRleCkgc3RhcnRWZXJ0ZXggPSBlbGVzWzBdLmlkKCk7XG4gICAgfVxuXG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHYpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHY7XG4gICAgICB2YXIgc3VidG91ciA9IFt2XTtcbiAgICAgIHZhciBhZGosIGFkalRhaWwsIGFkakhlYWQ7XG5cbiAgICAgIHdoaWxlIChub2Rlc1tjdXJyZW50Tm9kZV0ubGVuZ3RoKSB7XG4gICAgICAgIGFkaiA9IG5vZGVzW2N1cnJlbnROb2RlXS5zaGlmdCgpO1xuICAgICAgICBhZGpUYWlsID0gZWRnZXNbYWRqXVswXTtcbiAgICAgICAgYWRqSGVhZCA9IGVkZ2VzW2Fkal1bMV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IGFkakhlYWQpIHtcbiAgICAgICAgICBub2Rlc1thZGpIZWFkXSA9IG5vZGVzW2FkakhlYWRdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqSGVhZDtcbiAgICAgICAgfSBlbHNlIGlmICghZGlyZWN0ZWQgJiYgY3VycmVudE5vZGUgIT0gYWRqVGFpbCkge1xuICAgICAgICAgIG5vZGVzW2FkalRhaWxdID0gbm9kZXNbYWRqVGFpbF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpUYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGFkaik7XG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChjdXJyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJ0b3VyO1xuICAgIH07XG5cbiAgICB2YXIgdHJhaWwgPSBbXTtcbiAgICB2YXIgc3VidG91ciA9IFtdO1xuICAgIHN1YnRvdXIgPSB3YWxrKHN0YXJ0VmVydGV4KTtcblxuICAgIHdoaWxlIChzdWJ0b3VyLmxlbmd0aCAhPSAxKSB7XG4gICAgICBpZiAobm9kZXNbc3VidG91clswXV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJ0b3VyID0gd2FsayhzdWJ0b3VyLnNoaWZ0KCkpLmNvbmNhdChzdWJ0b3VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7IC8vIGZpbmFsIG5vZGVcblxuICAgIGZvciAodmFyIGQgaW4gbm9kZXMpIHtcbiAgICAgIGlmIChub2Rlc1tkXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQuZm91bmQgPSB0cnVlO1xuICAgIHJlc3VsdC50cmFpbCA9IHRoaXMuc3Bhd24odHJhaWwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kYyA9IHt9O1xuW2VsZXNmbiwgZWxlc2ZuJDEsIGVsZXNmbiQyLCBlbGVzZm4kMywgZWxlc2ZuJDQsIGVsZXNmbiQ1LCBlbGVzZm4kNiwgZWxlc2ZuJDcsIGVsZXNmbiQ4LCBlbGVzZm4kOSwgZWxlc2ZuJGEsIG1hcmtvdkNsdXN0ZXJpbmckMSwga0NsdXN0ZXJpbmcsIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSwgYWZmaW5pdHlQcm9wYWdhdGlvbiQxLCBlbGVzZm4kYl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGVsZXNmbiRjLCBwcm9wcyk7XG59KTtcblxuLyohXG5FbWJlZGRhYmxlIE1pbmltdW0gU3RyaWN0bHktQ29tcGxpYW50IFByb21pc2VzL0ErIDEuMS4xIFRoZW5hYmxlXG5Db3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIChodHRwOi8vZW5nZWxzY2hhbGwuY29tKVxuTGljZW5zZWQgdW5kZXIgVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuKi9cblxuLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xudmFyIFNUQVRFX1BFTkRJTkcgPSAwO1xuLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG5cbnZhciBTVEFURV9GVUxGSUxMRUQgPSAxO1xuLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG5cbnZhciBTVEFURV9SRUpFQ1RFRCA9IDI7XG4vKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xuXG52YXIgYXBpID0gZnVuY3Rpb24gYXBpKGV4ZWN1dG9yKSB7XG4gIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKSByZXR1cm4gbmV3IGFwaShleGVjdXRvcik7XG4gIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cblxuICB0aGlzLmlkID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gIC8qICBpbml0aWFsIHN0YXRlICAqL1xuXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkO1xuICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG5cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7XG4gIC8qICBpbml0aWFsIHJlYXNvbiAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cblxuICB0aGlzLm9uRnVsZmlsbGVkID0gW107XG4gIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gIHRoaXMub25SZWplY3RlZCA9IFtdO1xuICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG5cbiAgdGhpcy5wcm94eSA9IHtcbiAgICB0aGVuOiB0aGlzLnRoZW4uYmluZCh0aGlzKVxuICB9O1xuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cblxuICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSBleGVjdXRvci5jYWxsKHRoaXMsIHRoaXMuZnVsZmlsbC5iaW5kKHRoaXMpLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbn07XG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cblxuXG5hcGkucHJvdG90eXBlID0ge1xuICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgZnVsZmlsbDogZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlKTtcbiAgfSxcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgJ3JlamVjdFJlYXNvbicsIHZhbHVlKTtcbiAgfSxcblxuICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgdmFyIG5leHQgPSBuZXcgYXBpKCk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG5cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2gocmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJykpO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuXG4gICAgY3Vyci5vblJlamVjdGVkLnB1c2gocmVzb2x2ZXIob25SZWplY3RlZCwgbmV4dCwgJ3JlamVjdCcpKTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cblxuICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgcmV0dXJuIG5leHQucHJveHk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgfVxufTtcbi8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cblxudmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiBkZWxpdmVyKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuXG4gICAgY3VycltuYW1lXSA9IHZhbHVlO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG5cbiAgICBleGVjdXRlKGN1cnIpO1xuICB9XG5cbiAgcmV0dXJuIGN1cnI7XG59O1xuLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuXG5cbnZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShjdXJyKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUpO2Vsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvblJlamVjdGVkJywgY3Vyci5yZWplY3RSZWFzb24pO1xufTtcbi8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xuXG5cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG5cbiAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cblxuICB2YXIgaGFuZGxlcnMgPSBjdXJyW25hbWVdO1xuICBjdXJyW25hbWVdID0gW107XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG5cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTtcbiAgICB9XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG5cbiAgfTtcbiAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG5cblxuICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgc2V0SW1tZWRpYXRlKGZ1bmMpO2Vsc2Ugc2V0VGltZW91dChmdW5jLCAwKTtcbn07XG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cblxuXG52YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiByZXNvbHZlcihjYiwgbmV4dCwgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dC5yZWplY3QoZSk7XG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobmV4dCwgcmVzdWx0KTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4xXSAgKi9cbiAgICAgIH1cbiAgfTtcbn07XG4vKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovXG5cbi8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cblxuXG52YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgeCkge1xuICAvKiAgc2FuaXR5IGNoZWNrIGFyZ3VtZW50cyAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qICBzdXJnaWNhbGx5IGNoZWNrIGZvciBhIFwidGhlblwiIG1ldGhvZFxuICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG5cblxuICB2YXIgdGhlbjtcblxuICBpZiAoX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuID0geC50aGVuO1xuICAgIH1cbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cblxuXG4gIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi9cblxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgIHRoZW4uY2FsbCh4LFxuICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgaWYgKHkgPT09IHgpXG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2NpcmN1bGFyIHRoZW5hYmxlIGNoYWluJykpO2Vsc2UgcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgIH0sXG4gICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi9cblxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuXG4gICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG5cblxuICBwcm9taXNlLmZ1bGZpbGwoeCk7XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTsgLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuXG5cbmFwaS5hbGwgPSBmdW5jdGlvbiAocHMpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmVBbGwsIHJlamVjdEFsbCkge1xuICAgIHZhciB2YWxzID0gbmV3IEFycmF5KHBzLmxlbmd0aCk7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG5cbiAgICAgIGlmIChkb25lQ291bnQgPT09IHBzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlQWxsKHZhbHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5hcGkucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmUodmFsKTtcbiAgfSk7XG59O1xuXG5hcGkucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbCk7XG4gIH0pO1xufTtcblxudmFyIFByb21pc2UkMSA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIEFuaW1hdGlvbih0YXJnZXQsIG9wdHMsIG9wdHMyKSB7XG4gIHZhciBpc0NvcmUgPSBjb3JlKHRhcmdldCk7XG4gIHZhciBpc0VsZSA9ICFpc0NvcmU7XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IGV4dGVuZCh7XG4gICAgZHVyYXRpb246IDEwMDBcbiAgfSwgb3B0cywgb3B0czIpO1xuXG4gIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgX3AucGxheWluZyA9IGZhbHNlO1xuICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgX3AucHJvZ3Jlc3MgPSAwO1xuICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgX3AuZnJhbWVzID0gW107XG5cbiAgaWYgKF9wLmNvbXBsZXRlICYmIGZuKF9wLmNvbXBsZXRlKSkge1xuICAgIF9wLmNvbXBsZXRlcy5wdXNoKF9wLmNvbXBsZXRlKTtcbiAgfVxuXG4gIGlmIChpc0VsZSkge1xuICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICBfcC5zdGFydFBvc2l0aW9uID0gX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55XG4gICAgfTtcbiAgICBfcC5zdGFydFN0eWxlID0gX3Auc3RhcnRTdHlsZSB8fCB0YXJnZXQuY3koKS5zdHlsZSgpLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUodGFyZ2V0LCBfcC5zdHlsZSk7XG4gIH1cblxuICBpZiAoaXNDb3JlKSB7XG4gICAgdmFyIHBhbiA9IHRhcmdldC5wYW4oKTtcbiAgICBfcC5zdGFydFBhbiA9IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9O1xuICAgIF9wLnN0YXJ0Wm9vbSA9IHRhcmdldC56b29tKCk7XG4gIH0gLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcblxuXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG59O1xuXG52YXIgYW5pZm4gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuZXh0ZW5kKGFuaWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gIH0sXG4gIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuaG9va2VkKSB7XG4gICAgICAvLyBhZGQgdG8gdGFyZ2V0J3MgYW5pbWF0aW9uIHF1ZXVlXG4gICAgICB2YXIgcTtcbiAgICAgIHZhciB0QW5pID0gX3AudGFyZ2V0Ll9wcml2YXRlLmFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9wLnF1ZXVlKSB7XG4gICAgICAgIHEgPSB0QW5pLnF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IHRBbmkuY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgcS5wdXNoKHRoaXMpOyAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcblxuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oX3AudGFyZ2V0KSkge1xuICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woX3AudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgX3AuaG9va2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlOyAvLyBhdXRvcmV3aW5kXG5cbiAgICBpZiAoX3AucHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcblxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvb2soKTsgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBsYXlpbmc6IGZ1bmN0aW9uIHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGxheWluZztcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AuYXBwbHlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpOyAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhcHBseWluZzogZnVuY3Rpb24gYXBwbHlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXBwbHlpbmc7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9wLnN0b3BwZWQgPSB0cnVlOyAvLyB0byBiZSByZW1vdmVkIGZyb20gYW5pbWF0aW9uIHF1ZXVlc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJld2luZDogZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDApO1xuICB9LFxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24gZmFzdGZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMSk7XG4gIH0sXG4gIHRpbWU6IGZ1bmN0aW9uIHRpbWUodCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3ModCAvIF9wLmR1cmF0aW9uKTtcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhwKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29tcGxldGVkOiBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgIGlmIChfcGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7IC8vIHN3YXAgc3R5bGVzXG5cbiAgICBpZiAoX3Auc3R5bGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBfcC5zdHlsZVtpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbbmFtZV07XG4gICAgICAgIF9wLnN0YXJ0U3R5bGVbbmFtZV0gPSBwcm9wO1xuICAgICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXJyLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5hbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcbmFuaWZuLnJ1biA9IGFuaWZuLnBsYXk7XG5hbmlmbi5ydW5uaW5nID0gYW5pZm4ucGxheWluZztcblxudmFyIGRlZmluZSA9IHtcbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZWRcbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sXG4gIC8vIGNsZWFyUXVldWVcbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24gZGVsYXlBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy5kdXJhdGlvbikge1xuICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMgJiYgcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgfSAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG5cblxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuXG4gICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG5cbiAgICAgICAgaWYgKGNlbnRlclBhbiAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG5cbiAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9IC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcblxuXG4gICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcblxuICAgICAgICBpZiAodnAgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh2cC56b29tZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IHZwLnpvb207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB2cC5wYW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIH0gLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbihwcm9wZXJ0aWVzLCBxdWV1ZSA/IHtcbiAgICAgICAgICBxdWV1ZTogdHJ1ZVxuICAgICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgYW5pID0gYW5pc1tqXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICBpZiAoanVtcFRvRW5kKSB7XG4gICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgYW5pX3AuZHVyYXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcblxuXG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWp1bXBUb0VuZCkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG5cblxuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbnZhciBkZWZpbmUkMSA9IHtcbiAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgZGF0YTogZnVuY3Rpb24gZGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9LFxuICAgICAgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjsgLy8gLmRhdGEoJ2ZvbycsIC4uLilcblxuICAgICAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgICAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiAocC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldFxuICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7IC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcblxuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBjaGFuZ2UpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcblxuICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoZWxlKSkge1xuICAgICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICAgICAgcC5vblNldChzZWxmKTtcblxuICAgICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiBwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAvLyBleHRlbmRcbiAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgIHZhciBrLCB2O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIG9iaik7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgayA9IGtleXNbX2ldO1xuICAgICAgICAgIHYgPSBvYmpba107XG5cbiAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcblxuICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgfSAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93QmluZGluZyAmJiBmbihuYW1lKSkge1xuICAgICAgICAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiQxID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4kMSk7IC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSxcbiAgLy8gZGF0YVxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuXG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbChuYW1lcykge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcblxuICAgICAgaWYgKHN0cmluZyhuYW1lcykpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChlbXB0eVN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcblxuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKykge1xuICAgICAgICAgICAgICBhbGxbaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfSAvLyAucmVtb3ZlRGF0YSgpXG5cbiAgICAgIH0gZWxzZSBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuICAgICAgICBmb3IgKHZhciBfaV9hID0gMCwgX2xfYSA9IGFsbC5sZW5ndGg7IF9pX2EgPCBfbF9hOyBfaV9hKyspIHtcbiAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbX2lfYV0uX3ByaXZhdGVbcC5maWVsZF07XG5cbiAgICAgICAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyhfcHJpdmF0ZUZpZWxkcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfa2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzW19pMl07XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbX2tleV07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZEtleVRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzW19rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9IC8vIHJlbW92ZURhdGFcblxufTsgLy8gZGVmaW5lXG5cbnZhciBkZWZpbmUkMiA9IHtcbiAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uIGV2ZW50QWxpYXNlc09uKHByb3RvKSB7XG4gICAgdmFyIHAgPSBwcm90bztcbiAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgIHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmID0gcC5yZW1vdmVMaXN0ZW5lcjtcbiAgICBwLnRyaWdnZXIgPSBwLmVtaXQ7IC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcblxuICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiAoZXZlbnRzLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlKSB7XG4gICAgICAgICAgc2VsZi5vZmYuYXBwbHkoc2VsZiwgb2ZmQXJncyk7XG4gICAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG4gICAgICAgIHNlbGYub24uYXBwbHkoc2VsZiwgb25BcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07IC8vIGRlZmluZVxuXG4vLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbnZhciBkZWZpbmUkMyA9IHt9O1xuW2RlZmluZSwgZGVmaW5lJDEsIGRlZmluZSQyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGV4dGVuZChkZWZpbmUkMywgbSk7XG59KTtcblxudmFyIGVsZXNmbiRkID0ge1xuICBhbmltYXRlOiBkZWZpbmUkMy5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lJDMuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUkMy5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUkMy5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUkMy5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lJDMuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lJDMuc3RvcCgpXG59O1xuXG52YXIgZWxlc2ZuJGUgPSB7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoX2NsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBzZWxmWzBdLl9wcml2YXRlLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiByZXQucHVzaChjbHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzU2V0ID0gbmV3IFNldCQxKF9jbGFzc2VzKTsgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7IC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBfY2xhc3Nlc1tpXTtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcblxuICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG5cblxuICAgICAgaWYgKCFjaGFuZ2VkRWxlKSB7XG4gICAgICAgIGNoYW5nZWRFbGUgPSBlbGVDbGFzc2VzLnNpemUgIT09IF9jbGFzc2VzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgX3AuY2xhc3NlcyA9IGNsYXNzZXNTZXQ7XG4gICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH0gLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvZ2dsZVVuZGVmZCA9IHRvZ2dsZSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICB2YXIgY2hhbmdlZE5vdyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWRFbGUgJiYgY2hhbmdlZE5vdykge1xuICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBqIGNsYXNzZXNcblxuICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuXG5cbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gIH0sXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uIGZsYXNoQ2xhc3MoY2xhc3NlcywgZHVyYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgfVxuXG4gICAgc2VsZi5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgfSwgZHVyYXRpb24pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59O1xuZWxlc2ZuJGUuY2xhc3NOYW1lID0gZWxlc2ZuJGUuY2xhc3NOYW1lcyA9IGVsZXNmbiRlLmNsYXNzZXM7XG5cbnZhciB0b2tlbnMgPSB7XG4gIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJyxcbiAgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gbGV0IG5hbWVzLCBldGNcbiAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JyxcbiAgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJyxcbiAgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkqJ1wiLFxuICAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICBudW1iZXI6IG51bWJlciQxLFxuICAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLFxuICAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJyxcbiAgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gIHN1YmplY3Q6ICdcXFxcJCcsXG4gIGdyb3VwOiAnbm9kZXxlZGdlfFxcXFwqJyxcbiAgZGlyZWN0ZWRFZGdlOiAnXFxcXHMrLT5cXFxccysnLFxuICB1bmRpcmVjdGVkRWRnZTogJ1xcXFxzKzwtPlxcXFxzKydcbn07XG50b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuXG50b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG5cbnRva2Vucy5jbGFzc05hbWUgPSB0b2tlbnMudmFyaWFibGU7IC8vIGEgY2xhc3MgbmFtZSAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxudG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgb3BzLCBvcCwgaTsgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG5cbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgfSAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3AgPSBvcHNbaV07XG5cbiAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuXG5cbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG5cbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAqXG4gKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICovXG52YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja3M6IFtdXG4gIH07XG59O1xuXG4vKipcbiAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICovXG52YXIgVHlwZSA9IHtcbiAgLyoqIEUuZy4gbm9kZSAqL1xuICBHUk9VUDogMCxcblxuICAvKiogQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzICovXG4gIENPTExFQ1RJT046IDEsXG5cbiAgLyoqIEEgZmlsdGVyKGVsZSkgZnVuY3Rpb24gKi9cbiAgRklMVEVSOiAyLFxuXG4gIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICBEQVRBX0NPTVBBUkU6IDMsXG5cbiAgLyoqIEUuZy4gW2Zvb10gKi9cbiAgREFUQV9FWElTVDogNCxcblxuICAvKiogRS5nLiBbP2Zvb10gKi9cbiAgREFUQV9CT09MOiA1LFxuXG4gIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gIE1FVEFfQ09NUEFSRTogNixcblxuICAvKiogRS5nLiA6c2VsZWN0ZWQgKi9cbiAgU1RBVEU6IDcsXG5cbiAgLyoqIEUuZy4gI2ZvbyAqL1xuICBJRDogOCxcblxuICAvKiogRS5nLiAuZm9vICovXG4gIENMQVNTOiA5LFxuXG4gIC8qKiBFLmcuICNmb28gPC0+ICNiYXIgKi9cbiAgVU5ESVJFQ1RFRF9FREdFOiAxMCxcblxuICAvKiogRS5nLiAjZm9vIC0+ICNiYXIgKi9cbiAgRElSRUNURURfRURHRTogMTEsXG5cbiAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICBOT0RFX1NPVVJDRTogMTIsXG5cbiAgLyoqIEUuZy4gI2ZvbyAtPiAkI2JhciAqL1xuICBOT0RFX1RBUkdFVDogMTMsXG5cbiAgLyoqIEUuZy4gJCNmb28gPC0+ICNiYXIgKi9cbiAgTk9ERV9ORUlHSEJPUjogMTQsXG5cbiAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgQ0hJTEQ6IDE1LFxuXG4gIC8qKiBFLmcuICNmb28gI2JhciAqL1xuICBERVNDRU5EQU5UOiAxNixcblxuICAvKiogRS5nLiAkI2ZvbyA+ICNiYXIgKi9cbiAgUEFSRU5UOiAxNyxcblxuICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gIEFOQ0VTVE9SOiAxOCxcblxuICAvKiogRS5nLiAjZm9vID4gJGJhciA+ICNiYXogKi9cbiAgQ09NUE9VTkRfU1BMSVQ6IDE5LFxuXG4gIC8qKiBBbHdheXMgbWF0Y2hlcywgdXNlZnVsIHBsYWNlaG9sZGVyIGZvciBzdWJqZWN0IGluIGBDT01QT1VORF9TUExJVGAgKi9cbiAgVFJVRTogMjBcbn07XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNvbXBvdW5kJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bG9vcCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzaW1wbGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNTaW1wbGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5hY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAvLyBuLmIuIHNlbGVjdG9ycyB0aGF0IGFyZSBzdGFydGluZyBzdWJzdHJpbmdzIG9mIG90aGVycyBtdXN0IGhhdmUgdGhlIGxvbmdlciBvbmVzIGZpcnN0XG4gIHJldHVybiBkZXNjZW5kaW5nKGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IpO1xufSk7XG5cbnZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxUb0ZuID0ge307XG4gIHZhciBzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzID0gc3RhdGVTZWxlY3RvcnNbaV07XG4gICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgfVxuXG4gIHJldHVybiBzZWxUb0ZuO1xufSgpO1xuXG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbn07XG52YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnNlbGVjdG9yO1xufSkuam9pbignfCcpICsgJyknO1xuXG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcblxudmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24gY2xlYW5NZXRhQ2hhcnMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICQxO1xuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTGFzdFF1ZXJ5ID0gZnVuY3Rpb24gcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgZXhhbWluaW5nUXVlcnksIHJlcGxhY2VtZW50UXVlcnkpIHtcbiAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPSByZXBsYWNlbWVudFF1ZXJ5O1xufTsgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4vLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxlY3RvcltpXVxuLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBtYXRjaCgpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcblxuXG52YXIgZXhwcnMgPSBbe1xuICBuYW1lOiAnZ3JvdXAnLFxuICAvLyBqdXN0IHVzZWQgZm9yIGlkZW50aWZ5aW5nIHdoZW4gZGVidWdnaW5nXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgIGdyb3VwID0gX3JlZjJbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N0YXRlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICBzdGF0ZSA9IF9yZWY0WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5TVEFURSxcbiAgICAgIHZhbHVlOiBzdGF0ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdpZCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICBpZCA9IF9yZWY2WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5JRCxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhpZClcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEwWzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0VYSVNULFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFsdWUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjExKSB7XG4gICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTJbMV0sXG4gICAgICAgIHZhbHVlID0gX3JlZjEyWzJdO1xuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0NPTVBBUkUsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQm9vbCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTMpIHtcbiAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgICB2YXJpYWJsZSA9IF9yZWYxNFsxXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9CT09MLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ25leHRRdWVyeScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcblxuICAgIGlmIChjdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICBsYXN0US5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgfVxuXG4gICAgbGFzdFEuZWRnZUNvdW50ID0gZWRnZUNvdW50O1xuICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBjb21wb3VuZENvdW50O1xuICAgIHNlbGVjdG9yLmVkZ2VDb3VudCA9IDA7XG4gICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCA9IDA7IC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcblxuICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgIHJldHVybiBuZXh0UXVlcnk7IC8vIHRoaXMgaXMgdGhlIG5ldyBxdWVyeSB0byBiZSBmaWxsZWQgYnkgdGhlIGZvbGxvd2luZyBleHByc1xuICB9XG59LCB7XG4gIG5hbWU6ICdkaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGlyZWN0ZWRFZGdlLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuRElSRUNURURfRURHRSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcblxuICAgICAgdmFyIF90YXJnZXQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICBzcmNUZ3RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX1NPVVJDRSxcbiAgICAgICAgc291cmNlOiBfc291cmNlLFxuICAgICAgICB0YXJnZXQ6IF90YXJnZXRcbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVpZ2hib3VyaG9vZFxuICAgICAgdmFyIG5ob29kUSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXJ5O1xuICAgICAgdmFyIG5laWdoYm9yID0gbmV3UXVlcnkoKTtcbiAgICAgIG5ob29kUS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTk9ERV9ORUlHSEJPUixcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgbmVpZ2hib3I6IG5laWdoYm9yXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnY2hpbGQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBwYXJlbnRDaGlsZFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9wYXJlbnQgPSBuZXdRdWVyeSgpOyAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuXG5cbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTsgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG5cbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuXG4gICAgICBfcGFyZW50LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gcGFyZW50IGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgcGFyZW50OiBfcGFyZW50LFxuICAgICAgICBjaGlsZDogX2NoaWxkIC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBjaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9wYXJlbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgcGNRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIHBhcmVudDogX3BhcmVudDIsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9wYXJlbnQyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcblxuICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBhbmNDaFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9hbmNlc3RvciA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgIF9hbmNlc3Rvci5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfSk7IC8vIGFuY2VzdG9yIGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudCAvLyBlbXB0eSBmb3Igbm93XG5cbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpOyAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG5cbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfZGVzY2VuZGFudDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBkZXNjZW5kYW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuY2VzdG9yIHF1ZXJ5XG4gICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgIHZhciBfYW5jZXN0b3IyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHZhciBhZFFDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yMixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9hbmNlc3RvcjIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdzdWJqZWN0JyxcbiAgbW9kaWZpZXI6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgIHZhciB0b3BRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRvcENoayA9IHRvcFEuY2hlY2tzWzBdO1xuICAgIHZhciB0b3BUeXBlID0gdG9wQ2hrID09IG51bGwgPyBudWxsIDogdG9wQ2hrLnR5cGU7XG5cbiAgICBpZiAodG9wVHlwZSA9PT0gVHlwZS5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyBkaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgdGFyZ2V0XG4gICAgICAvLyBjaGFuZ2UgdG8gdGFyZ2V0IG5vZGUgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX1RBUkdFVDtcbiAgICB9IGVsc2UgaWYgKHRvcFR5cGUgPT09IFR5cGUuVU5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSBzZWNvbmQgbm9kZVxuICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG5cbiAgICAgIHRvcENoay5uZWlnaGJvciA9IHRvcENoay5ub2Rlc1swXTsgLy8gY2xlYW4gdXAgdW51c2VkIGZpZWxkcyBmb3IgbmV3IHR5cGVcblxuICAgICAgdG9wQ2hrLm5vZGVzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1dO1xuZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZS5yZWdleE9iaiA9IG5ldyBSZWdFeHAoJ14nICsgZS5yZWdleCk7XG59KTtcblxuLyoqXG4gKiBPZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICogQHJldHVybnMgVGhlIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgdGhlIG5ld2x5IHJlbWFpbmluZyB0ZXh0IGB7IGV4cHIsIG1hdGNoLCBuYW1lLCByZW1haW5pbmcgfWBcbiAqL1xuXG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHI7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goZS5yZWdleE9iaik7XG5cbiAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICBtYXRjaCA9IG07XG4gICAgICBleHByID0gZTtcbiAgICAgIG5hbWUgPSBuO1xuICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cHI6IGV4cHIsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgfTtcbn07XG4vKipcbiAqIENvbnN1bWUgYWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHRleHQgdG8gY29uc3VtZVxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWRcbiAqL1xuXG5cbnZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZztcbn07XG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIHN0b3JlIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gaW4gdGhlIFNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2VsZWN0b3Igd2FzIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKi9cblxuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gIHNlbGYubGVuZ3RoID0gMTtcbiAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcblxuICAgIGlmIChleHBySW5mby5leHByID09IG51bGwpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2BpcyBpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gZXhwckluZm8ubWF0Y2guc2xpY2UoMSk7IC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCBpbiBjdXJyZW50UXVlcnlcblxuICAgICAgdmFyIHJldCA9IGV4cHJJbmZvLmV4cHIucG9wdWxhdGUoc2VsZiwgY3VycmVudFF1ZXJ5LCBhcmdzKTtcblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7IC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuXG4gICAgaWYgKHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcblxuICBpZiAoc2VsZi5jdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgbGFzdFEuc3ViamVjdCA9IHNlbGYuY3VycmVudFN1YmplY3Q7XG4gIH1cblxuICBsYXN0US5lZGdlQ291bnQgPSBzZWxmLmVkZ2VDb3VudDtcbiAgbGFzdFEuY29tcG91bmRDb3VudCA9IHNlbGYuY29tcG91bmRDb3VudDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcSA9IHNlbGZbaV07IC8vIGluIGZ1dHVyZSwgdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhbGxvd2VkIGlmIHRoZXJlIHdlcmUgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgZGV0ZWN0aW9uIG9mIGludmFsaWQgY29tYmluYXRpb25zXG5cbiAgICBpZiAocS5jb21wb3VuZENvdW50ID4gMCAmJiBxLmVkZ2VDb3VudCA+IDApIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgYm90aCBhIGNvbXBvdW5kIHNlbGVjdG9yIGFuZCBhbiBlZGdlIHNlbGVjdG9yJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG59O1xuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKi9cblxuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMudG9TdHJpbmdDYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmdDYWNoZTtcbiAgfVxuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xlYW5WYWwgPSBmdW5jdGlvbiBjbGVhblZhbCh2YWwpIHtcbiAgICBpZiAoc3RyaW5nKHZhbCkpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsICsgJ1wiJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsZWFuKHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHZhbCkge1xuICAgIHJldHVybiAnICcgKyB2YWwgKyAnICc7XG4gIH07XG5cbiAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFR5cGUuR1JPVVA6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBjbGVhbih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwLnN1YnN0cmluZygwLCBncm91cC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgICAgICAgcmV0dXJuICdbJyArIGZpZWxkICsgc3BhY2UoY2xlYW4ob3BlcmF0b3IpKSArIGNsZWFuVmFsKHZhbHVlKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9CT09MOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9FWElTVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmllbGQyID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbJyArIF9maWVsZDIgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLk1FVEFfQ09NUEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3BlcmF0b3IyID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5TVEFURTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuSUQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyMnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5QQVJFTlQ6XG4gICAgICBjYXNlIFR5cGUuQ0hJTEQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5wYXJlbnQsIHN1YmplY3QpICsgc3BhY2UoJz4nKSArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suY2hpbGQsIHN1YmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5BTkNFU1RPUjpcbiAgICAgIGNhc2UgVHlwZS5ERVNDRU5EQU5UOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2suYW5jZXN0b3IsIHN1YmplY3QpICsgJyAnICsgcXVlcnlUb1N0cmluZyhjaGVjay5kZXNjZW5kYW50LCBzdWJqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuVFJVRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uIHF1ZXJ5VG9TdHJpbmcocXVlcnksIHN1YmplY3QpIHtcbiAgICByZXR1cm4gcXVlcnkuY2hlY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaGssIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAoc3ViamVjdCA9PT0gcXVlcnkgJiYgaSA9PT0gMCA/ICckJyA6ICcnKSArIGNoZWNrVG9TdHJpbmcoY2hrLCBzdWJqZWN0KTtcbiAgICB9LCAnJyk7XG4gIH07XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG4gICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcocXVlcnksIHF1ZXJ5LnN1YmplY3QpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gIHJldHVybiBzdHI7XG59O1xudmFyIHBhcnNlJDEgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG52YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIoZmllbGRWYWwpO1xuICB2YXIgaXNWYWxTdHIgPSBzdHJpbmcodmFsdWUpO1xuICB2YXIgZmllbGRTdHIsIHZhbFN0cjtcbiAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG5cbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgIG5vdEV4cHIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gIH1cblxuICBpZiAoaXNGaWVsZFN0ciB8fCBpc1ZhbFN0ciB8fCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFN0ciA9ICFpc0ZpZWxkU3RyICYmICFpc0ZpZWxkTnVtID8gJycgOiAnJyArIGZpZWxkVmFsO1xuICAgIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gIH0gLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG5cblxuICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgZmllbGRWYWwgPSBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICcqPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID49IDA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyQ9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0ciwgZmllbGRTdHIubGVuZ3RoIC0gdmFsU3RyLmxlbmd0aCkgPj0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnXj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc+JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPCc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgfSAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuXG5cbiAgaWYgKG5vdEV4cHIgJiYgKGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCkpIHtcbiAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG52YXIgYm9vbENtcCA9IGZ1bmN0aW9uIGJvb2xDbXAoZmllbGRWYWwsIG9wZXJhdG9yKSB7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICc/JzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGNhc2UgJyEnOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgY2FzZSAnXic6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPT09IHVuZGVmaW5lZDtcbiAgfVxufTtcbnZhciBleGlzdENtcCA9IGZ1bmN0aW9uIGV4aXN0Q21wKGZpZWxkVmFsKSB7XG4gIHJldHVybiBmaWVsZFZhbCAhPT0gdW5kZWZpbmVkO1xufTtcbnZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG59O1xudmFyIG1ldGEgPSBmdW5jdGlvbiBtZXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZVtmaWVsZF0oKTtcbn07XG5cbi8qKiBBIGxvb2t1cCBvZiBgbWF0Y2goY2hlY2ssIGVsZSlgIGZ1bmN0aW9ucyBieSBgVHlwZWAgaW50ICovXG5cbnZhciBtYXRjaCA9IFtdO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgZm9yIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gcXVlcnkgVGhlIGB7IHR5cGUsIHZhbHVlLCAuLi4gfWAgcXVlcnkgb2JqZWN0XG4gKiBAcGFyYW0gZWxlIFRoZSBlbGVtZW50IHRvIGNvbXBhcmUgYWdhaW5zdFxuKi9cblxudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5HUk9VUF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZ3JvdXAgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGdyb3VwID09PSAnKicgfHwgZ3JvdXAgPT09IGVsZS5ncm91cCgpO1xufTtcblxubWF0Y2hbVHlwZS5TVEFURV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgc3RhdGVTZWxlY3RvciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc3RhdGVTZWxlY3RvciwgZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG59O1xuXG5tYXRjaFtUeXBlLkNMQVNTXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjbHMgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5oYXNDbGFzcyhjbHMpO1xufTtcblxubWF0Y2hbVHlwZS5NRVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChtZXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChkYXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0JPT0xdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gYm9vbENtcChkYXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvcik7XG59O1xuXG5tYXRjaFtUeXBlLkRBVEFfRVhJU1RdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gZXhpc3RDbXAoZGF0YShlbGUsIGZpZWxkKSk7XG59O1xuXG5tYXRjaFtUeXBlLlVORElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgcUEgPSBjaGVjay5ub2Rlc1swXTtcbiAgdmFyIHFCID0gY2hlY2subm9kZXNbMV07XG4gIHZhciBzcmMgPSBlbGUuc291cmNlKCk7XG4gIHZhciB0Z3QgPSBlbGUudGFyZ2V0KCk7XG4gIHJldHVybiBtYXRjaGVzKHFBLCBzcmMpICYmIG1hdGNoZXMocUIsIHRndCkgfHwgbWF0Y2hlcyhxQiwgc3JjKSAmJiBtYXRjaGVzKHFBLCB0Z3QpO1xufTtcblxubWF0Y2hbVHlwZS5OT0RFX05FSUdIQk9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLm5vZGUsIGVsZSkgJiYgZWxlLm5laWdoYm9yaG9vZCgpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzKGNoZWNrLm5laWdoYm9yLCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suc291cmNlLCBlbGUuc291cmNlKCkpICYmIG1hdGNoZXMoY2hlY2sudGFyZ2V0LCBlbGUudGFyZ2V0KCkpO1xufTtcblxubWF0Y2hbVHlwZS5OT0RFX1NPVVJDRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5zb3VyY2UsIGVsZSkgJiYgZWxlLm91dGdvZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMoY2hlY2sudGFyZ2V0LCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfVEFSR0VUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnRhcmdldCwgZWxlKSAmJiBlbGUuaW5jb21lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyhjaGVjay5zb3VyY2UsIG4pO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuQ0hJTERdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suY2hpbGQsIGVsZSkgJiYgbWF0Y2hlcyhjaGVjay5wYXJlbnQsIGVsZS5wYXJlbnQoKSk7XG59O1xuXG5tYXRjaFtUeXBlLlBBUkVOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5wYXJlbnQsIGVsZSkgJiYgZWxlLmNoaWxkcmVuKCkuc29tZShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBtYXRjaGVzKGNoZWNrLmNoaWxkLCBjKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkRFU0NFTkRBTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suZGVzY2VuZGFudCwgZWxlKSAmJiBlbGUuYW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBtYXRjaGVzKGNoZWNrLmFuY2VzdG9yLCBhKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkFOQ0VTVE9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLmFuY2VzdG9yLCBlbGUpICYmIGVsZS5kZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyhjaGVjay5kZXNjZW5kYW50LCBkKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkNPTVBPVU5EX1NQTElUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnN1YmplY3QsIGVsZSkgJiYgbWF0Y2hlcyhjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMoY2hlY2sucmlnaHQsIGVsZSk7XG59O1xuXG5tYXRjaFtUeXBlLlRSVUVdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1hdGNoW1R5cGUuQ09MTEVDVElPTl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbi5oYXMoZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuRklMVEVSXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWx0ZXIgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGZpbHRlcihlbGUpO1xufTtcblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZm9yIDEgaWQgI2ZvbyBxdWVyaWVzLCBqdXN0IGdldCB0aGUgZWxlbWVudFxuXG4gIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrcy5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3NbMF0udHlwZSA9PT0gVHlwZS5JRCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmdldEVsZW1lbnRCeUlkKHNlbGZbMF0uY2hlY2tzWzBdLnZhbHVlKS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgaWYgKG1hdGNoZXMocXVlcnksIGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihzZWxlY3RvckZ1bmN0aW9uKTtcbn07IC8vIGZpbHRlclxuLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xuXG5cbnZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzJDEoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgaWYgKG1hdGNoZXMocXVlcnksIGVsZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IC8vIG1hdGNoZXNcblxuXG52YXIgbWF0Y2hpbmcgPSB7XG4gIG1hdGNoZXM6IG1hdGNoZXMkMSxcbiAgZmlsdGVyOiBmaWx0ZXJcbn07XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRoaXMuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHRoaXMuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICB0aGlzLmNvbXBvdW5kQ291bnQgPSAwO1xuICB0aGlzLmVkZ2VDb3VudCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZm4oc2VsZWN0b3IpKSB7XG4gICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICBjaGVja3M6IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuRklMVEVSLFxuICAgICAgICB2YWx1ZTogc2VsZWN0b3JcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHNlbGVjdG9yKSkge1xuICAgIGlmICghdGhpcy5wYXJzZShzZWxlY3RvcikpIHtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnKTtcbiAgfVxufTtcblxudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuW3BhcnNlJDEsIG1hdGNoaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBleHRlbmQoc2VsZm4sIHApO1xufSk7XG5cbnNlbGZuLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlucHV0VGV4dDtcbn07XG5cbnNlbGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbnNlbGZuLmVxID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuXG5zZWxmbi5zYW1lVGV4dCA9IGZ1bmN0aW9uIChvdGhlclNlbCkge1xuICByZXR1cm4gIXRoaXMuaW52YWxpZCAmJiAhb3RoZXJTZWwuaW52YWxpZCAmJiB0aGlzLnRleHQoKSA9PT0gb3RoZXJTZWwudGV4dCgpO1xufTtcblxuc2VsZm4uYWRkUXVlcnkgPSBmdW5jdGlvbiAocSkge1xuICB0aGlzW3RoaXMubGVuZ3RoKytdID0gcTtcbn07XG5cbnNlbGZuLnNlbGVjdG9yID0gc2VsZm4udG9TdHJpbmc7XG5cbnZhciBlbGVzZm4kZiA9IHtcbiAgYWxsQXJlOiBmdW5jdGlvbiBhbGxBcmUoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgc2FtZTogZnVuY3Rpb24gc2FtZShjb2xsZWN0aW9uKSB7XG4gICAgLy8gY2hlYXAgY29sbGVjdGlvbiByZWYgY2hlY2tcbiAgICBpZiAodGhpcyA9PT0gY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDsgLy8gY2hlYXAgbGVuZ3RoIGNoZWNrXG5cbiAgICBpZiAodGhpc0xlbmd0aCAhPT0gY29sbGVjdGlvbkxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2hlYXAgZWxlbWVudCByZWYgY2hlY2tcblxuXG4gICAgaWYgKHRoaXNMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID09PSBjb2xsZWN0aW9uWzBdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbnlTYW1lOiBmdW5jdGlvbiBhbnlTYW1lKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiBhbGxBcmVOZWlnaGJvcnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgbmhvb2QgPSB0aGlzLm5laWdoYm9yaG9vZCgpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBuaG9vZC5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxmLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9XG59O1xuZWxlc2ZuJGYuYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbiRmLmFsbEFyZU5laWdoYm9ycztcbmVsZXNmbiRmLmhhcyA9IGVsZXNmbiRmLmNvbnRhaW5zO1xuZWxlc2ZuJGYuZXF1YWwgPSBlbGVzZm4kZi5lcXVhbHMgPSBlbGVzZm4kZi5zYW1lO1xuXG52YXIgY2FjaGUgPSBmdW5jdGlvbiBjYWNoZShmbiwgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAga2V5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yT3JFbGVzKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGtleSA9IHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAxICYmIGtleSkge1xuICAgICAgdmFyIF9wID0gZWxlc1swXS5fcHJpdmF0ZTtcbiAgICAgIHZhciB0Y2ggPSBfcC50cmF2ZXJzYWxDYWNoZSA9IF9wLnRyYXZlcnNhbENhY2hlIHx8IHt9O1xuICAgICAgdmFyIGNoID0gdGNoW25hbWVdID0gdGNoW25hbWVdIHx8IFtdO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgICB2YXIgY2FjaGVIaXQgPSBjaFtoYXNoXTtcblxuICAgICAgaWYgKGNhY2hlSGl0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZUhpdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaFtoYXNoXSA9IGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBlbGVzZm4kZyA9IHtcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdOyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1swXS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgd2hpbGUgKGVsZXMubm9uZW1wdHkoKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBwYXJlbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cblxuICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiBjb21tb25BbmNlc3RvcnMoc2VsZWN0b3IpIHtcbiAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdChwYXJlbnRzKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG9ycGhhbnM6IGZ1bmN0aW9uIG9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY2hpbGRyZW46IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBlbGVDaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGVsZUNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihjaGlsZHJlbiwge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2NoaWxkcmVuJyksXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGRsZXNzOiBmdW5jdGlvbiBpc0NoaWxkbGVzcygpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGlzT3JwaGFuOiBmdW5jdGlvbiBpc09ycGhhbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCA9PSBudWxsO1xuICAgIH1cbiAgfSxcbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmdW5jdGlvbiBhZGQoZWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG5cbiAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkKHRoaXMuY2hpbGRyZW4oKSk7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvckVhY2hDb21wb3VuZChlbGVzLCBmbiwgaW5jbHVkZVNlbGYsIHJlY3Vyc2l2ZVN0ZXApIHtcbiAgdmFyIHEgPSBbXTtcbiAgdmFyIGRpZCA9IG5ldyBTZXQkMSgpO1xuICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHEucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgZWxlKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIF9lbGUgPSBxLnNoaWZ0KCk7XG5cbiAgICBmbihfZWxlKTtcbiAgICBkaWQuYWRkKF9lbGUuaWQoKSk7XG5cbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgX2VsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZXM7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoIWRpZC5oYXMoY2hpbGQuaWQoKSkpIHtcbiAgICAgICAgcS5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gdmVyeSBlZmZpY2llbnQgdmVyc2lvbiBvZiBlbGVzLmFkZCggZWxlcy5kZXNjZW5kYW50cygpICkuZm9yRWFjaCgpXG4vLyBmb3IgaW50ZXJuYWwgdXNlXG5cblxuZWxlc2ZuJGcuZm9yRWFjaERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkQ2hpbGRyZW4pO1xufTtcblxuZnVuY3Rpb24gYWRkUGFyZW50KHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNDaGlsZCgpKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICBpZiAoIWRpZC5oYXMocGFyZW50LmlkKCkpKSB7XG4gICAgICBxLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cbn1cblxuZWxlc2ZuJGcuZm9yRWFjaFVwID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudCk7XG59O1xuXG5mdW5jdGlvbiBhZGRQYXJlbnRBbmRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICBhZGRQYXJlbnQocSwgZGlkLCBlbGUpO1xuICBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSk7XG59XG5cbmVsZXNmbiRnLmZvckVhY2hVcEFuZERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50QW5kQ2hpbGRyZW4pO1xufTsgLy8gYWxpYXNlc1xuXG5cbmVsZXNmbiRnLmFuY2VzdG9ycyA9IGVsZXNmbiRnLnBhcmVudHM7XG5cbnZhciBmbiQxLCBlbGVzZm4kaDtcbmZuJDEgPSBlbGVzZm4kaCA9IHtcbiAgZGF0YTogZGVmaW5lJDMuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZSQzLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICBzY3JhdGNoOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJzY3JhdGNoOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVSc2NyYXRjaDogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9KSxcbiAgaWQ6IGZ1bmN0aW9uIGlkKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5mbiQxLmF0dHIgPSBmbiQxLmRhdGE7XG5mbiQxLnJlbW92ZUF0dHIgPSBmbiQxLnJlbW92ZURhdGE7XG52YXIgZGF0YSQxID0gZWxlc2ZuJGg7XG5cbnZhciBlbGVzZm4kaSA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiRpLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oaW5jbHVkZUxvb3BzKTtcblxuICAgICAgaWYgKGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpKSB7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJGksIHtcbiAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcbmV4dGVuZChlbGVzZm4kaSwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24gdG90YWxEZWdyZWUoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoaW5jbHVkZUxvb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbn0pO1xuXG52YXIgZm4kMiwgZWxlc2ZuJGo7XG5cbnZhciBiZWZvcmVQb3NpdGlvblNldCA9IGZ1bmN0aW9uIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1Bvcywgc2lsZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKCFlbGUubG9ja2VkKCkpIHtcbiAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgIHg6IG5ld1Bvcy54ICE9IG51bGwgPyBuZXdQb3MueCAtIG9sZFBvcy54IDogMCxcbiAgICAgICAgeTogbmV3UG9zLnkgIT0gbnVsbCA/IG5ld1Bvcy55IC0gb2xkUG9zLnkgOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGUuc2hpZnRDYWNoZWRCb3VuZGluZ0JveChkZWx0YSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcG9zaXRpb25EZWYgPSB7XG4gIGZpZWxkOiAncG9zaXRpb24nLFxuICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgfSxcbiAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBmYWxzZSk7XG4gIH0sXG4gIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgfSxcbiAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn07XG5mbiQyID0gZWxlc2ZuJGogPSB7XG4gIHBvc2l0aW9uOiBkZWZpbmUkMy5kYXRhKHBvc2l0aW9uRGVmKSxcbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lJDMuZGF0YShleHRlbmQoe30sIHBvc2l0aW9uRGVmLCB7XG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHRydWUpO1xuICAgIH1cbiAgfSkpLFxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhwb3MsIHNpbGVudCkge1xuICAgIGlmIChwbGFpbk9iamVjdChwb3MpKSB7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHRoaXMuc2lsZW50UG9zaXRpb24ocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZuKHBvcykpIHtcbiAgICAgIHZhciBfZm4gPSBwb3M7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICB2YXIgX3BvcyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoX3BvcyA9IF9mbihlbGUsIGkpKSB7XG4gICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgIHZhciBkZWx0YTtcblxuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogbnVtYmVyKGRpbS54KSA/IGRpbS54IDogMCxcbiAgICAgICAgeTogbnVtYmVyKGRpbS55KSA/IGRpbS55IDogMFxuICAgICAgfTtcbiAgICAgIHNpbGVudCA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlcih2YWwpKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGRlbHRhW2RpbV0gPSB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuZXdQb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgIHk6IHBvcy55ICsgZGVsdGEueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzaWxlbnRTaGlmdDogZnVuY3Rpb24gc2lsZW50U2hpZnQoZGltLCB2YWwpIHtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyKHZhbCkpIHtcbiAgICAgIHRoaXMuc2hpZnQoZGltLCB2YWwsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24gcmVuZGVyZWRQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHJwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuXG4gICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24oZGltLCAodmFsIC0gcGFuW2RpbV0pIC8gem9vbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChycG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICBycG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocG9zLCB6b29tLCBwYW4pO1xuXG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiByZWxhdGl2ZVBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBwcG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZTIgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gX2VsZTIucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIF9oYXNQYXJlbnQgPSBfcGFyZW50ICYmIF9wYXJlbnQubGVuZ3RoID4gMDtcblxuICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuXG4gICAgICAgIGlmIChfaGFzUGFyZW50KSB7XG4gICAgICAgICAgX3BhcmVudCA9IF9wYXJlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX29yaWdpbiA9IF9yZWxhdGl2ZVRvUGFyZW50ID8gX3BhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBfb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBfb3JpZ2luLnlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBwcG9zW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH1cbn07IC8vIGFsaWFzZXNcblxuZm4kMi5tb2RlbFBvc2l0aW9uID0gZm4kMi5wb2ludCA9IGZuJDIucG9zaXRpb247XG5mbiQyLm1vZGVsUG9zaXRpb25zID0gZm4kMi5wb2ludHMgPSBmbiQyLnBvc2l0aW9ucztcbmZuJDIucmVuZGVyZWRQb2ludCA9IGZuJDIucmVuZGVyZWRQb3NpdGlvbjtcbmZuJDIucmVsYXRpdmVQb2ludCA9IGZuJDIucmVsYXRpdmVQb3NpdGlvbjtcbnZhciBwb3NpdGlvbiA9IGVsZXNmbiRqO1xuXG52YXIgZm4kMywgZWxlc2ZuJGs7XG5mbiQzID0gZWxlc2ZuJGsgPSB7fTtcblxuZWxlc2ZuJGsucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHgyOiB4MixcbiAgICB5MTogeTEsXG4gICAgeTI6IHkyLFxuICAgIHc6IHgyIC0geDEsXG4gICAgaDogeTIgLSB5MVxuICB9O1xufTtcblxuZWxlc2ZuJGsuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLmZvckVhY2hVcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gZmFsc2U7XG4gICAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmVsZXNmbiRrLnVwZGF0ZUNvbXBvdW5kQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIG5vdCBwb3NzaWJsZSB0byBkbyBvbiBub24tY29tcG91bmQgZ3JhcGhzIG9yIHdpdGggdGhlIHN0eWxlIGRpc2FibGVkXG5cbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBiYXRjaGluZyAtLSBidXQgYm91bmRzIHdpbGwgYmUgc3RhbGUgKG9yIG5vdCBleGlzdCB5ZXQpXG5cblxuICBpZiAoIWZvcmNlICYmIGN5LmJhdGNoaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudC5pc1BhcmVudCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9wID0gcGFyZW50Ll9wcml2YXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgIHZhciBpbmNsdWRlTGFiZWxzID0gcGFyZW50LnBzdHlsZSgnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnKS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgIHZhciBtaW4gPSB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGxlZnQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLWxlZnQnKSxcbiAgICAgICAgcmlnaHQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLXJpZ2h0JylcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0JykucGZWYWx1ZSxcbiAgICAgICAgdG9wOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtdG9wJyksXG4gICAgICAgIGJvdHRvbTogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLWJvdHRvbScpXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7XG4gICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcbiAgICAgIC8vIHVwZGF0aW5nIHRoZSBjb21wb3VuZCBib3VuZHMgaGFwcGVucyBvdXRzaWRlIG9mIHRoZSByZWd1bGFyXG4gICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uOyAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgYmIgPSB7XG4gICAgICAgIHc6IHBhcmVudC5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgaDogcGFyZW50LnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZVxuICAgICAgfTtcbiAgICAgIGJiLngxID0gcG9zLnggLSBiYi53IC8gMjtcbiAgICAgIGJiLngyID0gcG9zLnggKyBiYi53IC8gMjtcbiAgICAgIGJiLnkxID0gcG9zLnkgLSBiYi5oIC8gMjtcbiAgICAgIGJiLnkyID0gcG9zLnkgKyBiYi5oIC8gMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQmlhc1ZhbHVlcyhwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCkge1xuICAgICAgdmFyIGJpYXNEaWZmID0gMDtcbiAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuXG4gICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmlhc0RpZmY6IGJpYXNEaWZmLFxuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmY6IGJpYXNDb21wbGVtZW50RGlmZlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUGFkZGluZ1ZhbHVlcyh3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nT2JqZWN0LCByZWxhdGl2ZVRvKSB7XG4gICAgICAvLyBBc3N1bWluZyBwZXJjZW50YWdlIGlzIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICclJykge1xuICAgICAgICBzd2l0Y2ggKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcblxuICAgICAgICAgIGNhc2UgJ2F2ZXJhZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogKHdpZHRoICsgaGVpZ2h0KSAvIDIgOiAwO1xuXG4gICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdPYmplY3QucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG5cbiAgICBpZiAobWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIGxlZnRWYWwgPSBsZWZ0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG5cbiAgICB2YXIgcmlnaHRWYWwgPSBtaW4ud2lkdGgucmlnaHQudmFsdWU7XG5cbiAgICBpZiAobWluLndpZHRoLnJpZ2h0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICByaWdodFZhbCA9IHJpZ2h0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG5cbiAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG5cbiAgICBpZiAobWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICB0b3BWYWwgPSB0b3BWYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG5cbiAgICB2YXIgYm90dG9tVmFsID0gbWluLmhlaWdodC5ib3R0b20udmFsdWU7XG5cbiAgICBpZiAobWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICBib3R0b21WYWwgPSBib3R0b21WYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGhCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmUmlnaHQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi5oZWlnaHQudmFsIC0gYmIuaCwgdG9wVmFsLCBib3R0b21WYWwpO1xuICAgIHZhciBkaWZmVG9wID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICBfcC5hdXRvUGFkZGluZyA9IGNvbXB1dGVQYWRkaW5nVmFsdWVzKGJiLncsIGJiLmgsIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmcnKSwgcGFyZW50LnBzdHlsZSgncGFkZGluZy1yZWxhdGl2ZS10bycpLnZhbHVlKTtcbiAgICBfcC5hdXRvV2lkdGggPSBNYXRoLm1heChiYi53LCBtaW4ud2lkdGgudmFsKTtcbiAgICBwb3MueCA9ICgtZGlmZkxlZnQgKyBiYi54MSArIGJiLngyICsgZGlmZlJpZ2h0KSAvIDI7XG4gICAgX3AuYXV0b0hlaWdodCA9IE1hdGgubWF4KGJiLmgsIG1pbi5oZWlnaHQudmFsKTtcbiAgICBwb3MueSA9ICgtZGlmZlRvcCArIGJiLnkxICsgYmIueTIgKyBkaWZmQm90dG9tKSAvIDI7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4pIHtcbiAgICAgIHVwZGF0ZShlbGUpO1xuXG4gICAgICBpZiAoIWN5LmJhdGNoaW5nKCkpIHtcbiAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzKGIsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICBpZiAoeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRvbid0IHVwZGF0ZSB3aXRoIG51bGwgZGltXG5cblxuICBpZiAoeDEgPT0gbnVsbCB8fCB5MSA9PSBudWxsIHx8IHgyID09IG51bGwgfHwgeTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGIueDEgPSB4MSA8IGIueDEgPyB4MSA6IGIueDE7XG4gIGIueDIgPSB4MiA+IGIueDIgPyB4MiA6IGIueDI7XG4gIGIueTEgPSB5MSA8IGIueTEgPyB5MSA6IGIueTE7XG4gIGIueTIgPSB5MiA+IGIueTIgPyB5MiA6IGIueTI7XG4gIGIudyA9IGIueDIgLSBiLngxO1xuICBiLmggPSBiLnkyIC0gYi55MTtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUJveChiLCBiMikge1xuICBpZiAoYjIgPT0gbnVsbCkge1xuICAgIHJldHVybiBiO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUJvdW5kcyhiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55Mik7XG59O1xuXG52YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KSB7XG4gIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCk7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiAoYXJyb3dUeXBlICE9PSAnbm9uZScpIHtcbiAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAndGFyZ2V0Jykge1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfSAvLyBhbHdheXMgc3RvcmUgdGhlIGluZGl2aWR1YWwgYXJyb3cgYm91bmRzXG5cblxuICAgIHZhciBiYnMgPSBfcC5hcnJvd0JvdW5kcyA9IF9wLmFycm93Qm91bmRzIHx8IHt9O1xuICAgIHZhciBiYiA9IGJic1twcmVmaXhdID0gYmJzW3ByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSB4IC0gaGFsZkFyVztcbiAgICBiYi55MSA9IHkgLSBoYWxmQXJXO1xuICAgIGJiLngyID0geCArIGhhbGZBclc7XG4gICAgYmIueTIgPSB5ICsgaGFsZkFyVztcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYiwgMSk7XG4gICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYmIueDEsIGJiLnkxLCBiYi54MiwgYmIueTIpO1xuICB9XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4RGFzaDtcblxuICBpZiAocHJlZml4KSB7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuXG5cbiAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmc7XG4gICAgbHgyICs9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nO1xuICAgIGx5MSArPSBtYXJnaW5ZIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZztcbiAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmc7IC8vIGFsd2F5cyBzdG9yZSB0aGUgdW5yb3RhdGVkIGxhYmVsIGJvdW5kcyBzZXBhcmF0ZWx5XG5cbiAgICB2YXIgYmJQcmVmaXggPSBwcmVmaXggfHwgJ21haW4nO1xuICAgIHZhciBiYnMgPSBfcC5sYWJlbEJvdW5kcztcbiAgICB2YXIgYmIgPSBiYnNbYmJQcmVmaXhdID0gYmJzW2JiUHJlZml4XSB8fCB7fTtcbiAgICBiYi54MSA9IGx4MTtcbiAgICBiYi55MSA9IGx5MTtcbiAgICBiYi54MiA9IGx4MjtcbiAgICBiYi55MiA9IGx5MjtcbiAgICBiYi53ID0gbHgyIC0gbHgxO1xuICAgIGJiLmggPSBseTIgLSBseTE7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuXG4gICAgaWYgKGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUpIHtcbiAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxBbmdsZScsIHByZWZpeCkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7IC8vIHJvdGF0aW9uIHBvaW50IChkZWZhdWx0IHZhbHVlIGZvciBjZW50ZXItY2VudGVyKVxuXG4gICAgICB2YXIgeG8gPSAobHgxICsgbHgyKSAvIDI7XG4gICAgICB2YXIgeW8gPSAobHkxICsgbHkyKSAvIDI7XG5cbiAgICAgIGlmICghaXNFZGdlKSB7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB4byA9IGx4MjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeG8gPSBseDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHlvID0gbHkyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgeW8gPSBseTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSB4bztcbiAgICAgICAgeSA9IHkgLSB5bztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIHhvLFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgeW9cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICBseDEgPSBNYXRoLm1pbihweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgIGx4MiA9IE1hdGgubWF4KHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHkxID0gTWF0aC5taW4ocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgICBseTIgPSBNYXRoLm1heChweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICB9XG5cbiAgICB2YXIgYmJQcmVmaXhSb3QgPSBiYlByZWZpeCArICdSb3QnO1xuICAgIHZhciBiYlJvdCA9IGJic1tiYlByZWZpeFJvdF0gPSBiYnNbYmJQcmVmaXhSb3RdIHx8IHt9O1xuICAgIGJiUm90LngxID0gbHgxO1xuICAgIGJiUm90LnkxID0gbHkxO1xuICAgIGJiUm90LngyID0gbHgyO1xuICAgIGJiUm90LnkyID0gbHkyO1xuICAgIGJiUm90LncgPSBseDIgLSBseDE7XG4gICAgYmJSb3QuaCA9IGx5MiAtIGx5MTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgIHVwZGF0ZUJvdW5kcyhfcC5sYWJlbEJvdW5kcy5hbGwsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTsgLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG5cblxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gIHZhciBoZWFkbGVzcyA9IGN5LmhlYWRsZXNzKCk7XG4gIHZhciBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyOyAvLyBleHRyZW1hIG9mIGJvZHkgLyBsaW5lc1xuXG4gIHZhciB4LCB5OyAvLyBub2RlIHBvc1xuXG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBtYW51YWxFeHBhbnNpb24gPSBpc05vZGUgJiYgc3R5bGVFbmFibGVkID8gZWxlLnBzdHlsZSgnYm91bmRzLWV4cGFuc2lvbicpLnBmVmFsdWUgOiBbMF07IC8vIG11c3QgdXNlIGBkaXNwbGF5YCBwcm9wIG9ubHksIGFzIHJlYWRpbmcgYGNvbXBvdW5kLndpZHRoKClgIGNhdXNlcyByZWN1cnNpb25cbiAgLy8gKG90aGVyIGZhY3RvcnMgbGlrZSB3aWR0aCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb24gYW55d2F5KVxuXG4gIHZhciBpc0Rpc3BsYXllZCA9IGZ1bmN0aW9uIGlzRGlzcGxheWVkKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgIT09ICdub25lJztcbiAgfTtcblxuICB2YXIgZGlzcGxheWVkID0gIXN0eWxlRW5hYmxlZCB8fCBpc0Rpc3BsYXllZChlbGUpIC8vIG11c3QgdGFrZSBpbnRvIGFjY291bnQgY29ubmVjdGVkIG5vZGVzIGIvYyBvZiBpbXBsaWNpdCBlZGdlIGhpZGluZyBvbiBkaXNwbGF5Om5vbmUgbm9kZVxuICAmJiAoIWlzRWRnZSB8fCBpc0Rpc3BsYXllZChlbGUuc291cmNlKCkpICYmIGlzRGlzcGxheWVkKGVsZS50YXJnZXQoKSkpO1xuXG4gIGlmIChkaXNwbGF5ZWQpIHtcbiAgICAvLyBkaXNwbGF5ZWQgc3VmZmljZXMsIHNpbmNlIHdlIHdpbGwgZmluZCB6ZXJvIGFyZWEgZWxlcyBhbnl3YXlcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IDA7XG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICBpZiAob3ZlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIHdIYWxmID0gMDtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHcgPSBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB3SGFsZiA9IHcgLyAyO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMpIHtcbiAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcblxuICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcblxuICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyOyAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgIGV5MiA9IHkgKyBoYWxmSDtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTsgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0gTWF0aC5taW4ocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV4MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICBleTEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7IC8vIHByZWNpc2UgZWRnZXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgICBpZiAoaHB0cyAmJiBocHRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgICAgZXkxID0gaHB0c1swXS55O1xuICAgICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgICAgdmFyIF90ZW1wID0gZXkxO1xuICAgICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnZlU3R5bGUgPT09ICdiZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICAgIHZhciBwdHM7XG5cbiAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3RheGknOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG4gICAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gcHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcbiAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmV6aWVyLWxpa2Ugb3Igc2VnbWVudC1saWtlIGVkZ2VcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcbiAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMiA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gX3RlbXAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgIHZhciBfdGVtcDMgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgfSAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG5cblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG5cbiAgICB9IC8vIGVkZ2VzXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyAmJiBpc0VkZ2UpIHtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC10YXJnZXQnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgfSAvLyBnaG9zdFxuICAgIC8vLy8vLy8vXG5cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJvdW5kcy54MSArIGd4LCBib3VuZHMueTEgKyBneSwgYm91bmRzLngyICsgZ3gsIGJvdW5kcy55MiArIGd5KTtcbiAgICAgIH1cbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgdmFyIGJiQm9keSA9IF9wLmJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiQm9keSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiQm9keSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYkJvZHksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgLy8gb3ZlcmxheVxuICAgIC8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIG92ZXJsYXlQYWRkaW5nLCBleTEgLSBvdmVybGF5UGFkZGluZywgZXgyICsgb3ZlcmxheVBhZGRpbmcsIGV5MiArIG92ZXJsYXlQYWRkaW5nKTtcbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgdmFyIGJiT3ZlcmxheSA9IF9wLm92ZXJsYXlCb3VuZHMgPSBfcC5vdmVybGF5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiT3ZlcmxheSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiT3ZlcmxheSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYk92ZXJsYXksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIGJiTGFiZWxzID0gX3AubGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyB8fCB7fTtcblxuICAgIGlmIChiYkxhYmVscy5hbGwgIT0gbnVsbCkge1xuICAgICAgY2xlYXJCb3VuZGluZ0JveChiYkxhYmVscy5hbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYkxhYmVscy5hbGwgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcblxuICBpZiAoYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQpIHtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJvdW5kcywgbWFudWFsRXhwYW5zaW9uKTsgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG5cbiAgICBleHBhbmRCb3VuZGluZ0JveChib3VuZHMsIDEpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICB2YXIgaSA9IDA7XG5cbiAgdmFyIHRmID0gZnVuY3Rpb24gdGYodmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPyAxIDogMCkgPDwgaSsrO1xuICB9O1xuXG4gIHZhciBrZXkgPSAwO1xuICBrZXkgKz0gdGYob3B0cy5pbmN1ZGVOb2Rlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVFZGdlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTWFpbkxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU92ZXJsYXlzKTtcbiAgcmV0dXJuIGtleTtcbn07XG5cbnZhciBnZXRCb3VuZGluZ0JveFBvc0tleSA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdmFyIHAxID0gZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHAyID0gZWxlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG5cbiAgICB2YXIgciA9IGZ1bmN0aW9uIHIoeCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XG4gICAgfTtcblxuICAgIHJldHVybiBoYXNoSW50c0FycmF5KFtyKHAxLngpLCByKHAxLnkpLCByKHAyLngpLCByKHAyLnkpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbnZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGJiO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIga2V5ID0gb3B0cyA9PSBudWxsID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KG9wdHMpO1xuICB2YXIgdXNpbmdEZWZPcHRzID0ga2V5ID09PSBkZWZCYk9wdHNLZXk7XG4gIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lO1xuXG4gIHZhciBpc0RpcnR5ID0gZnVuY3Rpb24gaXNEaXJ0eShlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJiQ2FjaGUgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgbmVlZFJlY2FsYyA9ICF1c2VDYWNoZSB8fCBpc0RpcnR5KGVsZSkgfHwgaXNFZGdlICYmIGlzRGlydHkoZWxlLnNvdXJjZSgpKSB8fCBpc0RpcnR5KGVsZS50YXJnZXQoKSk7XG5cbiAgaWYgKG5lZWRSZWNhbGMpIHtcbiAgICBpZiAoIWlzUG9zS2V5U2FtZSkge1xuICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSgpO1xuICAgIH1cblxuICAgIGJiID0gYm91bmRpbmdCb3hJbXBsKGVsZSwgZGVmQmJPcHRzKTtcbiAgICBfcC5iYkNhY2hlID0gYmI7XG4gICAgX3AuYmJDYWNoZVNoaWZ0LnggPSBfcC5iYkNhY2hlU2hpZnQueSA9IDA7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IGN1cnJQb3NLZXk7XG4gIH0gZWxzZSB7XG4gICAgYmIgPSBfcC5iYkNhY2hlO1xuICB9XG5cbiAgaWYgKCFuZWVkUmVjYWxjICYmIChfcC5iYkNhY2hlU2hpZnQueCAhPT0gMCB8fCBfcC5iYkNhY2hlU2hpZnQueSAhPT0gMCkpIHtcbiAgICB2YXIgc2hpZnQgPSBhc3NpZ25TaGlmdFRvQm91bmRpbmdCb3g7XG4gICAgdmFyIGRlbHRhID0gX3AuYmJDYWNoZVNoaWZ0O1xuXG4gICAgdmFyIHNhZmVTaGlmdCA9IGZ1bmN0aW9uIHNhZmVTaGlmdChiYiwgZGVsdGEpIHtcbiAgICAgIGlmIChiYiAhPSBudWxsKSB7XG4gICAgICAgIHNoaWZ0KGJiLCBkZWx0YSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNoaWZ0KGJiLCBkZWx0YSk7XG4gICAgdmFyIGJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzLFxuICAgICAgICBvdmVybGF5Qm91bmRzID0gX3Aub3ZlcmxheUJvdW5kcyxcbiAgICAgICAgbGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyxcbiAgICAgICAgYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcztcbiAgICBzYWZlU2hpZnQoYm9keUJvdW5kcywgZGVsdGEpO1xuICAgIHNhZmVTaGlmdChvdmVybGF5Qm91bmRzLCBkZWx0YSk7XG5cbiAgICBpZiAoYXJyb3dCb3VuZHMgIT0gbnVsbCkge1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzLnNvdXJjZSwgZGVsdGEpO1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzLnRhcmdldCwgZGVsdGEpO1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzWydtaWQtc291cmNlJ10sIGRlbHRhKTtcbiAgICAgIHNhZmVTaGlmdChhcnJvd0JvdW5kc1snbWlkLXRhcmdldCddLCBkZWx0YSk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsQm91bmRzICE9IG51bGwpIHtcbiAgICAgIHNhZmVTaGlmdChsYWJlbEJvdW5kcy5tYWluLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMuYWxsLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMuc291cmNlLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMudGFyZ2V0LCBkZWx0YSk7XG4gICAgfVxuICB9IC8vIGFsd2F5cyByZXNldCB0aGUgc2hpZnQsIGJlY2F1c2Ugd2UgZWl0aGVyIGFwcGxpZWQgdGhlIHNoaWZ0IG9yIGNsZWFyZWQgaXQgYnkgZG9pbmcgYSBmcmVzaCByZWNhbGNcblxuXG4gIF9wLmJiQ2FjaGVTaGlmdC54ID0gX3AuYmJDYWNoZVNoaWZ0LnkgPSAwOyAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcblxuICBpZiAoIXVzaW5nRGVmT3B0cykge1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVOb2RlcyAmJiBpc05vZGUgfHwgb3B0cy5pbmNsdWRlRWRnZXMgJiYgIWlzTm9kZSkge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLm92ZXJsYXlCb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AuYm9keUJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMgJiYgKCFpc0VkZ2UgfHwgb3B0cy5pbmNsdWRlU291cmNlTGFiZWxzICYmIG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuYWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMubWFpblJvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuc291cmNlUm90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cblxuICByZXR1cm4gYmI7XG59O1xuXG52YXIgZGVmQmJPcHRzID0ge1xuICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU1haW5MYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVTb3VyY2VMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVUYXJnZXRMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVPdmVybGF5czogdHJ1ZSxcbiAgdXNlQ2FjaGU6IHRydWVcbn07XG52YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KGRlZkJiT3B0cyk7XG52YXIgZmlsbGVkQmJPcHRzID0gZGVmYXVsdHMoZGVmQmJPcHRzKTtcblxuZWxlc2ZuJGsuYm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYm91bmRzOyAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLl9wcml2YXRlLmJiQ2FjaGUgIT0gbnVsbCAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYm91bmRzID0gY2FjaGVkQm91bmRpbmdCb3hJbXBsKHRoaXNbMF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZkJiT3B0cztcbiAgICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgY3VyclBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gICAgICAgIHZhciBpc1Bvc0tleVNhbWUgPSBfcC5iYkNhY2hlUG9zS2V5ID09PSBjdXJyUG9zS2V5O1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSBvcHRzLnVzZUNhY2hlICYmIGlzUG9zS2V5U2FtZTtcbiAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2VsZSA9IGVsZXNbX2ldO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbChfZWxlLCBvcHRzKSk7XG4gICAgfVxuICB9XG5cbiAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gIHJldHVybiBib3VuZHM7XG59O1xuXG5lbGVzZm4kay5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcCA9IHRoaXNbaV0uX3ByaXZhdGU7XG4gICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgX3AuYmJDYWNoZVNoaWZ0LnggPSBfcC5iYkNhY2hlU2hpZnQueSA9IDA7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IG51bGw7XG4gICAgX3AuYm9keUJvdW5kcyA9IG51bGw7XG4gICAgX3Aub3ZlcmxheUJvdW5kcyA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuYWxsID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpbiA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuc291cmNlUm90ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXNvdXJjZSddID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXRhcmdldCddID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZWxlc2ZuJGsuc2hpZnRDYWNoZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGJiID0gX3AuYmJDYWNoZTtcblxuICAgIGlmIChiYiAhPSBudWxsKSB7XG4gICAgICBfcC5iYkNhY2hlU2hpZnQueCArPSBkZWx0YS54O1xuICAgICAgX3AuYmJDYWNoZVNoaWZ0LnkgKz0gZGVsdGEueTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHByaXZhdGUgaGVscGVyIHRvIGdldCBib3VuZGluZyBib3ggZm9yIGN1c3RvbSBub2RlIHBvc2l0aW9uc1xuLy8gLSBnb29kIGZvciBwZXJmIGluIGNlcnRhaW4gY2FzZXMgYnV0IGN1cnJlbnRseSByZXF1aXJlcyBkaXJ0eWluZyB0aGUgcmVuZGVyZWQgc3R5bGVcbi8vIC0gd291bGQgYmUgYmV0dGVyIHRvIG5vdCBtb2RpZnkgdGhlIG5vZGVzIGJ1dCB0aGUgbm9kZXMgYXJlIHJlYWQgZGlyZWN0bHkgZXZlcnl3aGVyZSBpbiB0aGUgcmVuZGVyZXIuLi5cbi8vIC0gdHJ5IHRvIHVzZSBmb3Igb25seSB0aGluZ3MgbGlrZSBkaXNjcmV0ZSBsYXlvdXRzIHdoZXJlIHRoZSBub2RlIHBvc2l0aW9uIHdvdWxkIGNoYW5nZSBhbnl3YXlcblxuXG5lbGVzZm4kay5ib3VuZGluZ0JveEF0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwbGFpbk9iamVjdChmbikpIHtcbiAgICB2YXIgb2JqID0gZm47XG5cbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0b3JlT2xkUG9zID0gZnVuY3Rpb24gc3RvcmVPbGRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3MgPSBmbihub2RlLCBpKTtcbiAgfTtcblxuICB2YXIgZ2V0T2xkUG9zID0gZnVuY3Rpb24gZ2V0T2xkUG9zKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zO1xuICB9O1xuXG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcblxuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgfVxuXG4gIHZhciBiYiA9IGNvcHlCb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KHtcbiAgICB1c2VDYWNoZTogZmFsc2VcbiAgfSkpO1xuICBub2Rlcy5zaWxlbnRQb3NpdGlvbnMoZ2V0T2xkUG9zKTtcbiAgY3kuZW5kQmF0Y2goKTtcbiAgcmV0dXJuIGJiO1xufTtcblxuZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xudmFyIGJvdW5kcyA9IGVsZXNmbiRrO1xuXG52YXIgZm4kNCwgZWxlc2ZuJGw7XG5mbiQ0ID0gZWxlc2ZuJGwgPSB7fTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IGNhcGl0YWxpemUob3B0cy5uYW1lKTtcbiAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm91dGVyTmFtZSk7XG5cbiAgZm4kNFtvcHRzLm5hbWVdID0gZnVuY3Rpb24gZGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IGVsZS5wc3R5bGUob3B0cy5uYW1lKTtcblxuICAgICAgICBzd2l0Y2ggKGQuc3RyVmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmbiQ0WydvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB2YXIgZGltID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgdmFyIGJvcmRlciA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuXG4gICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuJDRbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgZCA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICByZXR1cm4gZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xuXG4gIGZuJDRbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnXG59KTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICdoZWlnaHQnXG59KTtcblxuZWxlc2ZuJGwucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgIGlmIChfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICB9XG59O1xuXG5lbGVzZm4kbC5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuXG5lbGVzZm4kbC5wYWRkZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUud2lkdGgoKSArIDIgKiBlbGUucGFkZGluZygpO1xufTtcblxudmFyIHdpZHRoSGVpZ2h0ID0gZWxlc2ZuJGw7XG5cbnZhciBpZkVkZ2UgPSBmdW5jdGlvbiBpZkVkZ2UoZWxlLCBnZXRWYWx1ZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKGVsZSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24oZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKGVsZSwgZ2V0UG9pbnRzKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgcmV0dXJuIGdldFBvaW50cyhlbGUpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbik7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBjb250cm9sUG9pbnRzID0gZnVuY3Rpb24gY29udHJvbFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldENvbnRyb2xQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U291cmNlRW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciB0YXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIHRhcmdldEVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0VGFyZ2V0RW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG59O1xuXG52YXIgcHRzID0ge1xuICBjb250cm9sUG9pbnRzOiB7XG4gICAgZ2V0OiBjb250cm9sUG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc2VnbWVudFBvaW50czoge1xuICAgIGdldDogc2VnbWVudFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNvdXJjZUVuZHBvaW50OiB7XG4gICAgZ2V0OiBzb3VyY2VFbmRwb2ludFxuICB9LFxuICB0YXJnZXRFbmRwb2ludDoge1xuICAgIGdldDogdGFyZ2V0RW5kcG9pbnRcbiAgfSxcbiAgbWlkcG9pbnQ6IHtcbiAgICBnZXQ6IG1pZHBvaW50XG4gIH1cbn07XG5cbnZhciByZW5kZXJlZE5hbWUgPSBmdW5jdGlvbiByZW5kZXJlZE5hbWUobmFtZSkge1xuICByZXR1cm4gJ3JlbmRlcmVkJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xufTtcblxudmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG5cbiAgb2JqW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZkVkZ2UodGhpcywgc3BlYy5nZXQpO1xuICB9O1xuXG4gIGlmIChzcGVjLm11bHQpIHtcbiAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbih0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbnZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cbnZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHNyYywgcHJvcHMpIHtcbiAgdGhpcy5yZWN5Y2xlKHNyYywgcHJvcHMpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXG5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7IC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsICYmIHNyYy50eXBlKSB7XG4gICAgICAvLyBQbGFpbiBvYmplY3QgY29udGFpbmluZyBhbGwgZXZlbnQgZGV0YWlsc1xuICAgICAgcHJvcHMgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW50IHN0cmluZ1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcblxuXG4gICAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gcHJvcHMub3JpZ2luYWxFdmVudDtcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT0gbnVsbCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLnRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH0gLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblxuXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxudmFyIGV2ZW50UmVnZXggPSAvXihbXi5dKykoXFwuKD86W14uXSspKT8kLzsgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcblxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyQ4ID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgIHJldHVybiBxMSA9PT0gcTI7XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKClcbiAgLypjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcygpXG4gIC8qY29udGV4dCwgZXZ0Ki9cbiAge30sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGNvbnRleHRcbiAgLyosIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICkge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LFxuICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KClcbiAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gIHt9LFxuICBhZnRlckVtaXQ6IGZ1bmN0aW9uIGFmdGVyRW1pdCgpXG4gIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICB7fSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKVxuICAvKmNvbnRleHQqL1xuICB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCgpXG4gIC8qY29udGV4dCovXG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY29udGV4dDogbnVsbFxufTtcbnZhciBkZWZhdWx0c0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyQ4KTtcbnZhciBlbXB0eU9wdHMgPSB7fTtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICAvLyBtaWNyby1vcHRpbWlzYXRpb24gdnMgT2JqZWN0LmFzc2lnbigpIC0tIHJlZHVjZXMgRWxlbWVudCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gZGVmYXVsdHNLZXlzW2ldO1xuICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XSB8fCBkZWZhdWx0cyQ4W2tleV07XG4gIH1cblxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5lbWl0dGluZyA9IDA7XG59XG5cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbnZhciBmb3JFYWNoRXZlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnQoc2VsZiwgaGFuZGxlciwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGlmIChmbihxdWFsaWZpZXIpKSB7XG4gICAgY2FsbGJhY2sgPSBxdWFsaWZpZXI7XG4gICAgcXVhbGlmaWVyID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjb25mT3ZlcnJpZGVzKSB7XG4gICAgaWYgKGNvbmYgPT0gbnVsbCkge1xuICAgICAgY29uZiA9IGNvbmZPdmVycmlkZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmYgPSBleHRlbmQoe30sIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuXG4gICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgdmFyIHJldCA9IGhhbmRsZXIoc2VsZiwgZXZ0LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuXG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gYWxsb3cgZXhpdGluZyBlYXJseVxuXG4gICAgfVxuICB9XG59O1xuXG52YXIgbWFrZUV2ZW50T2JqID0gZnVuY3Rpb24gbWFrZUV2ZW50T2JqKHNlbGYsIG9iaikge1xuICBzZWxmLmFkZEV2ZW50RmllbGRzKHNlbGYuY29udGV4dCwgb2JqKTtcbiAgcmV0dXJuIG5ldyBFdmVudChvYmoudHlwZSwgb2JqKTtcbn07XG5cbnZhciBmb3JFYWNoRXZlbnRPYmogPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnRPYmooc2VsZiwgaGFuZGxlciwgZXZlbnRzKSB7XG4gIGlmIChldmVudChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBldmVudHMpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBtYWtlRXZlbnRPYmooc2VsZiwgZXZlbnRzKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgZXZlbnRPYmogPSBtYWtlRXZlbnRPYmooc2VsZiwge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgdGFyZ2V0OiBzZWxmLmNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcihzZWxmLCBldmVudE9iaik7XG4gICAgfVxuICB9XG59O1xuXG5wLm9uID0gcC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgZm9yRWFjaEV2ZW50KHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgaWYgKGZuKGNhbGxiYWNrKSkge1xuICAgICAgc2VsZi5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgLy8gZnVsbCBldmVudCBzdHJpbmdcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgIHF1YWxpZmllcjogcXVhbGlmaWVyLFxuICAgICAgICAvLyBhIHJlc3RyaWN0aW9uIG9uIHdoZXRoZXIgdG8gbWF0Y2ggdGhpcyBlbWl0dGVyXG4gICAgICAgIGNvbmY6IGNvbmYgLy8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLm9uZSA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCB7XG4gICAgb25lOiB0cnVlXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IHAub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmVtaXR0aW5nICE9PSAwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBjb3B5QXJyYXkodGhpcy5saXN0ZW5lcnMpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgZm9yRWFjaEV2ZW50KF90aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFja1xuICAgIC8qLCBjb25mKi9cbiAgICApIHtcbiAgICAgIGlmICgobGlzdGVuZXIudHlwZSA9PT0gdHlwZSB8fCBldmVudHMgPT09ICcqJykgJiYgKCFuYW1lc3BhY2UgJiYgbGlzdGVuZXIubmFtZXNwYWNlICE9PSAnLionIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJiAoIXF1YWxpZmllciB8fCBzZWxmLnF1YWxpZmllckNvbXBhcmUobGlzdGVuZXIucXVhbGlmaWVyLCBxdWFsaWZpZXIpKSAmJiAoIWNhbGxiYWNrIHx8IGxpc3RlbmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoJyonKTtcbn07XG5cbnAuZW1pdCA9IHAudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudHMsIGV4dHJhUGFyYW1zLCBtYW51YWxDYWxsYmFjaykge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gIHZhciBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgdGhpcy5lbWl0dGluZysrO1xuXG4gIGlmICghYXJyYXkoZXh0cmFQYXJhbXMpKSB7XG4gICAgZXh0cmFQYXJhbXMgPSBbZXh0cmFQYXJhbXNdO1xuICB9XG5cbiAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgIH1dO1xuICAgICAgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihpKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgIGlmIChsaXN0ZW5lci50eXBlID09PSBldmVudE9iai50eXBlICYmICghbGlzdGVuZXIubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gZXZlbnRPYmoubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gdW5pdmVyc2FsTmFtZXNwYWNlKSAmJiBzZWxmLmV2ZW50TWF0Y2hlcyhzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaikpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbZXZlbnRPYmpdO1xuXG4gICAgICAgIGlmIChleHRyYVBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgICAgcHVzaChhcmdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJlZm9yZUVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25lKSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gc2VsZi5jYWxsYmFja0NvbnRleHQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGV2ZW50T2JqLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50T2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdDsgaSsrKSB7XG4gICAgICBfbG9vcDIoaSk7XG4gICAgfSAvLyBmb3IgbGlzdGVuZXJcblxuXG4gICAgaWYgKHNlbGYuYnViYmxlKHNlbGYuY29udGV4dCkgJiYgIWV2ZW50T2JqLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgIHNlbGYucGFyZW50KHNlbGYuY29udGV4dCkuZW1pdChldmVudE9iaiwgZXh0cmFQYXJhbXMpO1xuICAgIH1cbiAgfSwgZXZlbnRzKTtcbiAgdGhpcy5lbWl0dGluZy0tO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBlbWl0dGVyT3B0aW9ucyA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGVsZSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gZWxlLmN5KCk7XG4gICAgZXZ0LnRhcmdldCA9IGVsZTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBlbGU7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoY29udGV4dCwgbGlzdGVuZXJcbiAgLyosIGV2ZW50T2JqKi9cbiAgKSB7XG4gICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kbSA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCBlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjaywge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcbiAgICAvLyBub3RpZnkgcmVuZGVyZXJcblxuXG4gICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUkMy5ldmVudEFsaWFzZXNPbihlbGVzZm4kbSk7XG5cbnZhciBlbGVzZm4kbiA9IHtcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgLy8gaW50ZXJuYWwgaGVscGVyIHRvIGdldCBub2RlcyBhbmQgZWRnZXMgYXMgc2VwYXJhdGUgY29sbGVjdGlvbnMgd2l0aCBzaW5nbGUgaXRlcmF0aW9uIG92ZXIgZWxlbWVudHNcbiAgYnlHcm91cDogZnVuY3Rpb24gYnlHcm91cCgpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5zcGF3bigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBub2Rlcy5tZXJnZShlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZXMubWVyZ2UoZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgZWRnZXM6IGVkZ2VzXG4gICAgfTtcbiAgfSxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoX2ZpbHRlciwgdGhpc0FyZykge1xuICAgIGlmIChfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRoaXMgZmlyc3QgYi9jIGl0J3MgdGhlIG1vc3QgY29tbW9uL3BlcmZvcm1hbnQgY2FzZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoX2ZpbHRlcikgfHwgZWxlbWVudE9yQ29sbGVjdGlvbihfZmlsdGVyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihfZmlsdGVyKS5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChmbihfZmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlckVsZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gX2ZpbHRlci5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBfZmlsdGVyKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBmaWx0ZXJFbGVzLm1lcmdlKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcbiAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIHJNYXAgPSB0b1JlbW92ZS5fcHJpdmF0ZS5tYXA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZW1vdmUgPSByTWFwLmhhcyhlbGVtZW50LmlkKCkpO1xuXG4gICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gICAgfVxuICB9LFxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uIGFic29sdXRlQ29tcGxlbWVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm11dGFibGVFbGVtZW50cygpLm5vdCh0aGlzKTtcbiAgfSxcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgdmFyIG1hcDIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUubWFwIDogY29sMS5fcHJpdmF0ZS5tYXA7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gY29sW2ldLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgZW50cnkgPSBtYXAyLmdldChpZCk7XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVudHJ5LmVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICB4b3I6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgaWYgKCFpbk90aGVyKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZChjb2wxLCBjb2wyKTtcbiAgICBhZGQoY29sMiwgY29sMSk7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cblxuICAgIHZhciBsZWZ0ID0gW107XG4gICAgdmFyIHJpZ2h0ID0gW107XG4gICAgdmFyIGJvdGggPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgaWYgKGluT3RoZXIpIHtcbiAgICAgICAgICBib3RoLnB1c2goZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5zcGF3bihsZWZ0LCB7XG4gICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICByaWdodDogdGhpcy5zcGF3bihyaWdodCwge1xuICAgICAgICB1bmlxdWU6IHRydWVcbiAgICAgIH0pLFxuICAgICAgYm90aDogdGhpcy5zcGF3bihib3RoLCB7XG4gICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9O1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnRzLnB1c2godGhpc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IHRoaXMuX3ByaXZhdGUubWFwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvQWRkLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKHRvQWRkW19pXS5pZCgpKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKHRvQWRkW19pXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcblxuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b0FkZCAmJiBzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKGlkKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzW2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgZWxlOiB0b0FkZEVsZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgIHZhciBfaW5kZXggPSBtYXAuZ2V0KGlkKS5pbmRleDtcbiAgICAgICAgdGhpc1tfaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgIGluZGV4OiBfaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VBdDogZnVuY3Rpb24gdW5tZXJnZUF0KGkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7IC8vIHJlbW92ZSBlbGVcblxuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgbWFwW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxOyAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH0gLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcblxuXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cblxuICAgIHZhciBpID0gZW50cnkuaW5kZXg7XG4gICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiB1bm1lcmdlKHRvUmVtb3ZlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUodG9SZW1vdmVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1bm1lcmdlQnk6IGZ1bmN0aW9uIHVubWVyZ2VCeSh0b1JtRm4pIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0b1JtRm4oZWxlKSkge1xuICAgICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogbWFwRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGFyci5wdXNoKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4RWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtYXgsXG4gICAgICBlbGU6IG1heEVsZVxuICAgIH07XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gbWluKHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG52YXIgZm4kNSA9IGVsZXNmbiRuO1xuZm4kNVsndSddID0gZm4kNVsnfCddID0gZm4kNVsnKyddID0gZm4kNS51bmlvbiA9IGZuJDUub3IgPSBmbiQ1LmFkZDtcbmZuJDVbJ1xcXFwnXSA9IGZuJDVbJyEnXSA9IGZuJDVbJy0nXSA9IGZuJDUuZGlmZmVyZW5jZSA9IGZuJDUucmVsYXRpdmVDb21wbGVtZW50ID0gZm4kNS5zdWJ0cmFjdCA9IGZuJDUubm90O1xuZm4kNVsnbiddID0gZm4kNVsnJiddID0gZm4kNVsnLiddID0gZm4kNS5hbmQgPSBmbiQ1LmludGVyc2VjdGlvbiA9IGZuJDUuaW50ZXJzZWN0O1xuZm4kNVsnXiddID0gZm4kNVsnKCspJ10gPSBmbiQ1WycoLSknXSA9IGZuJDUuc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuJDUuc3ltZGlmZiA9IGZuJDUueG9yO1xuZm4kNS5mbkZpbHRlciA9IGZuJDUuZmlsdGVyRm4gPSBmbiQ1LnN0ZEZpbHRlciA9IGZuJDUuZmlsdGVyO1xuZm4kNS5jb21wbGVtZW50ID0gZm4kNS5hYnNjb21wID0gZm4kNS5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbnZhciBlbGVzZm4kbyA9IHtcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcbiAgaXNMb29wOiBmdW5jdGlvbiBpc0xvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSA9PT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgaXNTaW1wbGU6IGZ1bmN0aW9uIGlzU2ltcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gIT09IHRoaXMudGFyZ2V0KClbMF07XG4gIH0sXG4gIGdyb3VwOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xuXG52YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uIHpJbmRleFNvcnQoYSwgYikge1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoKGVsZSkge1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKTtcblxuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIE1BWF9JTlQ7XG4gICAgfSAvLyAnb3JwaGFuJ1xuXG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkZXB0aERpZmYgPSBnZXREZXB0aChhKSAtIGdldERlcHRoKGIpO1xuXG4gIGlmIChkZXB0aERpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZGVwdGhEaWZmO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1pbmRleC1jb21wYXJlJyk7XG5cbiAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwO1xuICAgIH0gLy8gJ21hbnVhbCdcblxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG5cbiAgaWYgKGVsZURpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZWxlRGlmZjtcbiAgfVxuXG4gIHZhciB6RGlmZiA9IGEucHN0eWxlKCd6LWluZGV4JykudmFsdWUgLSBiLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlO1xuXG4gIGlmICh6RGlmZiAhPT0gMCkge1xuICAgIHJldHVybiB6RGlmZjtcbiAgfSAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuXG5cbiAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xufTtcblxudmFyIGVsZXNmbiRwID0ge1xuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuJDEsIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4oZm4kMSkpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuJDEuYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgdGhpc10pIDogZm4kMShlbGUsIGksIHRoaXMpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihhcnJheSk7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9LFxuICBlcTogZnVuY3Rpb24gZXEoaSkge1xuICAgIHJldHVybiB0aGlzW2ldIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgfSxcbiAgbm9uZW1wdHk6IGZ1bmN0aW9uIG5vbmVtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KHNvcnRGbikge1xuICAgIGlmICghZm4oc29ydEZuKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoc29ydEZuKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3J0ZWQpO1xuICB9LFxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uIHNvcnRCeVpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0KHpJbmRleFNvcnQpO1xuICB9LFxuICB6RGVwdGg6IGZ1bmN0aW9uIHpEZXB0aCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmICghZWxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gbGV0IGN5ID0gZWxlLmN5KCk7XG5cblxuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9JTlQgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59O1xuZWxlc2ZuJHAuZWFjaCA9IGVsZXNmbiRwLmZvckVhY2g7XG5cbnZhciBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zID0gZGVmYXVsdHMoe1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kcSA9IHtcbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgZGltcztcblxuICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICBoOiBiYkRpbS5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICB9O1xuICAgIH0gLy8gc2FuaXRpc2UgdGhlIGRpbWVuc2lvbnMgZm9yIGV4dGVybmFsIGxheW91dHMgKGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8pXG5cblxuICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1zO1xuICB9LFxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24gbGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZm4pIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBsYXlvdXRFbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBub2RlcyAmIGVkZ2VzXG5cbiAgICB2YXIgZ2V0TWVtb2l6ZUtleSA9IGZ1bmN0aW9uIGdldE1lbW9pemVLZXkobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGZuTWVtID0gbWVtb2l6ZShmbiwgZ2V0TWVtb2l6ZUtleSk7IC8vIG1lbW9pemVkIHZlcnNpb24gb2YgcG9zaXRpb24gZnVuY3Rpb25cblxuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG5cbiAgICB2YXIgY2FsY3VsYXRlU3BhY2luZyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgbm9kZXNCYiwgcG9zKSB7XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiBub2Rlc0JiLngxICsgbm9kZXNCYi53IC8gMixcbiAgICAgICAgeTogbm9kZXNCYi55MSArIG5vZGVzQmIuaCAvIDJcbiAgICAgIH07XG4gICAgICB2YXIgc3BhY2luZ1ZlY3RvciA9IHtcbiAgICAgICAgLy8gc2NhbGUgZnJvbSBjZW50ZXIgb2YgYm91bmRpbmcgYm94IChub3QgbmVjZXNzYXJpbHkgMCwwKVxuICAgICAgICB4OiAocG9zLnggLSBjZW50ZXIueCkgKiBzcGFjaW5nLFxuICAgICAgICB5OiAocG9zLnkgLSBjZW50ZXIueSkgKiBzcGFjaW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBzcGFjaW5nVmVjdG9yLngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgc3BhY2luZ1ZlY3Rvci55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG5cbiAgICB2YXIgc3BhY2luZ0JiID0gZnVuY3Rpb24gc3BhY2luZ0JiKCkge1xuICAgICAgaWYgKCF1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICAgIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG5cbiAgICB2YXIgYmIgPSBzcGFjaW5nQmIoKTtcbiAgICB2YXIgZ2V0RmluYWxQb3MgPSBtZW1vaXplKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgbmV3UG9zID0gZm5NZW0obm9kZSwgaSk7XG5cbiAgICAgIGlmICh1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMob3B0aW9ucy5zcGFjaW5nRmFjdG9yKTtcbiAgICAgICAgbmV3UG9zID0gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBiYiwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9LCBnZXRNZW1vaXplS2V5KTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGdldEZpbmFsUG9zKG5vZGUsIGkpO1xuICAgICAgICB2YXIgYW5pbWF0ZU5vZGUgPSBvcHRpb25zLmFuaW1hdGVGaWx0ZXIgPT0gbnVsbCB8fCBvcHRpb25zLmFuaW1hdGVGaWx0ZXIobm9kZSwgaSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGFuaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICB2YXIgZml0QW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICBmaXQ6IHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94OiBsYXlvdXRFbGVzLmJvdW5kaW5nQm94QXQoZ2V0RmluYWxQb3MpLFxuICAgICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGZpdEFuaSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHpvb21QYW5BbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIHpvb206IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICBwYW46IG9wdGlvbnMucGFuLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goem9vbVBhbkFuaSk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnBsYXkoKTtcbiAgICAgIH0pO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgICAgUHJvbWlzZSQxLmFsbChsYXlvdXQuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnByb21pc2UoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucG9zaXRpb25zKGdldEZpbmFsUG9zKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT0gbnVsbCkge1xuICAgICAgICBjeS56b29tKG9wdGlvbnMuem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBhbikge1xuICAgICAgICBjeS5wYW4ob3B0aW9ucy5wYW4pO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSkpO1xuICB9XG59OyAvLyBhbGlhc2VzOlxuXG5lbGVzZm4kcS5jcmVhdGVMYXlvdXQgPSBlbGVzZm4kcS5tYWtlTGF5b3V0ID0gZWxlc2ZuJHEubGF5b3V0O1xuXG5mdW5jdGlvbiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBjYWNoZSA9IF9wLnN0eWxlQ2FjaGUgPSBfcC5zdHlsZUNhY2hlIHx8IFtdO1xuICB2YXIgdmFsO1xuXG4gIGlmICgodmFsID0gY2FjaGVba2V5XSkgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gY2FjaGVba2V5XSA9IGZuKGVsZSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRTdHlsZUZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcblxuICB2YXIgc2VsZkZuID0gZnVuY3Rpb24gc2VsZkZuKGVsZSkge1xuICAgIHJldHVybiBmbi5jYWxsKGVsZSk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIHNlbGZGbiwgZWxlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBlbGVzZm4kciA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXJ0eVN0eWxlQ2FjaGU6IGZ1bmN0aW9uIGRpcnR5U3R5bGVDYWNoZSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHZhciBlbGVzO1xuICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICBlbGVzLm1lcmdlKGVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICBlbGVzLmZvckVhY2goZGlydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBkaXJ0eShlbGUpO1xuICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG4gICAgICBiRWxlcy5tZXJnZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRFbGVzID0gc3R5bGUuYXBwbHkodXBkYXRlZEVsZXMpO1xuXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICBjaGFuZ2VkRWxlcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXQoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiBwYXJzZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBpbmNsdWRlTm9uRGVmYXVsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgb3ZlcnJpZGRlblN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKG92ZXJyaWRkZW5TdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZGVuU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVOb25EZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZTogZnVuY3Rpb24gbnVtZXJpY1N0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiBudW1lcmljU3R5bGVVbml0cyhwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0sXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9lbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoX2VsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoX2VsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24gZWZmZWN0aXZlT3BhY2l0eSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICB9XG4gIH0sXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA9PT0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgaWYgKHBhcmVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuXG4gICAgICBpZiAoIXBhcmVudE9rKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFvayhlbGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHJldHVybiBlZGdlT2tWaWFOb2RlKHNyYykgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoc3JjLCBlZGdlT2tWaWFOb2RlKSkgJiYgKHNyYyA9PT0gdGd0IHx8IGVkZ2VPa1ZpYU5vZGUodGd0KSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZCh0Z3QsIGVkZ2VPa1ZpYU5vZGUpKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG59KTtcbmVsZXNmbiRyLnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG59KTtcbmVsZXNmbiRyLmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZUludGVyYWN0aXZlLFxuICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuXG5lbGVzZm4kci5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gIH1cbn07XG5cbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG5lbGVzZm4kci52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVmlzaWJsZSxcbiAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG59KSk7XG5cbmVsZXNmbiRyLmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufTtcblxuZWxlc2ZuJHIuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiB0aGlzLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2JlemllcicgJiYgdGhpcy50YWtlc1VwU3BhY2UoKTtcbn0pO1xuZWxlc2ZuJHIuYnlwYXNzID0gZWxlc2ZuJHIuY3NzID0gZWxlc2ZuJHIuc3R5bGU7XG5lbGVzZm4kci5yZW5kZXJlZENzcyA9IGVsZXNmbiRyLnJlbmRlcmVkU3R5bGU7XG5lbGVzZm4kci5yZW1vdmVCeXBhc3MgPSBlbGVzZm4kci5yZW1vdmVDc3MgPSBlbGVzZm4kci5yZW1vdmVTdHlsZTtcbmVsZXNmbiRyLnBzdHlsZSA9IGVsZXNmbiRyLnBhcnNlZFN0eWxlO1xuXG52YXIgZWxlc2ZuJHMgPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlcik7XG4gICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBmbihhcmdzWzBdKSkge1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgX2hhbmRsZXIpO1xuICAgICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KClcbiAgICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCBhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICAgIGlmIChvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFibGUpIHtcbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKGNoYW5nZWRFbGVzKTtcbiAgICAgICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG5cbiAgICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG5cbiAgICAgICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICAgICAgY2hhbmdlZENvbGwuZW1pdChhZGRsRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gIGVsZXNmbiRzW3BhcmFtcy5maWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF07XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiRzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGVsZXNmbiRzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdncmFiYmFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgfHwgZWxlLnBhbm5hYmxlKCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdncmFiaWZ5JyxcbiAgb2ZmOiAndW5ncmFiaWZ5J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSk7XG5lbGVzZm4kcy5kZXNlbGVjdCA9IGVsZXNmbiRzLnVuc2VsZWN0O1xuXG5lbGVzZm4kcy5ncmFiYmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2FjdGl2ZScsXG4gIG9uOiAnYWN0aXZhdGUnLFxuICBvZmY6ICd1bmFjdGl2YXRlJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3Bhbm5hYmxlJyxcbiAgb246ICdwYW5pZnknLFxuICBvZmY6ICd1bnBhbmlmeSdcbn0pO1xuXG5lbGVzZm4kcy5pbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiR0ID0ge307IC8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICBpZiAocGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSB8fCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlKSB7XG4gICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldCwge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbnZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiBkZWZpbmVEYWdPbmVIb3AocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2godGd0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2goc3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKG9FbGVzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBuZXh0W2ldO1xuICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuXG4gICAgICAgIGlmICghc0VsZXNJZHNbbmlkXSkge1xuICAgICAgICAgIHNFbGVzSWRzW25pZF0gPSB0cnVlO1xuICAgICAgICAgIHNFbGVzLnB1c2gobik7XG4gICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuXG4gICAgICBlbGVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzRWxlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbmVsZXNmbiR0LmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9JbmNvbWluZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9PdXRnb2luZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLCAnb3V0Z29lcnMnKSxcbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIGluY29taW5nOiB0cnVlXG4gIH0pLCAnaW5jb21lcnMnKSxcbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBpbmNvbWluZzogdHJ1ZVxuICB9KVxufSk7IC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgbmVpZ2hib3Job29kOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpOyAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYzsgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcblxuICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfSAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcblxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcbiAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbiBjbG9zZWROZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24gb3Blbk5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZChzZWxlY3Rvcik7XG4gIH1cbn0pOyAvLyBhbGlhc2VzXG5cbmVsZXNmbiR0Lm5laWdoYm91cmhvb2QgPSBlbGVzZm4kdC5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4kdC5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJHQuY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuJHQub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kdC5vcGVuTmVpZ2hib3Job29kOyAvLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlcihzZWxlY3RvcikgOiBzcmM7XG4gIH0sICdzb3VyY2UnKSxcbiAgdGFyZ2V0OiBjYWNoZShmdW5jdGlvbiB0YXJnZXRJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHRndDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKHNlbGVjdG9yKSA6IHRndDtcbiAgfSwgJ3RhcmdldCcpLFxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG4gIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAndGFyZ2V0J1xuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHNyYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc291cmNlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0pLCAnZWRnZXNUbycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9OyAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcblxuICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKykge1xuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QpIHtcbiAgICAgICAgICBpZiAocC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG4gIHBhcmFsbGVsRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycpLFxuICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgY29kaXJlY3RlZDogdHJ1ZVxuICB9KSwgJ2NvZGlyZWN0ZWRFZGdlcycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtczsgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7IC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICBpZiAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQgfHwgIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufSAvLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICBpZiAocm9vdCAhPSBudWxsICYmIHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAvLyByb290IG1heSBjb250YWluIG9ubHkgZWRnZXNcbiAgICAgIHVudmlzaXRlZCA9IHJvb3Quc291cmNlcygpOyAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBub2RlIHRvIHVzZSAodW5kaXJlY3RlZCksIHNvIGp1c3QgdXNlIHRoZSBzb3VyY2Ugc2lkZXNcbiAgICB9XG5cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHZpc2l0SW5Db21wb25lbnQobm9kZSwgY29tcG9uZW50KSB7XG4gICAgICB2aXNpdGVkLm1lcmdlKG5vZGUpO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2Uobm9kZSk7XG4gICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgfTtcblxuICAgIGlmICh1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3Bhd24oKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkbyB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKTtcblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9LFxuICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLmN5KCkubXV0YWJsZUVsZW1lbnRzKCkuY29tcG9uZW50cyhlbGUpWzBdO1xuICB9XG59KTtcbmVsZXNmbiR0LmNvbXBvbmVudHNPZiA9IGVsZXNmbiR0LmNvbXBvbmVudHM7XG5cbnZhciBpZEZhY3RvcnkgPSB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShjeSwgZWxlbWVudCwgdHJ5VGhpc0lkKSB7XG4gICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB1dWlkKCk7XG5cbiAgICB3aGlsZSAoY3kuaGFzRWxlbWVudFdpdGhJZChpZCkpIHtcbiAgICAgIGlkID0gdXVpZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxufTsgLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcblxudmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cywgb3B0aW9ucykge1xuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICBlcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gIGlmICghZWxlbWVudHMpIHtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgcGxhaW5PYmplY3QoZWxlbWVudHNbMF0pICYmICFlbGVtZW50KGVsZW1lbnRzWzBdKSkge1xuICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7IC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG5cbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0gbmV3IFNldCQxKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYgKGpzb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX2RhdGEgPSBqc29uLmRhdGE7IC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG5cbiAgICAgIGlmIChfZGF0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgIF9kYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKGN5LCBqc29uKTtcbiAgICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YS5pZCkgfHwgZWxlc0lkcy5oYXMoX2RhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTtcbiAgICAgIGVsZXMucHVzaChlbGUpO1xuICAgICAgZWxlc0lkcy5hZGQoX2RhdGEuaWQpO1xuICAgIH1cblxuICAgIGVsZW1lbnRzID0gZWxlcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDAsIF9sID0gZWxlbWVudHMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQkMSA9IGVsZW1lbnRzW19pXVswXTsgLy8gWzBdIGluIGNhc2UgZWxlbWVudHMgaXMgYW4gYXJyYXkgb2YgY29sbGVjdGlvbnMsIHJhdGhlciB0aGFuIGFycmF5IG9mIGVsZW1lbnRzXG5cbiAgICBpZiAoZWxlbWVudCQxID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpZCA9IGVsZW1lbnQkMS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCBvcHRpb25zLnVuaXF1ZSAmJiAhbWFwLmhhcyhpZCkpIHtcbiAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICBlbGU6IGVsZW1lbnQkMVxuICAgICAgfSk7XG4gICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IGVsZW1lbnQkMTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgbWFwOiBtYXBcbiAgfTsgLy8gcmVzdG9yZSB0aGUgZWxlbWVudHMgaWYgd2UgY3JlYXRlZCB0aGVtIGZyb20ganNvblxuXG4gIGlmIChjcmVhdGVkRWxlbWVudHMpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTsgLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4vLyBhbmQgdXNlIGVsZWZuIGFuZCBlbGVzZm4gYXMgc2hvcnRoYW5kcyB0byB0aGUgcHJvdG90eXBlc1xuXG5cbnZhciBlbGVzZm4kdSA9IEVsZW1lbnQucHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5cbmVsZXNmbiR1Lmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcblxuZWxlc2ZuJHUuc3Bhd24gPSBmdW5jdGlvbiAoY3ksIGVsZXMsIG9wdHMpIHtcbiAgaWYgKCFjb3JlKGN5KSkge1xuICAgIC8vIGN5IGlzIG9wdGlvbmFsXG4gICAgb3B0cyA9IGVsZXM7XG4gICAgZWxlcyA9IGN5O1xuICAgIGN5ID0gdGhpcy5jeSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVzLCBvcHRzKTtcbn07XG5cbmVsZXNmbiR1LnNwYXduU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Bhd24odGhpcyk7XG59O1xuXG5lbGVzZm4kdS5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4kdS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3kucmVuZGVyZXIoKTtcbn07XG5cbmVsZXNmbiR1LmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcblxuZWxlc2ZuJHUuY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbGxlY3Rpb24odGhpcykpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gIH1cbn07XG5cbmVsZXNmbiR1LnVuaXF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHtcbiAgICB1bmlxdWU6IHRydWVcbiAgfSk7XG59O1xuXG5lbGVzZm4kdS5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKGlkKTtcbn07XG5cbmVsZXNmbiR1LmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCk7XG5cbiAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbiR1LiRpZCA9IGVsZXNmbiR1LmdldEVsZW1lbnRCeUlkO1xuXG5lbGVzZm4kdS5wb29sSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIHZhciBpZCA9IHRoaXNbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIGVsZXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kdS5pbmRleE9mID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgaWQgPSBlbGVbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kdS5pbmRleE9mSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcblxuZWxlc2ZuJHUuanNvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgaWYgKGVsZSA9PSBudWxsICYmIG9iaikge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cblxuICBpZiAoZWxlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgLy8gc2V0XG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICBlbGUuZGF0YShvYmouZGF0YSk7XG4gICAgICB2YXIgX2RhdGEyID0gcC5kYXRhO1xuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMgIT0gX2RhdGEyLnNvdXJjZSkge1xuICAgICAgICAgIHNwZWMuc291cmNlID0gJycgKyBzcmM7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0Z3QgIT0gbnVsbCAmJiB0Z3QgIT0gX2RhdGEyLnRhcmdldCkge1xuICAgICAgICAgIHNwZWMudGFyZ2V0ID0gJycgKyB0Z3Q7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmRhdGEucGFyZW50O1xuXG4gICAgICAgIGlmICgocGFyZW50ICE9IG51bGwgfHwgX2RhdGEyLnBhcmVudCAhPSBudWxsKSAmJiBwYXJlbnQgIT0gX2RhdGEyLnBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IHVuZGVmaW5lZCBpbXBlcmF0aXZlbHksIHNvIHVzZSBudWxsXG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50ID0gJycgKyBwYXJlbnQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmoucG9zaXRpb24pIHtcbiAgICAgIGVsZS5wb3NpdGlvbihvYmoucG9zaXRpb24pO1xuICAgIH0gLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG5cbiAgICB2YXIgY2hlY2tTd2l0Y2ggPSBmdW5jdGlvbiBjaGVja1N3aXRjaChrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSkge1xuICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuXG4gICAgICBpZiAob2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSkge1xuICAgICAgICBpZiAob2JqX2spIHtcbiAgICAgICAgICBlbGVbdHJ1ZUZuTmFtZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVbZmFsc2VGbk5hbWVdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tTd2l0Y2goJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycpO1xuICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcbiAgICBjaGVja1N3aXRjaCgncGFubmFibGUnLCAncGFuaWZ5JywgJ3VucGFuaWZ5Jyk7XG5cbiAgICBpZiAob2JqLmNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgZWxlLmNsYXNzZXMob2JqLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBnZXRcbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IGNvcHkocC5kYXRhKSxcbiAgICAgIHBvc2l0aW9uOiBjb3B5KHAucG9zaXRpb24pLFxuICAgICAgZ3JvdXA6IHAuZ3JvdXAsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgcGFubmFibGU6IHAucGFubmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcbiAgICBqc29uLmNsYXNzZXMgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgcC5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgcmV0dXJuIGpzb24uY2xhc3NlcyArPSBpKysgPT09IDAgPyBjbHMgOiAnICcgKyBjbHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5cbmVsZXNmbiR1Lmpzb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAganNvbnMucHVzaChqc29uKTtcbiAgfVxuXG4gIHJldHVybiBqc29ucztcbn07XG5cbmVsZXNmbiR1LmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXNBcnIpO1xufTtcblxuZWxlc2ZuJHUuY29weSA9IGVsZXNmbiR1LmNsb25lO1xuXG5lbGVzZm4kdS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBhZGRUb1Bvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlOyAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuXG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzO1xuXG4gIGZvciAodmFyIF9pMiA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgX2kyIDwgbDsgX2kyKyspIHtcbiAgICB2YXIgZWxlID0gc2VsZltfaTJdO1xuXG4gICAgaWYgKGFkZFRvUG9vbCAmJiAhZWxlLnJlbW92ZWQoKSkge1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG5cblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcbiAgdmFyIGk7XG5cbiAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21FbGVtZW50cygpIHtcbiAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgaS0tO1xuICB9OyAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG5cblxuICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2VsZSA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUuX3ByaXZhdGU7XG4gICAgdmFyIF9kYXRhMyA9IF9wcml2YXRlLmRhdGE7IC8vIHRoZSB0cmF2ZXJzYWwgY2FjaGUgc2hvdWxkIHN0YXJ0IGZyZXNoIHdoZW4gZWxlIGlzIGFkZGVkXG5cbiAgICBfZWxlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTsgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuXG5cbiAgICBpZiAoIWFkZFRvUG9vbCAmJiAhX3ByaXZhdGUucmVtb3ZlZCkgOyBlbHNlIGlmIChfZGF0YTMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2RhdGEzLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKGN5LCBfZWxlKTtcbiAgICB9IGVsc2UgaWYgKG51bWJlcihfZGF0YTMuaWQpKSB7XG4gICAgICBfZGF0YTMuaWQgPSAnJyArIF9kYXRhMy5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKGVtcHR5U3RyaW5nKF9kYXRhMy5pZCkgfHwgIXN0cmluZyhfZGF0YTMuaWQpKSB7XG4gICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG5cbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcblxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBfZGF0YTMuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgIGlmIChfZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247IC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLnkgPT0gbnVsbCkge1xuICAgICAgICBwb3MueSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9lbGUuaXNFZGdlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcbiAgICAgIHZhciBlZGdlID0gX2VsZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICB2YXIgdmFsID0gX2RhdGEzW2ZpZWxkXTtcblxuICAgICAgICBpZiAobnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBfZGF0YTNbZmllbGRdID0gJycgKyBfZGF0YTNbZmllbGRdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSAnJykge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN5Lmhhc0VsZW1lbnRXaXRoSWQodmFsKSkge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmFkU291cmNlT3JUYXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG5cbiAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMuc291cmNlKTtcbiAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMudGFyZ2V0KTsgLy8gb25seSBvbmUgZWRnZSBpbiBub2RlIGlmIGxvb3BcblxuICAgICAgaWYgKHNyYy5zYW1lKHRndCkpIHtcbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cblxuICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICB9IC8vIGlmIGlzIGVkZ2VcbiAgICAvLyBjcmVhdGUgbW9jayBpZHMgLyBpbmRleGVzIG1hcHMgZm9yIGVsZW1lbnQgc28gaXQgY2FuIGJlIHVzZWQgbGlrZSBjb2xsZWN0aW9uc1xuXG5cbiAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwJDEoKTtcblxuICAgIF9wcml2YXRlLm1hcC5zZXQoaWQsIHtcbiAgICAgIGVsZTogX2VsZSxcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICBjeS5hZGRUb1Bvb2woX2VsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcbiAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG5cblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgLy8gZWFjaCBub2RlXG4gICAgdmFyIG5vZGUgPSBub2Rlc1tfaTNdO1xuICAgIHZhciBfZGF0YTQgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICBpZiAobnVtYmVyKF9kYXRhNC5wYXJlbnQpKSB7XG4gICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgX2RhdGE0LnBhcmVudCA9ICcnICsgX2RhdGE0LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50SWQgPSBfZGF0YTQucGFyZW50O1xuICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgaWYgKHNwZWNpZmllZFBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcblxuICAgICAgaWYgKHBhcmVudC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcblxuICAgICAgICB3aGlsZSAoIWFuY2VzdG9yLmVtcHR5KCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5zYW1lKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmQXNQYXJlbnQpIHtcbiAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdOyAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcblxuICAgICAgICAgIGN5X3AuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZWxzZVxuXG4gICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG5cbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciByZXN0b3JlZCA9IG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCByZXN0b3JlZC5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2VsZTIgPSByZXN0b3JlZFtfaTRdO1xuXG4gICAgICBpZiAoX2VsZTIuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcblxuXG4gICAgICBfZWxlMi5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG5cblxuICAgICAgX2VsZTIuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICBfZWxlMi50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG5cbiAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICB9XG5cbiAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbiR1LnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuJHUuaW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4kdS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5OyAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG5cbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoZWRnZXNbaV0pO1xuICAgIH1cbiAgfSAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuXG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZChlbGUpIHtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXTtcblxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCAmJiBlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfSAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgYWRkKGVsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2UpIHtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIHJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7IC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuXG4gICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKSB7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgcGxsRWRnZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgc2VsZi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICBjeS5yZW1vdmVGcm9tUG9vbChlbGVzVG9SZW1vdmUpOyAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgfVxuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNSsrKSB7XG4gICAgdmFyIF9lbGUzID0gZWxlc1RvUmVtb3ZlW19pNV07XG5cbiAgICBpZiAoX2VsZTMuaXNFZGdlKCkpIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICB2YXIgc3JjID0gX2VsZTMuc291cmNlKClbMF07XG5cbiAgICAgIHZhciB0Z3QgPSBfZWxlMy50YXJnZXQoKVswXTtcblxuICAgICAgcmVtb3ZlRWRnZVJlZihzcmMsIF9lbGUzKTtcbiAgICAgIHJlbW92ZUVkZ2VSZWYodGd0LCBfZWxlMyk7XG5cbiAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGUzLnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGxFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcGxsRWRnZSA9IHBsbEVkZ2VzW2pdO1xuICAgICAgICByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKTtcblxuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBfZWxlMy5wYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgIF9lbGUzLl9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuXG5cbiAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2VsZTQgPSBlbGVzU3RpbGxJbnNpZGVbX2k2XTtcblxuICAgIGlmIChfZWxlNC5pc1BhcmVudCgpKSB7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXNUb1JlbW92ZSk7XG5cbiAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdEFuZE5vdGlmeSgncmVtb3ZlJyk7XG4gICAgfSBlbHNlIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICAgIH1cbiAgfSAvLyB0aGUgcGFyZW50cyB3aG8gd2VyZSBtb2RpZmllZCBieSB0aGUgcmVtb3ZhbCBuZWVkIHRoZWlyIHN0eWxlIHVwZGF0ZWRcblxuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBhbHRlcmVkUGFyZW50c1tfaTddO1xuXG4gICAgaWYgKCFyZW1vdmVGcm9tUG9vbCB8fCAhX2VsZTUucmVtb3ZlZCgpKSB7XG4gICAgICBfZWxlNS51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVkRWxlbWVudHM7XG59O1xuXG5lbGVzZm4kdS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IHRoaXM7IC8vIGp1c3QgY2xlYW4gdXAgcmVmcywgY2FjaGVzLCBldGMuIGluIHRoZSBzYW1lIHdheSBhcyB3aGVuIHJlbW92aW5nIGFuZCB0aGVuIHJlc3RvcmluZ1xuICAvLyAob3VyIGNhbGxzIHRvIHJlbW92ZS9yZXN0b3JlIGRvIG5vdCByZW1vdmUgZnJvbSB0aGUgZ3JhcGggb3IgbWFrZSBldmVudHMpXG5cbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoaWQpIHtcbiAgICByZXR1cm4gaWQgPT0gbnVsbCA/IGlkIDogJycgKyBpZDtcbiAgfTsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuXG4gIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNyY0lkID0gdG9TdHJpbmcoc3RydWN0LnNvdXJjZSk7XG4gICAgdmFyIHRndElkID0gdG9TdHJpbmcoc3RydWN0LnRhcmdldCk7XG4gICAgdmFyIHNyY0V4aXN0cyA9IHNyY0lkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZChzcmNJZCk7XG4gICAgdmFyIHRndEV4aXN0cyA9IHRndElkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG5cbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuXG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTUgPSBlbGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGd0RXhpc3RzKSB7XG4gICAgICAgICAgICAgIF9kYXRhNS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgfSk7XG4gICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSB0b1N0cmluZyhzdHJ1Y3QucGFyZW50KTtcbiAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuaGFzRWxlbWVudFdpdGhJZChwYXJlbnRJZCk7XG5cbiAgICBpZiAocGFyZW50RXhpc3RzKSB7XG4gICAgICB2YXIgcGlkVG9Bc3NpZ24gPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNiA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgX2RhdGE2LnBhcmVudCA9IHBpZFRvQXNzaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuW2VsZXNmbiRjLCBlbGVzZm4kZCwgZWxlc2ZuJGUsIGVsZXNmbiRmLCBlbGVzZm4kZywgZGF0YSQxLCBlbGVzZm4kaSwgZGltZW5zaW9ucywgZWxlc2ZuJG0sIGVsZXNmbiRuLCBlbGVzZm4kbywgZWxlc2ZuJHAsIGVsZXNmbiRxLCBlbGVzZm4kciwgZWxlc2ZuJHMsIGVsZXNmbiR0XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoZWxlc2ZuJHUsIHByb3BzKTtcbn0pO1xuXG52YXIgY29yZWZuID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvcHRzKSB7XG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7IC8vIGFkZCB0aGUgZWxlbWVudHNcblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgIGlmIChlbGVzLl9wcml2YXRlLmN5ID09PSBjeSkge1xuICAgICAgICAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBqc29ucy5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgIH0gLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiAoYXJyYXkob3B0cykpIHtcbiAgICAgICAgdmFyIF9qc29ucyA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29ucyk7XG4gICAgICB9IC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICAgIGVsc2UgaWYgKHBsYWluT2JqZWN0KG9wdHMpICYmIChhcnJheShvcHRzLm5vZGVzKSB8fCBhcnJheShvcHRzLmVkZ2VzKSkpIHtcbiAgICAgICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgICAgIHZhciBfanNvbnMyID0gW107XG4gICAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncnNbX2ldO1xuICAgICAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcblxuICAgICAgICAgICAgaWYgKGFycmF5KGVsZXNBcnJheSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgICAgICB9LCBlbGVzQXJyYXlbal0pO1xuXG4gICAgICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgICAgIH0gLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfanNvbiA9IG9wdHM7XG4gICAgICAgICAgICBlbGVtZW50cyA9IG5ldyBFbGVtZW50KGN5LCBfanNvbikuY29sbGVjdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbikge1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pKSA7IGVsc2UgaWYgKHN0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbi8qISBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQsXG4gICAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG4gICAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwLFxuICAgICAga1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuICAgICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG4gIC8qIE11c3QgY29udGFpbiBmb3VyIGFyZ3VtZW50cy4gKi9cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cblxuXG4gIG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG4gIG1YMiA9IE1hdGgubWluKG1YMiwgMSk7XG4gIG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG4gIG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG4gIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICByZXR1cm4gMy4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK19pKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrU3BsaW5lVGFibGVTaXplOyArK19pMikge1xuICAgICAgbVNhbXBsZVZhbHVlc1tfaTJdID0gY2FsY0JlemllcihfaTIgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuICAgIHZhciBjdXJyZW50WCxcbiAgICAgICAgY3VycmVudFQsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG5cbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcbiAgICAgICAgY3VycmVudFNhbXBsZSA9IDEsXG4gICAgICAgIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuXG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcbiAgICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemUsXG4gICAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmID0gZnVuY3Rpb24gZihhWCkge1xuICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICBwcmVjb21wdXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4gYVg7XG4gICAgfVxuXG4gICAgaWYgKGFYID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYVggPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICB9O1xuXG4gIGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHg6IG1YMSxcbiAgICAgIHk6IG1ZMVxuICAgIH0sIHtcbiAgICAgIHg6IG1YMixcbiAgICAgIHk6IG1ZMlxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBzdHIgPSBcImdlbmVyYXRlQmV6aWVyKFwiICsgW21YMSwgbVkxLCBtWDIsIG1ZMl0gKyBcIilcIjtcblxuICBmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIGY7XG59XG5cbi8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblxuLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xudmFyIGdlbmVyYXRlU3ByaW5nUks0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiAtc3RhdGUudGVuc2lvbiAqIHN0YXRlLnggLSBzdGF0ZS5mcmljdGlvbiAqIHN0YXRlLnY7XG4gIH1cblxuICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlLCBkdCwgZGVyaXZhdGl2ZSkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgdjogaW5pdGlhbFN0YXRlLnYgKyBkZXJpdmF0aXZlLmR2ICogZHQsXG4gICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9LFxuICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgIGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcbiAgICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcbiAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICBzdGF0ZS52ID0gc3RhdGUudiArIGR2ZHQgKiBkdDtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgeDogLTEsXG4gICAgICB2OiAwLFxuICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgIGZyaWN0aW9uOiBudWxsXG4gICAgfSxcbiAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICBoYXZlX2R1cmF0aW9uLFxuICAgICAgICBkdCxcbiAgICAgICAgbGFzdF9zdGF0ZTtcbiAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMDtcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG4gICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgIGluaXRTdGF0ZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcbiAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuXG4gICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICB0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cblxuICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR0ID0gRFQ7XG4gICAgfVxuXG4gICAgZm9yICg7Oykge1xuICAgICAgLyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAvKiBTdG9yZSB0aGUgcG9zaXRpb24uICovXG5cbiAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgIHRpbWVfbGFwc2VkICs9IDE2O1xuICAgICAgLyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovXG5cbiAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIGR1cmF0aW9uIGlzIG5vdCBkZWZpbmVkLCByZXR1cm4gdGhlIGFjdHVhbCB0aW1lIHJlcXVpcmVkIGZvciBjb21wbGV0aW5nIHRoaXMgYW5pbWF0aW9uLiBPdGhlcndpc2UsIHJldHVybiBhIGNsb3N1cmUgdGhhdCBob2xkcyB0aGVcbiAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cblxuXG4gICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiAocGVyY2VudENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gcGF0aFtwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSB8IDBdO1xuICAgIH07XG4gIH07XG59KCk7XG5cbnZhciBjdWJpY0JlemllciA9IGZ1bmN0aW9uIGN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKSB7XG4gIHZhciBiZXppZXIgPSBnZW5lcmF0ZUN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGJlemllcihwZXJjZW50KTtcbiAgfTtcbn07XG5cbnZhciBlYXNpbmdzID0ge1xuICAnbGluZWFyJzogZnVuY3Rpb24gbGluZWFyKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcbiAgfSxcbiAgLy8gZGVmYXVsdCBlYXNpbmdzXG4gICdlYXNlJzogY3ViaWNCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKSxcbiAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKSxcbiAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSksXG4gICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpLFxuICAvLyBzaW5lXG4gICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpLFxuICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuMzksIDAuNTc1LCAwLjU2NSwgMSksXG4gICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC40NDUsIDAuMDUsIDAuNTUsIDAuOTUpLFxuICAvLyBxdWFkXG4gICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllcigwLjU1LCAwLjA4NSwgMC42OCwgMC41MyksXG4gICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCksXG4gICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NSksXG4gIC8vIGN1YmljXG4gICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5KSxcbiAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSksXG4gIC8vIHF1YXJ0XG4gICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyKSxcbiAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC4xNjUsIDAuODQsIDAuNDQsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjc3LCAwLCAwLjE3NSwgMSksXG4gIC8vIHF1aW50XG4gICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KSxcbiAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC4yMywgMSwgMC4zMiwgMSksXG4gICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpLFxuICAvLyBleHBvXG4gICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllcigwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUpLFxuICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpLFxuICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDEsIDAsIDAsIDEpLFxuICAvLyBjaXJjXG4gICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllcigwLjYsIDAuMDQsIDAuOTgsIDAuMzM1KSxcbiAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjA3NSwgMC44MiwgMC4xNjUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuNzg1LCAwLjEzNSwgMC4xNSwgMC44NiksXG4gIC8vIHVzZXIgcGFyYW0gZWFzaW5ncy4uLlxuICAnc3ByaW5nJzogZnVuY3Rpb24gc3ByaW5nKHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgIHJldHVybiBlYXNpbmdzLmxpbmVhcjsgLy8gZHVyYXRpb24gMCA9PiBqdW1wIHRvIGVuZCBzbyBpbXBsIGRvZXNuJ3QgbWF0dGVyXG4gICAgfVxuXG4gICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKHBlcmNlbnQpO1xuICAgIH07XG4gIH0sXG4gICdjdWJpYy1iZXppZXInOiBjdWJpY0JlemllclxufTtcblxuZnVuY3Rpb24gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbikge1xuICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cblxuICB2YXIgdmFsID0gZWFzaW5nRm4oc3RhcnQsIGVuZCwgcGVyY2VudCk7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZS5yb3VuZFZhbHVlIHx8IHR5cGUuY29sb3IpIHtcbiAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cblxuICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWF4KHZhbCwgdHlwZS5taW4pO1xuICB9XG5cbiAgaWYgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1pbih2YWwsIHR5cGUubWF4KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHByb3AsIHNwZWMpIHtcbiAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHByb3AudmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCAmJiAoc3BlYyA9PSBudWxsIHx8IHNwZWMudHlwZS51bml0cyAhPT0gJyUnKSkge1xuICAgICAgcmV0dXJuIHByb3AucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhc2Uoc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiwgcHJvcFNwZWMpIHtcbiAgdmFyIHR5cGUgPSBwcm9wU3BlYyAhPSBudWxsID8gcHJvcFNwZWMudHlwZSA6IG51bGw7XG5cbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IGdldFZhbHVlKHN0YXJ0UHJvcCwgcHJvcFNwZWMpO1xuICB2YXIgZW5kID0gZ2V0VmFsdWUoZW5kUHJvcCwgcHJvcFNwZWMpO1xuXG4gIGlmIChudW1iZXIoc3RhcnQpICYmIG51bWJlcihlbmQpKSB7XG4gICAgcmV0dXJuIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0YXJ0KSAmJiBhcnJheShlbmQpKSB7XG4gICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNpID0gc3RhcnRbaV07XG4gICAgICB2YXIgZWkgPSBlbmRbaV07XG5cbiAgICAgIGlmIChzaSAhPSBudWxsICYmIGVpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbCA9IGdldEVhc2VkVmFsdWUodHlwZSwgc2ksIGVpLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gICAgICAgIGVhc2VkQXJyLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2VkQXJyLnB1c2goZWkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlYXNlZEFycjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0ZXAoc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICB2YXIgcEVhc2luZyA9IGFuaV9wLmVhc2luZztcbiAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcbiAgdmFyIGN5ID0gaXNDb3JlID8gc2VsZiA6IHNlbGYuY3koKTtcbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICBpZiAoIWFuaV9wLmVhc2luZ0ltcGwpIHtcbiAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgaWYgKHN0cmluZyhwRWFzaW5nKSkge1xuICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICBlYXNpbmdWYWxzID0gcEVhc2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgIGlmIChzdHJpbmcoZWFzaW5nVmFscykpIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gK247XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGFuaV9wLmR1cmF0aW9uKTsgLy8gbmVlZCBkdXJhdGlvbiB0byBnZW5lcmF0ZSBzcHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGljIGltcGwgYnkgbmFtZVxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWFzaW5nID0gYW5pX3AuZWFzaW5nSW1wbDtcbiAgdmFyIHBlcmNlbnQ7XG5cbiAgaWYgKGFuaV9wLmR1cmF0aW9uID09PSAwKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gIH1cblxuICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICBwZXJjZW50ID0gYW5pX3AucHJvZ3Jlc3M7XG4gIH1cblxuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG5cbiAgaWYgKGFuaV9wLmRlbGF5ID09IG51bGwpIHtcbiAgICAvLyB0aGVuIHVwZGF0ZVxuICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuXG4gICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSB7fTtcblxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLngsIGVuZFBvcy54KSkge1xuICAgICAgICBuZXdQb3MueCA9IGVhc2Uoc3RhcnRQb3MueCwgZW5kUG9zLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy55LCBlbmRQb3MueSkpIHtcbiAgICAgICAgbmV3UG9zLnkgPSBlYXNlKHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW47XG4gICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICB2YXIgcGFuID0gX3AucGFuO1xuICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG5cbiAgICBpZiAoYW5pbWF0aW5nUGFuKSB7XG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueCwgZW5kUGFuLngpKSB7XG4gICAgICAgIHBhbi54ID0gZWFzZShzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLnksIGVuZFBhbi55KSkge1xuICAgICAgICBwYW4ueSA9IGVhc2Uoc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZW1pdCgncGFuJyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbTtcbiAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuXG4gICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgIF9wLnpvb20gPSBib3VuZChfcC5taW5ab29tLCBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKSwgX3AubWF4Wm9vbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZW1pdCgnem9vbScpO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSkge1xuICAgICAgc2VsZi5lbWl0KCd2aWV3cG9ydCcpO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuXG4gICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIGVuZCA9IHByb3A7XG4gICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbX25hbWVdO1xuICAgICAgICB2YXIgcHJvcFNwZWMgPSBzdHlsZS5wcm9wZXJ0aWVzW3N0YXJ0Lm5hbWVdO1xuICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZywgcHJvcFNwZWMpO1xuICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyhzZWxmLCBfbmFtZSwgZWFzZWRWYWwpO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgICBzZWxmLmVtaXQoJ3N0eWxlJyk7XG4gICAgfSAvLyBpZlxuXG4gIH1cblxuICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG4gIHJldHVybiBwZXJjZW50O1xufVxuXG5mdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlcihzdGFydCkgJiYgbnVtYmVyKGVuZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBzdGVwQWxsKG5vdywgY3kpIHtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwT25lKGVsZSwgaXNDb3JlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgIHZhciByYW5BbmlzID0gZmFsc2U7IC8vIGNhbmNlbCBhbGwgYW5pbWF0aW9ucyBvbiBkaXNwbGF5Om5vbmUgZWxlXG5cbiAgICBpZiAoIWlzQ29yZSAmJiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgLy8gcHV0IGFsbCBjdXJyZW50IGFuZCBxdWV1ZSBhbmltYXRpb25zIGluIHRoaXMgdGljaydzIGN1cnJlbnQgbGlzdFxuICAgICAgLy8gYW5kIGVtcHR5IHRoZSBsaXN0cyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNwbGljZSgwLCBjdXJyZW50Lmxlbmd0aCkuY29uY2F0KHF1ZXVlLnNwbGljZSgwLCBxdWV1ZS5sZW5ndGgpKTsgLy8gc3RvcCBhbGwgYW5pbWF0aW9uc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFtpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcblxuXG4gICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG5cbiAgICAgIF9jYWxsYmFja3Muc3BsaWNlKDAsIF9jYWxsYmFja3MubGVuZ3RoKTtcbiAgICB9OyAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuXG5cbiAgICBmb3IgKHZhciBfaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbX2ldO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICBpZiAoYW5pX3Auc3RvcHBlZCkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShfaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG5cblxuICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbmlfcC5zdGFydGVkKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKGVsZSwgYW5pLCBub3cpO1xuICAgICAgfVxuXG4gICAgICBzdGVwKGVsZSwgYW5pLCBub3csIGlzQ29yZSk7XG5cbiAgICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcblxuICAgICAgaWYgKGFuaV9wLnN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBhbmlfcC5zdGVwKG5vdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmkuY29tcGxldGVkKCkpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoX2ksIDEpO1xuICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5jb21wbGV0ZXMpO1xuICAgICAgfVxuXG4gICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuQW5pcztcbiAgfSAvLyBzdGVwRWxlbWVudFxuICAvLyBoYW5kbGUgYWxsIGVsZXNcblxuXG4gIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcblxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBzdGVwT25lKGVsZSk7XG4gICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICB9IC8vIGVhY2ggZWxlbWVudFxuXG5cbiAgdmFyIHJhbkNvcmVBbmkgPSBzdGVwT25lKGN5LCB0cnVlKTsgLy8gbm90aWZ5IHJlbmRlcmVyXG5cbiAgaWYgKHJhbkVsZUFuaSB8fCByYW5Db3JlQW5pKSB7XG4gICAgaWYgKGVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY3kubm90aWZ5KCdkcmF3JywgZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgIH1cbiAgfSAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcblxuXG4gIGVsZXMudW5tZXJnZShkb25lRWxlcyk7XG4gIGN5LmVtaXQoJ3N0ZXAnKTtcbn0gLy8gc3RlcEFsbFxuXG52YXIgY29yZWZuJDEgPSB7XG4gIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICBhbmltYXRlOiBkZWZpbmUkMy5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lJDMuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUkMy5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUkMy5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUkMy5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lJDMuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lJDMuc3RvcCgpLFxuICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uIGFkZFRvQW5pbWF0aW9uUG9vbChlbGVzKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG5cbiAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKGVsZXMpO1xuICB9LFxuICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RvcEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICB9LFxuICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cblxuICAgIGZ1bmN0aW9uIGhlYWRsZXNzU3RlcCgpIHtcbiAgICAgIGlmICghY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0aW9uU3RlcChub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgICAgaGVhZGxlc3NTdGVwKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuXG4gICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlcikge1xuICAgICAgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICBoZWFkbGVzc1N0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgIH1cbiAgfVxufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zJDEgPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3kgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgIGV2dC5jeSA9IGN5O1xuICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcblxudmFyIGVsZXNmbiR2ID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucyQxLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGVsZXMpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQpO1xuICAgIHRoaXMubm90aWZ5KGV2ZW50LCBlbGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbmRlZmluZSQzLmV2ZW50QWxpYXNlc09uKGVsZXNmbiR2KTtcblxudmFyIGNvcmVmbiQyID0ge1xuICBwbmc6IGZ1bmN0aW9uIHBuZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcmVuZGVyZXIucG5nKG9wdGlvbnMpO1xuICB9LFxuICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyhvcHRpb25zKTtcbiAgfVxufTtcbmNvcmVmbiQyLmpwZWcgPSBjb3JlZm4kMi5qcGc7XG5cbnZhciBjb3JlZm4kMyA9IHtcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgIGlmIChMYXlvdXQgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ05vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kLiAgRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlcztcblxuICAgIGlmIChzdHJpbmcob3B0aW9ucy5lbGVzKSkge1xuICAgICAgZWxlcyA9IGN5LiQob3B0aW9ucy5lbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pKTtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG59O1xuY29yZWZuJDMuY3JlYXRlTGF5b3V0ID0gY29yZWZuJDMubWFrZUxheW91dCA9IGNvcmVmbiQzLmxheW91dDtcblxudmFyIGNvcmVmbiQ0ID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChldmVudEVsZXMgIT0gbnVsbCkge1xuICAgICAgICBlbGVzLm1lcmdlKGV2ZW50RWxlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIGV4aXQgaWYgZGVzdHJveSgpIGNhbGxlZCBvbiBjb3JlIG9yIHJlbmRlcmVyIGluIGJldHdlZW4gZnJhbWVzICMxNDk5ICMxNTI4XG5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQoKSB8fCAhcmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICB9LFxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm9Ob3RpZmljYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgfSxcbiAgYmF0Y2hpbmc6IGZ1bmN0aW9uIGJhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJhdGNoQ291bnQgPiAwO1xuICB9LFxuICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF9wLmJhdGNoQ291bnQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudC0tO1xuXG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcblxuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpOyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuXG4gICAgICBPYmplY3Qua2V5cyhfcC5iYXRjaE5vdGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmIChlbGVzLmVtcHR5KCkpIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgcmVuZGVyZXJEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgaGlkZUVkZ2VzT25WaWV3cG9ydDogZmFsc2UsXG4gIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcbiAgbW90aW9uQmx1cjogZmFsc2UsXG4gIG1vdGlvbkJsdXJPcGFjaXR5OiAwLjA1LFxuICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IDQsXG4gIHRvdWNoVGFwVGhyZXNob2xkOiA4LFxuICB3aGVlbFNlbnNpdGl2aXR5OiAxLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHNob3dGcHM6IGZhbHNlXG59KTtcbnZhciBjb3JlZm4kNSA9IHtcbiAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICByLnJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcbiAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5KCdkcmF3Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3Jlc2l6ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuXG4gICAgaWYgKFJlbmRlcmVyUHJvdG8gPT0gbnVsbCkge1xuICAgICAgZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYFwiLmNvbmNhdChvcHRpb25zLm5hbWUsIFwiYCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD9cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybihcIllvdSBoYXZlIHNldCBhIGN1c3RvbSB3aGVlbCBzZW5zaXRpdml0eS4gIFRoaXMgd2lsbCBtYWtlIHlvdXIgYXBwIHpvb20gdW5uYXR1cmFsbHkgd2hlbiB1c2luZyBtYWluc3RyZWFtIG1pY2UuICBZb3Ugc2hvdWxkIGNoYW5nZSB0aGlzIHZhbHVlIGZyb20gdGhlIGRlZmF1bHQgb25seSBpZiB5b3UgY2FuIGd1YXJhbnRlZSB0aGF0IGFsbCB5b3VyIHVzZXJzIHdpbGwgdXNlIHRoZSBzYW1lIGhhcmR3YXJlIGFuZCBPUyBjb25maWd1cmF0aW9uIGFzIHlvdXIgY3VycmVudCBtYWNoaW5lLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgck9wdHMgPSByZW5kZXJlckRlZmF1bHRzKG9wdGlvbnMpO1xuICAgIHJPcHRzLmN5ID0gY3k7XG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhyT3B0cyk7XG4gICAgdGhpcy5ub3RpZnkoJ2luaXQnKTtcbiAgfSxcbiAgZGVzdHJveVJlbmRlcmVyOiBmdW5jdGlvbiBkZXN0cm95UmVuZGVyZXIoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5ub3RpZnkoJ2Rlc3Ryb3knKTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmIChkb21FbGUpIHtcbiAgICAgIGRvbUVsZS5fY3lyZWcgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoZG9tRWxlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkb21FbGUucmVtb3ZlQ2hpbGQoZG9tRWxlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbnVsbDsgLy8gdG8gYmUgZXh0cmEgc2FmZSwgcmVtb3ZlIHRoZSByZWZcblxuICAgIGN5Lm11dGFibGVFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgX3AucnNjcmF0Y2ggPSB7fTtcbiAgICAgIF9wLnJzdHlsZSA9IHt9O1xuICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgIH0pO1xuICB9LFxuICBvblJlbmRlcjogZnVuY3Rpb24gb25SZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbigncmVuZGVyJywgZm4pO1xuICB9LFxuICBvZmZSZW5kZXI6IGZ1bmN0aW9uIG9mZlJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9mZigncmVuZGVyJywgZm4pO1xuICB9XG59O1xuY29yZWZuJDUuaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4kNS5yZXNpemU7XG5cbnZhciBjb3JlZm4kNiA9IHtcbiAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAvLyAtIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgaW4gdGhlIGdyYXBoIG9uIHNlbGVjdG9yIGFyZ1xuICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICBjb2xsZWN0aW9uOiBmdW5jdGlvbiBjb2xsZWN0aW9uKGVsZXMsIG9wdHMpIHtcbiAgICBpZiAoc3RyaW5nKGVsZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kKGVsZXMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgcmV0dXJuIGVsZXMuY29sbGVjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoZWxlcykpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBlbGVzLCBvcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gIH0sXG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH0sXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24gJChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgfVxuICB9LFxuICBtdXRhYmxlRWxlbWVudHM6IGZ1bmN0aW9uIG11dGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5jb3JlZm4kNi5lbGVtZW50cyA9IGNvcmVmbiQ2LmZpbHRlciA9IGNvcmVmbiQ2LiQ7XG5cbnZhciBzdHlmbiA9IHt9OyAvLyBrZXlzIGZvciBzdHlsZSBibG9ja3MsIGUuZy4gdHRmZnR0XG5cbnZhciBUUlVFID0gJ3QnO1xudmFyIEZBTFNFID0gJ2YnOyAvLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcblxuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgaWYgKF9wLm5ld1N0eWxlKSB7XG4gICAgLy8gY2xlYXIgc3R5bGUgY2FjaGVzXG4gICAgX3AuY29udGV4dFN0eWxlcyA9IHt9O1xuICAgIF9wLnByb3BEaWZmcyA9IHt9O1xuICAgIHNlbGYuY2xlYW5FbGVtZW50cyhlbGVzLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoZWxlKTtcblxuICAgIGlmIChjeHRNZXRhLmVtcHR5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZShjeHRNZXRhKTtcbiAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZShjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKTtcblxuICAgIGlmICghX3AubmV3U3R5bGUpIHtcbiAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBhcHAuZGlmZlByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgaGludHNEaWZmID0gc2VsZi51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZShlbGUpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlbWVudHNcblxuXG4gIF9wLm5ld1N0eWxlID0gZmFsc2U7XG4gIHJldHVybiB1cGRhdGVkRWxlcztcbn07XG5cbnN0eWZuLmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24gKG9sZEN4dEtleSwgbmV3Q3h0S2V5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgIGlmIChjeHRIYXNEaWZmZWQgfHwgbmV3SGFzQ3h0ICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICB2YXIgcHJvcHMgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgfSBlbHNlIGlmIChjeHRIYXNEaWZmZWQpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgfSBlbHNlIGlmIChjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7IC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgIC8vIGlzIGNhY2hlZClcblxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09IFRSVUU7XG5cbiAgICAgICAgICBpZiAoIWhhc0xhdGVyQ3h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuXG4gICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzW3Byb3AubmFtZV0gIT0gbnVsbDtcblxuICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWRkZWRQcm9wW25hbWVdICYmICFsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgIGFkZGVkUHJvcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgZGlmZlByb3BzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB9IC8vIGlmXG5cbiAgfSAvLyBmb3IgY29udGV4dHNcblxuXG4gIGNhY2hlW2R1YWxDeHRLZXldID0gZGlmZlByb3BzO1xuICByZXR1cm4gZGlmZlByb3BzO1xufTtcblxuc3R5Zm4uZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICBpZiAoc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSkge1xuICAgIHByZXZLZXkgPSAnJzsgLy8gc2luY2Ugd2UgbmVlZCB0byBhcHBseSBhbGwgc3R5bGUgaWYgYSBmcmVzaCBzdHlsZXNoZWV0XG4gIH0gLy8gZ2V0IHRoZSBjeHQga2V5XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyhlbGUpOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICBpZiAoY29udGV4dFNlbGVjdG9yTWF0Y2hlcykge1xuICAgICAgY3h0S2V5ICs9IFRSVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN4dEtleSArPSBGQUxTRTtcbiAgICB9XG4gIH0gLy8gZm9yIGNvbnRleHRcblxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcbiAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICB9O1xufTsgLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuXG5cbnN0eWZuLmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9OyAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuXG4gIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcblxuICAgIGlmICghaGFzQ3h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG5cbiAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVtkaWZmUHJvcE5hbWVdO1xuICAgIHZhciBlbGVQcm9wID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuXG4gICAgaWYgKCFjeHRQcm9wKSB7XG4gICAgICAvLyBubyBjb250ZXh0IHByb3AgbWVhbnMgZGVsZXRlXG4gICAgICBpZiAoIWVsZVByb3ApIHtcbiAgICAgICAgY29udGludWU7IC8vIG5vIGV4aXN0aW5nIHByb3AgbWVhbnMgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIC8vIG5iIGFmZmVjdHMgaW5pdGlhbCBhcHBsaWNhdGlvbiBvbiBtYXBwZWQgdmFsdWVzIGxpa2UgY29udHJvbC1wb2ludC1kaXN0YW5jZXNcbiAgICAgIH0gZWxzZSBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgZGVsZXRlQnlwYXNzZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgIFwiZGVsZXRlXCI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICBpZiAoZWxlUHJvcCA9PT0gY3h0UHJvcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIGEgbWFwcGVkIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICBpZiAoY3h0UHJvcC5tYXBwZWQgPT09IHR5cGVzLmZuIC8vIGNvbnRleHQgcHJvcCBpcyBmdW5jdGlvbiBtYXBwZXJcbiAgICAmJiBlbGVQcm9wICE9IG51bGwgLy8gc29tZSBwcm9wcyBjYW4gYmUgbnVsbCBldmVuIGJ5IGRlZmF1bHQgKGUuZy4gYSBwcm9wIHRoYXQgb3ZlcnJpZGVzIGFub3RoZXIgb25lKVxuICAgICYmIGVsZVByb3AubWFwcGluZyAhPSBudWxsIC8vIGVsZSBwcm9wIGlzIGEgY29uY3JldGUgdmFsdWUgZnJvbSBmcm9tIGEgbWFwcGVyXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nLnZhbHVlID09PSBjeHRQcm9wLnZhbHVlIC8vIHRoZSBjdXJyZW50IHByb3Agb24gdGhlIGVsZSBpcyBhIGZsYXQgcHJvcCB2YWx1ZSBmb3IgdGhlIGZ1bmN0aW9uIG1hcHBlclxuICAgICkge1xuICAgICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBlbGVQcm9wLm1hcHBpbmc7IC8vIGNhbiB3cml0ZSB0byBtYXBwaW5nLCBhcyBpdCdzIGEgcGVyLWVsZSBjb3B5XG5cbiAgICAgICAgdmFyIGZuVmFsdWUgPSBtYXBwaW5nLmZuVmFsdWUgPSBjeHRQcm9wLnZhbHVlKGVsZSk7IC8vIHRlbXBvcmFyaWx5IGNhY2hlIHRoZSB2YWx1ZSBpbiBjYXNlIG9mIGEgbWlzc1xuXG4gICAgICAgIGlmIChmblZhbHVlID09PSBtYXBwaW5nLnByZXZGblZhbHVlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY3h0UHJvcCk7XG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gIH07XG59O1xuXG5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BOYW1lcyA9IHNlbGYucHJvcGVydHlHcm91cE5hbWVzO1xuICB2YXIgcHJvcEdyS2V5cyA9IHNlbGYucHJvcGVydHlHcm91cEtleXM7XG5cbiAgdmFyIHByb3BIYXNoID0gZnVuY3Rpb24gcHJvcEhhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpIHtcbiAgICByZXR1cm4gc2VsZi5nZXRQcm9wZXJ0aWVzSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSk7XG4gIH07XG5cbiAgdmFyIG9sZFN0eWxlS2V5ID0gX3Auc3R5bGVLZXk7XG5cbiAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7IC8vIGdldCB0aGUgc3R5bGUga2V5IGhhc2hlcyBwZXIgcHJvcCBncm91cFxuICAvLyBidXQgbGF6aWx5IC0tIG9ubHkgdXNlIG5vbi1kZWZhdWx0IHByb3AgdmFsdWVzIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGhhc2hlc1xuICAvL1xuXG4gIHZhciBvdmVycmlkZGVuU3R5bGVzID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZGVuU3R5bGVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BHcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JLZXkgPSBwcm9wR3JLZXlzW2ldO1xuICAgIF9wLnN0eWxlS2V5c1tncktleV0gPSAwO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUdyS2V5ID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldID0gaGFzaEludCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVHcktleVdTdHIgPSBmdW5jdGlvbiB1cGRhdGVHcktleVdTdHIoc3RyVmFsLCBncktleSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICB1cGRhdGVHcktleShzdHJWYWwuY2hhckNvZGVBdChqKSwgZ3JLZXkpO1xuICAgIH1cbiAgfTsgLy8gLSBoYXNoaW5nIHdvcmtzIG9uIDMyIGJpdCBpbnRzIGIvYyB3ZSB1c2UgYml0d2lzZSBvcHNcbiAgLy8gLSBzbWFsbCBudW1iZXJzIGdldCBjdXQgb2ZmIChlLmcuIDAuMTIzIGlzIHNlZW4gYXMgMCBieSB0aGUgaGFzaGluZyBmdW5jdGlvbilcbiAgLy8gLSByYWlzZSB1cCBzbWFsbCBudW1iZXJzIHNvIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIGFyZSBzZWVuIGJ5IGhhc2hpbmdcbiAgLy8gLSBtYWtlIHNtYWxsIG51bWJlcnMgbGFyZ2VyIHRoYW4gYSBub3JtYWwgdmFsdWUgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAvLyAtIHdvcmtzIGluIHByYWN0aWNlIGFuZCBpdCdzIHJlbGF0aXZlbHkgY2hlYXBcblxuXG4gIHZhciBOID0gMjAwMDAwMDAwMDtcblxuICB2YXIgY2xlYW5OdW0gPSBmdW5jdGlvbiBjbGVhbk51bSh2YWwpIHtcbiAgICByZXR1cm4gLTEyOCA8IHZhbCAmJiB2YWwgPCAxMjggJiYgTWF0aC5mbG9vcih2YWwpICE9PSB2YWwgPyBOIC0gKHZhbCAqIDEwMjQgfCAwKSA6IHZhbDtcbiAgfTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcE5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWVzW19pXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IG92ZXJyaWRkZW5TdHlsZXNbbmFtZV07XG5cbiAgICBpZiAocGFyc2VkUHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcEluZm8gPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgdmFyIHR5cGUgPSBwcm9wSW5mby50eXBlO1xuICAgIHZhciBfZ3JLZXkgPSBwcm9wSW5mby5ncm91cEtleTtcbiAgICB2YXIgbm9ybWFsaXplZE51bWJlclZhbCA9IHZvaWQgMDtcblxuICAgIGlmIChwcm9wSW5mby5oYXNoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHByb3BJbmZvLmhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkUHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfSAvLyBtaWdodCBub3QgYmUgYSBudW1iZXIgaWYgaXQgYWxsb3dzIGVudW1zXG5cblxuICAgIHZhciBudW1iZXJWYWwgPSBwcm9wSW5mby5lbnVtcyA9PSBudWxsID8gcGFyc2VkUHJvcC52YWx1ZSA6IG51bGw7XG4gICAgdmFyIGhhdmVOb3JtTnVtID0gbm9ybWFsaXplZE51bWJlclZhbCAhPSBudWxsO1xuICAgIHZhciBoYXZlVW5pdGVkTnVtID0gbnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVOdW0gPSBoYXZlTm9ybU51bSB8fCBoYXZlVW5pdGVkTnVtO1xuICAgIHZhciB1bml0cyA9IHBhcnNlZFByb3AudW5pdHM7IC8vIG51bWJlcnMgYXJlIGNoZWFwZXIgdG8gaGFzaCB0aGFuIHN0cmluZ3NcbiAgICAvLyAxIGhhc2ggb3AgdnMgbiBoYXNoIG9wcyAoZm9yIGxlbmd0aCBuIHN0cmluZylcblxuICAgIGlmICh0eXBlLm51bWJlciAmJiBoYXZlTnVtKSB7XG4gICAgICB2YXIgdiA9IGhhdmVOb3JtTnVtID8gbm9ybWFsaXplZE51bWJlclZhbCA6IG51bWJlclZhbDtcblxuICAgICAgaWYgKHR5cGUubXVsdGlwbGUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odltfaTJdKSwgX2dyS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGF2ZU5vcm1OdW0gJiYgdW5pdHMgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVHcktleVdTdHIodW5pdHMsIF9ncktleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUdyS2V5V1N0cihwYXJzZWRQcm9wLnN0clZhbHVlLCBfZ3JLZXkpO1xuICAgIH1cbiAgfSAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAvL1xuXG5cbiAgdmFyIGhhc2ggPSAwO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHByb3BHcktleXMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfZ3JLZXkyID0gcHJvcEdyS2V5c1tfaTNdO1xuICAgIHZhciBnckhhc2ggPSBfcC5zdHlsZUtleXNbX2dyS2V5Ml07XG4gICAgaGFzaCA9IGhhc2hJbnQoZ3JIYXNoLCBoYXNoKTtcbiAgfVxuXG4gIF9wLnN0eWxlS2V5ID0gaGFzaDsgLy8gbGFiZWwgZGltc1xuICAvL1xuXG4gIHZhciBsYWJlbERpbXNLZXkgPSBfcC5sYWJlbERpbXNLZXkgPSBfcC5zdHlsZUtleXMubGFiZWxEaW1lbnNpb25zO1xuICBfcC5sYWJlbEtleSA9IHByb3BIYXNoKGVsZSwgWydsYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gaGFzaEludChfcC5zdHlsZUtleXMuY29tbW9uTGFiZWwsIF9wLmxhYmVsS2V5KTtcblxuICBpZiAoIWlzTm9kZSkge1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICAgIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBoYXNoSW50KF9wLnN0eWxlS2V5cy5jb21tb25MYWJlbCwgX3Auc291cmNlTGFiZWxLZXkpO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICAgIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBoYXNoSW50KF9wLnN0eWxlS2V5cy5jb21tb25MYWJlbCwgX3AudGFyZ2V0TGFiZWxLZXkpO1xuICB9IC8vIG5vZGVcbiAgLy9cblxuXG4gIGlmIChpc05vZGUpIHtcbiAgICB2YXIgX3Akc3R5bGVLZXlzID0gX3Auc3R5bGVLZXlzLFxuICAgICAgICBub2RlQm9keSA9IF9wJHN0eWxlS2V5cy5ub2RlQm9keSxcbiAgICAgICAgbm9kZUJvcmRlciA9IF9wJHN0eWxlS2V5cy5ub2RlQm9yZGVyLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcCRzdHlsZUtleXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgICBjb21wb3VuZCA9IF9wJHN0eWxlS2V5cy5jb21wb3VuZCxcbiAgICAgICAgcGllID0gX3Akc3R5bGVLZXlzLnBpZTtcbiAgICBfcC5ub2RlS2V5ID0gaGFzaEludHNBcnJheShbbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBjb21wb3VuZCwgcGllXSwgbm9kZUJvZHkpO1xuICAgIF9wLmhhc1BpZSA9IHBpZSAhPSAwO1xuICB9XG5cbiAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbn07XG5cbnN0eWZuLmNsZWFyU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBfcC5zdHlsZUtleXMgPSB7fTtcbiAgX3Auc3R5bGVLZXkgPSBudWxsO1xuICBfcC5sYWJlbEtleSA9IG51bGw7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5zb3VyY2VMYWJlbEtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC50YXJnZXRMYWJlbEtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5ub2RlS2V5ID0gbnVsbDtcbiAgX3AuaGFzUGllID0gbnVsbDtcbn07IC8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuXG5cbnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlLCBwYXJzZWRQcm9wKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBmbGF0UHJvcDtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbcHJvcC5uYW1lXS50eXBlO1xuICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gIHZhciBvcmlnUHJvcCA9IHN0eWxlW3Byb3AubmFtZV07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG5cbiAgdmFyIGdldFZhbCA9IGZ1bmN0aW9uIGdldFZhbChwKSB7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChwLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHAucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHAudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gY2hlY2tUcmlnZ2VycygpIHtcbiAgICB2YXIgZnJvbVZhbCA9IGdldFZhbChvcmlnUHJvcCk7XG4gICAgdmFyIHRvVmFsID0gZ2V0VmFsKHByb3ApO1xuICAgIHNlbGYuY2hlY2tUcmlnZ2VycyhlbGUsIHByb3AubmFtZSwgZnJvbVZhbCwgdG9WYWwpO1xuICB9OyAvLyBlZGdlIHNhbml0eSBjaGVja3MgdG8gcHJldmVudCB0aGUgY2xpZW50IGZyb20gbWFraW5nIHNlcmlvdXMgbWlzdGFrZXNcblxuXG4gIGlmIChwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgZWxlLmlzRWRnZSgpICYmICggLy8gbG9vcHMgbXVzdCBiZSBidW5kbGVkIGJlemllcnNcbiAgcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2JlemllcicgJiYgZWxlLmlzTG9vcCgpIHx8IC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snICYmIChlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSkpKSB7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gIH1cblxuICBpZiAocHJvcFtcImRlbGV0ZVwiXSkge1xuICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgYW5kIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBmYWxzZXkgdmFsdWVcbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfSAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcblxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uIHByaW50TWFwcGluZ0VycigpIHtcbiAgICB3YXJuKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChpLmUuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaGFzIG5vIG1hcHBpbmcgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnKTtcbiAgfTsgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuXG5cbiAgc3dpdGNoIChwcm9wLm1hcHBlZCkge1xuICAgIC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkVmFsID09IG51bGwpIHtcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVyY2VudDtcblxuICAgICAgICBpZiAoIW51bWJlcihmaWVsZFZhbCkpIHtcbiAgICAgICAgICAvLyB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgd2FybignRG8gbm90IHVzZSBjb250aW51b3VzIG1hcHBlcnMgd2l0aG91dCBzcGVjaWZ5aW5nIG51bWVyaWMgZGF0YSAoaS5lLiBgJyArIHByb3AuZmllbGQgKyAnOiAnICsgZmllbGRWYWwgKyAnYCBmb3IgYCcgKyBlbGUuaWQoKSArICdgIGlzIG5vbi1udW1lcmljKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmllbGRXaWR0aCA9IHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluO1xuXG4gICAgICAgICAgaWYgKGZpZWxkV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayAtLSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IGFzIG5vIHByb3BzIG9mIHplcm8gcmFuZ2Ugc2hvdWxkIGJlIHBhc3NlZCBoZXJlXG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gZmllbGRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcblxuXG4gICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5jb2xvcikge1xuICAgICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuICAgICAgICAgIHZhciBjbHIgPSBbTWF0aC5yb3VuZChyMSArIChyMiAtIHIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogcGVyY2VudCksIE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChhMSArIChhMiAtIGExKSAqIHBlcmNlbnQpXTtcbiAgICAgICAgICBmbGF0UHJvcCA9IHtcbiAgICAgICAgICAgIC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsXG4gICAgICAgICAgICAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5udW1iZXIpIHtcbiAgICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4gb25seSBtYXAgdG8gY29sb3VycyBhbmQgbnVtYmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IHRoZSBwcm9wZXJ0eSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG5cbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG5cbiAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgICB7XG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgdmFyIF9maWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgdmFyIF9maWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgX2ZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBfaTQrKykge1xuICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pNF07XG4gICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW19maWVsZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2ZpZWxkVmFsICE9IG51bGwpIHtcbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBfZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIHR5cGVzLmZuOlxuICAgICAge1xuICAgICAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgICAgICB2YXIgZm5SZXRWYWwgPSBwcm9wLmZuVmFsdWUgIT0gbnVsbCA/IHByb3AuZm5WYWx1ZSA6IGZuKGVsZSk7IC8vIGNoZWNrIGZvciBjYWNoZWQgdmFsdWUgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb25cblxuICAgICAgICBwcm9wLnByZXZGblZhbHVlID0gZm5SZXRWYWw7XG5cbiAgICAgICAgaWYgKGZuUmV0VmFsID09IG51bGwpIHtcbiAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBudWxsIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbnVsbCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIGludmFsaWQgdmFsdWVzIGZvciB0aGUgcHJvcGVydHkgdHlwZSAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIGludmFsaWQpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IGNvcHkocHJvcCk7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGJyZWFrO1xuICAgIC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gIH0gLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG5cblxuICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG5cbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDsgLy8gYW5kIHNldFxuICB9IGVsc2Uge1xuICAgIC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBjaGVja1RyaWdnZXJzKCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuc3R5Zm4uY2xlYW5FbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBrZWVwQnlwYXNzZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdGhpcy5jbGVhclN0eWxlSGludHMoZWxlKTtcbiAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuXG4gICAgaWYgKCFrZWVwQnlwYXNzZXMpIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbcHJvcE5hbWVdO1xuXG4gICAgICAgIGlmIChlbGVQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICAgIGVsZVByb3AuYnlwYXNzZWQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTsgLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuXG5cbnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTsgLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cblxuXG5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChlbGUsIGRpZmZQcm9wcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpLnZhbHVlO1xuICB2YXIgZHVyYXRpb24gPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGRlbGF5ID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kZWxheScpLnBmVmFsdWU7XG5cbiAgaWYgKHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwKSB7XG4gICAgdmFyIHN0eWxlID0ge307IC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcblxuICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3BdO1xuXG4gICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgdmFyIGluaXRWYWwgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgIGlmICghZnJvbVByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuXG5cbiAgICAgIGlmIChudW1iZXIoZnJvbVByb3AucGZWYWx1ZSkgJiYgbnVtYmVyKHRvUHJvcC5wZlZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIoZnJvbVByb3AudmFsdWUpICYmIG51bWJlcih0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcblxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmOyAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKGFycmF5KGZyb21Qcm9wLnZhbHVlKSAmJiBhcnJheSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV0gfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXTtcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfSAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcblxuXG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG5cbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGluaXRWYWwpOyAvLyBmcm9tIHZhbFxuXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuICAgIC8vIGNhbid0IHRyYW5zaXRpb24gaWYgdGhlcmUncyBub3RoaW5nIHByZXZpb3VzIHRvIHRyYW5zaXRpb24gZnJvbVxuXG5cbiAgICBpZiAoIWFueVByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGVsZS5kZWxheUFuaW1hdGlvbihkZWxheSkucGxheSgpLnByb21pc2UoKS50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsZS5hbmltYXRpb24oe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpLnZhbHVlLFxuICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZiggIWlzQnlwYXNzICl7XG4gICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIH1cblxuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKF9wLnRyYW5zaXRpb25pbmcpIHtcbiAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuXG4gIGlmICh0cmlnZ2VyQ2hlY2sgIT0gbnVsbCAmJiB0cmlnZ2VyQ2hlY2soZnJvbVZhbHVlLCB0b1ZhbHVlKSkge1xuICAgIG9uVHJpZ2dlcihwcm9wKTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNaT3JkZXI7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoJ3pvcmRlcicsIGVsZSk7XG4gIH0pO1xufTtcblxuc3R5Zm4uY2hlY2tCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7IC8vIGlmIHRoZSBwcm9wIGNoYW5nZSBtYWtlcyB0aGUgYmIgb2YgcGxsIGJlemllciBlZGdlcyBpbnZhbGlkLFxuICAgIC8vIHRoZW4gZGlydHkgdGhlIHBsbCBlZGdlIGJiIGNhY2hlIGFzIHdlbGxcblxuICAgIGlmICggLy8gb25seSBmb3IgYmV6aWVycyAtLSBzbyBwZXJmb3JtYW5jZSBvZiBvdGhlciBlZGdlcyBpc24ndCBhZmZlY3RlZFxuICAgIChlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJyAvLyBhbHJlYWR5IGEgYmV6aWVyXG4gICAgLy8gd2FzIGp1c3Qgbm93IGNoYW5nZWQgdG8gb3IgZnJvbSBhIGJlemllcjpcbiAgICB8fCBuYW1lID09PSAnY3VydmUtc3R5bGUnICYmIChmcm9tVmFsdWUgPT09ICdiZXppZXInIHx8IHRvVmFsdWUgPT09ICdiZXppZXInKSkgJiYgcHJvcC50cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzKSB7XG4gICAgICBlbGUucGFyYWxsZWxFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKHBsbEVkZ2UpIHtcbiAgICAgICAgaWYgKHBsbEVkZ2UuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuc3R5Zm4uY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICBlbGUuZGlydHlTdHlsZUNhY2hlKCk7XG4gIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgdGhpcy5jaGVja0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xufTtcblxudmFyIHN0eWZuJDEgPSB7fTsgLy8gYnlwYXNzZXMgYXJlIGFwcGxpZWQgdG8gYW4gZXhpc3Rpbmcgc3R5bGUgb24gYW4gZWxlbWVudCwgYW5kIGp1c3QgdGFja2VkIG9uIHRlbXBvcmFyaWx5XG4vLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuXG5zdHlmbiQxLmFwcGx5QnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlOyAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG5cbiAgaWYgKG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionKSB7XG4gICAgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShfbmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChwYXJzZWRQcm9wKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChwYXJzZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICB2YXIgX3BhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgIGlmIChfcGFyc2VkUHJvcCkge1xuICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNwZWNpZmllZFByb3BzKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbmFtZTIgPSBuYW1lc1tfaV07XG4gICAgICB2YXIgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbX25hbWUyXTtcblxuICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW2Rhc2gyY2FtZWwoX25hbWUyKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3BhcnNlZFByb3AyID0gdGhpcy5wYXJzZShfbmFtZTIsIF92YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKF9wYXJzZWRQcm9wMikge1xuICAgICAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3AyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuXG5cbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcblxuXG4gIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzW19pMl07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBfcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbX3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgX3Byb3ApIHx8IHJldDtcblxuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG5cbiAgcmV0dXJuIHJldDtcbn07IC8vIG9ubHkgdXNlZnVsIGluIHNwZWNpZmljIGNhc2VzIGxpa2UgYW5pbWF0aW9uXG5cblxuc3R5Zm4kMS5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1tuYW1lXS50eXBlO1xuICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcbiAgICB2YXIgb2xkVmFsdWUgPSAhcHJvcCA/IG51bGwgOiBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICBpZiAoIXByb3AgfHwgIXByb3AuYnlwYXNzKSB7XG4gICAgICAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnBmVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICdyZ2IoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0gZWxzZSBpZiAoaXNNdWx0aSkge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tUcmlnZ2VycyhlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gIH1cbn07XG5cbnN0eWZuJDEucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG59O1xuXG5zdHlmbiQxLnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHNbaV07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgIH07XG4gICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxufTtcblxudmFyIHN0eWZuJDIgPSB7fTsgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcblxuc3R5Zm4kMi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuXG4gIGlmIChweCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocHgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgfVxufTsgLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcblxuXG5zdHlmbiQyLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuXG4gIGlmICh3aW5kb3ckMSAmJiBkb21FbGVtZW50ICYmIHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICByZXR1cm4gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxudmFyIHN0eWZuJDMgPSB7fTsgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcblxuc3R5Zm4kMy5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcCkge1xuICBpZiAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldFJhd1N0eWxlKGVsZSwgdHJ1ZSk7XG4gIH1cbn07IC8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG5cbnN0eWZuJDMuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AubmFtZSwgaXNSZW5kZXJlZFZhbCk7XG5cbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICByc3R5bGVbcHJvcC5uYW1lXSA9IHZhbDtcbiAgICAgICAgcnN0eWxlW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4kMy5nZXRJbmRleGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4KSB7XG4gIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBlbGUuY3koKS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSlbc3VicHJvcGVydHldWzBdO1xufTtcblxuc3R5Zm4kMy5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC52YWx1ZSxcbiAgICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgICBzdHJWYWx1ZSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcblxuICAgICAgaWYgKGlzUmVuZGVyZWRWYWwgJiYgdHlwZS5udW1iZXIgJiYgdmFsdWUgIT0gbnVsbCAmJiBudW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgICAgIHZhciBnZXRSZW5kZXJlZFZhbHVlID0gZnVuY3Rpb24gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsICogem9vbTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMgPSBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWwsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlbmRlcmVkVmFsdWUodmFsKSArIHVuaXRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc0FycmF5VmFsdWUgPSBhcnJheSh2YWx1ZSk7XG4gICAgICAgIHZhciBoYXZlVW5pdHMgPSBpc0FycmF5VmFsdWUgPyB1bml0cy5ldmVyeShmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiB1ICE9IG51bGw7XG4gICAgICAgIH0pIDogdW5pdHMgIT0gbnVsbDtcblxuICAgICAgICBpZiAoaGF2ZVVuaXRzKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModiwgdW5pdHNbaV0pO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsdWUsIHVuaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKHYpID8gdiA6ICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2KTtcbiAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5zdHlmbiQzLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBhbmlQcm9wcykge1xuICB2YXIgcnN0eWxlID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbmlQcm9wID0gYW5pUHJvcHNbaV07XG4gICAgdmFyIG5hbWUgPSBhbmlQcm9wLm5hbWU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUobmFtZSk7XG5cbiAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgIGlmIChwbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICByc3R5bGVbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuJDMuZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24gKHByb3BzT2JqKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgdmFsID0gc3R5bGVbbmFtZV07XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVdIHx8IHByb3BzW2NhbWVsMmRhc2gobmFtZSldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCB2YWwpO1xuXG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuJDMuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWVzLCBzZWVkKSB7XG4gIHZhciBoYXNoID0gc2VlZDtcbiAgdmFyIG5hbWUsIHZhbCwgc3RyVmFsLCBjaFZhbDtcbiAgdmFyIGksIGo7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIG5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgdmFsID0gZWxlLnBzdHlsZShuYW1lLCBmYWxzZSk7XG5cbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodmFsLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgaGFzaCA9IGhhc2hJbnQoY2hWYWwsIGhhc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJWYWwgPSB2YWwuc3RyVmFsdWU7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY2hWYWwgPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgICAgaGFzaCA9IGhhc2hJbnQoY2hWYWwsIGhhc2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuc3R5Zm4kMy5nZXRQcm9wZXJ0aWVzSGFzaCA9IHN0eWZuJDMuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoO1xuXG52YXIgc3R5Zm4kNCA9IHt9O1xuXG5zdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICBzdHlsZS5jc3MobmFtZSwgdmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07IC8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuXG5cbnN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTsgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuXG5cbnN0eWZuJDQuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb24gPSBbXTtcblxuICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgY3NzW3Byb3AubmFtZV0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxudmFyIHN0eWZuJDUgPSB7fTtcblxuc3R5Zm4kNS5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyOyAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG5cbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOzspIHtcbiAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcblxuICAgIGlmIChub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcblxuICAgIGlmICghc2VsQW5kQmxvY2spIHtcbiAgICAgIHdhcm4oJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTsgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG5cbiAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcblxuICAgIGlmIChzZWxlY3RvclN0ciAhPT0gJ2NvcmUnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpOyAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG5cbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXG5cbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBfbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgICBpZiAoX25vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pXFxzKjsvKTtcblxuICAgICAgaWYgKCFwcm9wQW5kVmFsKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wU3RyXTtcblxuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyKTsgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKHByb3BTdHIsIHZhbFN0cik7XG5cbiAgICAgIGlmICghcGFyc2VkUHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7IC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcblxuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgIHZhbDogdmFsU3RyXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRCbG9jaykge1xuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9IC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuXG5cbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3RvclN0cik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4kNS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBzdHlmbiQ2ID0ge307XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBudW1iZXIgPSBudW1iZXIkMTtcbiAgdmFyIHJnYmEgPSByZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSBoc2xhTm9CYWNrUmVmcztcbiAgdmFyIGhleDMkMSA9IGhleDM7XG4gIHZhciBoZXg2JDEgPSBoZXg2O1xuXG4gIHZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShwcmVmaXgpIHtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJztcbiAgfTtcblxuICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEocHJlZml4KSB7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMkMSArICd8JyArIGhleDYkMTtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICB9O1xuXG4gIHZhciB1cmxSZWdleGVzID0gWydedXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKSQnLCAnXihub25lKSQnLCAnXiguKykkJ107IC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcblxuICBzdHlmbiQ2LnR5cGVzID0ge1xuICAgIHRpbWU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRzOiAnc3xtcycsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnbXMnXG4gICAgfSxcbiAgICBwZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJSdcbiAgICB9LFxuICAgIHBlcmNlbnRhZ2VzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJScsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgemVyb09uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBuT25lT25lTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IC0xLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG5vbk5lZ2F0aXZlSW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICBlbnVtczogWydwYXJlbnQnLCAnb3JpZ2luJ11cbiAgICB9LFxuICAgIG5vZGVTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBlbnVtczogWydsYWJlbCddXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBzdHJpY3RNaW46IHRydWVcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMFxuICAgIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd2ZXJ0aWNhbCcsICd1cHdhcmQnLCAnZG93bndhcmQnLCAnYXV0byddXG4gICAgfSxcbiAgICBwYWRkaW5nUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddXG4gICAgfSxcbiAgICBiZ1dIOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBlbnVtczogWydhdXRvJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdQb3M6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVwZWF0OiB7XG4gICAgICBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdGaXQ6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ3Jvc3NPcmlnaW46IHtcbiAgICAgIGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0NsaXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnbm9kZSddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sb3JzOiB7XG4gICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBmaWxsOiB7XG4gICAgICBlbnVtczogWydzb2xpZCcsICdsaW5lYXItZ3JhZGllbnQnLCAncmFkaWFsLWdyYWRpZW50J11cbiAgICB9LFxuICAgIGJvb2w6IHtcbiAgICAgIGVudW1zOiBbJ3llcycsICdubyddXG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXVxuICAgIH0sXG4gICAgbGluZUNhcDoge1xuICAgICAgZW51bXM6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXVxuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICB9LFxuICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3RheGknXVxuICAgIH0sXG4gICAgZm9udEZhbWlseToge1xuICAgICAgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnXG4gICAgfSxcbiAgICBmb250U3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddXG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiB7XG4gICAgICBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF1cbiAgICB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXVxuICAgIH0sXG4gICAgdGV4dFRyYW5zZm9ybToge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ11cbiAgICB9LFxuICAgIHRleHRXcmFwOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnXVxuICAgIH0sXG4gICAgdGV4dE92ZXJmbG93V3JhcDoge1xuICAgICAgZW51bXM6IFsnd2hpdGVzcGFjZScsICdhbnl3aGVyZSddXG4gICAgfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJ11cbiAgICB9LFxuICAgIG5vZGVTaGFwZToge1xuICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZScsICdib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdoZXhhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnY29uY2F2ZS1oZXhhZ29uJywgJ2hlcHRhZ29uJywgJ3JvdW5kLWhlcHRhZ29uJywgJ29jdGFnb24nLCAncm91bmQtb2N0YWdvbicsICd0YWcnLCAncm91bmQtdGFnJywgJ3N0YXInLCAnZGlhbW9uZCcsICdyb3VuZC1kaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJ11cbiAgICB9LFxuICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczoge1xuICAgICAgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ11cbiAgICB9LFxuICAgIGFycm93U2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICB9LFxuICAgIGFycm93RmlsbDoge1xuICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgfSxcbiAgICBkaXNwbGF5OiB7XG4gICAgICBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXVxuICAgIH0sXG4gICAgdmlzaWJpbGl0eToge1xuICAgICAgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgIH0sXG4gICAgekNvbXBvdW5kRGVwdGg6IHtcbiAgICAgIGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXVxuICAgIH0sXG4gICAgekluZGV4Q29tcGFyZToge1xuICAgICAgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXVxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddXG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICB9LFxuICAgIGp1c3RpZmljYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2F1dG8nXVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgc3RyaW5nOiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2RhdGEnKVxuICAgIH0sXG4gICAgbGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdsYXlvdXREYXRhJylcbiAgICB9LFxuICAgIHNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnc2NyYXRjaCcpXG4gICAgfSxcbiAgICBtYXBEYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKVxuICAgIH0sXG4gICAgbWFwTGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJylcbiAgICB9LFxuICAgIG1hcFNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpXG4gICAgfSxcbiAgICBmbjoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIGZuOiB0cnVlXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVybHM6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcHJvcExpc3Q6IHtcbiAgICAgIHByb3BMaXN0OiB0cnVlXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnXG4gICAgfSxcbiAgICB0ZXh0Um90YXRpb246IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJyxcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddXG4gICAgfSxcbiAgICBwb2x5Z29uUG9pbnRMaXN0OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGV2ZW5NdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgZWRnZURpc3RhbmNlczoge1xuICAgICAgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nXVxuICAgIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJywgJ291dHNpZGUtdG8tbGluZScsICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnXSxcbiAgICAgIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJywgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCddLFxuICAgICAgZW51bXM6IFsnbGluZWFyJywgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJywgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLCAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLCAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ11cbiAgICB9LFxuICAgIGdyYWRpZW50RGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWyd0by1ib3R0b20nLCAndG8tdG9wJywgJ3RvLWxlZnQnLCAndG8tcmlnaHQnLCAndG8tYm90dG9tLXJpZ2h0JywgJ3RvLWJvdHRvbS1sZWZ0JywgJ3RvLXRvcC1yaWdodCcsICd0by10b3AtbGVmdCcsICd0by1yaWdodC1ib3R0b20nLCAndG8tbGVmdC1ib3R0b20nLCAndG8tcmlnaHQtdG9wJywgJ3RvLWxlZnQtdG9wJ11cbiAgICB9LFxuICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbDEgPT0gMCAmJiB2YWwyICE9IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbDEgIT0gMCAmJiB2YWwyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uIGFueSh2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gdmFsMSAhPSB2YWwyO1xuICAgIH1cbiAgfTsgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gIC8vXG4gIC8vIC0gbi5iLiBhZGRpbmcgYSBuZXcgZ3JvdXAgb2YgcHJvcHMgbWF5IHJlcXVpcmUgdXBkYXRlcyB0byB1cGRhdGVTdHlsZUhpbnRzKClcbiAgLy8gLSBhZGRpbmcgbmV3IHByb3BzIHRvIGFuIGV4aXN0aW5nIGdyb3VwIGdldHMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5XG5cbiAgdmFyIHQgPSBzdHlmbiQ2LnR5cGVzO1xuICB2YXIgbWFpbkxhYmVsID0gW3tcbiAgICBuYW1lOiAnbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgc291cmNlTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdzb3VyY2UtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdGFyZ2V0TGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0YXJnZXQtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgbGFiZWxEaW1lbnNpb25zID0gW3tcbiAgICBuYW1lOiAnZm9udC1mYW1pbHknLFxuICAgIHR5cGU6IHQuZm9udEZhbWlseSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXN0eWxlJyxcbiAgICB0eXBlOiB0LmZvbnRTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXdlaWdodCcsXG4gICAgdHlwZTogdC5mb250V2VpZ2h0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtdHJhbnNmb3JtJyxcbiAgICB0eXBlOiB0LnRleHRUcmFuc2Zvcm0sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC13cmFwJyxcbiAgICB0eXBlOiB0LnRleHRXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3ZlcmZsb3ctd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0T3ZlcmZsb3dXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWF4LXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1oZWlnaHQnLFxuICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgY29tbW9uTGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0ZXh0LXZhbGlnbicsXG4gICAgdHlwZTogdC52YWxpZ24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1oYWxpZ24nLFxuICAgIHR5cGU6IHQuaGFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLFxuICAgIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWp1c3RpZmljYXRpb24nLFxuICAgIHR5cGU6IHQuanVzdGlmaWNhdGlvblxuICB9XTtcbiAgdmFyIGJlaGF2aW9yID0gW3tcbiAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2xcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWV2ZW50cycsXG4gICAgdHlwZTogdC5ib29sXG4gIH1dO1xuICB2YXIgdmlzaWJpbGl0eSA9IFt7XG4gICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgIHR5cGU6IHQuZGlzcGxheSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnM6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICd2aXNpYmlsaXR5JyxcbiAgICB0eXBlOiB0LnZpc2liaWxpdHksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnei1jb21wb3VuZC1kZXB0aCcsXG4gICAgdHlwZTogdC56Q29tcG91bmREZXB0aCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4LWNvbXBhcmUnLFxuICAgIHR5cGU6IHQuekluZGV4Q29tcGFyZSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4JyxcbiAgICB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG92ZXJsYXkgPSBbe1xuICAgIG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfV07XG4gIHZhciB0cmFuc2l0aW9uID0gW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsXG4gICAgdHlwZTogdC5wcm9wTGlzdFxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgICB0eXBlOiB0LmVhc2luZ1xuICB9XTtcblxuICB2YXIgbm9kZVNpemVIYXNoT3ZlcnJpZGUgPSBmdW5jdGlvbiBub2RlU2l6ZUhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApIHtcbiAgICBpZiAocGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIC1lbGUucG9vbEluZGV4KCk7IC8vIG5vIGhhc2gga2V5IGhpdHMgaXMgdXNpbmcgbGFiZWwgc2l6ZSAoaGl0cmF0ZSBmb3IgcGVyZiBwcm9iYWJseSBsb3cgYW55d2F5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbm9kZUJvZHkgPSBbe1xuICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgfSwge1xuICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlJyxcbiAgICB0eXBlOiB0Lm5vZGVTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsXG4gICAgdHlwZTogdC5wb2x5Z29uUG9pbnRMaXN0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpbGwnLFxuICAgIHR5cGU6IHQuZmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJyxcbiAgICB0eXBlOiB0Lm5PbmVPbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5ncmFkaWVudERpcmVjdGlvblxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LnBhZGRpbmdSZWxhdGl2ZVRvLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvdW5kcy1leHBhbnNpb24nLFxuICAgIHR5cGU6IHQuYm91bmRzRXhwYW5zaW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG5vZGVCb3JkZXIgPSBbe1xuICAgIG5hbWU6ICdib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gIH1dO1xuICB2YXIgYmFja2dyb3VuZEltYWdlID0gW3tcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsXG4gICAgdHlwZTogdC51cmxzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsXG4gICAgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgdHlwZTogdC5iZ1JlcGVhdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZml0JyxcbiAgICB0eXBlOiB0LmJnRml0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICB0eXBlOiB0LmJnQ2xpcFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9XTtcbiAgdmFyIGNvbXBvdW5kID0gW3tcbiAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgIHR5cGU6IHQucG9zaXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLFxuICAgIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGVkZ2VMaW5lID0gW3tcbiAgICBuYW1lOiAnbGluZS1zdHlsZScsXG4gICAgdHlwZTogdC5saW5lU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNhcCcsXG4gICAgdHlwZTogdC5saW5lQ2FwXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLXBhdHRlcm4nLFxuICAgIHR5cGU6IHQubnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZGFzaC1vZmZzZXQnLFxuICAgIHR5cGU6IHQubnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnY3VydmUtc3R5bGUnLFxuICAgIHR5cGU6IHQuY3VydmVTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVyczogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsXG4gICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuZWRnZURpc3RhbmNlcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1zY2FsZScsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLXN3ZWVwJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZ2hvc3QgPSBbe1xuICAgIG5hbWU6ICdnaG9zdCcsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTtcbiAgdmFyIGNvcmUgPSBbe1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07IC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcblxuICB2YXIgcGllID0gW107XG4gIHN0eWZuJDYucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG5cbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDYucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH0gLy8gZWRnZSBhcnJvd3NcblxuXG4gIHZhciBlZGdlQXJyb3cgPSBbXTtcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbiQ2LmFycm93UHJlZml4ZXMgPSBbJ3NvdXJjZScsICdtaWQtc291cmNlJywgJ3RhcmdldCcsICdtaWQtdGFyZ2V0J107XG4gIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB0eXBlOiB0LmFycm93U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB0eXBlOiB0LmFycm93RmlsbFxuICB9XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGUsXG4gICAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG4gIHZhciBwcm9wcyA9IHN0eWZuJDYucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgZ2hvc3QsIGNvbW1vbkxhYmVsLCBsYWJlbERpbWVuc2lvbnMsIG1haW5MYWJlbCwgc291cmNlTGFiZWwsIHRhcmdldExhYmVsLCBub2RlQm9keSwgbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBwaWUsIGNvbXBvdW5kLCBlZGdlTGluZSwgZWRnZUFycm93LCBjb3JlKTtcbiAgdmFyIHByb3BHcm91cHMgPSBzdHlmbiQ2LnByb3BlcnR5R3JvdXBzID0ge1xuICAgIC8vIGNvbW1vbiB0byBhbGwgZWxlc1xuICAgIGJlaGF2aW9yOiBiZWhhdmlvcixcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgIHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG4gICAgb3ZlcmxheTogb3ZlcmxheSxcbiAgICBnaG9zdDogZ2hvc3QsXG4gICAgLy8gbGFiZWxzXG4gICAgY29tbW9uTGFiZWw6IGNvbW1vbkxhYmVsLFxuICAgIGxhYmVsRGltZW5zaW9uczogbGFiZWxEaW1lbnNpb25zLFxuICAgIG1haW5MYWJlbDogbWFpbkxhYmVsLFxuICAgIHNvdXJjZUxhYmVsOiBzb3VyY2VMYWJlbCxcbiAgICB0YXJnZXRMYWJlbDogdGFyZ2V0TGFiZWwsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgIG5vZGVCb2R5OiBub2RlQm9keSxcbiAgICBub2RlQm9yZGVyOiBub2RlQm9yZGVyLFxuICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlLFxuICAgIHBpZTogcGllLFxuICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgZWRnZUxpbmU6IGVkZ2VMaW5lLFxuICAgIGVkZ2VBcnJvdzogZWRnZUFycm93LFxuICAgIGNvcmU6IGNvcmVcbiAgfTtcbiAgdmFyIHByb3BHcm91cE5hbWVzID0gc3R5Zm4kNi5wcm9wZXJ0eUdyb3VwTmFtZXMgPSB7fTtcbiAgdmFyIHByb3BHcm91cEtleXMgPSBzdHlmbiQ2LnByb3BlcnR5R3JvdXBLZXlzID0gT2JqZWN0LmtleXMocHJvcEdyb3Vwcyk7XG4gIHByb3BHcm91cEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcHJvcEdyb3VwTmFtZXNba2V5XSA9IHByb3BHcm91cHNba2V5XS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLm5hbWU7XG4gICAgfSk7XG4gICAgcHJvcEdyb3Vwc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLmdyb3VwS2V5ID0ga2V5O1xuICAgIH0pO1xuICB9KTsgLy8gZGVmaW5lIGFsaWFzZXNcblxuICB2YXIgYWxpYXNlcyA9IHN0eWZuJDYuYWxpYXNlcyA9IFt7XG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIHBvaW50c1RvOiAnbGFiZWwnXG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcydcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LXdlaWdodHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJyxcbiAgICBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1sZWZ0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yaWdodCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctdG9wJyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1ib3R0b20nLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfV07IC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcblxuICBzdHlmbiQ2LnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5uYW1lO1xuICB9KTsgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW19pXTtcbiAgICBwcm9wc1twcm9wLm5hbWVdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfSAvLyBtYXAgYWxpYXNlc1xuXG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYWxpYXNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGFsaWFzID0gYWxpYXNlc1tfaTJdO1xuICAgIHZhciBwb2ludHNUb1Byb3AgPSBwcm9wc1thbGlhcy5wb2ludHNUb107XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9OyAvLyBhZGQgYWxpYXMgcHJvcCBmb3IgcGFyc2luZ1xuXG4gICAgcHJvcHMucHVzaChhbGlhc1Byb3ApO1xuICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG5zdHlmbiQ2LmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbbmFtZV07XG59O1xuXG5zdHlmbiQ2LmdldERlZmF1bHRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gIGlmIChfcC5kZWZhdWx0UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xuICB9XG5cbiAgdmFyIHJhd1Byb3BzID0gZXh0ZW5kKHtcbiAgICAvLyBjb3JlIHByb3BzXG4gICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1LFxuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAndGV4dC1qdXN0aWZpY2F0aW9uJzogJ2F1dG8nLFxuICAgICdsaW5lLWhlaWdodCc6IDEsXG4gICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICd0ZXh0LW92ZXJmbG93LXdyYXAnOiAnd2hpdGVzcGFjZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAnb3BhY2l0eSc6IDEsXG4gICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAnei1pbmRleCc6IDAsXG4gICAgJ2xhYmVsJzogJycsXG4gICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWZpbGwnOiAnc29saWQnLFxuICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1vZmZzZXQteCc6IDAsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXknOiAwLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnaGVpZ2h0JzogMzAsXG4gICAgJ3dpZHRoJzogMzAsXG4gICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG4gICAgJ2JvdW5kcy1leHBhbnNpb24nOiAwLFxuICAgIC8vIG5vZGUgZ3JhZGllbnRcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nOiAndG8tYm90dG9tJyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgLy8gZ2hvc3QgcHJvcHNcbiAgICAnZ2hvc3QnOiAnbm8nLFxuICAgICdnaG9zdC1vZmZzZXQteSc6IDAsXG4gICAgJ2dob3N0LW9mZnNldC14JzogMCxcbiAgICAnZ2hvc3Qtb3BhY2l0eSc6IDAsXG4gICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAncGFkZGluZyc6IDAsXG4gICAgJ3BhZGRpbmctcmVsYXRpdmUtdG8nOiAnd2lkdGgnLFxuICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcbiAgICAnbWluLXdpZHRoJzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLXJpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy10b3AnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogMFxuICB9LCB7XG4gICAgLy8gbm9kZSBwaWUgYmdcbiAgICAncGllLXNpemUnOiAnMTAwJSdcbiAgfSwgW3tcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLFxuICAgIHZhbHVlOiAnYmxhY2snXG4gIH0sIHtcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtc2l6ZScsXG4gICAgdmFsdWU6ICcwJSdcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDYucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSwge1xuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ2xpbmUtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY2FwJzogJ2J1dHQnLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgJ3RheGktdHVybic6ICc1MCUnLFxuICAgICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJzogMTAsXG4gICAgJ3RheGktZGlyZWN0aW9uJzogJ2F1dG8nLFxuICAgICdlZGdlLWRpc3RhbmNlcyc6ICdpbnRlcnNlY3Rpb24nLFxuICAgICdjdXJ2ZS1zdHlsZSc6ICdoYXlzdGFjaycsXG4gICAgJ2hheXN0YWNrLXJhZGl1cyc6IDAsXG4gICAgJ2Fycm93LXNjYWxlJzogMSxcbiAgICAnbG9vcC1kaXJlY3Rpb24nOiAnLTQ1ZGVnJyxcbiAgICAnbG9vcC1zd2VlcCc6ICctOTBkZWcnLFxuICAgICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAnbGluZS1kYXNoLXBhdHRlcm4nOiBbNiwgM10sXG4gICAgJ2xpbmUtZGFzaC1vZmZzZXQnOiAwXG4gIH0sIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB2YWx1ZTogJ25vbmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHZhbHVlOiAnIzk5OSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB2YWx1ZTogJ2ZpbGxlZCdcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBzdHlmbiQ2LmFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSk7XG4gIHZhciBwYXJzZWRQcm9wcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG5cbiAgICBpZiAocHJvcC5wb2ludHNUbykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgdmFyIHZhbCA9IHJhd1Byb3BzW25hbWVdO1xuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWwpO1xuICAgIHBhcnNlZFByb3BzW25hbWVdID0gcGFyc2VkUHJvcDtcbiAgfVxuXG4gIF9wLmRlZmF1bHRQcm9wZXJ0aWVzID0gcGFyc2VkUHJvcHM7XG4gIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbn07XG5cbnN0eWZuJDYuYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0b3IoJzpwYXJlbnQnKS5jc3Moe1xuICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICdwYWRkaW5nJzogMTAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAnYm9yZGVyLXdpZHRoJzogMVxuICB9KS5zZWxlY3RvcignZWRnZScpLmNzcyh7XG4gICAgJ3dpZHRoJzogM1xuICB9KS5zZWxlY3RvcignOmxvb3AnKS5jc3Moe1xuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInXG4gIH0pLnNlbGVjdG9yKCdlZGdlOmNvbXBvdW5kJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnXG4gIH0pLnNlbGVjdG9yKCc6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdsaW5lLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5J1xuICB9KS5zZWxlY3RvcignOnBhcmVudDpzZWxlY3RlZCcpLmNzcyh7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0NDRTFGOScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjYWVjOGU1J1xuICB9KS5zZWxlY3RvcignOmFjdGl2ZScpLmNzcyh7XG4gICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICB9KTtcbiAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG59O1xuXG52YXIgc3R5Zm4kNyA9IHt9OyAvLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcblxuc3R5Zm4kNy5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuXG4gIGlmIChmbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGJ5cGFzc0tleSA9IHByb3BJc0J5cGFzcyA/ICd0JyA6ICdmJztcbiAgdmFyIHZhbHVlS2V5ID0gJycgKyB2YWx1ZTtcbiAgdmFyIGFyZ0hhc2ggPSBoYXNoU3RyaW5ncyhuYW1lLCB2YWx1ZUtleSwgYnlwYXNzS2V5LCBmbGF0S2V5KTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwgW107XG4gIHZhciByZXQ7XG5cbiAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfSAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuXG5cbiAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgcmV0ID0gY29weShyZXQpO1xuXG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0LnZhbHVlID0gY29weShyZXQudmFsdWUpOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5zdHlmbiQ3LnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuXG4gIGlmICghcHJvcCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgd2FybihcIlRoZSBzdHlsZSBwcm9wZXJ0eSBgXCIuY29uY2F0KG5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcImAgaXMgaW52YWxpZFwiKSk7XG4gIH1cblxuICByZXR1cm4gcHJvcDtcbn07IC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuXG5cbnN0eWZuJDcucGFyc2VJbXBsID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuXG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBjYW4ndCBhc3NpZ24gdW5kZWZpbmVkXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcblxuXG4gIGlmIChwcm9wZXJ0eS5hbGlhcykge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cblxuICB2YXIgdmFsdWVJc1N0cmluZyA9IHN0cmluZyh2YWx1ZSk7XG5cbiAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuXG5cbiAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcblxuXG4gIGlmIChmbih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcblxuXG4gIHZhciBkYXRhLCBtYXBEYXRhO1xuXG4gIGlmICghdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0IHx8IHZhbHVlLmxlbmd0aCA8IDcgfHwgdmFsdWVbMV0gIT09ICdhJykgOyBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gNyAmJiB2YWx1ZVswXSA9PT0gJ2QnICYmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTsgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG5cbiAgICBpZiAoISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG5cbiAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuXG4gICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcblxuXG4gICAgaWYgKHZhbHVlTWluLnBmVmFsdWUgPT09IHZhbHVlTWF4LnBmVmFsdWUgfHwgdmFsdWVNaW4uc3RyVmFsdWUgPT09IHZhbHVlTWF4LnN0clZhbHVlKSB7XG4gICAgICB3YXJuKCdgJyArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSB2YWxpZCBtYXBwZXIgYmVjYXVzZSB0aGUgb3V0cHV0IHJhbmdlIGlzIHplcm87IGNvbnZlcnRpbmcgdG8gYCcgKyBuYW1lICsgJzogJyArIHZhbHVlTWluLnN0clZhbHVlICsgJ2AnKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlTWluLnN0clZhbHVlKTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgIHx8IChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxKSAmJiAoIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICBjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgKTtcblxuICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgdmFyIHZhbHM7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgfSBlbHNlIGlmIChhcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHZhbEFyciA9IFtdO1xuICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgIHZhciBzdHJWYWwgPSAnJztcbiAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcbiAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IHN0cmluZyhwLnZhbHVlKTtcbiAgICAgIHZhbEFyci5wdXNoKHAudmFsdWUpO1xuICAgICAgcGZWYWxBcnIucHVzaChwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUpO1xuICAgICAgdW5pdHNBcnIucHVzaChwLnVuaXRzKTtcbiAgICAgIHN0clZhbCArPSAoaSA+IDAgPyAnICcgOiAnJykgKyBwLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0pIHtcbiAgICAgIGlmICh2YWxBcnIubGVuZ3RoID09PSAxICYmIHN0cmluZyh2YWxBcnJbMF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHN0clZhbCxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgfTtcbiAgfSAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcblxuXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuXG4gICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTsgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG5cblxuICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgIH1cblxuICAgIGlmICghdHlwZS51bml0bGVzcykge1xuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG5cbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG5cblxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgnXignICsgbnVtYmVyJDEgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTsgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgLy8gKGkuZS4gYGxlZnRgLCBgYXV0b2AsIGV0YylcblxuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH0gLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG5cblxuICAgIGlmICh0eXBlLmludGVnZXIgJiYgIWludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuXG5cbiAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPCB0eXBlLm1pbiB8fCB0eXBlLnN0cmljdE1pbiAmJiB2YWx1ZSA9PT0gdHlwZS5taW4pIHx8IHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID4gdHlwZS5tYXggfHwgdHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9OyAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG5cbiAgICBpZiAodHlwZS51bml0bGVzcyB8fCB1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyB2YWx1ZSA6IHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlO1xuICAgIH0gLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG5cblxuICAgIGlmICh1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfSAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcmFkXG5cblxuICAgIGlmICh1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogZGVnMnJhZCh2YWx1ZSk7XG4gICAgfSAvLyBub3JtYWxpemUgdmFsdWUgaW4gJVxuXG5cbiAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2UgaWYgKHR5cGUucHJvcExpc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgaWYgKHByb3BzU3RyID09PSAnbm9uZScpIDsgZWxzZSB7XG4gICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3BzU3BsaXQgPSBwcm9wc1N0ci5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHNTcGxpdC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbX2kyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdgJyArIHByb3BOYW1lICsgJ2AgaXMgbm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignICcpLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICB2YXIgdHVwbGUgPSBjb2xvcjJ0dXBsZSh2YWx1ZSk7XG5cbiAgICBpZiAoIXR1cGxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgIHBmVmFsdWU6IHR1cGxlLFxuICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIHR1cGxlWzBdICsgJywnICsgdHVwbGVbMV0gKyAnLCcgKyB0dXBsZVsyXSArICcpJyxcbiAgICAgIC8vIG4uYi4gbm8gc3BhY2VzIGIvYyBvZiBtdWx0aXBsZSBzdXBwb3J0XG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgIGlmICh0eXBlLmVudW1zKSB7XG4gICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG5cbiAgICAgIGlmIChlbnVtUHJvcCkge1xuICAgICAgICByZXR1cm4gZW51bVByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbdHlwZS5yZWdleF07XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByZWdleGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhlc1tfaTNdKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG5cbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgIGlmIChtKSB7XG4gICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcbiAgfSBlbHNlIGlmICh0eXBlLnN0cmluZykge1xuICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAvLyBjaGVjayBlbnVtcyBsYXN0IGJlY2F1c2UgaXQncyBhIGNvbWJvIHR5cGUgaW4gb3RoZXJzXG4gICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cbn07XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIFN0eWxlKGN5KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlKGN5KTtcbiAgfVxuXG4gIGlmICghY29yZShjeSkpIHtcbiAgICBlcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge31cbiAgfTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xuXG52YXIgc3R5Zm4kOCA9IFN0eWxlLnByb3RvdHlwZTtcblxuc3R5Zm4kOC5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZSc7XG59OyAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG5cblxuc3R5Zm4kOC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgX3AubmV3U3R5bGUgPSB0cnVlO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuJDgucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3RvclxuXG5cbnN0eWZuJDguY29yZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcE5hbWVdIHx8IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BOYW1lKTtcbn07IC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcblxuXG5zdHlmbiQ4LnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcblxuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5cbnN0eWZuJDguY3NzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtwcm9wLm5hbWVdO1xuXG4gICAgICBpZiAobWFwVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFwVmFsID0gbWFwW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXBWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNzc1J1bGUocHJvcC5uYW1lLCBtYXBWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuY3NzUnVsZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfSAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcblxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4kOC5zdHlsZSA9IHN0eWZuJDguY3NzOyAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5zdHlmbiQ4LmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpOyAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG5cbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5tYXBwZWQpIHtcbiAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB9IC8vIGFkZCB0byBjb3JlIHN0eWxlIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG5cbiAgICBpZiAoY3VycmVudFNlbGVjdG9ySXNDb3JlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4kOC5hcHBlbmQgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgc3R5bGUuYXBwZW5kVG9TdHlsZSh0aGlzKTtcbiAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21Kc29uKHN0eWxlKTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgdGhpcy5hcHBlbmRGcm9tU3RyaW5nKHN0eWxlKTtcbiAgfSAvLyB5b3UgcHJvYmFibHkgd291bGRuJ3Qgd2FudCB0byBhcHBlbmQgYSBTdHlsZSwgc2luY2UgeW91J2QgZHVwbGljYXRlIHRoZSBkZWZhdWx0IHBhcnRzXG5cblxuICByZXR1cm4gdGhpcztcbn07IC8vIHN0YXRpYyBmdW5jdGlvblxuXG5cblN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24gKGN5LCBqc29uKSB7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gIHN0eWxlLmZyb21Kc29uKGpzb24pO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG5TdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGN5LCBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBTdHlsZShjeSkuZnJvbVN0cmluZyhzdHJpbmcpO1xufTtcblxuW3N0eWZuLCBzdHlmbiQxLCBzdHlmbiQyLCBzdHlmbiQzLCBzdHlmbiQ0LCBzdHlmbiQ1LCBzdHlmbiQ2LCBzdHlmbiQ3XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoc3R5Zm4kOCwgcHJvcHMpO1xufSk7XG5TdHlsZS50eXBlcyA9IHN0eWZuJDgudHlwZXM7XG5TdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4kOC5wcm9wZXJ0aWVzO1xuU3R5bGUucHJvcGVydHlHcm91cHMgPSBzdHlmbiQ4LnByb3BlcnR5R3JvdXBzO1xuU3R5bGUucHJvcGVydHlHcm91cE5hbWVzID0gc3R5Zm4kOC5wcm9wZXJ0eUdyb3VwTmFtZXM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwS2V5cyA9IHN0eWZuJDgucHJvcGVydHlHcm91cEtleXM7XG5cbnZhciBjb3JlZm4kNyA9IHtcbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5ld1N0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUobmV3U3R5bGUpO1xuICAgICAgcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wLnN0eWxlO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbnZhciBjb3JlZm4kOCA9IHtcbiAgYXV0b2xvY2s6IGZ1bmN0aW9uIGF1dG9sb2NrKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24gYXV0b3Vuc2VsZWN0aWZ5KGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZShzZWxUeXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5zZWxlY3Rpb25UeXBlID09IG51bGwpIHtcbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBkZWZhdWx0U2VsZWN0aW9uVHlwZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoc2VsVHlwZSA9PT0gJ2FkZGl0aXZlJyB8fCBzZWxUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9wLnNlbGVjdGlvblR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJQYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB6b29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGJveFNlbGVjdGlvbkVuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHBhbjogZnVuY3Rpb24gcGFuKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIC5wYW4oKVxuICAgICAgICByZXR1cm4gcGFuO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChzdHJpbmcoYXJnc1swXSkpIHtcbiAgICAgICAgICAvLyAucGFuKCd4JylcbiAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgIHJldHVybiBwYW5bZGltXTtcbiAgICAgICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmIChudW1iZXIoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaW52YWxpZFxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHBsYWluT2JqZWN0KGFyZzApKSB7XG4gICAgICAgICAgLy8gLnBhbkJ5KHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgaWYgKG51bWJlcih4KSkge1xuICAgICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZzA7XG4gICAgICAgIHZhbCA9IGFyZzE7XG5cbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGZpdDogZnVuY3Rpb24gZml0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKTtcblxuICAgIGlmICh2aWV3cG9ydFN0YXRlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZykge1xuICAgIGlmIChudW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZWxlbWVudHMgaXMgb3B0aW9uYWxcbiAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYjtcblxuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuJChzZWwpO1xuICAgIH0gZWxzZSBpZiAoYm91bmRpbmdCb3goZWxlbWVudHMpKSB7XG4gICAgICAvLyBhc3N1bWUgYmJcbiAgICAgIHZhciBiYmUgPSBlbGVtZW50cztcbiAgICAgIGJiID0ge1xuICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICB5MTogYmJlLnkxLFxuICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICB5MjogYmJlLnkyXG4gICAgICB9O1xuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSAmJiBlbGVtZW50cy5lbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBmaXQgdG8gbm90aGluZ1xuXG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBudW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogMDtcblxuICAgIGlmICghaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgYmIudyA+IDAgJiYgYmIuaCA+IDApIHtcbiAgICAgIHpvb20gPSBNYXRoLm1pbigodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCk7IC8vIGNyb3Agem9vbVxuXG4gICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0ge1xuICAgICAgICAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHBhblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIHpvb21SYW5nZTogZnVuY3Rpb24gem9vbVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgdmFyIG9wdHMgPSBtaW47XG4gICAgICBtaW4gPSBvcHRzLm1pbjtcbiAgICAgIG1heCA9IG9wdHMubWF4O1xuICAgIH1cblxuICAgIGlmIChudW1iZXIobWluKSAmJiBudW1iZXIobWF4KSAmJiBtaW4gPD0gbWF4KSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICB9IGVsc2UgaWYgKG51bWJlcihtaW4pICYmIG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA8PSBfcC5tYXhab29tKSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1pblpvb206IGZ1bmN0aW9uIG1pblpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1pbjogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtYXg6IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0Wm9vbWVkVmlld3BvcnQ6IGZ1bmN0aW9uIGdldFpvb21lZFZpZXdwb3J0KHBhcmFtcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnRQYW4gPSBfcC5wYW47XG4gICAgdmFyIGN1cnJlbnRab29tID0gX3Auem9vbTtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuXG4gICAgdmFyIHpvb207XG4gICAgdmFyIGJhaWwgPSBmYWxzZTtcblxuICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgIGJhaWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIocGFyYW1zKSkge1xuICAgICAgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgIHpvb20gPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcblxuICAgICAgaWYgKHBhcmFtcy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHBhcmFtcy5wb3NpdGlvbiwgY3VycmVudFpvb20sIGN1cnJlbnRQYW4pO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zICE9IG51bGwgJiYgIV9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBjcm9wIHpvb21cblxuXG4gICAgem9vbSA9IHpvb20gPiBfcC5tYXhab29tID8gX3AubWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCBfcC5taW5ab29tID8gX3AubWluWm9vbSA6IHpvb207IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuXG4gICAgaWYgKGJhaWwgfHwgIW51bWJlcih6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIW51bWJlcihwb3MueCkgfHwgIW51bWJlcihwb3MueSkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgIC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IGN1cnJlbnRQYW47XG4gICAgICB2YXIgem9vbTEgPSBjdXJyZW50Wm9vbTtcbiAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICBwYW5uZWQ6IHRydWUsXG4gICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICBwYW46IHBhbjJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogZmFsc2UsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogY3VycmVudFBhblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHpvb206IGZ1bmN0aW9uIHpvb20ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldFxuICAgICAgdmFyIHZwID0gdGhpcy5nZXRab29tZWRWaWV3cG9ydChwYXJhbXMpO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgX3Auem9vbSA9IHZwLnpvb207XG5cbiAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgX3AucGFuLnggPSB2cC5wYW4ueDtcbiAgICAgICAgX3AucGFuLnkgPSB2cC5wYW4ueTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfSxcbiAgdmlld3BvcnQ6IGZ1bmN0aW9uIHZpZXdwb3J0KG9wdHMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghbnVtYmVyKG9wdHMuem9vbSkpIHtcbiAgICAgIHpvb21EZWZkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRzLnBhbikpIHtcbiAgICAgIHBhbkRlZmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXpvb21EZWZkICYmICFwYW5EZWZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoem9vbURlZmQpIHtcbiAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuXG4gICAgICBpZiAoeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auem9vbSA9IHo7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgIGlmIChudW1iZXIocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIocC55KSkge1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFuRmFpbGVkKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCdwYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5lbWl0KGV2ZW50cy5qb2luKCcgJykpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGVsZW1lbnRzKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKGVsZW1lbnRzKTtcblxuICAgIGlmIChwYW4pIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgY2VudHJlIHBhbiB0byBub3RoaW5nXG5cblxuICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuICAgIHZhciBwYW4gPSB7XG4gICAgICAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICB9O1xuICAgIHJldHVybiBwYW47XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQoe1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuICAgIHJldHVybiBfcC5zaXplQ2FjaGUgPSBfcC5zaXplQ2FjaGUgfHwgKGNvbnRhaW5lciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcblxuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgICB9O1xuICAgIH0oKSA6IHtcbiAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMVxuICAgIH0pO1xuICB9LFxuICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLndpZHRoO1xuICB9LFxuICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICB9LFxuICBleHRlbnQ6IGZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuICAgIHZhciBiID0ge1xuICAgICAgeDE6IChyYi54MSAtIHBhbi54KSAvIHpvb20sXG4gICAgICB4MjogKHJiLngyIC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHkxOiAocmIueTEgLSBwYW4ueSkgLyB6b29tLFxuICAgICAgeTI6IChyYi55MiAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuICAgIHJldHVybiBiO1xuICB9LFxuICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24gcmVuZGVyZWRFeHRlbnQoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDI6IHdpZHRoLFxuICAgICAgeTI6IGhlaWdodCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0XG4gICAgfTtcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5jb3JlZm4kOC5jZW50cmUgPSBjb3JlZm4kOC5jZW50ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmNvcmVmbiQ4LmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4kOC5hdXRvbG9jaztcbmNvcmVmbiQ4LmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbiQ4LmF1dG91bmdyYWJpZnk7XG5cbnZhciBmbiQ2ID0ge1xuICBkYXRhOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlRGF0YTogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZSQzLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUkMy5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KVxufTsgLy8gYWxpYXNlc1xuXG5mbiQ2LmF0dHIgPSBmbiQ2LmRhdGE7XG5mbiQ2LnJlbW92ZUF0dHIgPSBmbiQ2LnJlbW92ZURhdGE7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gIHZhciBjeSA9IHRoaXM7XG4gIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7IC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuXG4gIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuXG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcblxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuX2N5cmVnID0gcmVnO1xuICB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcblxuXG4gIHJlZy5jeSA9IGN5O1xuICB2YXIgaGVhZCA9IHdpbmRvdyQxICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gIHZhciBvcHRpb25zID0gb3B0cztcbiAgb3B0aW9ucy5sYXlvdXQgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5sYXlvdXQpO1xuICBvcHRpb25zLnJlbmRlcmVyID0gZXh0ZW5kKHtcbiAgICBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5yZW5kZXJlcik7XG5cbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uIGRlZlZhbChkZWYsIHZhbCwgYWx0VmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiAoYWx0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gaHRtbCBkb20gZWxlIGNvbnRhaW5lclxuICAgIHJlYWR5OiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgLy8gY2FjaGVkIG9wdGlvbnNcbiAgICBlbGVtZW50czogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgaW4gdGhlIGdyYXBoXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgZGF0YToge30sXG4gICAgLy8gZGF0YSBmb3IgdGhlIGNvcmVcbiAgICBzY3JhdGNoOiB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgIGxheW91dDogbnVsbCxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCksXG4gICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgYXV0b2xvY2s6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgc3R5bGVFbmFibGVkOiBvcHRpb25zLnN0eWxlRW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gaGVhZCA6IG9wdGlvbnMuc3R5bGVFbmFibGVkLFxuICAgIHpvb206IG51bWJlcihvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIob3B0aW9ucy5wYW4ueCkgPyBvcHRpb25zLnBhbi54IDogMCxcbiAgICAgIHk6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpOyAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcblxuICB0aGlzLnNlbGVjdGlvblR5cGUob3B0aW9ucy5zZWxlY3Rpb25UeXBlKTsgLy8gaW5pdCB6b29tIGJvdW5kc1xuXG4gIHRoaXMuem9vbVJhbmdlKHtcbiAgICBtaW46IG9wdGlvbnMubWluWm9vbSxcbiAgICBtYXg6IG9wdGlvbnMubWF4Wm9vbVxuICB9KTtcblxuICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiBsb2FkRXh0RGF0YShleHREYXRhLCBuZXh0KSB7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZShwcm9taXNlKTtcblxuICAgIGlmIChhbnlJc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlJDEuYWxsKGV4dERhdGEpLnRoZW4obmV4dCk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dChleHREYXRhKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgIH1cbiAgfTsgLy8gc3RhcnQgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHNvIHdlIGhhdmUgc29tZXRoaW5nIGJlZm9yZSBsb2FkaW5nIGFuIGV4dGVybmFsIHN0eWxlc2hlZXRcblxuXG4gIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICBjeS5zZXRTdHlsZShbXSk7XG4gIH0gLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuXG5cbiAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlcik7IC8vIGFsbG93IHJlbmRlcmluZyBoaW50cyBpbiB0b3AgbGV2ZWwgb3B0aW9uc1xuXG4gIGN5LmluaXRSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuXG4gIHZhciBzZXRFbGVzQW5kTGF5b3V0ID0gZnVuY3Rpb24gc2V0RWxlc0FuZExheW91dChlbGVtZW50cywgb25sb2FkLCBvbmRvbmUpIHtcbiAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTsgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuXG4gICAgdmFyIG9sZEVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIGlmIChvbGRFbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChlbGVtZW50cykgfHwgYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIGN5LmFkZChlbGVtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kub25lKCdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgY3kuZW1pdChlKTsgLy8gd2UgbWlzc2VkIHRoaXMgZXZlbnQgYnkgdHVybmluZyBub3RpZmljYXRpb25zIG9mZiwgc28gcGFzcyBpdCBvblxuXG4gICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgY3kuZW1pdEFuZE5vdGlmeSgnbG9hZCcpO1xuICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICBjeS5lbWl0KCdkb25lJyk7XG4gICAgfSk7XG4gICAgdmFyIGxheW91dE9wdHMgPSBleHRlbmQoe30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgIGN5LmxheW91dChsYXlvdXRPcHRzKS5ydW4oKTtcbiAgfTtcblxuICBsb2FkRXh0RGF0YShbb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50c10sIGZ1bmN0aW9uICh0aGVucykge1xuICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTsgLy8gaW5pdCBzdHlsZVxuXG4gICAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgICAgY3kuc3R5bGUoKS5hcHBlbmQoaW5pdFN0eWxlKTtcbiAgICB9IC8vIGluaXRpYWwgbG9hZFxuXG5cbiAgICBzZXRFbGVzQW5kTGF5b3V0KGluaXRFbGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTsgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuXG4gICAgICBpZiAoZm4ob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9IC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiQxID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4kMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuXG4gICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH0pO1xufTtcblxudmFyIGNvcmVmbiQ5ID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbmV4dGVuZChjb3JlZm4kOSwge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb3JlJztcbiAgfSxcbiAgaXNSZWFkeTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZGVzdHJveWVkO1xuICB9LFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmIChjeS5kZXN0cm95ZWQoKSkgcmV0dXJuO1xuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgY3kuX3ByaXZhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgfSxcbiAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9LFxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbiBoYXNDb21wb3VuZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG4gIGhlYWRsZXNzOiBmdW5jdGlvbiBoZWFkbGVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlci5pc0hlYWRsZXNzKCk7XG4gIH0sXG4gIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24gc3R5bGVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcbiAgYWRkVG9Qb29sOiBmdW5jdGlvbiBhZGRUb1Bvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMubWVyZ2UoZWxlcyk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uIHJlbW92ZUZyb21Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoZWxlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyIHx8IG51bGw7XG4gIH0sXG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcblxuICAgIGlmICghaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgfVxuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgfSkpO1xuICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgbmFtZTogJ251bGwnXG4gICAgfSk7XG4gICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICB9LFxuICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIHZhciBnZXRGcmVzaFJlZiA9IGZ1bmN0aW9uIGdldEZyZXNoUmVmKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKGVsZS5pZCgpKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIC8vIHNldFxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAob2JqLmVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIGlkSW5Kc29uW2lkXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgdG9Nb2QucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlOiBlbGUsXG4gICAgICAgICAgICAgICAganNvbjoganNvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyO1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9Nb2QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX3RvTW9kJF9pID0gdG9Nb2RbX2ldLFxuICAgICAgICAgICAgICAgIF9lbGUgPSBfdG9Nb2QkX2kuZWxlLFxuICAgICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG5cbiAgICAgICAgICAgIF9lbGUuanNvbihfanNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhcnJheShvYmouZWxlbWVudHMpKSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyhvYmouZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG5cbiAgICAgICAgICAgIGlmIChhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzVG9SZW1vdmUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uW2VsZS5pZCgpXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUubWVyZ2UoZWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdCByZW1vdmVkIHcvcGFyZW50XG5cbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gaW50ZXJtZWRpYXRlIHBhcmVudHMgbWF5IGJlIG1vdmVkIGJ5IHByaW9yIGxpbmUsIHNvIG1ha2Ugc3VyZSB3ZSByZW1vdmUgYnkgZnJlc2ggcmVmc1xuXG4gICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RnJlc2hSZWYoZWxlKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20pIHtcbiAgICAgICAgY3kuem9vbShvYmouem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoucGFuKSB7XG4gICAgICAgIGlmIChvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkpIHtcbiAgICAgICAgICBjeS5wYW4ob2JqLnBhbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRzID0gWydtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJywgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsICdib3hTZWxlY3Rpb25FbmFibGVkJywgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5J107XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGZpZWxkcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBmID0gZmllbGRzW19pMl07XG5cbiAgICAgICAgaWYgKG9ialtmXSAhPSBudWxsKSB7XG4gICAgICAgICAgY3lbZl0ob2JqW2ZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldFxuICAgICAgdmFyIGZsYXQgPSAhIW9iajtcbiAgICAgIHZhciBqc29uID0ge307XG5cbiAgICAgIGlmIChmbGF0KSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCkubWFwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmpzb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgICBpZiAoIWpzb24uZWxlbWVudHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQpIHtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLmRhdGEgPSBjb3B5KGN5LmRhdGEoKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gX3Auem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IF9wLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IF9wLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBfcC5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gX3AubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBfcC5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gX3AudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjb3B5KF9wLnBhbik7XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBfcC5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5yZW5kZXJlciA9IGNvcHkob3B0aW9ucy5yZW5kZXJlcik7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfVxufSk7XG5jb3JlZm4kOS4kaWQgPSBjb3JlZm4kOS5nZXRFbGVtZW50QnlJZDtcbltjb3JlZm4sIGNvcmVmbiQxLCBlbGVzZm4kdiwgY29yZWZuJDIsIGNvcmVmbiQzLCBjb3JlZm4kNCwgY29yZWZuJDUsIGNvcmVmbiQ2LCBjb3JlZm4kNywgY29yZWZuJDgsIGZuJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChjb3JlZm4kOSwgcHJvcHMpO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbnZhciBkZWZhdWx0cyQ5ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIG9uIGZpdFxuICBjaXJjbGU6IGZhbHNlLFxuICAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gIGdyaWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGNyZWF0ZSBhbiBldmVuIGdyaWQgaW50byB3aGljaCB0aGUgREFHIGlzIHBsYWNlZCAoY2lyY2xlOmZhbHNlIG9ubHkpXG4gIHNwYWNpbmdGYWN0b3I6IDEuNzUsXG4gIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICByb290czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gIG1heGltYWw6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHNoaWZ0IG5vZGVzIGRvd24gdGhlaXIgbmF0dXJhbCBCRlMgZGVwdGhzIGluIG9yZGVyIHRvIGF2b2lkIHVwd2FyZHMgZWRnZXMgKERBR1Mgb25seSlcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZCxcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8oZWxlKSB7XG4gIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jyk7XG59O1xuXG52YXIgc2V0SW5mbyA9IGZ1bmN0aW9uIHNldEluZm8oZWxlLCBvYmopIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnLCBvYmopO1xufTtcblxuZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ5LCBvcHRpb25zKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gIH0pO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICB2YXIgbWF4aW1hbCA9IG9wdGlvbnMubWF4aW1hbCB8fCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50cyA+IDA7IC8vIG1heGltYWxBZGp1c3RtZW50cyBmb3IgY29tcGF0LiB3LyBvbGQgY29kZVxuXG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgcm9vdHM7XG5cbiAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiAoYXJyYXkob3B0aW9ucy5yb290cykpIHtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgIHJvb3RzQXJyYXkucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbihyb290c0FycmF5KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IGN5LiQob3B0aW9ucy5yb290cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gZWxlcy5jb21wb25lbnRzKCk7XG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzW19pXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKGZhbHNlKTtcbiAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmRlZ3JlZShmYWxzZSkgPT09IG1heERlZ3JlZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKGNvbXBSb290cyk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29tcG9uZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX2xvb3AoX2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZXB0aHMgPSBbXTtcbiAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcblxuICB2YXIgYWRkVG9EZXB0aCA9IGZ1bmN0aW9uIGFkZFRvRGVwdGgoZWxlLCBkKSB7XG4gICAgaWYgKGRlcHRoc1tkXSA9PSBudWxsKSB7XG4gICAgICBkZXB0aHNbZF0gPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGRlcHRoc1tkXS5sZW5ndGg7XG4gICAgZGVwdGhzW2RdLnB1c2goZWxlKTtcbiAgICBzZXRJbmZvKGVsZSwge1xuICAgICAgaW5kZXg6IGksXG4gICAgICBkZXB0aDogZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjaGFuZ2VEZXB0aCA9IGZ1bmN0aW9uIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpIHtcbiAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKGVsZSksXG4gICAgICAgIGRlcHRoID0gX2dldEluZm8uZGVwdGgsXG4gICAgICAgIGluZGV4ID0gX2dldEluZm8uaW5kZXg7XG5cbiAgICBkZXB0aHNbZGVwdGhdW2luZGV4XSA9IG51bGw7XG4gICAgYWRkVG9EZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgfTsgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuXG5cbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGVkZ2UsIHBOb2RlLCBpLCBkZXB0aCkge1xuICAgICAgdmFyIGVsZSA9IG5vZGVbMF07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIGFkZFRvRGVwdGgoZWxlLCBkZXB0aCk7XG4gICAgICBmb3VuZEJ5QmZzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9KTsgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcblxuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuXG4gICAgaWYgKGZvdW5kQnlCZnNbX2VsZS5pZCgpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ycGhhbk5vZGVzLnB1c2goX2VsZSk7XG4gICAgfVxuICB9IC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcblxuXG4gIHZhciBhc3NpZ25EZXB0aHNBdCA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRoc0F0KGkpIHtcbiAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9lbGUyID0gZWxlc1tqXTtcblxuICAgICAgaWYgKF9lbGUyID09IG51bGwpIHtcbiAgICAgICAgZWxlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGotLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNldEluZm8oX2VsZTIsIHtcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIGluZGV4OiBqXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFzc2lnbkRlcHRocyA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRocygpIHtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBkZXB0aHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgYXNzaWduRGVwdGhzQXQoX2kzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFkanVzdE1heGltYWxseSA9IGZ1bmN0aW9uIGFkanVzdE1heGltYWxseShlbGUsIHNoaWZ0ZWQpIHtcbiAgICB2YXIgZUluZm8gPSBnZXRJbmZvKGVsZSk7XG4gICAgdmFyIGluY29tZXJzID0gZWxlLmluY29tZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSAtMTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBpbmNtciA9IGluY29tZXJzW2tdO1xuICAgICAgdmFyIGlJbmZvID0gZ2V0SW5mbyhpbmNtcik7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBpSW5mby5kZXB0aCk7XG4gICAgfVxuXG4gICAgaWYgKGVJbmZvLmRlcHRoIDw9IG1heERlcHRoKSB7XG4gICAgICBpZiAoc2hpZnRlZFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZURlcHRoKGVsZSwgbWF4RGVwdGggKyAxKTtcbiAgICAgIHNoaWZ0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gZm9yIHRoZSBkaXJlY3RlZCBjYXNlLCB0cnkgdG8gbWFrZSB0aGUgZWRnZXMgYWxsIGdvIGRvd24gKGkuZS4gZGVwdGggaSA9PiBkZXB0aCBpICsgMSlcblxuXG4gIGlmIChkaXJlY3RlZCAmJiBtYXhpbWFsKSB7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgc2hpZnRlZCA9IHt9O1xuXG4gICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfTtcblxuICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgIHJldHVybiBRLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfSk7XG5cbiAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX2VsZTMgPSBkZXF1ZXVlKCk7XG5cbiAgICAgIHZhciBkaWRTaGlmdCA9IGFkanVzdE1heGltYWxseShfZWxlMywgc2hpZnRlZCk7XG5cbiAgICAgIGlmIChkaWRTaGlmdCkge1xuICAgICAgICBfZWxlMy5vdXRnb2VycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgICB9KS5mb3JFYWNoKGVucXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChkaWRTaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKCdEZXRlY3RlZCBkb3VibGUgbWF4aW1hbCBzaGlmdCBmb3Igbm9kZSBgJyArIF9lbGUzLmlkKCkgKyAnYC4gIEJhaWxpbmcgbWF4aW1hbCBhZGp1c3RtZW50IGR1ZSB0byBjeWNsZS4gIFVzZSBgb3B0aW9ucy5tYXhpbWFsOiB0cnVlYCBvbmx5IG9uIERBR3MuJyk7XG4gICAgICAgIGJyZWFrOyAvLyBleGl0IG9uIGZhaWx1cmVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25EZXB0aHMoKTsgLy8gY2xlYXIgaG9sZXNcbiAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG5cbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW19pNF07XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICB9XG4gIH0gLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG5cblxuICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG5cbiAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFdlaWdodGVkUGVyY2VudChlbGUpIHtcbiAgICBpZiAoY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV07XG4gICAgfVxuXG4gICAgdmFyIGVsZURlcHRoID0gZ2V0SW5mbyhlbGUpLmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCk7XG4gICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbX2k1XTtcblxuICAgICAgaWYgKG5laWdoYm9yLmlzRWRnZSgpIHx8IG5laWdoYm9yLmlzUGFyZW50KCkgfHwgIW5vZGVzLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZiA9IGdldEluZm8obmVpZ2hib3IpO1xuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDsgLy8gdW5hc3NpZ25lZCBuZWlnaGJvdXJzIHNob3VsZG4ndCBhZmZlY3QgdGhlIG9yZGVyaW5nXG5cbiAgICAgIGlmIChpbmRleCA9PSBudWxsIHx8IGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgaWYgKGRlcHRoIDwgZWxlRGVwdGgpIHtcbiAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgIGlmIChzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBwdXQgbG9uZSBub2RlcyBhdCB0aGUgc3RhcnRcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH1cblxuICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0gPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9OyAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiBzb3J0Rm4oYSwgYikge1xuICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGEpO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGIpO1xuICAgIHZhciBkaWZmID0gYXBjdCAtIGJwY3Q7XG5cbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyhhLmlkKCksIGIuaWQoKSk7IC8vIG1ha2Ugc3VyZSBzb3J0IGRvZXNuJ3QgaGF2ZSBkb24ndC1jYXJlIGNvbXBhcmlzb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgfTsgLy8gc29ydCBlYWNoIGxldmVsIHRvIG1ha2UgY29ubmVjdGVkIG5vZGVzIGNsb3NlclxuXG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGVwdGhzLmxlbmd0aDsgX2k2KyspIHtcbiAgICBkZXB0aHNbX2k2XS5zb3J0KHNvcnRGbik7XG5cbiAgICBhc3NpZ25EZXB0aHNBdChfaTYpO1xuICB9IC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgdG8gYSBuZXcgdG9wLWxldmVsIGRlcHRoXG5cblxuICB2YXIgb3JwaGFuRGVwdGggPSBbXTtcblxuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBvcnBoYW5Ob2Rlcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgb3JwaGFuRGVwdGgucHVzaChvcnBoYW5Ob2Rlc1tfaTddKTtcbiAgfVxuXG4gIGRlcHRocy51bnNoaWZ0KG9ycGhhbkRlcHRoKTtcbiAgYXNzaWduRGVwdGhzKCk7XG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcblxuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkZXB0aHMubGVuZ3RoOyBfaTgrKykge1xuICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heChkZXB0aHNbX2k4XS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUpO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLngxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIG1heERlcHRoU2l6ZSA9IGRlcHRocy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWxlcykge1xuICAgIHJldHVybiBNYXRoLm1heChtYXgsIGVsZXMubGVuZ3RoKTtcbiAgfSwgMCk7XG5cbiAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWxlKSB7XG4gICAgdmFyIF9nZXRJbmZvMiA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgZGVwdGggPSBfZ2V0SW5mbzIuZGVwdGgsXG4gICAgICAgIGluZGV4ID0gX2dldEluZm8yLmluZGV4O1xuXG4gICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heChiYi53IC8gKChvcHRpb25zLmdyaWQgPyBtYXhEZXB0aFNpemUgOiBkZXB0aFNpemUpICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbihiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCk7XG4gICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heChyYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UpO1xuXG4gICAgaWYgKCFvcHRpb25zLmNpcmNsZSkge1xuICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICBpZiAoZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3NpdGlvbik7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJGEgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHJhZGl1czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsXG4gIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsXG4gIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxufTtcblxuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyRhLCBvcHRpb25zKTtcbn1cblxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gIHZhciBkVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpO1xuICB2YXIgcjtcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuXG4gIGlmIChudW1iZXIob3B0aW9ucy5yYWRpdXMpKSB7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYgKG5vZGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKGJiLmgsIGJiLncpIC8gMiAtIG1pbkRpc3RhbmNlO1xuICB9IC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG5cblxuICBpZiAobm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gIH1cblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICB2YXIgcnggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgfTtcbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRiID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLFxuICAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLFxuICAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgLy8gdGhlIGxldGlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbn07XG5cbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGIsIG9wdGlvbnMpO1xufVxuXG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuXG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwOyAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcblxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7IC8vIGZvciBzdHlsZSBtYXBwaW5nXG5cbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9IC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG5cblxuICBub2Rlcy51cGRhdGVTdHlsZSgpOyAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcblxuICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCk7XG4gIH0gLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuXG5cbiAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9KTtcbiAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgobm9kZXMpOyAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuXG4gIHZhciBsZXZlbHMgPSBbW11dO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG5cbiAgICBpZiAoY3VycmVudExldmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlKTtcblxuICAgICAgaWYgKGRpZmYgPj0gbGV2ZWxXaWR0aCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICB9IC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICB9IC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcblxuXG4gIHZhciByID0gMDtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpOyAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuXG4gICAgaWYgKGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0ICogbWluRGlzdCAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgIH1cblxuICAgIGxldmVsLnIgPSByO1xuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIF9yID0gMDtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxldmVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2xldmVsID0gbGV2ZWxzW19pNF07XG4gICAgICB2YXIgckRlbHRhID0gX2xldmVsLnIgLSBfcjtcbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICB9XG5cbiAgICBfciA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcblxuICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICBfciA9IF9sZXZlbDIucjtcbiAgICAgIH1cblxuICAgICAgX2xldmVsMi5yID0gX3I7XG4gICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSBwb3NpdGlvbnNcblxuXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBsZXZlbHMubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfbGV2ZWwzID0gbGV2ZWxzW19pNl07XG4gICAgdmFyIF9kVGhldGEgPSBfbGV2ZWwzLmRUaGV0YTtcbiAgICB2YXIgX3IyID0gX2xldmVsMy5yO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfbGV2ZWwzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX3ZhbCA9IF9sZXZlbDNbal07XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgX3IyICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgIH1cbiAgfSAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcblxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgcmV0dXJuIHBvc1tpZF07XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8qXG5UaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG5odHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG5Nb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cbnZhciBERUJVRztcbi8qKlxuICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAqL1xuXG52YXIgZGVmYXVsdHMkYyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gIC8vIHRydWUgOiBBbmltYXRlIGNvbnRpbnVvdXNseSBhcyB0aGUgbGF5b3V0IGlzIHJ1bm5pbmdcbiAgLy8gZmFsc2UgOiBKdXN0IHNob3cgdGhlIGVuZCByZXN1bHRcbiAgLy8gJ2VuZCcgOiBBbmltYXRlIHdpdGggdGhlIGVuZCByZXN1bHQsIGZyb20gdGhlIGluaXRpYWwgcG9zaXRpb25zIHRvIHRoZSBlbmQgcG9zaXRpb25zXG4gIGFuaW1hdGU6IHRydWUsXG4gIC8vIEVhc2luZyBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25EdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZFxuICAvLyBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWRcbiAgLy8gTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzIGZvciBhbmltYXRlOnRydWVcbiAgLy8gKHByZXZlbnRzIGZsYXNoaW5nIG9uIGZhc3QgcnVucylcbiAgYW5pbWF0aW9uVGhyZXNob2xkOiAyNTAsXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgcmVmcmVzaDogMjAsXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBSYW5kb21pemUgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBub2RlcyAodHJ1ZSkgb3IgdXNlIGV4aXN0aW5nIHBvc2l0aW9ucyAoZmFsc2UpXG4gIHJhbmRvbWl6ZTogZmFsc2UsXG4gIC8vIEV4dHJhIHNwYWNpbmcgYmV0d2VlbiBjb21wb25lbnRzIGluIG5vbi1jb21wb3VuZCBncmFwaHNcbiAgY29tcG9uZW50U3BhY2luZzogNDAsXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDIwNDg7XG4gIH0sXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlT3ZlcmxhcDogNCxcbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24gaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAxLjIsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAxLFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMTAwMCxcbiAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgaW5pdGlhbFRlbXA6IDEwMDAsXG4gIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gIGNvb2xpbmdGYWN0b3I6IDAuOTksXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjBcbn07XG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGMsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcbn1cbi8qKlxuICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gKi9cblxuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgfSAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcblxuXG4gIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgREVCVUcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIERFQlVHID0gZmFsc2U7XG4gIH0gLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuXG5cbiAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpOyAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG5cbiAgaWYgKERFQlVHKSB7XG4gICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICB9IC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcblxuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gIHZhciByZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTsgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcblxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgY3kuZml0KG9wdGlvbnMucGFkZGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uIG1haW5Mb29wKGkpIHtcbiAgICBpZiAobGF5b3V0LnN0b3BwZWQgfHwgaSA+PSBvcHRpb25zLm51bUl0ZXIpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG5cblxuICAgIHN0ZXAkMShsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG5cbiAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjsgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgcmVmcmVzaCgpOyAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFNjYWxlZFBvcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxvb3BSZXQgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgd2hpbGUgKGxvb3BSZXQgJiYgZiA8IG9wdGlvbnMucmVmcmVzaCkge1xuICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgZisrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvb3BSZXQpIHtcbiAgICAgICAgLy8gaXQncyBkb25lXG4gICAgICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgICAgaWYgKG5vdyAtIHN0YXJ0VGltZSA+PSBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZyYW1lKCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxvb3BSZXQpIHtcbiAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuXG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xuXG5cbnZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gIC8vIFNob3J0Y3V0XG4gIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGN5LndpZHRoKCksXG4gICAgY2xpZW50SGVpZ2h0OiBjeS53aWR0aCgpLFxuICAgIGJvdW5kaW5nQm94OiBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSlcbiAgfTtcbiAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICB2YXIgaWQyY21wdElkID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbal07XG4gICAgICBpZDJjbXB0SWRbbm9kZS5pZCgpXSA9IGk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHRlbXBOb2RlID0ge307XG4gICAgdGVtcE5vZGUuaXNMb2NrZWQgPSBuLmxvY2tlZCgpO1xuICAgIHRlbXBOb2RlLmlkID0gbi5kYXRhKCdpZCcpO1xuICAgIHRlbXBOb2RlLnBhcmVudElkID0gbi5kYXRhKCdwYXJlbnQnKTtcbiAgICB0ZW1wTm9kZS5jbXB0SWQgPSBpZDJjbXB0SWRbbi5pZCgpXTtcbiAgICB0ZW1wTm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWCA9IG4ucG9zaXRpb24oJ3gnKTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblkgPSBuLnBvc2l0aW9uKCd5Jyk7XG4gICAgdGVtcE5vZGUub2Zmc2V0WCA9IDA7XG4gICAgdGVtcE5vZGUub2Zmc2V0WSA9IDA7XG4gICAgdGVtcE5vZGUuaGVpZ2h0ID0gbmJiLnc7XG4gICAgdGVtcE5vZGUud2lkdGggPSBuYmIuaDtcbiAgICB0ZW1wTm9kZS5tYXhYID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggLyAyO1xuICAgIHRlbXBOb2RlLm1pblggPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWF4WSA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUubWluWSA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUucGFkTGVmdCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRSaWdodCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRUb3AgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkQm90dG9tID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpOyAvLyBmb3JjZXNcblxuICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBmbihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uOyAvLyBBZGQgbmV3IG5vZGVcblxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7IC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcblxuICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gIH0gLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuXG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG5cbiAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICB2YXIgdGVtcEdyYXBoID0gW107IC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDsgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG5cbiAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTtcbiAgICB9XG4gIH0gLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcblxuXG4gIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCh0ZW1wR3JhcGgpOyAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVfaWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZV9peCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkID0gZS5kYXRhKCdpZCcpO1xuICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7IC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG5cbiAgICB2YXIgaWRlYWxMZW5ndGggPSBmbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gZm4ob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5KGUpIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTsgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG5cbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG5cbiAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTsgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggPSAwOyAvLyBTb3VyY2UgZGVwdGhcblxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG5cbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IC8vIFRhcmdldCBkZXB0aFxuXG5cbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuXG5cbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgIH1cblxuICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG4gICAgdGVtcEVkZ2UuZWxhc3RpY2l0eSA9IGVsYXN0aWNpdHk7XG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgfSAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcblxuXG4gIHJldHVybiBsYXlvdXRJbmZvO1xufTtcbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG5cblxudmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiBmaW5kTENBKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcblxuICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAqXG4gKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdGVycyAobWF4OiAyKSBmb3VuZCBpblxuICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAqL1xuXG5cbnZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uIGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdOyAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuXG4gIGlmICgtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTEpICYmIC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDIsXG4gICAgICBncmFwaDogZ3JhcGhJeFxuICAgIH07XG4gIH0gLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcblxuXG4gIHZhciBjID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGVJZCA9IGdyYXBoW2ldO1xuICAgIHZhciBub2RlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjsgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG5cbiAgICBpZiAoMCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuXG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcblxuICAgICAgaWYgKDIgPT09IGMpIHtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudDogYyxcbiAgICBncmFwaDogZ3JhcGhJeFxuICB9O1xufTtcbi8qKlxuICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZ1xuICovXG5cblxuaWYgKGZhbHNlKSB7XG4gIHZhciBwcmludExheW91dEluZm87XG59XG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG5cblxudmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSkge1xuICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07IC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuXG4gICAgaWYgKDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRTY2FsZUluQm91bmRzRm4gPSBmdW5jdGlvbiBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpIHtcbiAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgdmFyIGNvc2VCQiA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeDI6IC1JbmZpbml0eSxcbiAgICB5MTogSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICB9KTtcbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgIC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG5cblxudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICBub2Rlcy5wb3NpdGlvbnMoZ2V0U2NhbGVkUG9zKTsgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcblxuICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgbGF5b3V0OiB0aGlzXG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gKi9cbi8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgaWYgKERFQlVHKSB7XG4vLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbi8vICAgfVxuLy8gfTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG5cblxudmFyIHN0ZXAkMSA9IGZ1bmN0aW9uIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgX3N0ZXApIHtcbiAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgLy8gbG9nRGVidWcocyk7XG4gIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG5cbiAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG5cbiAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuXG4gIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuXG4gIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uIHJhbmRvbURpc3RhbmNlKG1heCkge1xuICByZXR1cm4gLW1heCArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xufTtcbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gKi9cblxuXG52YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcbiAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuXG4gIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgdmFyIG1heFJhbmREaXN0ID0gMTsgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG4gIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG5cbiAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgfVxuXG4gIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG5cbiAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDsgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTsgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpOyAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcblxuICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBmb3JjZSA9IChub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbikgLyBkaXN0YW5jZVNxcjtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgfSAvLyBBcHBseSBmb3JjZVxuXG5cbiAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICB9XG5cbiAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICB9IC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgLy8gbG9nRGVidWcocyk7XG5cblxuICByZXR1cm47XG59O1xuLyoqXG4gKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICovXG5cblxudmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uIG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuICBpZiAoZFggPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gIH1cblxuICBpZiAoZFkgPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gIH1cblxuICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gKi9cblxuXG52YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbiBmaW5kQ2xpcHBpbmdQb2ludChub2RlLCBkWCwgZFkpIHtcbiAgLy8gU2hvcmN1dHNcbiAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgdmFyIG5vZGVTbG9wZSA9IEggLyBXOyAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAvL1xuICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuXG4gIHZhciByZXMgPSB7fTsgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcblxuICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgcmVzLnggPSBYOyAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG5cbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcblxuXG4gIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcblxuXG4gIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcblxuXG4gIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG5cblxuICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSArIEggLyAyOyAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG5cblxuICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSAtIEggLyAyOyAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICovXG5cblxudmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICB2YXIgZWRnZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHNvdXJjZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTsgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTsgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cblxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuXG5cbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG4gICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgIH0gLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcblxuXG4gICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIH0gLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIHZhciBkaXN0VGhyZXNob2xkID0gMTsgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuXG4gICAgaWYgKDAgPT09IGkpIHtcbiAgICAgIHZhciBjZW50ZXJYID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgdmFyIGNlbnRlclkgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgIHZhciB0ZW1wID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgdmFyIHBhcmVudCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgIH0gLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dOyAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgIGlmIChub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgIGlmIChkID4gZGlzdFRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7IC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgIH0gLy8gcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tXG4gKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24gcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcblxuICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG4gIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuXG4gIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7IC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG5cbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZUlkID0gcXVldWVbc3RhcnQrK107XG4gICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjsgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuXG4gICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7IC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTsgLy8gUHJvcGFnYXRlIG9mZnNldFxuXG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG5cbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9IC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG5cblxuICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICovXG5cblxudmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG5cblxuICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcbiAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICBuLm9mZnNldFggPSAwO1xuICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgbi5taW5YID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgIG4ubWF4WCA9IG4ucG9zaXRpb25YICsgbi53aWR0aDtcbiAgICBuLm1pblkgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgIG4ubWF4WSA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7IC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcblxuICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgfSAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgbi53aWR0aCA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgIG4uaGVpZ2h0ID0gbi5tYXhZIC0gbi5taW5ZOyAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uXG4gICovXG5cblxudmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbiBsaW1pdEZvcmNlKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuXG4gIGlmIChmb3JjZSA+IG1heCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgIHk6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgeDogZm9yY2VYLFxuICAgICAgeTogZm9yY2VZXG4gICAgfTtcbiAgfSAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gKi9cblxuXG52YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG5vZGUsIGxheW91dEluZm8pIHtcbiAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuXG4gIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuO1xuICB9IC8vIEdldCBQYXJlbnQgTm9kZVxuXG5cbiAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gIHZhciBmbGFnID0gZmFsc2U7IC8vIE1heFhcblxuICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICB9IC8vIE1pblhcblxuXG4gIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICB9IC8vIE1heFlcblxuXG4gIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgfSAvLyBNaW5ZXG5cblxuICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gIH0gLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcblxuXG4gIGlmIChmbGFnKSB7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgfSAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybjtcbn07XG5cbnZhciBzZXBhcmF0ZUNvbXBvbmVudHMgPSBmdW5jdGlvbiBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdID0gY29tcG9uZW50c1tjaWRdIHx8IFtdO1xuICAgIGNvbXBvbmVudC5wdXNoKG5vZGUpO1xuICB9XG5cbiAgdmFyIHRvdGFsQSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjLngxID0gSW5maW5pdHk7XG4gICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgYy55MiA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG4gPSBjW2pdO1xuICAgICAgYy54MSA9IE1hdGgubWluKGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aCAvIDIpO1xuICAgICAgYy54MiA9IE1hdGgubWF4KGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aCAvIDIpO1xuICAgICAgYy55MSA9IE1hdGgubWluKGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyKTtcbiAgICAgIGMueTIgPSBNYXRoLm1heChjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgYy5oID0gYy55MiAtIGMueTE7XG4gICAgdG90YWxBICs9IGMudyAqIGMuaDtcbiAgfVxuXG4gIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gIH0pO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHVzZWRXID0gMDtcbiAgdmFyIHJvd0ggPSAwO1xuICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgIGlmICghYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG5cbiAgICAgIGlmICghbi5pc0xvY2tlZCkge1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB4IC0gYy54MTtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0geSAtIGMueTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeCArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgIHJvd0ggPSBNYXRoLm1heChyb3dILCBjLmgpO1xuXG4gICAgaWYgKHVzZWRXID4gbWF4Um93Vykge1xuICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgeCA9IDA7XG4gICAgICB1c2VkVyA9IDA7XG4gICAgICByb3dIID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0cyRkID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCxcbiAgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsXG4gIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSxcbiAgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbn07XG5cbmZ1bmN0aW9uIEdyaWRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGQsIG9wdGlvbnMpO1xufVxuXG5HcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG5cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgaWYgKGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCkge1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSxcbiAgICAgICAgeTogYmIueTFcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uIHNtYWxsKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcblxuICAgICAgICBpZiAobWluID09IHJvd3MpIHtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24gbGFyZ2UodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuXG4gICAgICAgIGlmIChtYXggPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7IC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG5cbiAgICBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgfSBlbHNlIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBNYXRoLmNlaWwoY2VsbHMgLyByb3dzKTtcbiAgICB9IGVsc2UgaWYgKG9Sb3dzID09IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgICAgcm93cyA9IE1hdGguY2VpbChjZWxscyAvIGNvbHMpO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmIChjb2xzICogcm93cyA+IGNlbGxzKSB7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7IC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuXG4gICAgICAgIGlmICgoc20gLSAxKSAqIGxnID49IGNlbGxzKSB7XG4gICAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICgobGcgLSAxKSAqIHNtID49IGNlbGxzKSB7XG4gICAgICAgICAgbGFyZ2UobGcgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgICB2YXIgX3NtID0gc21hbGwoKTtcblxuICAgICAgICAgIHZhciBfbGcgPSBsYXJnZSgpOyAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG5cblxuICAgICAgICAgIGlmICgoX2xnICsgMSkgKiBfc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICAgIGxhcmdlKF9sZyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFsbChfc20gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uZGVuc2UpIHtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmJiID0gbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heChjZWxsV2lkdGgsIHcpO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbEhlaWdodCwgaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uIHVzZWQocm93LCBjb2wpIHtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgIH07IC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG5cblxuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciBjb2wgPSAwO1xuXG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICBjb2wrKztcblxuICAgICAgaWYgKGNvbCA+PSBjb2xzKSB7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07IC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuXG5cbiAgICB2YXIgaWQybWFuUG9zID0ge307XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcblxuICAgICAgaWYgKHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgdmFyIF9wb3MgPSB7XG4gICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3Bvcy5jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgIF9wb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBfcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICBfcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlkMm1hblBvc1tfbm9kZS5pZCgpXSA9IF9wb3M7XG4gICAgICAgIHVzZShfcG9zLnJvdywgX3Bvcy5jb2wpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmIChlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuXG5cbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuXG4gICAgICBpZiAocmNQb3MpIHtcbiAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIHVzZShyb3csIGNvbCk7XG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkZSA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG5cbn07IC8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcblxuZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkZSwgb3B0aW9ucyk7XG59IC8vIHJ1bnMgdGhlIGxheW91dFxuXG5cbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG5cbiAgdmFyIGxheW91dCA9IHRoaXM7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gKGRpc2FibGUgZXNsaW50IGZvciBuZXh0IGxpbmUgYXMgdGhpcyBzZXJ2ZXMgYXMgZXhhbXBsZSBsYXlvdXQgY29kZSB0byBleHRlcm5hbCBkZXZlbG9wZXJzKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTsgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIC8vIG4uYi4gbW9zdCBsYXlvdXRzIHdvdWxkIHVzZSBsYXlvdXRQb3NpdGlvbnMoKSwgaW5zdGVhZCBvZiBwb3NpdGlvbnMoKSBhbmQgbWFudWFsIGV2ZW50c1xuXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pOyAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7IC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTsgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5cblxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkZiA9IHtcbiAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gIHpvb206IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBwYW46IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG59O1xuXG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGYsIG9wdGlvbnMpO1xufVxuXG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gZm4ob3B0aW9ucy5wb3NpdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvcHlQb3NpdGlvbihub2RlLnBvc2l0aW9uKCkpO1xuICAgIH1cblxuICAgIGlmIChwb3NJc0ZuKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5wb3NpdGlvbnMobm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG5cbiAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcblxuICAgIGlmIChub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRnID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGcsIG9wdGlvbnMpO1xufVxuXG5SYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLncpLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi5oKVxuICAgIH07XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGxheW91dCA9IFt7XG4gIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NpcmNsZScsXG4gIGltcGw6IENpcmNsZUxheW91dFxufSwge1xuICBuYW1lOiAnY29uY2VudHJpYycsXG4gIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2Nvc2UnLFxuICBpbXBsOiBDb3NlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdncmlkJyxcbiAgaW1wbDogR3JpZExheW91dFxufSwge1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3ByZXNldCcsXG4gIGltcGw6IFByZXNldExheW91dFxufSwge1xuICBuYW1lOiAncmFuZG9tJyxcbiAgaW1wbDogUmFuZG9tTGF5b3V0XG59XTtcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIHRocm93SW1nRXJyID0gZnVuY3Rpb24gdGhyb3dJbWdFcnIoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQSBoZWFkbGVzcyBpbnN0YW5jZSBjYW4gbm90IHJlbmRlciBpbWFnZXMnKTtcbn07XG5cbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCQxLFxuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMrKztcbiAgfSxcbiAgaW5pdDogbm9vcCQxLFxuICBpc0hlYWRsZXNzOiBmdW5jdGlvbiBpc0hlYWRsZXNzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwbmc6IHRocm93SW1nRXJyLFxuICBqcGc6IHRocm93SW1nRXJyXG59O1xuXG52YXIgQlJwID0ge307XG5CUnAuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuXG5CUnAucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzOyAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uIGJiQ29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHB0cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgcmV0UHRzLnB1c2godHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRQdHM7XG4gIH07XG5cbiAgdmFyIHBvaW50c1RvQXJyID0gZnVuY3Rpb24gcG9pbnRzVG9BcnIocHRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICBpZiAoc3RyaW5nKGRlZm4pKSB7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgfVxuXG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgfSwgZGVmbik7XG4gIH07XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgnbm9uZScsIHtcbiAgICBjb2xsaWRlOiBmYWxzaWZ5LFxuICAgIHJvdWdoQ29sbGlkZTogZmFsc2lmeSxcbiAgICBkcmF3OiBub29wLFxuICAgIHNwYWNpbmc6IHplcm9pZnksXG4gICAgZ2FwOiB6ZXJvaWZ5XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsIHtcbiAgICBwb2ludHM6IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICBjb250cm9sUG9pbnQ6IFswLCAtMC4xNV0sXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuY29udHJvbFBvaW50O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMpO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgcG9pbnRzVGVlOiBbLTAuMTUsIC0wLjQsIC0wLjE1LCAtMC41LCAwLjE1LCAtMC41LCAwLjE1LCAtMC40XSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsIC8vIGZpcnN0IGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIC0wLjE1LCAtMC40LCAwLjE1LCAtMC40LCAvLyBzZWNvbmQgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgMC4xNSwgLTAuNF0sXG4gICAgY3Jvc3NMaW5lUHRzOiBmdW5jdGlvbiBjcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSB7XG4gICAgICAvLyBzaGlmdCBwb2ludHMgc28gdGhhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3Jvc3MgcG9pbnRzIG1hdGNoZXMgZWRnZSB3aWR0aFxuICAgICAgdmFyIHAgPSB0aGlzLmJhc2VDcm9zc0xpbmVQdHMuc2xpY2UoKTtcbiAgICAgIHZhciBzaGlmdEZhY3RvciA9IGVkZ2VXaWR0aCAvIHNpemU7XG4gICAgICB2YXIgeTAgPSAzO1xuICAgICAgdmFyIHkxID0gNTtcbiAgICAgIHBbeTBdID0gcFt5MF0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHBbeTFdID0gcFt5MV0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndmVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAwLCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC41MjU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgdmFyIGluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgIH0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAsIC0wLjE1LCAtMC4xLCAwLjE1LCAtMC4xLCAwLjE1LCAwXSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnc3F1YXJlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLjAwLCAwLjE1LCAwLjAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2RpYW1vbmQnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjE1LCAwLCAtMC4zLCAwLjE1LCAtMC4xNSwgMCwgMF0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaGV2cm9uJywge1xuICAgIHBvaW50czogWzAsIDAsIC0wLjE1LCAtMC4xNSwgLTAuMSwgLTAuMiwgMCwgLTAuMSwgMC4xLCAtMC4yLCAwLjE1LCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDAuOTUgKiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBCUnAkMSA9IHt9OyAvLyBQcm9qZWN0IG1vdXNlXG5cbkJScCQxLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICB2YXIgc2NhbGUgPSBvZmZzZXRzWzRdO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgeCA9ICgoY2xpZW50WCAtIG9mZnNldExlZnQpIC8gc2NhbGUgLSBwYW4ueCkgLyB6b29tO1xuICB2YXIgeSA9ICgoY2xpZW50WSAtIG9mZnNldFRvcCkgLyBzY2FsZSAtIHBhbi55KSAvIHpvb207XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG5CUnAkMS5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb250YWluZXJCQikge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuXG4gIHZhciBzdHlsZVZhbHVlID0gZnVuY3Rpb24gc3R5bGVWYWx1ZShuYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gIH07XG5cbiAgdmFyIHBhZGRpbmcgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ3BhZGRpbmctdG9wJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpXG4gIH07XG4gIHZhciBib3JkZXIgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgfTtcbiAgdmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICB2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgdmFyIHBhZGRpbmdIb3IgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICB2YXIgcGFkZGluZ1ZlciA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIHZhciBib3JkZXJIb3IgPSBib3JkZXIubGVmdCArIGJvcmRlci5yaWdodDtcbiAgdmFyIHNjYWxlID0gcmVjdC53aWR0aCAvIChjbGllbnRXaWR0aCArIGJvcmRlckhvcik7XG4gIHZhciB1bnNjYWxlZFcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdIb3I7XG4gIHZhciB1bnNjYWxlZEggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVmVyO1xuICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBhZGRpbmcubGVmdCArIGJvcmRlci5sZWZ0O1xuICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nLnRvcCArIGJvcmRlci50b3A7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5lckJCID0gW2xlZnQsIHRvcCwgdW5zY2FsZWRXLCB1bnNjYWxlZEgsIHNjYWxlXTtcbn07XG5cbkJScCQxLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuXG5CUnAkMS5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgcmV0dXJuIHRoaXMuZmluZE5lYXJlc3RFbGVtZW50cyh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaClbMF07XG59O1xuXG5CUnAkMS5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgdmFyIG5lYXIgPSBbXTsgLy8gMSBub2RlIG1heCwgMSBlZGdlIG1heFxuXG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuXG4gIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlKGVsZSwgc3FEaXN0KSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgaWYgKG5lYXJOb2RlKSB7XG4gICAgICAgIHJldHVybjsgLy8gY2FuJ3QgcmVwbGFjZSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyTm9kZSA9IGVsZTtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKSB7XG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApIHtcbiAgICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzW3NlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpXTtcblxuICAgICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpKSB7XG4gICAgICAgICAgYWRkRWxlKG5vZGUsIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSkge1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHN0eWxlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlV2lkdGggLyAyICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG5cbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNxRGlzdDtcblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpbkxpbmVWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuXG4gICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IHRndCB8fCBfcC50YXJnZXQ7XG4gICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aChzdHlsZVdpZHRoLCBzY2FsZSk7XG4gICAgdmFyIGFycm93cyA9IFt7XG4gICAgICBuYW1lOiAnc291cmNlJyxcbiAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgeTogcnMuYXJyb3dTdGFydFksXG4gICAgICBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQnLFxuICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgeTogcnMuYXJyb3dFbmRZLFxuICAgICAgYW5nbGU6IHJzLnRndEFycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXNvdXJjZScsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pZC10YXJnZXQnLFxuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFksXG4gICAgICBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZVxuICAgIH1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbZWRnZS5wc3R5bGUoYXIubmFtZSArICctYXJyb3ctc2hhcGUnKS52YWx1ZV07XG4gICAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcblxuICAgICAgaWYgKHNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkgJiYgc2hhcGUuY29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkpIHtcbiAgICAgICAgYWRkRWxlKGVkZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuXG5cbiAgICBpZiAoaGFzQ29tcG91bmRzICYmIG5lYXIubGVuZ3RoID4gMCkge1xuICAgICAgY2hlY2tOb2RlKHNyYyk7XG4gICAgICBjaGVja05vZGUodGd0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwcm9wKG9iaiwgbmFtZSwgcHJlKSB7XG4gICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICB2YXIgcHJlZml4RGFzaDtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG5cbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgYmIgPSBfcC5sYWJlbEJvdW5kc1twcmVmaXggfHwgJ21haW4nXTtcbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnZhbHVlO1xuICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBseCA9IHByZXByb3AocnN0eWxlLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbHkgPSBwcmVwcm9wKHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBseDEgPSBiYi54MSAtIHRoO1xuICAgIHZhciBseDIgPSBiYi54MiArIHRoO1xuICAgIHZhciBseTEgPSBiYi55MSAtIHRoO1xuICAgIHZhciBseTIgPSBiYi55MiArIHRoO1xuXG4gICAgaWYgKHRoZXRhKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgdmFyIHBvaW50cyA9IFtweDF5MS54LCBweDF5MS55LCBweDJ5MS54LCBweDJ5MS55LCBweDJ5Mi54LCBweDJ5Mi55LCBweDF5Mi54LCBweDF5Mi55XTtcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8gYSBjaGVhcGVyIGJiIGNoZWNrXG4gICAgICBpZiAoaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgY2hlY2tOb2RlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3NvdXJjZScpIHx8IGNoZWNrTGFiZWwoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXI7XG59OyAvLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5cblxuQlJwJDEuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuaW50ZXJhY3RpdmU7XG4gIHZhciBib3ggPSBbXTtcbiAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuICB2YXIgYm94QmIgPSBtYWtlQm91bmRpbmdCb3goe1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MlxuICB9KTtcblxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYm94QmIsIG5vZGVCYikgJiYgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChub2RlQmIsIGJveEJiKSkge1xuICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFwb2ludEluQm91bmRpbmdCb3goYm94QmIsIHB0c1tpXSkpIHtcbiAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbEluc2lkZSkge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG52YXIgQlJwJDIgPSB7fTtcblxuQlJwJDIuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnOyAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG5cbiAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgfVxuXG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTsgLy8gc291cmNlXG4gIC8vXG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIHJzLnNlZ3B0c1swXTtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIHJzLnNlZ3B0c1sxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4xKTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xKTtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgfVxuXG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIG1pZCB0YXJnZXRcbiAgLy9cblxuICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gIHZhciBtaWRZID0gcnMubWlkWTtcblxuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyO1xuICAgIG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyO1xuICB9XG5cbiAgZGlzcFggPSBlbmRYIC0gc3RhcnRYO1xuICBkaXNwWSA9IGVuZFkgLSBzdGFydFk7XG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG5cbiAgICAgIHZhciBpYyA9IHAwICsgMjtcbiAgICAgIHZhciBwMSA9IGljICsgMjtcbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wKTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wKTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wMDAxKTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wMDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuXG4gICAgICB2YXIgcDAgPSBpYyAtIDI7IC8vIHN0YXJ0cHRcblxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNDk5OSk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNSk7XG4gICAgfVxuXG4gICAgZGlzcFggPSBicDF4IC0gYnAweDtcbiAgICBkaXNwWSA9IGJwMXkgLSBicDB5O1xuICB9XG5cbiAgcnMubWlkdGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbiAgcnMubWlkRGlzcFggPSBkaXNwWDtcbiAgcnMubWlkRGlzcFkgPSBkaXNwWTsgLy8gbWlkIHNvdXJjZVxuICAvL1xuXG4gIGRpc3BYICo9IC0xO1xuICBkaXNwWSAqPSAtMTtcblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSA7IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuICAgICAgZGlzcFggPSAtKHB0c1tpM10gLSBwdHNbaTJdKTtcbiAgICAgIGRpc3BZID0gLShwdHNbaTMgKyAxXSAtIHB0c1tpMiArIDFdKTtcbiAgICB9XG4gIH1cblxuICBycy5taWRzcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpOyAvLyB0YXJnZXRcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMl07XG4gICAgZGlzcFkgPSBlbmRZIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgbCA9IHB0cy5sZW5ndGg7XG4gICAgdmFyIGJYID0gcWJlemllckF0KHB0c1tsIC0gNl0sIHB0c1tsIC0gNF0sIHB0c1tsIC0gMl0sIDAuOSk7XG4gICAgdmFyIGJZID0gcWJlemllckF0KHB0c1tsIC0gNV0sIHB0c1tsIC0gM10sIHB0c1tsIC0gMV0sIDAuOSk7XG4gICAgZGlzcFggPSBlbmRYIC0gYlg7XG4gICAgZGlzcFkgPSBlbmRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBlbmRYIC0gbWlkWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBtaWRZO1xuICB9XG5cbiAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbn07XG5cbkJScCQyLmdldEFycm93V2lkdGggPSBCUnAkMi5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uIChlZGdlV2lkdGgsIHNjYWxlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdO1xuXG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxudmFyIEJScCQzID0ge307XG5cbkJScCQzLmZpbmRIYXlzdGFja1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuXG4gICAgaWYgKCFycy5oYXlzdGFjaykge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMuc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICAgIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCdoYXlzdGFjay1yYWRpdXMnKS52YWx1ZTtcbiAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cyAvIDI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICBycy5oYXlzdGFja1B0cyA9IHJzLmFsbHB0cyA9IFtycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueSwgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LCBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnldO1xuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjsgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcblxuICAgIHJzLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICBycy5oYXlzdGFjayA9IHRydWU7XG4gICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kU2VnbWVudHNQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXdlaWdodHMnKTtcbiAgdmFyIHNlZ21lbnREcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LWRpc3RhbmNlcycpO1xuICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oc2VnbWVudFdzLnBmVmFsdWUubGVuZ3RoLCBzZWdtZW50RHMucGZWYWx1ZS5sZW5ndGgpO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHJzLnNlZ3B0cyA9IFtdO1xuXG4gIGZvciAodmFyIHMgPSAwOyBzIDwgc2VnbWVudHNOOyBzKyspIHtcbiAgICB2YXIgdyA9IHNlZ21lbnRXcy5wZlZhbHVlW3NdO1xuICAgIHZhciBkID0gc2VnbWVudERzLnBmVmFsdWVbc107XG4gICAgdmFyIHcxID0gMSAtIHc7XG4gICAgdmFyIHcyID0gdztcbiAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5zZWdwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGQpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gIC8vIFNlbGYtZWRnZVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZGlyQ291bnRzID0gcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGxvb3BTd3AgPSBlZGdlLnBzdHlsZSgnbG9vcC1zd2VlcCcpLnBmVmFsdWU7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cblxuICB2YXIgbG9vcEFuZ2xlID0gbG9vcERpciAtIE1hdGguUEkgLyAyO1xuICB2YXIgb3V0QW5nbGUgPSBsb29wQW5nbGUgLSBsb29wU3dwIC8gMjtcbiAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjsgLy8gaW5jcmVhc2UgYnkgc3RlcCBzaXplIGZvciBvdmVybGFwcGluZyBsb29wcywga2V5ZWQgb24gZGlyZWN0aW9uIGFuZCBzd2VlcCB2YWx1ZXNcblxuICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG4gIHJzLmN0cmxwdHMgPSBbc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKV07XG59O1xuXG5CUnAkMy5maW5kQ29tcG91bmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gQ29tcG91bmQgZWRnZVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG4gIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cblxuICB2YXIgbG9vcFcgPSA1MDtcbiAgdmFyIGxvb3BhUG9zID0ge1xuICAgIHg6IHNyY1Bvcy54IC0gc3JjVyAvIDIsXG4gICAgeTogc3JjUG9zLnkgLSBzcmNIIC8gMlxuICB9O1xuICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gIH07XG4gIHZhciBsb29wUG9zID0ge1xuICAgIHg6IE1hdGgubWluKGxvb3BhUG9zLngsIGxvb3BiUG9zLngpLFxuICAgIHk6IE1hdGgubWluKGxvb3BhUG9zLnksIGxvb3BiUG9zLnkpXG4gIH07IC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuXG4gIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkpO1xuICB2YXIgY29tcG91bmRTdHJldGNoQiA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIDAuMDEpKTtcbiAgcnMuY3RybHB0cyA9IFtsb29wUG9zLngsIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLCBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQiwgbG9vcFBvcy55XTtcbn07XG5cbkJScCQzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAvLyBTdHJhaWdodCBlZGdlIHdpdGhpbiBidW5kbGVcbiAgZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG59O1xuXG5CUnAkMy5maW5kQmV6aWVyUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0gcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UsXG4gICAgICBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHM7XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0V3MgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC13ZWlnaHRzJyk7XG4gIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbihjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCkgOiAxO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdOyAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICBycy5jdHJscHRzID0gW107XG5cbiAgZm9yICh2YXIgYiA9IDA7IGIgPCBiZXppZXJOOyBiKyspIHtcbiAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckluZm8uZWxlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZSAqIChlZGdlSXNTd2FwcGVkID8gLTEgOiAxKTtcbiAgICB2YXIgbWFuY3RybHB0RGlzdCA9IHZvaWQgMDtcbiAgICB2YXIgc2lnbiA9IHNpZ251bShub3JtY3RybHB0RGlzdCk7XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuXG4gICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICB9XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcbiAgICB2YXIgdzEgPSAxIC0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciB3MiA9IGN0cmxwdFdlaWdodDtcbiAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5jdHJscHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kVGF4aVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBUYXhpY2FiIGdlb21ldHJ5IHdpdGggdHdvIHR1cm5zIG1heGltdW1cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICB2YXIgVkVSVElDQUwgPSAndmVydGljYWwnO1xuICB2YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbiAgdmFyIExFRlRXQVJEID0gJ2xlZnR3YXJkJztcbiAgdmFyIFJJR0hUV0FSRCA9ICdyaWdodHdhcmQnO1xuICB2YXIgRE9XTldBUkQgPSAnZG93bndhcmQnO1xuICB2YXIgVVBXQVJEID0gJ3Vwd2FyZCc7XG4gIHZhciBBVVRPID0gJ2F1dG8nO1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHZhciBkSW5jbHVkZXNOb2RlQm9keSA9IGVkZ2VEaXN0YW5jZXMgIT09ICdub2RlLXBvc2l0aW9uJztcbiAgdmFyIHRheGlEaXIgPSBlZGdlLnBzdHlsZSgndGF4aS1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgdmFyIHJhd1RheGlEaXIgPSB0YXhpRGlyOyAvLyB1bnByb2Nlc3NlZCB2YWx1ZVxuXG4gIHZhciB0YXhpVHVybiA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4nKTtcbiAgdmFyIHRheGlUdXJuUGZWYWwgPSB0YXhpVHVybi5wZlZhbHVlO1xuICB2YXIgbWluRCA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJykucGZWYWx1ZTtcbiAgdmFyIHR1cm5Jc1BlcmNlbnQgPSB0YXhpVHVybi51bml0cyA9PT0gJyUnO1xuICB2YXIgZHcgPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNXICsgdGd0VykgLyAyIDogMDtcbiAgdmFyIGRoID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjSCArIHRndEgpIC8gMiA6IDA7XG4gIHZhciBwZHggPSBwb3NQdHMueDIgLSBwb3NQdHMueDE7XG4gIHZhciBwZHkgPSBwb3NQdHMueTIgLSBwb3NQdHMueTE7IC8vIHRha2UgYXdheSB0aGUgZWZmZWN0aXZlIHcvaCBmcm9tIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGRlbHRhIHZhbHVlXG5cbiAgdmFyIHN1YkRXSCA9IGZ1bmN0aW9uIHN1YkRXSChkeHksIGR3aCkge1xuICAgIGlmIChkeHkgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZHh5IC0gZHdoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGR4eSArIGR3aCwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuXG4gIGlmICh0YXhpRGlyID09PSBBVVRPKSB7XG4gICAgdGF4aURpciA9IE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSA/IEhPUklaT05UQUwgOiBWRVJUSUNBTDtcbiAgfSBlbHNlIGlmICh0YXhpRGlyID09PSBVUFdBUkQgfHwgdGF4aURpciA9PT0gRE9XTldBUkQpIHtcbiAgICB0YXhpRGlyID0gVkVSVElDQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGF4aURpciA9PT0gTEVGVFdBUkQgfHwgdGF4aURpciA9PT0gUklHSFRXQVJEKSB7XG4gICAgdGF4aURpciA9IEhPUklaT05UQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH1cblxuICB2YXIgaXNWZXJ0ID0gdGF4aURpciA9PT0gVkVSVElDQUw7XG4gIHZhciBsID0gaXNWZXJ0ID8gZHkgOiBkeDtcbiAgdmFyIHBsID0gaXNWZXJ0ID8gcGR5IDogcGR4O1xuICB2YXIgc2duTCA9IHNpZ251bShwbCk7XG4gIHZhciBmb3JjZWREaXIgPSBmYWxzZTtcblxuICBpZiAoIShpc0V4cGxpY2l0RGlyICYmIHR1cm5Jc1BlcmNlbnQpIC8vIGZvcmNpbmcgaW4gdGhpcyBjYXNlIHdvdWxkIGNhdXNlIHdlaXJkIGdyb3dpbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAmJiAocmF3VGF4aURpciA9PT0gRE9XTldBUkQgJiYgcGwgPCAwIHx8IHJhd1RheGlEaXIgPT09IFVQV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gTEVGVFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCAmJiBwbCA8IDApKSB7XG4gICAgc2duTCAqPSAtMTtcbiAgICBsID0gc2duTCAqIE1hdGguYWJzKGwpO1xuICAgIGZvcmNlZERpciA9IHRydWU7XG4gIH1cblxuICB2YXIgZCA9IHR1cm5Jc1BlcmNlbnQgPyB0YXhpVHVyblBmVmFsICogbCA6IHRheGlUdXJuUGZWYWwgKiBzZ25MO1xuXG4gIHZhciBnZXRJc1Rvb0Nsb3NlID0gZnVuY3Rpb24gZ2V0SXNUb29DbG9zZShkKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGQpIDwgbWluRCB8fCBNYXRoLmFicyhkKSA+PSBNYXRoLmFicyhsKTtcbiAgfTtcblxuICB2YXIgaXNUb29DbG9zZVNyYyA9IGdldElzVG9vQ2xvc2UoZCk7XG4gIHZhciBpc1Rvb0Nsb3NlVGd0ID0gZ2V0SXNUb29DbG9zZShsIC0gZCk7XG4gIHZhciBpc1Rvb0Nsb3NlID0gaXNUb29DbG9zZVNyYyB8fCBpc1Rvb0Nsb3NlVGd0O1xuXG4gIGlmIChpc1Rvb0Nsb3NlICYmICFmb3JjZWREaXIpIHtcbiAgICAvLyBub24taWRlYWwgcm91dGluZ1xuICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGZhbGxiYWNrc1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNIIC8gMjtcbiAgICAgIHZhciBsU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHgpIDw9IHRndFcgLyAyO1xuXG4gICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICB5MiA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gsIHkxLCB4LCB5Ml07XG4gICAgICB9IGVsc2UgaWYgKGxTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIHgxID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgeDIgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4MSwgeSwgeDIsIHldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTC1zaGFwZSBmYWxsYmFjayAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCB3aXRoIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDEsIHBvc1B0cy55Ml07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWwgZmFsbGJhY2tzXG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNXIC8gMjtcblxuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuXG4gICAgICBpZiAoX2xTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF95ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuXG4gICAgICAgIHZhciBfeCA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG5cbiAgICAgICAgdmFyIF95MiA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgIF95MyA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194MywgX3kyLCBfeDMsIF95M107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIGZvciB0cmVlIHNpYmxpbmdzKVxuICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngyLCBwb3NQdHMueTFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgdmFyIF95NCA9IHBvc1B0cy55MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNIIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgICBfeDUgPSBwb3NQdHMueDI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g0LCBfeTQsIF94NSwgX3k0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgdmFyIF94NiA9IHBvc1B0cy54MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNXIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF95NSA9IHBvc1B0cy55MSxcbiAgICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICB9XG4gIH1cbn07XG5cbkJScCQzLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDsgLy8gY2FuIG9ubHkgY29ycmVjdCBiZXppZXJzIGZvciBub3cuLi5cblxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SCxcbiAgICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgICAgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZTtcbiAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyKHJzLnN0YXJ0WCkgfHwgIW51bWJlcihycy5zdGFydFkpO1xuICAgIHZhciBiYWRBU3RhcnQgPSAhbnVtYmVyKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyKHJzLmFycm93U3RhcnRZKTtcbiAgICB2YXIgYmFkRW5kID0gIW51bWJlcihycy5lbmRYKSB8fCAhbnVtYmVyKHJzLmVuZFkpO1xuICAgIHZhciBiYWRBRW5kID0gIW51bWJlcihycy5hcnJvd0VuZFgpIHx8ICFudW1iZXIocnMuYXJyb3dFbmRZKTtcbiAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgdmFyIHN0YXJ0QUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBycy5zdGFydFgsXG4gICAgICB5OiBycy5zdGFydFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIGVuZEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuZW5kWCxcbiAgICAgIHk6IHJzLmVuZFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgIGlmIChiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCkge1xuICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlOyAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG5cbiAgICAgIHZhciBjcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICB9O1xuICAgICAgdmFyIGNwTCA9IE1hdGguc3FydChjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cbiAgICAgIHZhciBjcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICB9O1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgdmFyIGNwUHJvaiA9IHtcbiAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICB9O1xuICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgY3BQcm9qLngsIGNwUHJvai55LCAwKTtcblxuICAgICAgaWYgKGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTsgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuXG4gICAgICB2YXIgX2NwRCA9IHtcbiAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHRndFBvcy54LFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHZhciBfY3BMID0gTWF0aC5zcXJ0KF9jcEQueCAqIF9jcEQueCArIF9jcEQueSAqIF9jcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cblxuICAgICAgdmFyIF9jcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogX2NwRC54IC8gX2NwTCxcbiAgICAgICAgeTogX2NwRC55IC8gX2NwTFxuICAgICAgfTtcblxuICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcblxuICAgICAgdmFyIF9jcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIDIgKiBfcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgX2NwTS55ICogMiAqIF9yYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBfY3BQcm9qLngsIF9jcFByb2oueSwgMCk7XG5cbiAgICAgIGlmIChjbG9zZUVuZEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgX2NwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSB0Z3RDdHJsUHRJbnRuWzBdICsgX2NwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBfY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdmVybGFwcGluZykge1xuICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDMuc3RvcmVBbGxwdHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmIChycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIpIHtcbiAgICAgIC8vIGN0cmwgcHQgaXRzZWxmXG4gICAgICBycy5hbGxwdHMucHVzaChycy5jdHJscHRzW2JdLCBycy5jdHJscHRzW2IgKyAxXSk7IC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuXG4gICAgICBpZiAoYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCkge1xuICAgICAgICBycy5hbGxwdHMucHVzaCgocnMuY3RybHB0c1tiXSArIHJzLmN0cmxwdHNbYiArIDJdKSAvIDIsIChycy5jdHJscHRzW2IgKyAxXSArIHJzLmN0cmxwdHNbYiArIDNdKSAvIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgIHZhciBtLCBtdDtcblxuICAgIGlmIChycy5jdHJscHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1ttXTtcbiAgICAgIHJzLm1pZFkgPSBycy5hbGxwdHNbbSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAzO1xuICAgICAgbXQgPSAwLjU7XG4gICAgICBycy5taWRYID0gcWJlemllckF0KHJzLmFsbHB0c1ttXSwgcnMuYWxscHRzW20gKyAyXSwgcnMuYWxscHRzW20gKyA0XSwgbXQpO1xuICAgICAgcnMubWlkWSA9IHFiZXppZXJBdChycy5hbGxwdHNbbSArIDFdLCBycy5hbGxwdHNbbSArIDNdLCBycy5hbGxwdHNbbSArIDVdLCBtdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgIHJzLmFsbHB0cyA9IFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWV07IC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcblxuICAgIHJzLm1pZFggPSAocnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYKSAvIDQ7XG4gICAgcnMubWlkWSA9IChycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkpIC8gNDtcbiAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICBycy5hbGxwdHMucHVzaC5hcHBseShycy5hbGxwdHMsIHJzLnNlZ3B0cyk7XG4gICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG5cbiAgICBpZiAocnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgcnMubWlkWCA9IChycy5zZWdwdHNbaTFdICsgcnMuc2VncHRzW2kyXSkgLyAyO1xuICAgICAgcnMubWlkWSA9IChycy5zZWdwdHNbaTEgKyAxXSArIHJzLnNlZ3B0c1tpMiArIDFdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcblxuICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1tfaV07XG4gICAgICBycy5taWRZID0gcnMuc2VncHRzW19pICsgMV07XG4gICAgfVxuICB9XG59O1xuXG5CUnAkMy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgaWYgKHJzLm5vZGVzT3ZlcmxhcCB8fCBudW1iZXIocnMuc3RhcnRYKSAmJiBudW1iZXIocnMuc3RhcnRZKSAmJiBudW1iZXIocnMuZW5kWCkgJiYgbnVtYmVyKHJzLmVuZFkpKSB7XG4gICAgcnMubG9nZ2VkRXJyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFycy5sb2dnZWRFcnIpIHtcbiAgICAgIHJzLmxvZ2dlZEVyciA9IHRydWU7XG4gICAgICB3YXJuKCdFZGdlIGAnICsgZWRnZS5pZCgpICsgJ2AgaGFzIGludmFsaWQgZW5kcG9pbnRzIGFuZCBzbyBpdCBpcyBpbXBvc3NpYmxlIHRvIGRyYXcuICBBZGp1c3QgeW91ciBlZGdlIHN0eWxlIChlLmcuIGNvbnRyb2wgcG9pbnRzKSBhY2NvcmRpbmdseSBvciB1c2UgYW4gYWx0ZXJuYXRpdmUgZWRnZSB0eXBlLiAgVGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB0aGUgc291cmNlIG5vZGUgYW5kIHRoZSB0YXJnZXQgbm9kZSBvdmVybGFwLicpO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDMuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSB7XG4gICAgbWFwOiBuZXcgTWFwJDEoKSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChwYWlySWQpIHtcbiAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgIGlmIChtYXAyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hcDIuZ2V0KHBhaXJJZFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBhaXJJZCwgdmFsKSB7XG4gICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuXG4gICAgICBpZiAobWFwMiA9PSBudWxsKSB7XG4gICAgICAgIG1hcDIgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KHBhaXJJZFswXSwgbWFwMik7XG4gICAgICB9XG5cbiAgICAgIG1hcDIuc2V0KHBhaXJJZFsxXSwgdmFsKTtcbiAgICB9XG4gIH07XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107IC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTsgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcblxuICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaChlZGdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgICB2YXIgZWRnZUlzQmV6aWVyID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdiZXppZXInO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjSW5kZXggPSBzcmMucG9vbEluZGV4KCk7XG4gICAgdmFyIHRndEluZGV4ID0gdGd0LnBvb2xJbmRleCgpO1xuICAgIHZhciBwYWlySWQgPSBbc3JjSW5kZXgsIHRndEluZGV4XS5zb3J0KCk7XG4gICAgdmFyIHRhYmxlRW50cnkgPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG5cbiAgICBpZiAodGFibGVFbnRyeSA9PSBudWxsKSB7XG4gICAgICB0YWJsZUVudHJ5ID0ge1xuICAgICAgICBlbGVzOiBbXVxuICAgICAgfTtcbiAgICAgIGhhc2hUYWJsZS5zZXQocGFpcklkLCB0YWJsZUVudHJ5KTtcbiAgICAgIHBhaXJJZHMucHVzaChwYWlySWQpO1xuICAgIH1cblxuICAgIHRhYmxlRW50cnkuZWxlcy5wdXNoKGVkZ2UpO1xuXG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgdGFibGVFbnRyeS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlZGdlSXNCZXppZXIpIHtcbiAgICAgIHRhYmxlRW50cnkuaGFzQmV6aWVyID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnRcblxuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHApIHtcbiAgICB2YXIgcGFpcklkID0gcGFpcklkc1twXTtcbiAgICB2YXIgcGFpckluZm8gPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG4gICAgdmFyIHN3YXBwZWRwYWlySW5mbyA9IHZvaWQgMDtcblxuICAgIGlmICghcGFpckluZm8uaGFzVW5idW5kbGVkKSB7XG4gICAgICB2YXIgcGxsRWRnZXMgPSBwYWlySW5mby5lbGVzWzBdLnBhcmFsbGVsRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuaXNCdW5kbGVkQmV6aWVyKCk7XG4gICAgICB9KTtcbiAgICAgIGNsZWFyQXJyYXkocGFpckluZm8uZWxlcyk7XG4gICAgICBwbGxFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBwYWlySW5mby5lbGVzLnB1c2goZWRnZSk7XG4gICAgICB9KTsgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcblxuICAgICAgcGFpckluZm8uZWxlcy5zb3J0KGZ1bmN0aW9uIChlZGdlMSwgZWRnZTIpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UxLnBvb2xJbmRleCgpIC0gZWRnZTIucG9vbEluZGV4KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RFZGdlID0gcGFpckluZm8uZWxlc1swXTtcbiAgICB2YXIgc3JjID0gZmlyc3RFZGdlLnNvdXJjZSgpO1xuICAgIHZhciB0Z3QgPSBmaXJzdEVkZ2UudGFyZ2V0KCk7IC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgdy5yLnQuIHBhaXJJZFxuXG4gICAgaWYgKHNyYy5wb29sSW5kZXgoKSA+IHRndC5wb29sSW5kZXgoKSkge1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cblxuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gcGFpckluZm8udGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBwYWlySW5mby5zcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHBhaXJJbmZvLnNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgdGd0VyA9IHBhaXJJbmZvLnRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHZhciB0Z3RIID0gcGFpckluZm8udGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgdmFyIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHNyYyldO1xuXG4gICAgdmFyIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHRndCldO1xuXG4gICAgcGFpckluZm8uZGlyQ291bnRzID0ge1xuICAgICAgJ25vcnRoJzogMCxcbiAgICAgICd3ZXN0JzogMCxcbiAgICAgICdzb3V0aCc6IDAsXG4gICAgICAnZWFzdCc6IDAsXG4gICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAnc291dGhlYXN0JzogMFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYWlySW5mby5lbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZWRnZSA9IHBhaXJJbmZvLmVsZXNbX2kyXTtcbiAgICAgIHZhciBycyA9IF9lZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICB2YXIgX2N1cnZlU3R5bGUgPSBfZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG5cbiAgICAgIHZhciBfZWRnZUlzVW5idW5kbGVkID0gX2N1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3RheGknOyAvLyB3aGV0aGVyIHRoZSBub3JtYWxpc2VkIHBhaXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGVkZ2UncyBzcmMtdGd0IG9yZGVyXG5cblxuICAgICAgdmFyIGVkZ2VJc1N3YXBwZWQgPSAhc3JjLnNhbWUoX2VkZ2Uuc291cmNlKCkpO1xuXG4gICAgICBpZiAoIXBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgc3JjICE9PSB0Z3QgJiYgKHBhaXJJbmZvLmhhc0JlemllciB8fCBwYWlySW5mby5oYXNVbmJ1bmRsZWQpKSB7XG4gICAgICAgIHBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gPSB0cnVlOyAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDApO1xuICAgICAgICB2YXIgc3JjSW50biA9IHBhaXJJbmZvLnNyY0ludG4gPSBzcmNPdXRzaWRlOyAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBzcmNQb3MueCwgc3JjUG9zLnksIDApO1xuICAgICAgICB2YXIgdGd0SW50biA9IHBhaXJJbmZvLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkeSA9IHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdO1xuICAgICAgICB2YXIgZHggPSB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB2YXIgdmVjdG9yID0gcGFpckluZm8udmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtID0gcGFpckluZm8udmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICB9OyAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcblxuICAgICAgICBwYWlySW5mby5ub2Rlc092ZXJsYXAgPSAhbnVtYmVyKGwpIHx8IHRndFNoYXBlLmNoZWNrUG9pbnQoc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55KSB8fCBzcmNTaGFwZS5jaGVja1BvaW50KHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIDAsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSk7XG4gICAgICAgIHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlID0gdmVjdG9yTm9ybUludmVyc2U7XG4gICAgICAgIHN3YXBwZWRwYWlySW5mbyA9IHtcbiAgICAgICAgICBub2Rlc092ZXJsYXA6IHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCxcbiAgICAgICAgICBkaXJDb3VudHM6IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICAgICAgICBjYWxjdWxhdGVkSW50ZXJzZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIGhhc0JlemllcjogcGFpckluZm8uaGFzQmV6aWVyLFxuICAgICAgICAgIGhhc1VuYnVuZGxlZDogcGFpckluZm8uaGFzVW5idW5kbGVkLFxuICAgICAgICAgIGVsZXM6IHBhaXJJbmZvLmVsZXMsXG4gICAgICAgICAgc3JjUG9zOiB0Z3RQb3MsXG4gICAgICAgICAgdGd0UG9zOiBzcmNQb3MsXG4gICAgICAgICAgc3JjVzogdGd0VyxcbiAgICAgICAgICBzcmNIOiB0Z3RILFxuICAgICAgICAgIHRndFc6IHNyY1csXG4gICAgICAgICAgdGd0SDogc3JjSCxcbiAgICAgICAgICBzcmNJbnRuOiB0Z3RJbnRuLFxuICAgICAgICAgIHRndEludG46IHNyY0ludG4sXG4gICAgICAgICAgc3JjU2hhcGU6IHRndFNoYXBlLFxuICAgICAgICAgIHRndFNoYXBlOiBzcmNTaGFwZSxcbiAgICAgICAgICBwb3NQdHM6IHtcbiAgICAgICAgICAgIHgxOiBwb3NQdHMueDIsXG4gICAgICAgICAgICB5MTogcG9zUHRzLnkyLFxuICAgICAgICAgICAgeDI6IHBvc1B0cy54MSxcbiAgICAgICAgICAgIHkyOiBwb3NQdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVyc2VjdGlvblB0czoge1xuICAgICAgICAgICAgeDE6IGludGVyc2VjdGlvblB0cy54MixcbiAgICAgICAgICAgIHkxOiBpbnRlcnNlY3Rpb25QdHMueTIsXG4gICAgICAgICAgICB4MjogaW50ZXJzZWN0aW9uUHRzLngxLFxuICAgICAgICAgICAgeTI6IGludGVyc2VjdGlvblB0cy55MVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvck5vcm06IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybS55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZToge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm1JbnZlcnNlLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybUludmVyc2UueVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhc3NlZFBhaXJJbmZvID0gZWRnZUlzU3dhcHBlZCA/IHN3YXBwZWRwYWlySW5mbyA6IHBhaXJJbmZvO1xuICAgICAgcnMubm9kZXNPdmVybGFwID0gcGFzc2VkUGFpckluZm8ubm9kZXNPdmVybGFwO1xuICAgICAgcnMuc3JjSW50biA9IHBhc3NlZFBhaXJJbmZvLnNyY0ludG47XG4gICAgICBycy50Z3RJbnRuID0gcGFzc2VkUGFpckluZm8udGd0SW50bjtcblxuICAgICAgaWYgKGhhc0NvbXBvdW5kcyAmJiAoc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpKSAmJiAoc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykgfHwgc3JjLnNhbWUodGd0KSAmJiBzcmMuaXNQYXJlbnQoKSkpIHtcbiAgICAgICAgX3RoaXMuZmluZENvbXBvdW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIF90aGlzLmZpbmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzZWdtZW50cycpIHtcbiAgICAgICAgX3RoaXMuZmluZFNlZ21lbnRzUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAndGF4aScpIHtcbiAgICAgICAgX3RoaXMuZmluZFRheGlQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgIV9lZGdlSXNVbmJ1bmRsZWQgJiYgcGFpckluZm8uZWxlcy5sZW5ndGggJSAyID09PSAxICYmIF9pMiA9PT0gTWF0aC5mbG9vcihwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIpKSB7XG4gICAgICAgIF90aGlzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMoX2VkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZmluZEJlemllclBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZpbmRFbmRwb2ludHMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG5cbiAgICAgIF90aGlzLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nKF9lZGdlKTtcblxuICAgICAgX3RoaXMuc3RvcmVBbGxwdHMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKF9lZGdlKTtcblxuICAgICAgX3RoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKF9lZGdlKTtcbiAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG5cbiAgfTtcblxuICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICBfbG9vcChwKTtcbiAgfSAvLyBmb3IgcGFpciBpZHNcbiAgLy8gaGF5c3RhY2tzIGF2b2lkIHRoZSBleHBlbnNlIG9mIHBhaXJJbmZvIHN0dWZmIChpbnRlcnNlY3Rpb25zIGV0Yy4pXG5cblxuICB0aGlzLmZpbmRIYXlzdGFja1BvaW50cyhoYXlzdGFja0VkZ2VzKTtcbn07XG5cbmZ1bmN0aW9uIGdldFB0cyhwdHMpIHtcbiAgdmFyIHJldFB0cyA9IFtdO1xuXG4gIGlmIChwdHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBwdHNbaV07XG4gICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgIHJldFB0cy5wdXNoKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0UHRzO1xufVxuXG5CUnAkMy5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgIHJldHVybiBnZXRQdHMocnMuc2VncHRzKTtcbiAgfVxufTtcblxuQlJwJDMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG5cbiAgaWYgKHR5cGUgPT09ICdiZXppZXInIHx8IHR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgdHlwZSA9PT0gJ3NlbGYnIHx8IHR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICByZXR1cm4gZ2V0UHRzKHJzLmN0cmxwdHMpO1xuICB9XG59O1xuXG5CUnAkMy5nZXRFZGdlTWlkcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbn07XG5cbnZhciBCUnAkNCA9IHt9O1xuXG5CUnAkNC5tYW51YWxFbmRwdFRvUHggPSBmdW5jdGlvbiAobm9kZSwgcHJvcCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBucG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICBpZiAocHJvcC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcCA9IFtwcm9wLnBmVmFsdWVbMF0sIHByb3AucGZWYWx1ZVsxXV07XG5cbiAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgfVxuXG4gICAgaWYgKHByb3AudW5pdHNbMV0gPT09ICclJykge1xuICAgICAgcFsxXSA9IHBbMV0gKiBoO1xuICAgIH1cblxuICAgIHBbMF0gKz0gbnBvcy54O1xuICAgIHBbMV0gKz0gbnBvcy55O1xuICAgIHJldHVybiBwO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmdsZSA9IHByb3AucGZWYWx1ZVswXTtcbiAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCh3LCBoKTtcbiAgICB2YXIgX3AgPSBbbnBvcy54ICsgTWF0aC5jb3MoYW5nbGUpICogbCwgbnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogbF07XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uaW50ZXJzZWN0TGluZShucG9zLngsIG5wb3MueSwgdywgaCwgX3BbMF0sIF9wWzFdLCAwKTtcbiAgfVxufTtcblxuQlJwJDQuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdDtcbiAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICB2YXIgc3JjUG9zID0gc291cmNlLnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RQb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgdGd0RGlzdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgdGF4aSA9IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICB2YXIgb3ZlcnJpZGVFbmRwdHMgPSBzZWxmIHx8IHRheGk7XG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHNyY01hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHNyY01hbkVuZHB0LnZhbHVlO1xuICB2YXIgdGd0TWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiB0Z3RNYW5FbmRwdC52YWx1ZTtcbiAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcbiAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcblxuICB2YXIgcDI7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiBzb3VyY2Ugc2lkZVxuXG4gIHZhciBwMV9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCB0YXJnZXQgc2hhcGVcblxuICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgaWYgKGJlemllcikge1xuICAgIHZhciBjcFN0YXJ0ID0gW3JzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV1dO1xuICAgIHZhciBjcEVuZCA9IG11bHRpID8gW3JzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDFdXSA6IGNwU3RhcnQ7XG4gICAgcDEgPSBjcEVuZDtcbiAgICBwMiA9IGNwU3RhcnQ7XG4gIH0gZWxzZSBpZiAobGluZXMpIHtcbiAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbdGd0UG9zLngsIHRndFBvcy55XSA6IHJzLnNlZ3B0cy5zbGljZSgwLCAyKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbc3JjUG9zLngsIHNyY1Bvcy55XSA6IHJzLnNlZ3B0cy5zbGljZShycy5zZWdwdHMubGVuZ3RoIC0gMik7XG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG5cbiAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCh0YXJnZXQsIHRndE1hbkVuZHB0KTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy50Z3RJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH1cblxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGFyZ2V0Lm91dGVyV2lkdGgoKSwgdGFyZ2V0Lm91dGVySGVpZ2h0KCksIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuXG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHZhciB0cnMgPSB0YXJnZXQuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgbHcgPSB0cnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBsaCA9IHRycy5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBseCA9IHRycy5sYWJlbFg7XG4gICAgICB2YXIgbHkgPSB0cnMubGFiZWxZO1xuICAgICAgdmFyIHZhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKHZhID09PSAndG9wJykge1xuICAgICAgICBseSAtPSBsaCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHZhID09PSAnYm90dG9tJykge1xuICAgICAgICBseSArPSBsaCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChoYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGx4IC09IGx3IC8gMjtcbiAgICAgIH0gZWxzZSBpZiAoaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgbHggKz0gbHcgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxJbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddLmludGVyc2VjdExpbmUobHgsIGx5LCBsdywgbGgsIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgdmFyIGludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG4gICAgICB2YXIgbGFiSW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChsYWJlbEludGVyc2VjdCkpO1xuXG4gICAgICBpZiAobGFiSW50U3FkaXN0IDwgaW50U3FkaXN0KSB7XG4gICAgICAgIGludGVyc2VjdCA9IGxhYmVsSW50ZXJzZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJvd0VuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHZhciBlZGdlRW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcblxuICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHNvdXJjZSwgc3JjTWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gcDI7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCk7XG5cbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHNycyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfbHcgPSBzcnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBfbGggPSBzcnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgX2x4ID0gc3JzLmxhYmVsWDtcbiAgICAgIHZhciBfbHkgPSBzcnMubGFiZWxZO1xuICAgICAgdmFyIF92YSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChfdmEgPT09ICd0b3AnKSB7XG4gICAgICAgIF9seSAtPSBfbGggLyAyO1xuICAgICAgfSBlbHNlIGlmIChfdmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIF9seSArPSBfbGggLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKF9oYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIF9seCAtPSBfbHcgLyAyO1xuICAgICAgfSBlbHNlIGlmIChfaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgX2x4ICs9IF9sdyAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbGFiZWxJbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddLmludGVyc2VjdExpbmUoX2x4LCBfbHksIF9sdywgX2xoLCBwMl9pWzBdLCBwMl9pWzFdLCAwKTtcblxuICAgICAgdmFyIF9yZWZQdCA9IHRndFBvcztcblxuICAgICAgdmFyIF9pbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcblxuICAgICAgdmFyIF9sYWJJbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChfbGFiZWxJbnRlcnNlY3QpKTtcblxuICAgICAgaWYgKF9sYWJJbnRTcWRpc3QgPCBfaW50U3FkaXN0KSB7XG4gICAgICAgIGludGVyc2VjdCA9IF9sYWJlbEludGVyc2VjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYXJyb3dTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHZhciBlZGdlU3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcblxuICBpZiAoaGFzRW5kcHRzKSB7XG4gICAgaWYgKCFudW1iZXIocnMuc3RhcnRYKSB8fCAhbnVtYmVyKHJzLnN0YXJ0WSkgfHwgIW51bWJlcihycy5lbmRYKSB8fCAhbnVtYmVyKHJzLmVuZFkpKSB7XG4gICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDQuZ2V0U291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMF0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzFdXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgICB5OiBycy5hcnJvd1N0YXJ0WVxuICAgICAgfTtcbiAgfVxufTtcblxuQlJwJDQuZ2V0VGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMl0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzNdXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgeTogcnMuYXJyb3dFbmRZXG4gICAgICB9O1xuICB9XG59O1xuXG52YXIgQlJwJDUgPSB7fTtcblxuZnVuY3Rpb24gcHVzaEJlemllclB0cyhyLCBlZGdlLCBwdHMpIHtcbiAgdmFyIHFiZXppZXJBdCQxID0gZnVuY3Rpb24gcWJlemllckF0JDEocDEsIHAyLCBwMywgdCkge1xuICAgIHJldHVybiBxYmV6aWVyQXQocDEsIHAyLCBwMywgdCk7XG4gIH07XG5cbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcbiAgICBicHRzLnB1c2goe1xuICAgICAgeDogcWJlemllckF0JDEocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgcCksXG4gICAgICB5OiBxYmV6aWVyQXQkMShwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCBwKVxuICAgIH0pO1xuICB9XG59XG5cbkJScCQ1LnN0b3JlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlOyAvLyBjbGVhciB0aGUgY2FjaGVkIHBvaW50cyBzdGF0ZVxuXG4gIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBudWxsO1xuICBfcC5yc3R5bGUubGluZVB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IG51bGw7XG5cbiAgaWYgKGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnKSB7XG4gICAgX3AucnN0eWxlLmJlemllclB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBwdXNoQmV6aWVyUHRzKHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZShpLCBpICsgNikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHZhciBscHRzID0gX3AucnN0eWxlLmxpbmVQdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgbHB0cy5wdXNoKHtcbiAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXQgPT09ICdoYXlzdGFjaycpIHtcbiAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFt7XG4gICAgICB4OiBocHRzWzBdLFxuICAgICAgeTogaHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IGhwdHNbMl0sXG4gICAgICB5OiBocHRzWzNdXG4gICAgfV07XG4gIH1cblxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5cbkJScCQ1LnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbn07XG5cbnZhciBCUnAkNiA9IHt9O1xuXG5CUnAkNi5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhub2RlKTtcbn07XG5cbnZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPT09IDAgJiYgYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgPSBhbmdsZSAqIC0xO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufTtcblxudmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG59O1xuXG52YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiBiZXppZXJBbmdsZShwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciB0MCA9IGJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gIHZhciB0MSA9IGJvdW5kKDAsIHQgKyAwLjAwMSwgMSk7XG4gIHZhciBscDAgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gIHZhciBscDEgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MSk7XG4gIHJldHVybiBsaW5lQW5nbGUobHAwLCBscDEpO1xufTtcblxuQlJwJDYucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBwO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gIH07XG5cbiAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBubyBsYWJlbHMgPT4gbm8gY2FsY3NcbiAgICB9IC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gIC8vXG5cblxuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuXG4gIHZhciBzZXRScyA9IGZ1bmN0aW9uIHNldFJzKHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gIH07XG5cbiAgc2V0UnMoJ2xhYmVsWCcsIG51bGwsIHAueCk7XG4gIHNldFJzKCdsYWJlbFknLCBudWxsLCBwLnkpO1xuICB2YXIgbWlkQW5nbGUgPSBsaW5lQW5nbGVGcm9tRGVsdGEocnMubWlkRGlzcFgsIHJzLm1pZERpc3BZKTtcbiAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgbnVsbCwgbWlkQW5nbGUpO1xuXG4gIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICBpZiAoY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG5cbiAgICB2YXIgY3RybHB0cyA9IFtdOyAvLyBzdG9yZSBlYWNoIGN0cmxwdCBpbmZvIGluaXRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHAwID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH07XG4gICAgICB2YXIgcDEgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgIH07IC8vIGN0cmxwdFxuXG4gICAgICB2YXIgcDIgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgNF0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgNV1cbiAgICAgIH07XG4gICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgcDI6IHAyLFxuICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkaXN0KHAwLCBwMSk7XG4gICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1tjcC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgdDA6IHQwLFxuICAgICAgICB0MTogdDEsXG4gICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfTtcbiAgICAgIGNwLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0gLy8gdXBkYXRlIGVhY2ggY3RybHB0IHdpdGggc2VnbWVudCBpbmZvXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdHJscHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tfaV07XG4gICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tfaSAtIDFdO1xuXG4gICAgICBpZiAocHJldkNwKSB7XG4gICAgICAgIGNwLnN0YXJ0RGlzdCA9IHByZXZDcC5zdGFydERpc3QgKyBwcmV2Q3AubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KGNwLCBjcC5wMCwgYnB0c1tfaSAqIG5Qcm9qc10sIDAsIHIuYmV6aWVyUHJvalBjdHNbMF0pOyAvLyBmaXJzdFxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKykge1xuICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgal0sIGJwdHNbX2kgKiBuUHJvanMgKyBqICsgMV0sIHIuYmV6aWVyUHJvalBjdHNbal0sIHIuYmV6aWVyUHJvalBjdHNbaiArIDFdKTtcbiAgICAgIH1cblxuICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKHByZWZpeCkge1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuXG4gICAgaWYgKCFjb250ZW50W3ByZWZpeF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY3BzID0gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICB2YXIgc3RhcnREaXN0ID0gMDtcbiAgICAgICAgICB2YXIgdG90YWxEaXN0ID0gMDsgLy8gZmluZCB0aGUgc2VnbWVudCB3ZSdyZSBvblxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY3Auc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9zZWcgPSBfY3Auc2VnbWVudHNbaXNTcmMgPyBqIDogX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDEgLSBqXTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RTZWcgPSBpID09PSBjcHMubGVuZ3RoIC0gMSAmJiBqID09PSBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgc3RhcnREaXN0ID0gdG90YWxEaXN0O1xuICAgICAgICAgICAgICB0b3RhbERpc3QgKz0gX3NlZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKHRvdGFsRGlzdCA+PSBvZmZzZXQgfHwgbGFzdFNlZykge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgICAgY3A6IF9jcCxcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IF9zZWdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3AgPSBzZWxlY3RlZC5jcDtcbiAgICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgICB2YXIgdFNlZ21lbnQgPSAob2Zmc2V0IC0gc3RhcnREaXN0KSAvIHNlZy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHNlZ0R0ID0gc2VnLnQxIC0gc2VnLnQwO1xuICAgICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcbiAgICAgICAgICB0ID0gYm91bmQoMCwgdCwgMSk7XG4gICAgICAgICAgcCA9IHFiZXppZXJQdEF0KGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgICBkaSxcbiAgICAgICAgICAgICAgZDA7XG4gICAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgICB2YXIgbCA9IHJzLmFsbHB0cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgKyAzIDwgbDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChpc1NyYykge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMiArIDJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAzXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSAyIC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDEgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gNCAtIF9pMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAzIC0gX2kyXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaSA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgIGQgKz0gZGk7XG5cbiAgICAgICAgICAgIGlmIChkID49IG9mZnNldCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcEQgPSBvZmZzZXQgLSBkMDtcblxuICAgICAgICAgIHZhciBfdCA9IHBEIC8gZGk7XG5cbiAgICAgICAgICBfdCA9IGJvdW5kKDAsIF90LCAxKTtcbiAgICAgICAgICBwID0gbGluZUF0KHAwLCBwMSwgX3QpO1xuICAgICAgICAgIGFuZ2xlID0gbGluZUFuZ2xlKHAwLCBwMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRScygnbGFiZWxYJywgcHJlZml4LCBwLngpO1xuICAgIHNldFJzKCdsYWJlbFknLCBwcmVmaXgsIHAueSk7XG4gICAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgcHJlZml4LCBhbmdsZSk7XG4gIH07XG5cbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbignc291cmNlJyk7XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3RhcmdldCcpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKGVkZ2UpO1xufTtcblxuQlJwJDYuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUpO1xuXG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAnc291cmNlJyk7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG5CUnAkNi5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpO1xuICB2YXIgbGluZUhlaWdodCA9IGVsZS5wc3R5bGUoJ2xpbmUtaGVpZ2h0JykucGZWYWx1ZTtcbiAgdmFyIHRleHRXcmFwID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykuc3RyVmFsdWU7XG4gIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG4gIHZhciBudW1MaW5lcyA9IHRleHRXcmFwICE9PSAnd3JhcCcgPyAxIDogTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxKTtcbiAgdmFyIG5vcm1QZXJMaW5lSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCAvIG51bUxpbmVzO1xuICB2YXIgbGFiZWxMaW5lSGVpZ2h0ID0gbm9ybVBlckxpbmVIZWlnaHQgKiBsaW5lSGVpZ2h0O1xuICB2YXIgd2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0ICsgKG51bUxpbmVzIC0gMSkgKiAobGluZUhlaWdodCAtIDEpICogbm9ybVBlckxpbmVIZWlnaHQ7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgsIGxhYmVsTGluZUhlaWdodCk7XG59O1xuXG5CUnAkNi5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGZkID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwZmQgKyAnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRUcmFuc2Zvcm0gPSBlbGUucHN0eWxlKCd0ZXh0LXRyYW5zZm9ybScpLnZhbHVlO1xuXG4gIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uIHJzY3JhdGNoKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCk7XG4gICAgfVxuICB9OyAvLyBmb3IgZW1wdHkgdGV4dCwgc2tpcCBhbGwgcHJvY2Vzc2luZ1xuXG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSA7IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlO1xuXG4gIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpOyAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG5cbiAgICBpZiAobGFiZWxLZXkgIT0gbnVsbCAmJiByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JykgPT09IGxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnKTtcbiAgICB9XG5cbiAgICB2YXIgendzcCA9IFwiXFx1MjAwQlwiO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBvdmVyZmxvdyA9IGVsZS5wc3R5bGUoJ3RleHQtb3ZlcmZsb3ctd3JhcCcpLnZhbHVlO1xuICAgIHZhciBvdmVyZmxvd0FueSA9IG92ZXJmbG93ID09PSAnYW55d2hlcmUnO1xuICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcbiAgICB2YXIgd29yZHNSZWdleCA9IC9bXFxzXFx1MjAwYl0rLztcbiAgICB2YXIgd29yZFNlcGFyYXRvciA9IG92ZXJmbG93QW55ID8gJycgOiAnICc7XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICBpZiAob3ZlcmZsb3dBbnkpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZExpbmUgPSBsaW5lLnNwbGl0KCcnKS5qb2luKHp3c3ApO1xuICAgICAgICBsaW5lID0gcHJvY2Vzc2VkTGluZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVXID4gbWF4Vykge1xuICAgICAgICAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQod29yZHNSZWdleCk7XG4gICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbd107XG4gICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArIHdvcmRTZXBhcmF0b3IgKyB3b3JkO1xuICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGVzdExpbmUpO1xuICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgIC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoc3VibGluZSkge1xuICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcblxuXG4gICAgICAgIGlmICghc3VibGluZS5tYXRjaCgvXltcXHNcXHUyMDBiXSskLykpIHtcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG5cbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCB3cmFwcGVkTGluZXMpO1xuICAgIHRleHQgPSByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcsIHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScsIGxhYmVsS2V5KTtcbiAgfSBlbHNlIGlmICh3cmFwU3R5bGUgPT09ICdlbGxpcHNpcycpIHtcbiAgICB2YXIgX21heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGVsbGlwc2l6ZWQgPSAnJztcbiAgICB2YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbiAgICB2YXIgaW5jTGFzdENoID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3aWR0aFdpdGhOZXh0Q2ggPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGVsbGlwc2l6ZWQgKyB0ZXh0W2ldICsgZWxsaXBzaXMpLndpZHRoO1xuXG4gICAgICBpZiAod2lkdGhXaXRoTmV4dENoID4gX21heFcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcblxuICAgICAgaWYgKGkgPT09IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgICBpbmNMYXN0Q2ggPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5jTGFzdENoKSB7XG4gICAgICBlbGxpcHNpemVkICs9IGVsbGlwc2lzO1xuICAgIH1cblxuICAgIHJldHVybiBlbGxpcHNpemVkO1xuICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG5CUnAkNi5nZXRMYWJlbEp1c3RpZmljYXRpb24gPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBqdXN0aWZpY2F0aW9uID0gZWxlLnBzdHlsZSgndGV4dC1qdXN0aWZpY2F0aW9uJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcblxuICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBqdXN0aWZpY2F0aW9uO1xuICB9XG59O1xuXG5CUnAkNi5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNhY2hlS2V5ID0gaGFzaFN0cmluZyh0ZXh0LCBlbGUuX3ByaXZhdGUubGFiZWxEaW1zS2V5KTtcbiAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSBbXSk7XG4gIHZhciBleGlzdGluZ1ZhbCA9IGNhY2hlW2NhY2hlS2V5XTtcblxuICBpZiAoZXhpc3RpbmdWYWwgIT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ1ZhbDtcbiAgfVxuXG4gIHZhciBzaXplTXVsdCA9IDE7IC8vIGluY3JlYXNlIHRoZSBzY2FsZSB0byBpbmNyZWFzZSBhY2N1cmFjeSB3LnIudC4gem9vbWVkIHRleHRcblxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVNdWx0ICogZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gIGlmICghZGl2KSB7XG4gICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cblxuICB2YXIgZHMgPSBkaXYuc3R5bGU7IC8vIGZyb20gZWxlIHN0eWxlXG5cbiAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICBkcy5mb250U2l6ZSA9IHNpemU7XG4gIGRzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7IC8vIGZvcmNlZCBzdHlsZVxuXG4gIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgZHMudG9wID0gJy05OTk5cHgnO1xuICBkcy56SW5kZXggPSAnLTEnO1xuICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIGRzLnBhZGRpbmcgPSAnMCc7XG4gIGRzLmxpbmVIZWlnaHQgPSAnMSc7XG5cbiAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgfSBlbHNlIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gIH0gLy8gcHV0IGxhYmVsIGNvbnRlbnQgaW4gZGl2XG5cblxuICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldID0ge1xuICAgIHdpZHRoOiBNYXRoLmNlaWwoZGl2LmNsaWVudFdpZHRoIC8gc2l6ZU11bHQpLFxuICAgIGhlaWdodDogTWF0aC5jZWlsKGRpdi5jbGllbnRIZWlnaHQgLyBzaXplTXVsdClcbiAgfTtcbn07XG5cbkJScCQ2LmNhbGN1bGF0ZUxhYmVsQW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIHByZWZpeERhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciByb3RTdHIgPSByb3Quc3RyVmFsdWU7XG5cbiAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIHJzLmxhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYgKHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJvdC5wZlZhbHVlO1xuICB9XG59O1xuXG5CUnAkNi5jYWxjdWxhdGVMYWJlbEFuZ2xlcyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICBycy5sYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSk7XG5cbiAgaWYgKGlzRWRnZSkge1xuICAgIHJzLnNvdXJjZUxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAnc291cmNlJyk7XG4gICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICd0YXJnZXQnKTtcbiAgfVxufTtcblxudmFyIEJScCQ3ID0ge307XG52YXIgVE9PX1NNQUxMX0NVVF9SRUNUID0gMjg7XG52YXIgd2FybmVkQ3V0UmVjdCA9IGZhbHNlO1xuXG5CUnAkNy5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuXG4gIGlmIChzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgJiYgKG5vZGUud2lkdGgoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCB8fCBub2RlLmhlaWdodCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUKSkge1xuICAgIGlmICghd2FybmVkQ3V0UmVjdCkge1xuICAgICAgd2FybignVGhlIGBjdXRyZWN0YW5nbGVgIG5vZGUgc2hhcGUgY2FuIG5vdCBiZSB1c2VkIGF0IHNtYWxsIHNpemVzIHNvIGByZWN0YW5nbGVgIGlzIHVzZWQgaW5zdGVhZCcpO1xuICAgICAgd2FybmVkQ3V0UmVjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICB9XG5cbiAgaWYgKG5vZGUuaXNQYXJlbnQoKSkge1xuICAgIGlmIChzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnYmFycmVsJykge1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICB2YXIgcG9pbnRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykudmFsdWU7XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbihwb2ludHMpLm5hbWU7XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG52YXIgQlJwJDggPSB7fTtcblxuQlJwJDgucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShlbGVzKSB7XG4gICAgdmFyIGRpcnR5U3R5bGVDYWNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgZWxlc1RvVXBkYXRlLm1lcmdlKGVsZXMpO1xuXG4gICAgaWYgKGRpcnR5U3R5bGVDYWNoZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHIuYmluZGVyKGN5KS5vbignYm91bmRzLiogZGlydHkuKicsIGZ1bmN0aW9uIG9uRGlydHlCb3VuZHMoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICBlbnF1ZXVlKGVsZSk7XG4gIH0pLm9uKCdzdHlsZS4qIGJhY2tncm91bmQuKicsIGZ1bmN0aW9uIG9uRGlydHlTdHlsZShlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlLCBmYWxzZSk7XG4gIH0pO1xuXG4gIHZhciB1cGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZUNhbGNzKHdpbGxEcmF3KSB7XG4gICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1RvVXBkYXRlW2ldO1xuICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpICYmICFyc3R5bGUuY2xlYW5Db25uZWN0ZWQpIHtcbiAgICAgICAgICBlbnF1ZXVlKGVsZS5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbaV07XG4gICAgICAgICAgZm4od2lsbERyYXcsIGVsZXNUb1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWxlc1RvVXBkYXRlKTtcbiAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVFbGVDYWxjcyh0cnVlKTtcbiAgfTtcblxuICByLmJlZm9yZVJlbmRlcih1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzKTtcbn07XG5cbkJScCQ4Lm9uVXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyB8fCBbXTtcbiAgZm5zLnB1c2goZm4pO1xufTtcblxuQlJwJDgucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZXMsIHVzZUNhY2hlKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIHVzZSBjYWNoZSBieSBkZWZhdWx0IGZvciBwZXJmXG5cblxuICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlOyAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcblxuICAgIGlmICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4gfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuXG5cbiAgICBpZiAoZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlZGdlc1xuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gIH0gLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihlbGUpO1xuICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIHJzdHlsZS5ub2RlVyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICByc3R5bGUubm9kZUggPSBlbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlO1xuICB9XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyhlZGdlcyk7IC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7IC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG5cbiAgICByc3R5bGUuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHJzdHlsZS5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgcnN0eWxlLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgcnN0eWxlLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgcnN0eWxlLm1pZFggPSBycy5taWRYO1xuICAgIHJzdHlsZS5taWRZID0gcnMubWlkWTtcbiAgICByc3R5bGUubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgIHJzdHlsZS50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxudmFyIEJScCQ5ID0ge307XG5cbkJScCQ5LnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG5cbiAgaWYgKCFlbGVzKSB7XG4gICAgLy8ganVzdCBsZXQgdGhpcyBiZSByZWNhbGN1bGF0ZWQgb24gdGhlIG5leHQgeiBzb3J0IHRpY2tcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVzLmRyYWcgPSBbXTtcbiAgZWxlcy5ub25kcmFnID0gW107XG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuXG5CUnAkOS5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBudWxsO1xufTtcblxuQlJwJDkuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoZm9yY2VSZWNhbGMpIHtcbiAgaWYgKGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcbiAgICBlbGVzLnNvcnQoekluZGV4U29ydCk7XG4gICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICB0aGlzLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn07XG5cbnZhciBCUnAkYSA9IHt9O1xuW0JScCQxLCBCUnAkMiwgQlJwJDMsIEJScCQ0LCBCUnAkNSwgQlJwJDYsIEJScCQ3LCBCUnAkOCwgQlJwJDldLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkYSwgcHJvcHMpO1xufSk7XG5cbnZhciBCUnAkYiA9IHt9O1xuXG5CUnAkYi5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGlmICghY2FjaGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgIGNhY2hlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9KTsgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcblxuICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcblxuICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luOyAvLyBwcmV2ZW50IHRhaW50ZWQgY2FudmFzXG4gICAgfVxuXG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxudmFyIEJScCRjID0ge307XG4vKiBnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgUmVzaXplT2JzZXJ2ZXIsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuQlJwJGMucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7IC8vIGNvcHlcblxuICB2YXIgYiA9IHRoaXMuYmluZGVyKHRhcmdldCk7XG4gIHJldHVybiBiLm9uLmFwcGx5KGIsIGFyZ3MpO1xufTtcblxuQlJwJGMuYmluZGVyID0gZnVuY3Rpb24gKHRndCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB0Z3RJc0RvbSA9IHRndCA9PT0gd2luZG93IHx8IHRndCA9PT0gZG9jdW1lbnQgfHwgdGd0ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvbUVsZW1lbnQodGd0KTtcblxuICBpZiAoci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPT0gbnVsbCkge1xuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gbm90IHN1cHBvcnRlZFxuICAgIH1cblxuICAgIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gc3VwcG9ydHNQYXNzaXZlO1xuICB9XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGd0SXNEb20gJiYgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMpIHtcbiAgICAgIC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGd0LFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICAgICh0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24pLmFwcGx5KHRndCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvbjogb24sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIGJpbmQ6IG9uXG4gIH07XG59O1xuXG5CUnAkYy5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLmlzTm9kZSgpICYmICFub2RlLmxvY2tlZCgpICYmIG5vZGUuZ3JhYmJhYmxlKCk7XG59O1xuXG5CUnAkYy5ub2RlSXNHcmFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5ub2RlSXNEcmFnZ2FibGUobm9kZSkgJiYgbm9kZS5pbnRlcmFjdGl2ZSgpO1xufTtcblxuQlJwJGMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBpc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH07XG5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiB0cmlnZ2VyRXZlbnRzKHRhcmdldCwgbmFtZXMsIGUsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSByLmN5O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB0YXJnZXQuZW1pdCh7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24gaXNNdWx0U2VsS2V5RG93bihlKSB7XG4gICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgfTtcblxuICB2YXIgYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2ggPSBmdW5jdGlvbiBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCBkb3ducykge1xuICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcblxuICAgIGlmIChyLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBkb3duICYmIGRvd24ucGFubmFibGUoKSkge1xuICAgICAgLy8gYSBncmFiYmFibGUgY29tcG91bmQgbm9kZSBiZWxvdyB0aGUgZWxlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICBpZiAoZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG5cbiAgdmFyIHNldEdyYWJiZWQgPSBmdW5jdGlvbiBzZXRHcmFiYmVkKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgc2V0RnJlZWQgPSBmdW5jdGlvbiBzZXRGcmVlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBzZXRJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHNldEluRHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uIHNldE91dERyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uIHNldEdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUdyYWJUYXJnZXQgPSBmdW5jdGlvbiByZW1vdmVHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgYWRkVG9EcmFnTGlzdCA9IGZ1bmN0aW9uIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKSB7XG4gICAgdmFyIGxpc3QgPSBvcHRzLmFkZFRvTGlzdDtcbiAgICB2YXIgbGlzdEhhc0VsZSA9IGxpc3QuaGFzKGVsZSk7XG5cbiAgICBpZiAoIWxpc3RIYXNFbGUpIHtcbiAgICAgIGxpc3QubWVyZ2UoZWxlKTtcbiAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICB9XG4gIH07IC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG5cblxuICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbiBhZGREZXNjZW5kYW50c1RvRHJhZyhub2RlLCBvcHRzKSB7XG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBpbm5lck5vZGVzLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBvcHRzLmFkZFRvTGlzdC51bm1lcmdlKGlubmVyTm9kZXMpO1xuICAgIH1cbiAgfTsgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG5cblxuICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiBhZGROb2Rlc1RvRHJhZyhub2Rlcywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZXMsIG9wdHMpOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcbiAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZXMsIHtcbiAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuXG4gIHZhciBhZGROb2RlVG9EcmFnID0gYWRkTm9kZXNUb0RyYWc7XG5cbiAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiBmcmVlRHJhZ2dlZEVsZW1lbnRzKGdyYWJiZWRFbGVzKSB7XG4gICAgaWYgKCFncmFiYmVkRWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcblxuXG4gICAgci5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgc2V0RnJlZWQoZWxlKTtcbiAgICAgIHNldE91dERyYWdMYXllcihlbGUpO1xuICAgICAgcmVtb3ZlR3JhYlRhcmdldChlbGUpO1xuICAgIH0pO1xuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTsgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuXG5cbiAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZSwgb3B0cykge1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG5cbiAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuXG5cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5hbmNlc3RvcnMoKS5vcnBoYW5zKCk7IC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcblxuICAgIGlmIChwYXJlbnQuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpLm1lcmdlKHBhcmVudCkudW5tZXJnZShub2RlKS51bm1lcmdlKG5vZGUuZGVzY2VuZGFudHMoKSk7XG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmx1ckFjdGl2ZURvbUVsZW1lbnQgPSBmdW5jdGlvbiBibHVyQWN0aXZlRG9tRWxlbWVudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAhPSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhdmVNdXRhdGlvbnNBcGkgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBoYXZlUmVzaXplT2JzZXJ2ZXJBcGkgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnOyAvLyB3YXRjaCBmb3Igd2hlbiB0aGUgY3kgY29udGFpbmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG5cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dG5zKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICBpZiAock5vZGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgICAgaWYgKHJOb2RlID09PSByLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoci5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLnBhcmVudE5vZGUsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBvblJlc2l6ZSA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICAgIHIuY3kucmVzaXplKCk7XG4gIH0sIDEwMCk7XG5cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gIH0gLy8gYXV0byByZXNpemVcblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChoYXZlUmVzaXplT2JzZXJ2ZXJBcGkpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyKTtcbiAgfVxuXG4gIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgZm4oZG9tRWxlKTtcbiAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW52YWxpZGF0ZUNvb3JkcyA9IGZ1bmN0aW9uIGludmFsaWRhdGVDb29yZHMoKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgfTtcblxuICBmb3JFYWNoVXAoci5jb250YWluZXIsIGZ1bmN0aW9uIChkb21FbGUpIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICd0cmFuc2l0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnYW5pbWF0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gIH0pOyAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcblxuICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGV2ZW50SW5Db250YWluZXIoZSkge1xuICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB4ID0gY29udGFpbmVyUGFnZUNvb3Jkc1swXTtcbiAgICB2YXIgeSA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMV07XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyUGFnZUNvb3Jkc1syXTtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyUGFnZUNvb3Jkc1szXTtcbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIFByaW1hcnkga2V5XG5cblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgZWxlLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH07IC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuXG5cbiAgICBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIG5lYXIuZW1pdChjeHRFdnQpO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTsgLy8gUHJpbWFyeSBidXR0b25cbiAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfSAvLyBFbGVtZW50IGRyYWdnaW5nXG5cblxuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgICAgaWYgKCFuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCh0cmlnZ2VyR3JhYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25zID0gbmVhcnM7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vkb3duJywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiAobmVhci5wYW5uYWJsZSgpKSB7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICB9XG5cbiAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG5cblxuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSBudWxsO1xuXG4gICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW1vdmUnLCAndm1vdXNlbW92ZScsICd0YXBkcmFnJ10sIGUsIHtcbiAgICAgIHg6IHBvc1swXSxcbiAgICAgIHk6IHBvc1sxXVxuICAgIH0pO1xuXG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTsgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cblxuXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcblxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAocG9zWzBdIC0gbWRQb3NbMF0pICogem9vbSxcbiAgICAgICAgICAgIHk6IChwb3NbMV0gLSBtZFBvc1sxXSkgKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY3kucGFuQnkoZGVsdGFQKTtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICB9IC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG5cblxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgfSBlbHNlIGlmIChzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24ucGFubmFibGUoKSkpIHtcbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIChtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkpKSB7XG4gICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgci5ob3ZlckRhdGEuZG93bnMpO1xuXG4gICAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChtZG93blBvcyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuICAgICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkpIHtcbiAgICAgICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuICAgICAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pKSB7XG4gICAgICAgICAgICAvLyBkcmFnIG5vZGVcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIHZhciB0b1RyaWdnZXIgPSBjeS5jb2xsZWN0aW9uKCk7IC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG5cbiAgICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVtZW50cywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG51bWJlcihkaXNwWzBdKSAmJiBudW1iZXIoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkRWxlID0gZHJhZ2dlZEVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgIGlmIChyLm5vZGVJc0RyYWdnYWJsZShkRWxlKSAmJiBkRWxlLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5tZXJnZShkRWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgdG9UcmlnZ2VyLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcblxuXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uIG1vdXNldXBIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKCFjYXB0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcblxuICAgIGlmIChyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmIChkb3duKSB7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3h0VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGRvd24uZW1pdChjeHRUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSkge1xuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAmJiAhci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbJ2NsaWNrJywgJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcblxuXG4gICAgICBpZiAoZG93biA9PSBudWxsICYmIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG4gICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB9IC8vIFNpbmdsZSBzZWxlY3Rpb25cblxuXG4gICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykgOyBlbHNlIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKG5lYXIpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICBpZiAoYm94Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJykge1xuICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UoYm94KS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgfSAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuXG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gLy8gQ2FuY2VsIGRyYWcgcGFuXG5cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcblxuICAgICAgICBpZiAoZG93bldhc0dyYWJiZWQpIHtcbiAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuXG4gICAgc2VsZWN0WzRdID0gMDtcbiAgICByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcbiAgfSwgZmFsc2UpO1xuXG4gIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiB3aGVlbEhhbmRsZXIoZSkge1xuICAgIGlmIChyLnNjcm9sbGluZ1BhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LCBwb3NbMV0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS55XTtcblxuICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoci5kYXRhLndoZWVsVGltZW91dCk7XG4gICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTApO1xuICAgICAgdmFyIGRpZmY7XG5cbiAgICAgIGlmIChlLmRlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTA7XG4gICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhWSAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuXG4gICAgICBpZiAobmVlZHNXaGVlbEZpeCkge1xuICAgICAgICAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgfVxuXG4gICAgICBjeS56b29tKHtcbiAgICAgICAgbGV2ZWw6IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKSxcbiAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHJwb3NbMF0sXG4gICAgICAgICAgeTogcnBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gIC8vIC0tXG5cblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcbiAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG5cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuXG4gIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG5cbiAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG5cbiAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbiBkaXN0YW5jZVNxKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgfTtcblxuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9IC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcbiAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID0gMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0ICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBjZW50ZXIxID0gWyhmMXgxICsgZjJ4MSkgLyAyLCAoZjF5MSArIGYyeTEpIC8gMl07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLCAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21dOyAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcblxuICAgICAgaWYgKGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICB9IGVsc2UgaWYgKG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICAgIC8vIHNhZmFyaSBvbiBpb3MgcGFucyB0aGUgcGFnZSBvdGhlcndpc2UgKG5vcm1hbGx5IHlvdSBzaG91bGQgYmUgYWJsZSB0byBwcmV2ZW50ZGVmYXVsdCBvbiB0b3VjaG1vdmUuLi4pXG4gICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuXG4gICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVzKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgbi5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgeDogbm93WzBdLFxuICAgICAgICB5OiBub3dbMV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IC8vIFRhcCwgdGFwaG9sZFxuICAgICAgLy8gLS0tLS1cblxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgY2xlYXJUaW1lb3V0KHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoci50b3VjaERhdGEuc3RhcnQsIFsndGFwaG9sZCddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZXTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zKSB7XG4gICAgICB2YXIgZGlzcCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgfSAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcblxuXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7IC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuXG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDsgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuXG4gICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gY29udGV4dCBzd2lwZVxuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBib3ggc2VsZWN0aW9uXG5cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSB0cnVlO1xuICAgICAgc2VsZWN0WzRdID0gMTtcblxuICAgICAgaWYgKCFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzICsgMTtcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTsgLy8gcGluY2ggdG8gem9vbVxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gcGluY2gtdG8tem9vbVxuICAgICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgaWYgKGRyYWdnZWRFbGVzKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuICAgICAgICAgIGRlX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRlX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX3N0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7IC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcblxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpOyAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuXG4gICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICBpZiAodHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKSB7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTsgLy8gZGVsdGEgZmluZ2VyIDJcblxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxOyAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG5cbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyOyAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG5cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTsgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG5cbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTsgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuXG4gICAgICAgIGlmIChfc3RhcnQgJiYgX3N0YXJ0LmFjdGl2ZSgpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgX3N0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KCdmcmVlb24nKTtcblxuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIF9zdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG5cbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG4gICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgfSAvLyBSZS1wcm9qZWN0XG5cblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBzaW5nbGUgZmluZ2VyIGV2ZW50cyBsaWtlIHBhbm5pbmdcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgICAgdmFyIG5lYXI7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gLy8gZHJhZ2dpbmcgbm9kZXNcblxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZXMsIHtcbiAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyKGRpc3BbMF0pICYmIG51bWJlcihkaXNwWzFdKSkge1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlcihkcmFnRGVsdGFbMF0pICYmIG51bWJlcihkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXSkge1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0b3VjaG1vdmVcblxuXG4gICAgICAgIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0IHx8IG5lYXIsIFsndG91Y2htb3ZlJywgJ3RhcGRyYWcnLCAndm1vdXNlbW92ZSddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgbGFzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3V0JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH0gLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcblxuICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm93W2ldICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gJiYgaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcGFubmluZ1xuXG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQucGFubmFibGUoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyk7XG5cbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gUmUtcHJvamVjdFxuXG5cbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfSAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyAmJiByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gIT0gbnVsbCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaGNhbmNlbEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRvdWNoZW5kSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGVuZEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eFRhcGVuZDtcblxuICAgIGlmIChyLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGN0eFRhcGVuZCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgdmFyIGN0eFRhcCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG5cblxuICAgIGlmICghZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgY3kuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcblxuICAgICAgaWYgKGJveC5ub25lbXB0eSgpKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIDsgZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0V2FzR3JhYmJlZCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIHN0YXJ0LmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTsgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG5cbiAgICAgIGlmICghci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuXG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKHN0YXJ0KS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBzdGFydC51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgIH1cblxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCB0b3VjaHN0YXJ0XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhlIG9sZCBzdGFydCBnbG9iYWwgcG9zJ24gbWF5IG5vdCBiZSB0aGUgc2FtZSBmaW5nZXIgdGhhdCByZW1haW5zXG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gICAgICB9XG5cbiAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9IC8vci5yZWRyYXcoKTtcblxuICB9LCBmYWxzZSk7IC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG5cbiAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuXG4gICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uIG1ha2VUb3VjaChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgIHJhZGl1c1g6IGUud2lkdGggLyAyLFxuICAgICAgICByYWRpdXNZOiBlLmhlaWdodCAvIDIsXG4gICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbWFrZVBvaW50ZXIgPSBmdW5jdGlvbiBtYWtlUG9pbnRlcihlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogZSxcbiAgICAgICAgdG91Y2g6IG1ha2VUb3VjaChlKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiBhZGRQb2ludGVyKGUpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2gobWFrZVBvaW50ZXIoZSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzW2ldO1xuXG4gICAgICAgIGlmIChwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihlKSB7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSlbMF07XG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uIGFkZFRvdWNoZXNUb0V2ZW50KGUpIHtcbiAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlcklzTW91c2UgPSBmdW5jdGlvbiBwb2ludGVySXNNb3VzZShlKSB7XG4gICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBlLnBvaW50ZXJUeXBlID09PSA0O1xuICAgIH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGFkZFBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoZW5kSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdXBkYXRlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2htb3ZlSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIEJScCRkID0ge307XG5cbkJScCRkLmdlbmVyYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdwb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnZWxsaXBzZScsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIgKyBwYWRkaW5nLCBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHJldHVybiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgLy8gUHJlLWNvbXB1dGUgY29udHJvbCBwb2ludHNcbiAgLy8gU2luY2UgdGhlc2UgcG9pbnRzIGRlcGVuZCBvbiB0aGUgcmFkaXVzIGxlbmd0aCAod2hpY2ggaW4gdHVybnMgZGVwZW5kIG9uIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUpIHdlIHdpbGwgb25seSBwcmUtY29tcHV0ZVxuICAvLyB0aGUgdW5pdCB2ZWN0b3JzLlxuICAvLyBGb3Igc2ltcGxpY2l0eSB0aGUgbGF5b3V0IHdpbGwgYmU6XG4gIC8vIFsgcDAsIFVuaXRWZWN0b3JQMFAxLCBwMSwgVW5pVmVjdG9yUDFQMiwgLi4uLCBwbiwgVW5pdFZlY3RvclBuUDAgXVxuICB2YXIgYWxsUG9pbnRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB2YXIgc291cmNlSW5kZXggPSBpICogMjtcbiAgICB2YXIgZGVzdEluZGV4ID0gdm9pZCAwO1xuXG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIGRlc3RJbmRleCA9IChpICsgMSkgKiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIGFsbFBvaW50c1tpICogNF0gPSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgIGFsbFBvaW50c1tpICogNCArIDFdID0gcG9pbnRzW3NvdXJjZUluZGV4ICsgMV07XG4gICAgdmFyIHhEZXN0ID0gcG9pbnRzW2Rlc3RJbmRleF0gLSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgIHZhciB5RGVzdCA9IHBvaW50c1tkZXN0SW5kZXggKyAxXSAtIHBvaW50c1tzb3VyY2VJbmRleCArIDFdO1xuICAgIHZhciBub3JtID0gTWF0aC5zcXJ0KHhEZXN0ICogeERlc3QgKyB5RGVzdCAqIHlEZXN0KTtcbiAgICBhbGxQb2ludHNbaSAqIDQgKyAyXSA9IHhEZXN0IC8gbm9ybTtcbiAgICBhbGxQb2ludHNbaSAqIDQgKyAzXSA9IHlEZXN0IC8gbm9ybTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IGFsbFBvaW50cyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncm91bmQtcG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydyb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGRpYW0gPSBjb3JuZXJSYWRpdXMgKiAyOyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUN1dFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snY3V0LXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnY3V0LXJlY3RhbmdsZScsXG4gICAgY29ybmVyTGVuZ3RoOiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVDdXRUcmlhbmdsZVB0czogZnVuY3Rpb24gZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgY2wgPSB0aGlzLmNvcm5lckxlbmd0aDtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7IC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSB0cmlhbmdsZSBwdCBvbiBbNCwgNV1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgY2wsIHhCZWdpbiArIGNsLCB5QmVnaW4sIHhCZWdpbiArIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gY2wsIHhFbmQgLSBjbCwgeUVuZCwgeEVuZCAtIGNsLCB5RW5kIC0gY2xdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgY2wsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGNsLCB4QmVnaW4gKyBjbCwgeUVuZCAtIGNsXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICB2YXIgY1B0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtjUHRzLnRvcExlZnQuc3BsaWNlKDAsIDQpLCBjUHRzLnRvcFJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21SaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tTGVmdC5zcGxpY2UoMCwgNCldKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXRUcmlhbmdsZVB0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wTGVmdCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcFJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21MZWZ0KTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUJhcnJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYmFycmVsJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2JhcnJlbCcsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAvLyB1c2UgdHdvIGZpeGVkIHQgdmFsdWVzIGZvciB0aGUgYmV6aWVyIGN1cnZlIGFwcHJveGltYXRpb25cbiAgICAgIHZhciB0MCA9IDAuMTU7XG4gICAgICB2YXIgdDEgPSAwLjU7XG4gICAgICB2YXIgdDIgPSAwLjg1O1xuICAgICAgdmFyIGJQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuXG4gICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgIHZhciBtMCA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQwKTtcbiAgICAgICAgdmFyIG0xID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDEpO1xuICAgICAgICB2YXIgbTIgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0Mik7XG4gICAgICAgIHJldHVybiBbcHRzWzBdLCBwdHNbMV0sIG0wLngsIG0wLnksIG0xLngsIG0xLnksIG0yLngsIG0yLnksIHB0c1s0XSwgcHRzWzVdXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQoYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcExlZnQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tTGVmdCkpO1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgICB2YXIgY3RybFB0WE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdpZHRoOyAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgY29udHJvbCBwdCBvbiBbNCwgNV1cblxuICAgICAgdmFyIHB0cyA9IHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgaE9mZnNldCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW5dLFxuICAgICAgICB0b3BSaWdodDogW3hFbmQgLSB3T2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGhPZmZzZXRdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBoT2Zmc2V0LCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCAtIHdPZmZzZXQsIHlFbmRdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgd09mZnNldCwgeUVuZCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gaE9mZnNldF1cbiAgICAgIH07XG4gICAgICBwdHMudG9wTGVmdC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMudG9wUmlnaHQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbUxlZnQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbVJpZ2h0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwdHM7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0OyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogaE9mZnNldCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB3T2Zmc2V0LCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFycmVsQ3VydmVQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdOyAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuXG4gICAgICAgIHZhciB5MiA9IGN1cnZlUHRzWzFdO1xuICAgICAgICB2YXIgeE1pbiA9IE1hdGgubWluKHgwLCB4Mik7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoeDAsIHgyKTtcbiAgICAgICAgdmFyIHlNaW4gPSBNYXRoLm1pbih5MCwgeTIpO1xuICAgICAgICB2YXIgeU1heCA9IE1hdGgubWF4KHkwLCB5Mik7XG5cbiAgICAgICAgaWYgKHhNaW4gPD0geCAmJiB4IDw9IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPD0geU1heCkge1xuICAgICAgICAgIHZhciBjb2VmZiA9IGJlemllclB0c1RvUXVhZENvZWZmKHgwLCB4MSwgeDIpO1xuICAgICAgICAgIHZhciByb290cyA9IHNvbHZlUXVhZHJhdGljKGNvZWZmWzBdLCBjb2VmZlsxXSwgY29lZmZbMl0sIHgpO1xuICAgICAgICAgIHZhciB2YWxpZFJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgdmFyIGN1cnZlUmVnaW9ucyA9IE9iamVjdC5rZXlzKGJhcnJlbEN1cnZlUHRzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZVJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGN1cnZlUmVnaW9uc1tpXTtcbiAgICAgICAgdmFyIGNvcm5lclB0cyA9IGJhcnJlbEN1cnZlUHRzW2Nvcm5lcl07XG4gICAgICAgIHZhciB0ID0gZ2V0Q3VydmVUKHgsIHksIGNvcm5lclB0cyk7XG5cbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkwID0gY29ybmVyUHRzWzVdO1xuICAgICAgICB2YXIgeTEgPSBjb3JuZXJQdHNbM107XG4gICAgICAgIHZhciB5MiA9IGNvcm5lclB0c1sxXTtcbiAgICAgICAgdmFyIGJlelkgPSBxYmV6aWVyQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc1RvcCAmJiBiZXpZIDw9IHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNCb3R0b20gJiYgeSA8PSBiZXpZKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snYm90dG9tcm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0b3BJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRvcEludGVyc2VjdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGRpYW0gPSAyICogY29ybmVyUmFkaXVzOyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gY2hlY2sgbm9uLXJvdW5kZWQgdG9wIHNpZGVcblxuXG4gICAgICB2YXIgb3V0ZXJXaWR0aCA9IHdpZHRoIC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0IC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIHBvaW50cyA9IFtjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0LCBjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHRdO1xuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgdGhpcy5nZW5lcmF0ZUVsbGlwc2UoKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmVjdGFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApKTtcbiAgbm9kZVNoYXBlc1snc3F1YXJlJ10gPSBub2RlU2hhcGVzWydyZWN0YW5nbGUnXTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG4gIHRoaXMuZ2VuZXJhdGVDdXRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUJhcnJlbCgpO1xuICB0aGlzLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUoKTtcbiAge1xuICAgIHZhciBkaWFtb25kUG9pbnRzID0gWzAsIDEsIDEsIDAsIDAsIC0xLCAtMSwgMF07XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2RpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1kaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gIH1cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3BlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtcGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdvY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpOyAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuXG4gICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwIC8gNDsgaSsrKSB7XG4gICAgICBzdGFyNVBvaW50c1tpICogNF0gPSBvdXRlclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDFdID0gb3V0ZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cbiAgc3RhcjVQb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUoc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3ZlZScsIFstMSwgLTEsIDAsIC0wLjMzMywgMSwgLTEsIDAsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3Job21ib2lkJywgWy0xLCAtMSwgMC4zMzMsIC0xLCAxLCAxLCAtMC4zMzMsIDFdKTtcbiAgdGhpcy5ub2RlU2hhcGVzWydjb25jYXZlaGV4YWdvbiddID0gdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmUtaGV4YWdvbicsIFstMSwgLTAuOTUsIC0wLjc1LCAwLCAtMSwgMC45NSwgMSwgMC45NSwgMC43NSwgMCwgMSwgLTAuOTVdKTtcbiAge1xuICAgIHZhciB0YWdQb2ludHMgPSBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCB0YWdQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRhZycsIHRhZ1BvaW50cyk7XG4gIH1cblxuICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICB2YXIgc2hhcGU7XG5cbiAgICBpZiAoc2hhcGUgPSB0aGlzW25hbWVdKSB7XG4gICAgICAvLyBnb3QgY2FjaGVkIHNoYXBlXG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuXG5cbiAgICByZXR1cm4gcmVuZGVyZXIuZ2VuZXJhdGVQb2x5Z29uKG5hbWUsIHBvaW50cyk7XG4gIH07XG59O1xuXG52YXIgQlJwJGUgPSB7fTtcblxuQlJwJGUudGltZVRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcblxuQlJwJGUucmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDtcbiAgfVxuXG4gIGlmIChyLmxhc3RSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3RSZWRyYXdUaW1lID0gMDtcbiAgfVxuXG4gIGlmIChyLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0RHJhd1RpbWUgPSAwO1xuICB9XG5cbiAgci5yZXF1ZXN0ZWRGcmFtZSA9IHRydWU7XG4gIHIucmVuZGVyT3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5CUnAkZS5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoZm4sIHByaW9yaXR5KSB7XG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBhZGQgdGljayBjYWxsYmFja3Mgd2hlbiBkZXN0cm95ZWRcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByaW9yaXR5ID09IG51bGwpIHtcbiAgICBlcnJvcignUHJpb3JpdHkgaXMgbm90IG9wdGlvbmFsIGZvciBiZWZvcmVSZW5kZXInKTtcbiAgfVxuXG4gIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcbiAgY2JzLnB1c2goe1xuICAgIGZuOiBmbixcbiAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgfSk7IC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcblxuICBjYnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgfSk7XG59O1xuXG52YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHdpbGxEcmF3LCBzdGFydFRpbWUpIHtcbiAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICB9XG59O1xuXG5CUnAkZS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcblxuICBpZiAoci5yZW5kZXJMb29wU3RhcnRlZCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uIHJlbmRlckZuKHJlcXVlc3RUaW1lKSB7XG4gICAgaWYgKHIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LmJhdGNoaW5nKCkpIDsgZWxzZSBpZiAoci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUpIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB0cnVlLCByZXF1ZXN0VGltZSk7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgIHIucmVuZGVyKHIucmVuZGVyT3B0aW9ucyk7XG4gICAgICB2YXIgZW5kVGltZSA9IHIubGFzdERyYXdUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICBpZiAoci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjsgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuXG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZSAvIDIgKyBkdXJhdGlvbiAvIDI7XG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCBmYWxzZSwgcmVxdWVzdFRpbWUpO1xuICAgIH1cblxuICAgIHIuc2tpcEZyYW1lID0gZmFsc2U7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbiAgfTtcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xufTtcblxudmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMuaW5pdChvcHRpb25zKTtcbn07XG5cbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAkZiA9IEJSLnByb3RvdHlwZTtcbkJScCRmLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcblxuQlJwJGYuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5vcHRpb25zID0gb3B0aW9ucztcbiAgci5jeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBjdHIgPSByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7IC8vIHByZXBlbmQgYSBzdHlsZXNoZWV0IGluIHRoZSBoZWFkIHN1Y2ggdGhhdFxuXG4gIGlmICh3aW5kb3ckMSkge1xuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdyQxLmRvY3VtZW50O1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICB2YXIgc3R5bGVzaGVldElkID0gJ19fX19fX19fX19jeXRvc2NhcGVfc3R5bGVzaGVldCc7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICdfX19fX19fX19fY3l0b3NjYXBlX2NvbnRhaW5lcic7XG4gICAgdmFyIHN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3R5bGVzaGVldElkKSAhPSBudWxsO1xuXG4gICAgaWYgKGN0ci5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgY3RyLmNsYXNzTmFtZSA9IChjdHIuY2xhc3NOYW1lIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXNoZWV0LmlkID0gc3R5bGVzaGVldElkO1xuICAgICAgc3R5bGVzaGVldC5pbm5lckhUTUwgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY3RyKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB3YXJuKCdBIEN5dG9zY2FwZSBjb250YWluZXIgaGFzIHN0eWxlIHBvc2l0aW9uOnN0YXRpYyBhbmQgc28gY2FuIG5vdCB1c2UgVUkgZXh0ZW5zaW9ucyBwcm9wZXJseScpO1xuICAgIH1cbiAgfVxuXG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTsgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG5cbiAgci5ob3ZlckRhdGEgPSB7XG4gICAgZG93bjogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGRvd25UaW1lOiBudWxsLFxuICAgIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sXG4gICAgY2FwdHVyZTogZmFsc2VcbiAgfTtcbiAgci5kcmFnRGF0YSA9IHtcbiAgICBwb3NzaWJsZURyYWdFbGVtZW50czogW11cbiAgfTtcbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gIH07XG4gIHIucmVkcmF3cyA9IDA7XG4gIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcbiAgci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuXG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG51bWJlcihvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcblxuICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHtcbiAgICAvLyBoaWdoZXIgcHJpb3JpdHkgZXhlY3MgYmVmb3JlIGxvd2VyIG9uZVxuICAgIGFuaW1hdGlvbnM6IDQwMCxcbiAgICBlbGVDYWxjczogMzAwLFxuICAgIGVsZVR4ckRlcTogMjAwLFxuICAgIGx5clR4ckRlcTogMTUwLFxuICAgIGx5clR4clNraXA6IDEwMFxuICB9O1xuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG59O1xuXG5CUnAkZi5ub3RpZnkgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgci5sb2FkKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2FkZCcgfHwgZXZlbnROYW1lID09PSAncmVtb3ZlJyB8fCBldmVudE5hbWUgPT09ICdtb3ZlJyAmJiBjeS5oYXNDb21wb3VuZE5vZGVzKCkgfHwgZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAnem9yZGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAncmVzaXplJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgfVxuXG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScCRmLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzW2ldO1xuICAgIHZhciBiID0gYmluZGluZztcbiAgICB2YXIgdGd0ID0gYi50YXJnZXQ7XG4gICAgKHRndC5vZmYgfHwgdGd0LnJlbW92ZUV2ZW50TGlzdGVuZXIpLmFwcGx5KHRndCwgYi5hcmdzKTtcbiAgfVxuXG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5vblVwZGF0ZUVsZUNhbGNzRm5zID0gW107XG5cbiAgaWYgKHIucmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmIChyLnN0eWxlT2JzZXJ2ZXIpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2ggKGUpIHsvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgfVxuICB9XG59O1xuXG5CUnAkZi5pc0hlYWRsZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5bQlJwLCBCUnAkYSwgQlJwJGIsIEJScCRjLCBCUnAkZCwgQlJwJGVdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkZiwgcHJvcHMpO1xufSk7XG5cbnZhciBmdWxsRnBzVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1lIDYwIGZyYW1lcyBwZXIgc2Vjb25kXG5cbnZhciBkZWZzID0ge1xuICBzZXR1cERlcXVldWVpbmc6IGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZyhvcHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZ0ltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCk7XG5cbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSh3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHZhciBhdmdSZW5kZXJUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgdmFyIHJlbmRlclRpbWUgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgZGVxZCA9IFtdO1xuICAgICAgICB2YXIgZXh0ZW50ID0gci5jeS5leHRlbnQoKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTsgLy8gaWYgd2UgYXJlbid0IGluIGEgdGljayB0aGF0IGNhdXNlcyBhIGRyYXcsIHRoZW4gdGhlIHJlbmRlcmVkIHN0eWxlXG4gICAgICAgIC8vIHF1ZXVlIHdvbid0IGF1dG9tYXRpY2FsbHkgYmUgZmx1c2hlZCBiZWZvcmUgZGVxdWV1ZWluZyBzdGFydHNcblxuICAgICAgICBpZiAoIXdpbGxEcmF3KSB7XG4gICAgICAgICAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuXG4gICAgICAgICAgaWYgKHJlbmRlclRpbWUgPCBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgcmVuZGVyaW5nIGZhc3RlciB0aGFuIHRoZSBpZGVhbCBmcHMsIHRoZW4gZG8gZGVxdWV1ZWluZ1xuICAgICAgICAgICAgLy8gZHVyaW5nIGFsbCBvZiB0aGUgcmVtYWluaW5nIGZyYW1lIHRpbWVcbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG5cbiAgICAgICAgICAgIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxRmFzdENvc3QgKiB0aW1lQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWUgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50KTtcblxuICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuXG5cbiAgICAgICAgaWYgKGRlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdHMub25EZXFkKHNlbGYsIGRlcWQpO1xuXG4gICAgICAgICAgaWYgKCF3aWxsRHJhdyAmJiBvcHRzLnNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBwaXhlbFJhdGlvLCBleHRlbnQpKSB7XG4gICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCBub29wO1xuICAgICAgci5iZWZvcmVSZW5kZXIoZGVxdWV1ZSwgcHJpb3JpdHkoc2VsZikpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIFVzZXMga2V5cyBzbyBlbGVtZW50cyBtYXkgc2hhcmUgdGhlIHNhbWUgY2FjaGUuXG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChnZXRLZXkpIHtcbiAgICB2YXIgZG9lc0VsZUludmFsaWRhdGVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNpZnk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCk7XG5cbiAgICB0aGlzLmlkc0J5S2V5ID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5rZXlGb3JJZCA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMuY2FjaGVzQnlMdmwgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmx2bHMgPSBbXTtcbiAgICB0aGlzLmdldEtleSA9IGdldEtleTtcbiAgICB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gZG9lc0VsZUludmFsaWRhdGVLZXk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCwgW3tcbiAgICBrZXk6IFwiZ2V0SWRzRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkc0ZvcihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcihcIkNhbiBub3QgZ2V0IGlkIGxpc3QgZm9yIG51bGwga2V5XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRzQnlLZXkgPSB0aGlzLmlkc0J5S2V5O1xuICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzQnlLZXkuZ2V0KGtleSk7XG5cbiAgICAgIGlmICghaWRzKSB7XG4gICAgICAgIGlkcyA9IG5ldyBTZXQkMSgpO1xuICAgICAgICBpZHNCeUtleS5zZXQoa2V5LCBpZHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KS5hZGQoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KVtcImRlbGV0ZVwiXShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE51bWJlck9mSWRzRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlck9mSWRzRm9yS2V5KGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRzRm9yKGtleSkuc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHZhciBjdXJyS2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5hZGRJZEZvcktleShjdXJyS2V5LCBpZCk7XG4gICAgICB0aGlzLmtleUZvcklkLnNldChpZCwgY3VycktleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUtleU1hcHBpbmdGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWRbXCJkZWxldGVcIl0oaWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlIYXNDaGFuZ2VkRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleUhhc0NoYW5nZWRGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIG5ld0tleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICByZXR1cm4gcHJldktleSAhPT0gbmV3S2V5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ludmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnZhbGlkKGVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5SGFzQ2hhbmdlZEZvcihlbGUpIHx8IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVzQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGVzQXQobHZsKSB7XG4gICAgICB2YXIgY2FjaGVzQnlMdmwgPSB0aGlzLmNhY2hlc0J5THZsLFxuICAgICAgICAgIGx2bHMgPSB0aGlzLmx2bHM7XG4gICAgICB2YXIgY2FjaGVzID0gY2FjaGVzQnlMdmwuZ2V0KGx2bCk7XG5cbiAgICAgIGlmICghY2FjaGVzKSB7XG4gICAgICAgIGNhY2hlcyA9IG5ldyBNYXAkMSgpO1xuICAgICAgICBjYWNoZXNCeUx2bC5zZXQobHZsLCBjYWNoZXMpO1xuICAgICAgICBsdmxzLnB1c2gobHZsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuZ2V0KGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7IC8vIGdldHRpbmcgZm9yIGFuIGVsZW1lbnQgbWF5IG5lZWQgdG8gYWRkIHRvIHRoZSBpZCBsaXN0IGIvYyBlbGVzIGNhbiBzaGFyZSBrZXlzXG5cbiAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvckNhY2hlZEtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChlbGUuaWQoKSk7IC8vIG4uYi4gdXNlIGNhY2hlZCBrZXksIG5vdCBuZXdseSBjb21wdXRlZCBrZXlcblxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhY2hlKGtleSwgbHZsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmhhcyhrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiB0aGlzLmhhc0NhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKSB7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmdldENhY2hlc0F0KGx2bCkuc2V0KGtleSwgY2FjaGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGVsZSwgbHZsLCBjYWNoZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLnNldENhY2hlKGtleSwgbHZsLCBjYWNoZSk7XG4gICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlS2V5KGtleSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5sdmxzLmZvckVhY2goZnVuY3Rpb24gKGx2bCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfSk7XG4gICAgfSAvLyByZXR1cm5zIHRydWUgaWYgbm8gb3RoZXIgZWxlcyByZWZlcmVuY2UgdGhlIGludmFsaWRhdGVkIGNhY2hlIChuLmIuIG90aGVyIGVsZXMgbWF5IG5lZWQgdGhlIGNhY2hlIHdpdGggdGhlIHNhbWUga2V5KVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpOyAvLyBuLmIuIHVzZSBzdG9yZWQga2V5IHJhdGhlciB0aGFuIGN1cnJlbnQgKHBvdGVudGlhbCBrZXkpXG5cbiAgICAgIHRoaXMuZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgdmFyIGVudGlyZUtleUludmFsaWRhdGVkID0gdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuXG4gICAgICBpZiAoZW50aXJlS2V5SW52YWxpZGF0ZWQpIHtcbiAgICAgICAgLy8gY2xlYXIgbWFwcGluZyBmb3IgY3VycmVudCBrZXlcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRpcmVLZXlJbnZhbGlkYXRlZCB8fCB0aGlzLmdldE51bWJlck9mSWRzRm9yS2V5KGtleSkgPT09IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXA7XG59KCk7XG5cbnZhciBtaW5UeHJIID0gMjU7IC8vIHRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGNhY2hlIGZvciBzbWFsbCBoZWlnaHQgZWxlcyAoc3BlY2lhbCBjYXNlKVxuXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG5cbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbnZhciBtYXhMdmwgPSAzOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG5cbnZhciBtYXhab29tID0gNy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcblxudmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcblxudmFyIGRlZlR4cldpZHRoID0gMTAyNDsgLy8gZGVmYXVsdC9taW5pbXVtIHRleHR1cmUgd2lkdGhcblxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcblxudmFyIG1heFR4ckggPSAxMDI0OyAvLyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSB0ZXh0dXJlXG5cbnZhciBtaW5VdGlsaXR5ID0gMC4yOyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG5cbnZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcblxudmFyIG1heEZ1bGxuZXNzQ2hlY2tzID0gMTA7IC8vIGRlcXVldWVkIGFmdGVyIHRoaXMgbWFueSBjaGVja3NcblxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG5cbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSAxMDA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxudmFyIGdldFR4clJlYXNvbnMgPSB7XG4gIGRlcXVldWU6ICdkZXF1ZXVlJyxcbiAgZG93bnNjYWxlOiAnZG93bnNjYWxlJyxcbiAgaGlnaFF1YWxpdHk6ICdoaWdoUXVhbGl0eSdcbn07XG52YXIgaW5pdERlZmF1bHRzID0gZGVmYXVsdHMoe1xuICBnZXRLZXk6IG51bGwsXG4gIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICBkcmF3RWxlbWVudDogbnVsbCxcbiAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICBpc1Zpc2libGU6IHRydWVpZnksXG4gIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxufSk7XG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlciwgaW5pdE9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHNlbGYub25EZXF1ZXVlcyA9IFtdO1xuICB2YXIgb3B0cyA9IGluaXREZWZhdWx0cyhpbml0T3B0aW9ucyk7XG4gIGV4dGVuZChzZWxmLCBvcHRzKTtcbiAgc2VsZi5sb29rdXAgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChvcHRzLmdldEtleSwgb3B0cy5kb2VzRWxlSW52YWxpZGF0ZUtleSk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xuXG52YXIgRVRDcCA9IEVsZW1lbnRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29uczsgLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5cbkVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07IC8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuXG5cbkVUQ3AuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbdHhySF0gPSBydHh0clFzW3R4ckhdIHx8IFtdO1xuICByZXR1cm4gcnR4dHJRO1xufTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcblxuXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH0pO1xuICByZXR1cm4gcTtcbn07IC8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzIChlbGVtZW50IGlkIGxvb2t1cClcblxuXG5FVENwLmdldEVsZW1lbnRLZXlUb1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrMnEgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlIHx8IHt9O1xuICByZXR1cm4gazJxO1xufTtcblxuRVRDcC5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCBpc05hTihiYi53KSB8fCBpc05hTihiYi5oKSB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFzZWxmLmFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIHx8ICFzZWxmLmFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcbiAgfVxuXG4gIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICBsdmwgPSBtaW5Mdmw7XG4gIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGVsZVNjYWxlZEggPSBiYi5oICogc2NhbGU7XG4gIHZhciBlbGVTY2FsZWRXID0gYmIudyAqIHNjYWxlO1xuICB2YXIgc2NhbGVkTGFiZWxTaG93biA9IHIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlLCBzY2FsZSk7XG5cbiAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZWxlQ2FjaGUgPSBsb29rdXAuZ2V0KGVsZSwgbHZsKTsgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuXG4gIGlmIChlbGVDYWNoZSAmJiBlbGVDYWNoZS5pbnZhbGlkYXRlZCkge1xuICAgIGVsZUNhY2hlLmludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgZWxlQ2FjaGUudGV4dHVyZS5pbnZhbGlkYXRlZFdpZHRoIC09IGVsZUNhY2hlLndpZHRoO1xuICB9XG5cbiAgaWYgKGVsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG5cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVykge1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuXG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7IC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcblxuICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuXG4gIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICB9OyAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuXG5cbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gIH0gLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcblxuXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gIH0gLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG5cblxuICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcblxuICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuXG4gIGZvciAodmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgdmFyIGMgPSBsb29rdXAuZ2V0KGVsZSwgbCk7XG5cbiAgICBpZiAoYykge1xuICAgICAgaGlnaGVyQ2FjaGUgPSBjO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24gZG93bnNjYWxlKCkge1xuICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLCBvbmVVcENhY2hlLngsIDAsIG9uZVVwQ2FjaGUud2lkdGgsIG9uZVVwQ2FjaGUuaGVpZ2h0LCB0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIKTtcbiAgfTsgLy8gcmVzZXQgZWxlIGFyZWEgaW4gdGV4dHVyZVxuXG5cbiAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICB0eHIuY29udGV4dC5jbGVhclJlY3QodHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgdHhySCk7XG5cbiAgaWYgKHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSkge1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcbiAgfSBlbHNlIGlmIChzY2FsYWJsZUZyb20oaGlnaGVyQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB1c2UgdGhlIGhpZ2hlciBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgbmV4dCBsZXZlbCBkb3duXG4gICAgLy8gdG8gY2hlYXBseSBzY2FsZSB0b3dhcmRzIHRoZSBzbWFsbGVyIGxldmVsXG4gICAgaWYgKGhpZ2hRdWFsaXR5UmVxKSB7XG4gICAgICBmb3IgKHZhciBfbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBfbCA+IGx2bDsgX2wtLSkge1xuICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIF9sLCBnZXRUeHJSZWFzb25zLmRvd25zY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIGRvd25zY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcblxuICAgIGlmICghZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxKSB7XG4gICAgICBmb3IgKHZhciBfbDIgPSBsdmwgLSAxOyBfbDIgPj0gbWluTHZsOyBfbDItLSkge1xuICAgICAgICB2YXIgX2MgPSBsb29rdXAuZ2V0KGVsZSwgX2wyKTtcblxuICAgICAgICBpZiAoX2MpIHtcbiAgICAgICAgICBsb3dlckNhY2hlID0gX2M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpKSB7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgbHZsKTtcbiAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgIH1cblxuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSh0eHIudXNlZFdpZHRoLCAwKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIHRoaXMuZHJhd0VsZW1lbnQodHhyLmNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIGZhbHNlKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKC10eHIudXNlZFdpZHRoLCAwKTtcbiAgfVxuXG4gIGVsZUNhY2hlID0ge1xuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG4gIHR4ci51c2VkV2lkdGggKz0gTWF0aC5jZWlsKGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nKTtcbiAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcbiAgbG9va3VwLnNldChlbGUsIGx2bCwgZWxlQ2FjaGUpO1xuICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5cbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlRWxlbWVudChlbGVzW2ldKTtcbiAgfVxufTtcblxuRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG4gIHZhciBjYWNoZXMgPSBbXTtcbiAgdmFyIGludmFsaWQgPSBsb29rdXAuaXNJbnZhbGlkKGVsZSk7XG5cbiAgaWYgKCFpbnZhbGlkKSB7XG4gICAgcmV0dXJuOyAvLyBvdmVycmlkZSB0aGUgaW52YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIGVsZW1lbnQga2V5IGhhcyBub3QgY2hhbmdlZFxuICB9XG5cbiAgZm9yICh2YXIgbHZsID0gbWluTHZsOyBsdmwgPD0gbWF4THZsOyBsdmwrKykge1xuICAgIHZhciBjYWNoZSA9IGxvb2t1cC5nZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpO1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vT3RoZXJFbGVzVXNlQ2FjaGUgPSBsb29rdXAuaW52YWxpZGF0ZShlbGUpO1xuXG4gIGlmIChub090aGVyRWxlc1VzZUNhY2hlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfY2FjaGUgPSBjYWNoZXNbaV07XG4gICAgICB2YXIgdHhyID0gX2NhY2hlLnRleHR1cmU7IC8vIHJlbW92ZSBzcGFjZSBmcm9tIHRoZSB0ZXh0dXJlIGl0IGJlbG9uZ3MgdG9cblxuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggKz0gX2NhY2hlLndpZHRoOyAvLyBtYXJrIHRoZSBjYWNoZSBhcyBpbnZhbGlkYXRlZFxuXG4gICAgICBfY2FjaGUuaW52YWxpZGF0ZWQgPSB0cnVlOyAvLyByZXRpcmUgdGhlIHRleHR1cmUgaWYgaXRzIHV0aWxpdHkgaXMgbG93XG5cbiAgICAgIHNlbGYuY2hlY2tUZXh0dXJlVXRpbGl0eSh0eHIpO1xuICAgIH1cbiAgfSAvLyByZW1vdmUgZnJvbSBxdWV1ZSBzaW5jZSB0aGUgb2xkIHJlcSB3YXMgZm9yIHRoZSBvbGQgc3RhdGVcblxuXG4gIHNlbGYucmVtb3ZlRnJvbVF1ZXVlKGVsZSk7XG59O1xuXG5FVENwLmNoZWNrVGV4dHVyZVV0aWxpdHkgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGludmFsaWRhdGUgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlIGlmIHRoZSBjYWNoZSBzaXplIGlzIHNtYWxsXG4gIGlmICh0eHIuaW52YWxpZGF0ZWRXaWR0aCA+PSBtaW5VdGlsaXR5ICogdHhyLndpZHRoKSB7XG4gICAgdGhpcy5yZXRpcmVUZXh0dXJlKHR4cik7XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlRnVsbG5lc3MgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGlmIHRleHR1cmUgaGFzIGJlZW4gbW9zdGx5IGZpbGxlZCBhbmQgcGFzc2VkIG92ZXIgc2V2ZXJhbCB0aW1lcywgcmVtb3ZlXG4gIC8vIGl0IGZyb20gdGhlIHF1ZXVlIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FzdGUgdGltZSBsb29raW5nIGF0IGl0IHRvIHB1dCBuZXcgdGhpbmdzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHIuaGVpZ2h0KTtcblxuICBpZiAodHhyLnVzZWRXaWR0aCAvIHR4ci53aWR0aCA+IG1heEZ1bGxuZXNzICYmIHR4ci5mdWxsbmVzc0NoZWNrcyA+PSBtYXhGdWxsbmVzc0NoZWNrcykge1xuICAgIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuXG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiAodHhyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSBhY3RpdmUgLyBzZWFyY2hhYmxlIHF1ZXVlOlxuXG4gIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB0eHIucmV0aXJlZCA9IHRydWU7IC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgbG9va3VwLmRlbGV0ZUNhY2hlKGVsZUNhY2hlLmtleSwgZWxlQ2FjaGUubGV2ZWwpO1xuICB9XG5cbiAgY2xlYXJBcnJheShlbGVDYWNoZXMpOyAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgcnR4dHJRLnB1c2godHhyKTtcbn07XG5cbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHR4ciA9IHt9O1xuICB0eHJRLnB1c2godHhyKTtcbiAgdHhyLmVsZUNhY2hlcyA9IFtdO1xuICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgdHhyLndpZHRoID0gTWF0aC5tYXgoZGVmVHhyV2lkdGgsIG1pblcpO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICB0eHIuY2FudmFzID0gc2VsZi5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gIHR4ci5jb250ZXh0ID0gdHhyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICByZXR1cm4gdHhyO1xufTtcblxuRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ0eHRyUS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eHIgPSBydHh0clFbaV07XG5cbiAgICBpZiAodHhyLndpZHRoID49IG1pblcpIHtcbiAgICAgIHR4ci5yZXRpcmVkID0gZmFsc2U7XG4gICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gICAgICBjbGVhckFycmF5KHR4ci5lbGVDYWNoZXMpO1xuICAgICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gICAgICByZW1vdmVGcm9tQXJyYXkocnR4dHJRLCB0eHIpO1xuICAgICAgdHhyUS5wdXNoKHR4cik7XG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBrMnFba2V5XTtcblxuICBpZiAoZXhpc3RpbmdSZXEpIHtcbiAgICAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoZXhpc3RpbmdSZXEubGV2ZWwsIGx2bCk7XG4gICAgZXhpc3RpbmdSZXEuZWxlcy5tZXJnZShlbGUpO1xuICAgIGV4aXN0aW5nUmVxLnJlcXMrKztcbiAgICBxLnVwZGF0ZUl0ZW0oZXhpc3RpbmdSZXEpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSB7XG4gICAgICBlbGVzOiBlbGUuc3Bhd24oKS5tZXJnZShlbGUpLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHJlcXM6IDEsXG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgcS5wdXNoKHJlcSk7XG4gICAgazJxW2tleV0gPSByZXE7XG4gIH1cbn07XG5cbkVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvXG4vKiwgZXh0ZW50Ki9cbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGRlcXVldWVkID0gW107XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlcVNpemU7IGkrKykge1xuICAgIGlmIChxLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciByZXEgPSBxLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHJlcS5rZXk7XG4gICAgICB2YXIgZWxlID0gcmVxLmVsZXNbMF07IC8vIGFsbCBlbGVzIGhhdmUgdGhlIHNhbWUga2V5XG5cbiAgICAgIHZhciBjYWNoZUV4aXN0cyA9IGxvb2t1cC5oYXNDYWNoZShlbGUsIHJlcS5sZXZlbCk7IC8vIGNsZWFyIG91dCB0aGUga2V5IHRvIHJlcSBsb29rdXBcblxuICAgICAgazJxW2tleV0gPSBudWxsOyAvLyBkZXF1ZXVlaW5nIGlzbid0IG5lY2Vzc2FyeSB3aXRoIGFuIGV4aXN0aW5nIGNhY2hlXG5cbiAgICAgIGlmIChjYWNoZUV4aXN0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuICAgICAgdmFyIGJiID0gc2VsZi5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcXVldWVkO1xufTtcblxuRVRDcC5yZW1vdmVGcm9tUXVldWUgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgdmFyIHJlcSA9IGsycVtrZXldO1xuXG4gIGlmIChyZXEgIT0gbnVsbCkge1xuICAgIGlmIChyZXEuZWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHJlbW92ZSBpZiBsYXN0IGVsZSBpbiB0aGUgcmVxXG4gICAgICAvLyBicmluZyB0byBmcm9udCBvZiBxdWV1ZVxuICAgICAgcmVxLnJlcXMgPSBNQVhfSU5UO1xuICAgICAgcS51cGRhdGVJdGVtKHJlcSk7XG4gICAgICBxLnBvcCgpOyAvLyByZW1vdmUgZnJvbSBxdWV1ZVxuXG4gICAgICBrMnFba2V5XSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmVtb3ZlIGVsZSBmcm9tIHJlcVxuICAgICAgcmVxLmVsZXMudW5tZXJnZShlbGUpO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcblxuRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbn07XG5cbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuICAgICAgZm4oZGVxZCk7XG4gICAgfVxuICB9LFxuICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uIHNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGVzID0gZGVxZFtpXS5lbGVzO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGJiID0gZWxlc1tqXS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxuXG52YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbnZhciBtYXhMdmwkMSA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxudmFyIG1heFpvb20kMSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG5cbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQkMSA9IDUwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxuXG52YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG5cbnZhciBkZXFDb3N0JDEgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QkMSA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxudmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcblxudmFyIGRlcUZhc3RDb3N0JDEgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBtYXhEZXFTaXplJDEgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xuXG52YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG5cbnZhciB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBoaWdoIHF1YWxpdHkgZWxlIHR4ciByZXF1ZXN0cyAoZ2VuZXJhbGx5IGZhc3RlciBhbmQgY2hlYXBlciBpbiB0aGUgbG9uZ3Rlcm0pXG4vLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIExheWVyZWRUZXh0dXJlQ2FjaGUocmVuZGVyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgc2VsZi5sYXllcnNCeUxldmVsID0ge307IC8vIGUuZy4gMiA9PiBbIGxheWVyMSwgbGF5ZXIyLCAuLi4sIGxheWVyTiBdXG5cbiAgc2VsZi5maXJzdEdldCA9IHRydWU7XG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gMiAqIGludmFsaWRUaHJlc2hvbGQ7XG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgc2VsZi5lbGVUeHJEZXFzID0gY3kuY29sbGVjdGlvbigpO1xuICBzZWxmLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQgPSB1dGlsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcblxuICB2YXIgcVNvcnQgPSBmdW5jdGlvbiBxU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfTtcblxuICBzZWxmLmxheWVyc1F1ZXVlID0gbmV3IEhlYXAocVNvcnQpO1xuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcblxudmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCQxID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuTFRDcC5tYWtlTGF5ZXIgPSBmdW5jdGlvbiAoYmIsIGx2bCkge1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuICB2YXIgY2FudmFzID0gdGhpcy5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHcsIGgpO1xuICB2YXIgbGF5ZXIgPSB7XG4gICAgaWQ6IGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQkMSxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07IC8vIGxvZygnbWFrZSBsYXllciAlcyB3aXRoIHcgJXMgYW5kIGggJXMgYW5kIGx2bCAlcycsIGxheWVyLmlkLCBsYXllci53aWR0aCwgbGF5ZXIuaGVpZ2h0LCBsYXllci5sZXZlbCk7XG5cbiAgdmFyIGN4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBkeCA9IC1sYXllci5iYi54MTtcbiAgdmFyIGR5ID0gLWxheWVyLmJiLnkxOyAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcblxuICBjeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgY3h0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICByZXR1cm4gbGF5ZXI7XG59O1xuXG5MVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7IC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcblxuICAgIGlmIChsdmwgPCBtaW5MdmwkMSkge1xuICAgICAgbHZsID0gbWluTHZsJDE7XG4gICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20kMSB8fCBsdmwgPiBtYXhMdmwkMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsdmwsIGVsZXMpO1xuICB2YXIgbGF5ZXJzQnlMdmwgPSBzZWxmLmxheWVyc0J5TGV2ZWw7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciBsYXllcnMgPSBsYXllcnNCeUx2bFtsdmxdID0gbGF5ZXJzQnlMdmxbbHZsXSB8fCBbXTtcbiAgdmFyIGJiO1xuICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZShsdmwsIGVsZXMpO1xuICB2YXIgdG1wTGF5ZXJzO1xuXG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcblxuICAgICAgaWYgKHNlbGYubGV2ZWxJc0NvbXBsZXRlKGwsIGVsZXMpKSB7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uIGNoZWNrTHZscyhkaXIpIHtcbiAgICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwkMSA8PSBsICYmIGwgPD0gbWF4THZsJDE7IGwgKz0gZGlyKSB7XG4gICAgICAgIGlmIChjYW5Vc2VBc1RtcEx2bChsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrTHZscygrMSk7XG4gICAgY2hlY2tMdmxzKC0xKTsgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuICAgIGNoZWNrVGVtcExldmVscygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIHZhciBnZXRCYiA9IGZ1bmN0aW9uIGdldEJiKCkge1xuICAgIGlmICghYmIpIHtcbiAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGFmdGVyID0gb3B0cy5hZnRlcjtcbiAgICBnZXRCYigpO1xuICAgIHZhciBhcmVhID0gYmIudyAqIHNjYWxlICogKGJiLmggKiBzY2FsZSk7XG5cbiAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG5cbiAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcbiAgICAgIGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0cy5pbnNlcnQpIHtcbiAgICAgIC8vIG5vIGFmdGVyIHNwZWNpZmllZCA9PiBmaXJzdCBsYXllciBtYWRlIHNvIHB1dCBhdCBzdGFydFxuICAgICAgbGF5ZXJzLnVuc2hpZnQobGF5ZXIpO1xuICAgIH0gLy8gaWYoIHRtcExheWVycyApe1xuICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuXG4gIGlmIChzZWxmLnNraXBwaW5nICYmICFmaXJzdEdldCkge1xuICAgIC8vIGxvZygnc2tpcCBsYXllcnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBsb2coJ2RvIGxheWVycycpO1xuXG5cbiAgdmFyIGxheWVyID0gbnVsbDtcbiAgdmFyIG1heEVsZXNQZXJMYXllciA9IGVsZXMubGVuZ3RoIC8gZGVmTnVtTGF5ZXJzO1xuICB2YXIgYWxsb3dMYXp5UXVldWVpbmcgPSAgIWZpcnN0R2V0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTsgLy8gbG9nKCdsb29rIGF0IGVsZScsIGVsZS5pZCgpKTtcblxuICAgIHZhciBleGlzdGluZ0xheWVyID0gY2FjaGVzW2x2bF07XG5cbiAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFsYXllciB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXIgfHwgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkpKSB7XG4gICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG4gICAgICBsYXllciA9IG1ha2VMYXllcih7XG4gICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgYWZ0ZXI6IGxheWVyXG4gICAgICB9KTsgLy8gaWYgbm93IGxheWVyIGNhbiBiZSBidWlsdCB0aGVuIHdlIGNhbid0IHVzZSBsYXllcnMgYXQgdGhpcyBsZXZlbFxuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBsb2coJ25ldyBsYXllciB3aXRoIGlkICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgfVxuXG4gICAgaWYgKHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKGxheWVyLCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2coJ2RyYXcgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKTtcbiAgICB9XG5cbiAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcbiAgICBjYWNoZXNbbHZsXSA9IGxheWVyO1xuICB9IC8vIGxvZygnLS0nKTtcblxuXG4gIGlmICh0bXBMYXllcnMpIHtcbiAgICAvLyB0aGVuIHdlIG9ubHkgcXVldWVkIHRoZSBjdXJyZW50IGxheWVyc2V0IGFuZCBjYW4ndCBkcmF3IGl0IHlldFxuICAgIHJldHVybiB0bXBMYXllcnM7XG4gIH1cblxuICBpZiAoYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAvLyBsb2coJ2xhenkgcXVldWUgbGV2ZWwnLCBsdmwpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGxheWVycztcbn07IC8vIGEgbGF5ZXIgbWF5IHdhbnQgdG8gdXNlIGFuIGVsZSBjYWNoZSBvZiBhIGhpZ2hlciBsZXZlbCB0byBhdm9pZCBibHVycmluZXNzXG4vLyBzbyB0aGUgbGF5ZXIgbGV2ZWwgbWlnaHQgbm90IGVxdWFsIHRoZSBlbGUgbGV2ZWxcblxuXG5MVENwLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCA9IGZ1bmN0aW9uIChsdmwsIHB4UmF0aW8pIHtcbiAgcmV0dXJuIGx2bDtcbn07XG5cbkxUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsdmwgPSBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsdmwsIHB4UmF0aW8pO1xuXG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIG51bGwsIG51bGwsIGx2bCwgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzKTtcbiAgfVxuXG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgfVxufTtcblxuTFRDcC5sZXZlbElzQ29tcGxldGUgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIGlmICghbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbnVtRWxlc0luTGF5ZXJzID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTsgLy8gaWYgdGhlcmUgYXJlIGFueSBlbGVzIG5lZWRlZCB0byBiZSBkcmF3biB5ZXQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuICAgIGlmIChsYXllci5yZXFzID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGhlIGxheWVyIGlzIGludmFsaWQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH0gLy8gd2Ugc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgbnVtYmVyIG9mIGVsZXMgcGFzc2VkIGluIHRvIGJlIGNvbXBsZXRlXG5cblxuICBpZiAobnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuTFRDcC52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIGlmICghbGF5ZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7IC8vIGZpbmQgdGhlIG9mZnNldFxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSkge1xuICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0YW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHRoZSBlbGVzIGluIHRoZSBsYXllciBtdXN0IGJlIGluIHRoZSBzYW1lIGNvbnRpbnVvdXMgb3JkZXIsIGVsc2UgdGhlIGxheWVyIGlzIGludmFsaWRcblxuXG4gICAgdmFyIG8gPSBvZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyLmVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzW2pdICE9PSBlbGVzW28gKyBqXSkge1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzRWxlcyA9IGVsZW1lbnQoZWxlc1swXSk7IC8vIGNvbGxlY3QgdWRwYXRlZCBlbGVtZW50cyAoY2FzY2FkZWQgZnJvbSB0aGUgbGF5ZXJzKSBhbmQgdXBkYXRlIGVhY2hcbiAgLy8gbGF5ZXIgaXRzZWxmIGFsb25nIHRoZSB3YXlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBmb3IgKHZhciBsID0gbWluTHZsJDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuXG5cbiAgICAgIGlmIChyZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobGF5ZXIubGV2ZWwpICE9PSByZXEubGV2ZWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShsYXllciwgZWxlLCByZXEpO1xuICAgIH1cbiAgfVxufTtcblxuTFRDcC5oYXZlTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBoYXZlTGF5ZXJzID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgbCA9IG1pbkx2bCQxOyBsIDw9IG1heEx2bCQxOyBsKyspIHtcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuXG4gICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGF2ZUxheWVycztcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpOyAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKGxheWVyLCBlbGUsIHJlcSkge1xuICAgIHNlbGYuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgfSk7XG59O1xuXG5MVENwLmludmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUnKTtcbiAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gc2F2ZSBjeWNsZXNcblxuXG4gIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07IC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpOyAvLyBsYXllci5lbGVzID0gW107XG5cbiAgbGF5ZXIuZWxlc1F1ZXVlID0gW107XG4gIGxheWVyLmludmFsaWQgPSB0cnVlO1xuXG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG5cbiAgICBpZiAoY2FjaGVzKSB7XG4gICAgICBjYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7IC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9IC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuXG4gICAgfVxuICB9KTtcbn07XG5cbkxUQ3AuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuXG4gIHRoaXMuZWxlVHhyRGVxcy5tZXJnZShlbGUpO1xuICB0aGlzLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQoKTtcbn07XG5cbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307IC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG5cbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZSkge1xuICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgcS5wdXNoKGxheWVyKTtcbiAgfVxufTtcblxuTFRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBkZXFkID0gW107XG4gIHZhciBlbGVEZXFzID0gMDtcblxuICB3aGlsZSAoZWxlRGVxcyA8IG1heERlcVNpemUkMSkge1xuICAgIGlmIChxLnNpemUoKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gcS5wZWVrKCk7IC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcblxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gaWYgdGhpcyBpcyBhIHJlcGxhY2VtZW50IGxheWVyIHRoYXQgaGFzIGJlZW4gc3VwZXJjZWRlZCwgdGhlbiBmb3JnZXQgaXRcblxuXG4gICAgaWYgKGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgJXMgaXMgaW52YWxpZDsgZGVxdWV1ZWQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IGxheWVyLmVsZXNRdWV1ZS5zaGlmdCgpO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyk7XG4gICAgICBlbGVEZXFzKys7XG4gICAgfVxuXG4gICAgaWYgKGRlcWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKHRydWUpO1xuICAgIH0gLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcblxuXG4gICAgaWYgKGxheWVyLmVsZXNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHEucG9wKCk7XG4gICAgICBsYXllci5yZXFzID0gMDsgLy8gbG9nKCdkZXF1ZXVlIG9mIGxheWVyICVzIGNvbXBsZXRlJywgbGF5ZXIuaWQpO1xuICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZXMpIHtcbiAgICAgICAgc2VsZi5hcHBseUxheWVyUmVwbGFjZW1lbnQobGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxZDtcbn07XG5cbkxUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbGF5ZXIubGV2ZWxdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKHJlcGxhY2VkKTsgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuXG4gIGlmIChpbmRleCA8IDAgfHwgcmVwbGFjZWQuaW52YWxpZCkge1xuICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGF5ZXJzSW5MZXZlbFtpbmRleF0gPSBsYXllcjsgLy8gcmVwbGFjZSBsZXZlbCByZWZcbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3AgPSBsYXllci5lbGVzW2ldLl9wcml2YXRlO1xuICAgIHZhciBjYWNoZSA9IF9wLmltZ0xheWVyQ2FjaGVzID0gX3AuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlW2xheWVyLmxldmVsXSA9IGxheWVyO1xuICAgIH1cbiAgfSAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG5cbiAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG59O1xuXG5MVENwLnJlcXVlc3RSZWRyYXcgPSB1dGlsKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkJDEsXG4gIGRlcUNvc3Q6IGRlcUNvc3QkMSxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCQxLFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0JDEsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCQxLFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvKTtcbiAgfSxcbiAgb25EZXFkOiBub29wLFxuICBzaG91bGRSZWRyYXc6IHRydWVpZnksXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgQ1JwID0ge307XG52YXIgaW1wbDtcblxuZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpYW5nbGVCYWNrY3VydmUoY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQpIHtcbiAgdmFyIGZpcnN0UHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZmlyc3RQdCA9IHB0O1xuICAgIH1cblxuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xufVxuXG5mdW5jdGlvbiB0cmlhbmdsZVRlZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cblxuICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGVlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbn1cblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICd0cmlhbmdsZS1jcm9zcyc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUnOiBjaXJjbGVcbiAgfSkpW25hbWVdO1xufTtcblxudmFyIENScCQxID0ge307XG5cbkNScCQxLmRyYXdFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdFbGVtZW50T3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0Um90YXRpb24sIGdldE9wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgYmIgPSBlbGVUeHJDYWNoZS5nZXRCb3VuZGluZ0JveChlbGUpO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWdub3JlIHplcm8gc2l6ZSBjYXNlXG5cblxuICB2YXIgZWxlQ2FjaGUgPSBlbGVUeHJDYWNoZS5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKTtcblxuICBpZiAoZWxlQ2FjaGUgIT0gbnVsbCkge1xuICAgIHZhciBvcGFjaXR5ID0gZ2V0T3BhY2l0eShyLCBlbGUpO1xuXG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGhldGEgPSBnZXRSb3RhdGlvbihyLCBlbGUpO1xuICAgIHZhciB4MSA9IGJiLngxLFxuICAgICAgICB5MSA9IGJiLnkxLFxuICAgICAgICB3ID0gYmIudyxcbiAgICAgICAgaCA9IGJiLmg7XG4gICAgdmFyIHgsIHksIHN4LCBzeSwgc21vb3RoO1xuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICB2YXIgcm90UHQgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvblBvaW50KGVsZSk7XG4gICAgICBzeCA9IHJvdFB0Lng7XG4gICAgICBzeSA9IHJvdFB0Lnk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgc21vb3RoID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG5cbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2ZmID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25PZmZzZXQoZWxlKTtcbiAgICAgIHggPSBvZmYueDtcbiAgICAgIHkgPSBvZmYueTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgxO1xuICAgICAgeSA9IHkxO1xuICAgIH1cblxuICAgIHZhciBvbGRHbG9iYWxBbHBoYTtcblxuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBvbGRHbG9iYWxBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGEgKiBvcGFjaXR5O1xuICAgIH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGVsZUNhY2hlLnRleHR1cmUuY2FudmFzLCBlbGVDYWNoZS54LCAwLCBlbGVDYWNoZS53aWR0aCwgZWxlQ2FjaGUuaGVpZ2h0LCB4LCB5LCB3LCBoKTtcblxuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGE7XG4gICAgfVxuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXN4LCAtc3kpO1xuXG4gICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsZVR4ckNhY2hlLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7IC8vIGRpcmVjdCBkcmF3IGZhbGxiYWNrXG4gIH1cbn07XG5cbnZhciBnZXRaZXJvUm90YXRpb24gPSBmdW5jdGlvbiBnZXRaZXJvUm90YXRpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxudmFyIGdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCBudWxsKTtcbn07XG5cbnZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xufTtcblxudmFyIGdldFRhcmdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG59O1xuXG52YXIgZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkociwgZWxlKSB7XG4gIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xufTtcblxudmFyIGdldFRleHRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0VGV4dE9wYWNpdHkoZSwgZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS5wZlZhbHVlICogZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG5cbkNScCQxLmRyYXdDYWNoZWRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50LCBsdmwsIHJlcXVlc3RIaWdoUXVhbGl0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBfciRkYXRhID0gci5kYXRhLFxuICAgICAgZWxlVHhyQ2FjaGUgPSBfciRkYXRhLmVsZVR4ckNhY2hlLFxuICAgICAgbGJsVHhyQ2FjaGUgPSBfciRkYXRhLmxibFR4ckNhY2hlLFxuICAgICAgc2xiVHhyQ2FjaGUgPSBfciRkYXRhLnNsYlR4ckNhY2hlLFxuICAgICAgdGxiVHhyQ2FjaGUgPSBfciRkYXRhLnRsYlR4ckNhY2hlO1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgdmFyIHJlYXNvbiA9IHJlcXVlc3RIaWdoUXVhbGl0eSA9PT0gdHJ1ZSA/IGVsZVR4ckNhY2hlLnJlYXNvbnMuaGlnaFF1YWxpdHkgOiBudWxsO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWV4dGVudCB8fCBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcblxuICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFplcm9Sb3RhdGlvbiwgZ2V0T3BhY2l0eSk7XG5cbiAgICBpZiAoIWlzRWRnZSB8fCAhYmFkTGluZSkge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBsYmxUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGdlICYmICFiYWRMaW5lKSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHNsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCB0bGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFRhcmdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG5cbiAgICByLmRyYXdFbGVtZW50T3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkMS5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkMS5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxuQ1JwJDEuZHJhd0NhY2hlZE5vZGVzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoZWxlcywgcHhSYXRpbyk7XG5cbiAgaWYgKGxheWVycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgYmIgPSBsYXllci5iYjtcblxuICAgICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG4vKiBnbG9iYWwgUGF0aDJEICovXG52YXIgQ1JwJDIgPSB7fTtcblxuQ1JwJDIuZHJhd0VkZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhZWRnZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcblxuXG4gIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYmI7XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgbGluZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2xpbmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBsaW5lQ2FwID0gZWRnZS5wc3R5bGUoJ2xpbmUtY2FwJykudmFsdWU7XG5cbiAgdmFyIGRyYXdMaW5lID0gZnVuY3Rpb24gZHJhd0xpbmUoKSB7XG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG9wYWNpdHk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgY29udGV4dC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICB9O1xuXG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgfTtcblxuICB2YXIgZHJhd0Fycm93cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd3MoKSB7XG4gICAgdmFyIGFycm93T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3BhY2l0eTtcbiAgICByLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGFycm93T3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWRnZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgfTtcblxuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmZWN0aXZlR2hvc3RPcGFjaXR5ID0gb3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGRyYXdMaW5lKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgZHJhd0Fycm93cyhlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIGRyYXdMaW5lKCk7XG4gIGRyYXdBcnJvd3MoKTtcbiAgZHJhd092ZXJsYXkoKTtcbiAgZHJhd1RleHQoKTtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbkNScCQyLmRyYXdFZGdlT3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgaWYgKG92ZXJsYXlPcGFjaXR5ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBvdmVybGF5UGFkZGluZyA9IGVkZ2UucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS5wZlZhbHVlO1xuICB2YXIgb3ZlcmxheVdpZHRoID0gMiAqIG92ZXJsYXlQYWRkaW5nO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gZWRnZS5wc3R5bGUoJ292ZXJsYXktY29sb3InKS52YWx1ZTtcbiAgY29udGV4dC5saW5lV2lkdGggPSBvdmVybGF5V2lkdGg7XG5cbiAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgJiYgIXVzZVBhdGhzKSB7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gIH1cblxuICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xufTtcblxuQ1JwJDIuZHJhd0VkZ2VQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgbGluZURhc2hQYXR0ZXJuID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1wYXR0ZXJuJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1vZmZzZXQnKS5wZlZhbHVlO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbignJCcpO1xuICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuXG4gICAgaWYgKGtleU1hdGNoZXMpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjYW52YXNDeHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKGxpbmVEYXNoUGF0dGVybik7XG4gICAgICAgIGNhbnZhc0N4dC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSArIDEgPCBwdHMubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pXSwgcHRzW19pICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0N4dDtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9IC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuXG5cbiAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgfVxufTtcblxuQ1JwJDIuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxuXG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcblxuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxufTtcblxuQ1JwJDIuZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcblxuICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBlZGdlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgfVxuXG4gIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICBpZiAob3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnKSB7XG4gICAgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG59O1xuXG5DUnAkMi5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKSAmJiBzaGFwZSAhPT0gJ3RyaWFuZ2xlLWNyb3NzJztcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG4gIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlV2lkdGgsIHNjYWxlKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBjYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgPSByLmFycm93UGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5nKHNoYXBlKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IGNhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gc3RvcmUgaW4gdGhlIHBhdGggY2FjaGUgd2l0aCB2YWx1ZXMgZWFzaWx5IG1hbmlwdWxhdGVkIGxhdGVyXG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCAxLCAwLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHNldCB0cmFuc2Zvcm0gdG8gYXJyb3cgcG9zaXRpb24vb3JpZW50YXRpb25cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgY29udGV4dC5zY2FsZShzaXplLCBzaXplKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gKHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEpIC8gKHVzZVBhdGhzID8gc2l6ZSA6IDEpO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICAvLyByZXNldCB0cmFuc2Zvcm0gYnkgYXBwbHlpbmcgaW52ZXJzZVxuICAgIGNvbnRleHQuc2NhbGUoMSAvIHNpemUsIDEgLyBzaXplKTtcbiAgICBjb250ZXh0LnJvdGF0ZSgtYW5nbGUpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn07XG5cbnZhciBDUnAkMyA9IHt9O1xuXG5DUnAkMy5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpIHtcbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKTtcbn07XG5cbkNScCQzLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4LCBub2RlT3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBub2RlWCA9IHBvcy54O1xuICB2YXIgbm9kZVkgPSBwb3MueTtcbiAgdmFyIHN0eWxlT2JqID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBnZXRJbmRleGVkU3R5bGUgPSBzdHlsZU9iai5nZXRJbmRleGVkU3R5bGUuYmluZChzdHlsZU9iaik7XG4gIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtZml0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgcmVwZWF0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZ1gyID0gbm9kZS5wYWRkaW5nKCkgKiAyO1xuICB2YXIgbm9kZVRXID0gbm9kZVcgKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBub2RlVEggPSBub2RlSCArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWNsaXAnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICB2YXIgaW1nT3BhY2l0eSA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXgpICogbm9kZU9wYWNpdHk7XG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7IC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG5cbiAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG5cbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIHggPSBub2RlWCAtIG5vZGVUVyAvIDI7IC8vIGxlZnRcblxuICB2YXIgcG9zWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gcG9zWFBmVmFsO1xuICB9XG5cbiAgdmFyIG9mZlhVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIG9mZlhQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChvZmZYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogb2ZmWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gb2ZmWFBmVmFsO1xuICB9XG5cbiAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuXG4gIHZhciBwb3NZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1lQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKHBvc1lVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBwb3NZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBwb3NZUGZWYWw7XG4gIH1cblxuICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKG9mZllVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBvZmZZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBvZmZZUGZWYWw7XG4gIH1cblxuICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG5cbiAgaWYgKHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICAgICAgY29udGV4dC5jbGlwKHJzLnBhdGhDYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCk7XG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2FmZURyYXdJbWFnZShjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGgpO1xuXG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRIKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG5cbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcbn07XG5cbnZhciBDUnAkNCA9IHt9O1xuXG5DUnAkNC5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uIChlbGUsIHNjYWxlKSB7XG4gIGlmICghc2NhbGUpIHtcbiAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpOyAvLyB0aGUgZWZmZWN0aXZlIHRleHR1cmUgbGV2ZWxcblxuICAgIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgfVxuXG4gIHZhciBjb21wdXRlZFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICogc2NhbGU7XG4gIHZhciBtaW5TaXplID0gZWxlLnBzdHlsZSgnbWluLXpvb21lZC1mb250LXNpemUnKS5wZlZhbHVlO1xuXG4gIGlmIChjb21wdXRlZFNpemUgPCBtaW5TaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DUnAkNC5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBmb3JjZSwgcHJlZml4KSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIganVzdGlmaWNhdGlvbiA9IHIuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBqdXN0aWZpY2F0aW9uO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG5cbiAgICB2YXIgX2xhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcblxuICAgIHZhciBzcmNMYWJlbCA9IGVsZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpO1xuICAgIHZhciB0Z3RMYWJlbCA9IGVsZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpO1xuXG4gICAgaWYgKGJhZExpbmUgfHwgKCFfbGFiZWwgfHwgIV9sYWJlbC52YWx1ZSkgJiYgKCFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUpICYmICghdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfVxuXG4gIHZhciBhcHBseVJvdGF0aW9uID0gIXNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gIHZhciBiYjtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgbnVsbCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG5cbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3NvdXJjZScsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICd0YXJnZXQnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIHByZWZpeCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gIH1cblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbkNScCQ0LmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBjYWNoZTtcbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuICByZXR1cm4gY2FjaGU7XG59OyAvLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4vLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5cblxuQ1JwJDQuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgKiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBvcGFjaXR5O1xuICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG5cbiAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcbn07IC8vIFRPRE8gZW5zdXJlIHJlLXVzZWRcblxuXG5mdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDU7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn1cblxuQ1JwJDQuZ2V0VGV4dEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciB0aGV0YTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICB2YXIgdGV4dEFuZ2xlID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuXG4gIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgdGhldGEgPSBlbGUuaXNFZGdlKCkgPyB0ZXh0QW5nbGUgOiAwO1xuICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICB0aGV0YSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHRoZXRhO1xufTtcblxuQ1JwJDQuZHJhd1RleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBwcmVmaXgpIHtcbiAgdmFyIGFwcGx5Um90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcblxuICBpZiAodXNlRWxlT3BhY2l0eSAmJiAocGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA9PT0gMCkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gdXNlICdtYWluJyBhcyBhbiBhbGlhcyBmb3IgdGhlIG1haW4gbGFiZWwgKGkuZS4gbnVsbCBwcmVmaXgpXG5cblxuICBpZiAocHJlZml4ID09PSAnbWFpbicpIHtcbiAgICBwcmVmaXggPSBudWxsO1xuICB9XG5cbiAgdmFyIHRleHRYID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gIHZhciB0ZXh0WSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICB2YXIgb3JnVGV4dFgsIG9yZ1RleHRZOyAvLyB1c2VkIGZvciByb3RhdGlvblxuXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuXG4gIGlmICh0ZXh0ICE9IG51bGwgJiYgdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpKSB7XG4gICAgdGhpcy5zZXR1cFRleHRTdHlsZShjb250ZXh0LCBlbGUsIHVzZUVsZU9wYWNpdHkpO1xuICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciB0ZXh0VyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgdGV4dEggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuICAgIHZhciB0aGV0YTtcblxuICAgIGlmICghYXBwbHlSb3RhdGlvbikge1xuICAgICAgdGhldGEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGV0YSA9IHRoaXMuZ2V0VGV4dEFuZ2xlKGVsZSwgcHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICBvcmdUZXh0WSA9IHRleHRZO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUob3JnVGV4dFgsIG9yZ1RleHRZKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgIHRleHRYID0gMDtcbiAgICAgIHRleHRZID0gMDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZICs9IHRleHRIO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuXG4gICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICB2YXIgYmdYID0gdGV4dFggLSBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgYmdYIC09IHRleHRXIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdXID0gdGV4dFcgKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdIID0gdGV4dEggKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzFdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsyXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtc2hhcGUnKS5zdHJWYWx1ZTtcblxuICAgICAgICBpZiAoc3R5bGVTaGFwZS5pbmRleE9mKCdyb3VuZCcpID09PSAwKSB7XG4gICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgc3dpdGNoICh0ZXh0Qm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG5cbiAgICAgICAgaWYgKHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDI7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gMiAqIGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmIChlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZSA9PT0gJ3dyYXAnKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgIHZhciBoYWxmVGV4dFcgPSB0ZXh0VyAvIDI7XG4gICAgICB2YXIganVzdGlmaWNhdGlvbiA9IHRoaXMuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG5cbiAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIDsgZWxzZSBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogcmlnaHRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC10ZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGZpY2F0aW9uIDogY2VudGVyXG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogbGVmdFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRleHRYICs9IHRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgfVxuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLW9yZ1RleHRYLCAtb3JnVGV4dFkpO1xuICAgIH1cbiAgfVxufTtcblxuLyogZ2xvYmFsIFBhdGgyRCAqL1xudmFyIENScCQ1ID0ge307XG5cbkNScCQ1LmRyYXdOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgaWYgKCFudW1iZXIocG9zLngpIHx8ICFudW1iZXIocG9zLnkpKSB7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuXG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhbm9kZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nOyAvL1xuICAvLyBzZXR1cCBzaGlmdFxuXG4gIHZhciBiYjtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH0gLy9cbiAgLy8gbG9hZCBiZyBpbWFnZVxuXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBudW1JbWFnZXMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cmwgPSB1cmxzW2ldO1xuICAgIHZhciBkZWZkID0gdXJsRGVmaW5lZFtpXSA9IHVybCAhPSBudWxsICYmIHVybCAhPT0gJ25vbmUnO1xuXG4gICAgaWYgKGRlZmQpIHtcbiAgICAgIHZhciBiZ0ltZ0Nyb3NzT3JpZ2luID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgJ3ZhbHVlJywgaSk7XG4gICAgICBudW1JbWFnZXMrKzsgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcblxuICAgICAgaW1hZ2VbaV0gPSByLmdldENhY2hlZEltYWdlKHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy9cbiAgLy8gc2V0dXAgc3R5bGVzXG5cblxuICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYmdPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICB2YXIgc2V0dXBTaGFwZUNvbG9yID0gZnVuY3Rpb24gc2V0dXBTaGFwZUNvbG9yKCkge1xuICAgIHZhciBiZ09weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYmdPcGFjaXR5O1xuICAgIHIuZWxlRmlsbFN0eWxlKGNvbnRleHQsIG5vZGUsIGJnT3B5KTtcbiAgfTtcblxuICB2YXIgc2V0dXBCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIHNldHVwQm9yZGVyQ29sb3IoKSB7XG4gICAgdmFyIGJkck9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYm9yZGVyT3BhY2l0eTtcbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgYmRyT3B5KTtcbiAgfTsgLy9cbiAgLy8gc2V0dXAgc2hhcGVcblxuXG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICB2YXIgcGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5ncyhzdHlsZVNoYXBlID09PSAncG9seWdvbicgPyBzdHlsZVNoYXBlICsgJywnICsgc2hhcGVQdHMuam9pbignLCcpIDogc3R5bGVTaGFwZSwgJycgKyBub2RlSGVpZ2h0LCAnJyArIG5vZGVXaWR0aCk7XG4gICAgdmFyIGNhY2hlZFBhdGggPSBwYXRoQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgIHBhdGggPSBjYWNoZWRQYXRoO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoQ2FjaGVba2V5XSA9IHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZSgpIHtcbiAgICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBucG9zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcocGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3SW1hZ2VzID0gZnVuY3Rpb24gZHJhd0ltYWdlcygpIHtcbiAgICB2YXIgbm9kZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbWFnZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGlmICh1cmxEZWZpbmVkW19pXSAmJiBpbWFnZVtfaV0uY29tcGxldGUgJiYgIWltYWdlW19pXS5lcnJvcikge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICByLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZVtfaV0sIG5vZGUsIF9pLCBub2RlT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG5cbiAgICBpZiAocHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nKSB7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgIG5vZGUudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd1BpZSA9IGZ1bmN0aW9uIGRyYXdQaWUoKSB7XG4gICAgdmFyIHJlZHJhd1NoYXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGllT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZWxlT3BhY2l0eTtcblxuICAgIGlmIChyLmhhc1BpZShub2RlKSkge1xuICAgICAgci5kcmF3UGllKGNvbnRleHQsIG5vZGUsIHBpZU9wYWNpdHkpOyAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHBpZSBuZWVkIGl0XG5cbiAgICAgIGlmIChyZWRyYXdTaGFwZSkge1xuICAgICAgICBpZiAoIXVzZVBhdGhzKSB7XG4gICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGFya2VuID0gZnVuY3Rpb24gZGFya2VuKCkge1xuICAgIHZhciBkYXJrZW5PcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgIHZhciBvcGFjaXR5ID0gKGRhcmtuZXNzID4gMCA/IGRhcmtuZXNzIDogLWRhcmtuZXNzKSAqIGRhcmtlbk9wYWNpdHk7XG4gICAgdmFyIGMgPSBkYXJrbmVzcyA+IDAgPyAwIDogMjU1O1xuXG4gICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGMsIGMsIGMsIG9wYWNpdHkpO1xuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3Qm9yZGVyID0gZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoIChib3JkZXJTdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGggLyAzO1xuICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfSAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuXG5cbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIG5vZGUsIG51bGwsIGRyYXdMYWJlbCk7XG4gIH07XG5cbiAgdmFyIGdob3N0ID0gbm9kZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgIGRyYXdCb3JkZXIoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gIH1cblxuICBzZXR1cFNoYXBlQ29sb3IoKTtcbiAgZHJhd1NoYXBlKCk7XG4gIGRyYXdJbWFnZXMoKTtcbiAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gIGRhcmtlbigpO1xuICBzZXR1cEJvcmRlckNvbG9yKCk7XG4gIGRyYXdCb3JkZXIoKTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gIH1cblxuICBkcmF3VGV4dCgpO1xuICBkcmF3T3ZlcmxheSgpOyAvL1xuICAvLyBjbGVhbiB1cCBzaGlmdFxuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcblxuQ1JwJDUuZHJhd05vZGVPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KSB7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gbm9kZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IG5vZGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcbiAgdmFyIG92ZXJsYXlDb2xvciA9IG5vZGUucHN0eWxlKCdvdmVybGF5LWNvbG9yJykudmFsdWU7XG5cbiAgaWYgKG92ZXJsYXlPcGFjaXR5ID4gMCkge1xuICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICBpZiAobm9kZVdpZHRoID09IG51bGwgfHwgbm9kZUhlaWdodCA9PSBudWxsKSB7XG4gICAgICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgICAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gICAgICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nO1xuICAgIH1cblxuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICAgIHIubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLCBub2RlSGVpZ2h0ICsgb3ZlcmxheVBhZGRpbmcgKiAyKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxufTsgLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5cblxuQ1JwJDUuaGFzUGllID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcblxuQ1JwJDUuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoJ3BpZS1zaXplJyk7XG4gIHZhciB4ID0gcG9zLng7XG4gIHZhciB5ID0gcG9zLnk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKG5vZGVXLCBub2RlSCkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG5cbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIGlmIChwaWVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAocGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG5cbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTsgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcblxuICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxufTtcblxudmFyIENScCQ2ID0ge307XG52YXIgbW90aW9uQmx1ckRlbGF5ID0gMTAwOyAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuQ1JwJDYuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59O1xuXG5DUnAkNi5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAkNi5jcmVhdGVHcmFkaWVudFN0eWxlRm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYXBlU3R5bGVOYW1lLCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGU7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNvbG9ycyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtY29sb3JzJykudmFsdWUsXG4gICAgICBwb3NpdGlvbnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycpLnBmVmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCksXG4gICAgICAgICAgbWlkID0gZWxlLm1pZHBvaW50KCk7XG4gICAgICB2YXIgZDEgPSBkaXN0KHN0YXJ0LCBtaWQpO1xuICAgICAgdmFyIGQyID0gZGlzdChlbmQsIG1pZCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtaWQueCwgbWlkLnksIDAsIG1pZC54LCBtaWQueSwgTWF0aC5tYXgoZDEsIGQyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQocG9zLngsIHBvcy55LCAwLCBwb3MueCwgcG9zLnksIE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIF9zdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICAgIF9lbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKTtcblxuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgICBfd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICBfaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpLFxuICAgICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgICAgaGFsZkhlaWdodCA9IF9oZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nKS52YWx1ZTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tbGVmdCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by10b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wLWxlZnQnOlxuICAgICAgICBjYXNlICd0by1sZWZ0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgZ3JhZGllbnQgc3R5bGVcblxuICB2YXIgaGFzUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aCA9PT0gY29sb3JzLmxlbmd0aDtcbiAgdmFyIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgfVxuXG4gIHJldHVybiBncmFkaWVudFN0eWxlO1xufTtcblxuQ1JwJDYuZ3JhZGllbnRGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdiYWNrZ3JvdW5kJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuXG5DUnAkNi5jb2xvckZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNi5lbGVGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gIHZhciBiYWNrZ3JvdW5kRmlsbCA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlO1xuXG4gIGlmIChiYWNrZ3JvdW5kRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgYmFja2dyb3VuZEZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgdGhpcy5ncmFkaWVudEZpbGxTdHlsZShjb250ZXh0LCBlbGUsIGJhY2tncm91bmRGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYmFja2dyb3VuZENvbG9yWzBdLCBiYWNrZ3JvdW5kQ29sb3JbMV0sIGJhY2tncm91bmRDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5cbkNScCQ2LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5cbkNScCQ2LmNvbG9yU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNi5lbGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGxpbmVGaWxsID0gZWxlLnBzdHlsZSgnbGluZS1maWxsJykudmFsdWU7XG5cbiAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07IC8vIFJlc2l6ZSBjYW52YXNcblxuXG5DUnAkNi5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuXG4gIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQpIHtcbiAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgfVxuXG4gIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG5cbiAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG5cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbn07XG5cbkNScCQ2LnJlbmRlclRvID0gZnVuY3Rpb24gKGN4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gIHRoaXMucmVuZGVyKHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSk7XG59O1xuXG5DUnAkNi5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGlmIChyLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICB9XG5cbiAgICByLnByZXZQeFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICBpZiAoci5tYkZyYW1lcyA9PSBudWxsKSB7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICByLm1iRnJhbWVzKys7XG5cbiAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgfSAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG5cblxuICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICB9XG4gIH1cblxuICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfSAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG5cblxuICBpZiAoci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcpIHtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTsgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcblxuICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICB9IC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cblxuICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gIGZ1bmN0aW9uIG1iY2xlYXIoY29udGV4dCwgeCwgeSwgdywgaCkge1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG4gICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgIH1cblxuICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5jeS5hbmltYXRlZCgpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuICBuZWVkTWJDbGVhcltyLk5PREVdID0gIW5lZWREcmF3W3IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuXG4gIGlmIChuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTtcbiAgfVxuXG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKTtcblxuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5ub25kcmFnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMuZHJhZyk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHIuc2hvd0ZwcyB8fCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykge1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcblxuICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJykudmFsdWUgLyB6b29tO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5maWxsUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBzdHlsZS5jb3JlKCdhY3RpdmUtYmctc2l6ZScpLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcblxuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9IC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuXG5cbiAgaWYgKG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxKSB7XG4gICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXTtcbiAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuICAgICAgY3h0LmRyYXdJbWFnZSh0eHQsIC8vIGltZ1xuICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltyLkRSQUddKTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGN5LmVtaXQoJ3JlbmRlcicpO1xuICB9XG59O1xuXG52YXIgQ1JwJDcgPSB7fTsgLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5cbkNScCQ3LmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQ3LmRyYXdSb3VuZFBvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2ludHMubGVuZ3RoIC8gNDsgX2krKykge1xuICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBzb3VyY2VVdiA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VVdiA9IF9pICogNCAtIDI7XG4gICAgfVxuXG4gICAgZGVzdFV2ID0gX2kgKiA0ICsgMjtcbiAgICB2YXIgcHggPSB4ICsgaGFsZlcgKiBwb2ludHNbX2kgKiA0XTtcbiAgICB2YXIgcHkgPSB5ICsgaGFsZkggKiBwb2ludHNbX2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLXBvaW50c1tzb3VyY2VVdl0gKiBwb2ludHNbZGVzdFV2XSAtIHBvaW50c1tzb3VyY2VVdiArIDFdICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2XTtcbiAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhjcDB4LCBjcDB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lVG8oY3AweCwgY3AweSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5hcmNUbyhweCwgcHksIGNwMXgsIGNwMXksIGNvcm5lclJhZGl1cyk7XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTsgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcblxuXG5DUnAkNy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfSAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG5cblxuICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7IC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG5cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcblxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG5cbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEpvaW4gbGluZVxuXG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQ3LmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5KTtcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwJDcuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJMZW5ndGggPSBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAkNy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luLCB5RW5kIC0gaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kKTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kIC0gd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luICsgd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xudmFyIHNpbiA9IHt9O1xudmFyIGNvcyA9IHt9O1xudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcblxuZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbn1cblxuQ1JwJDcuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG5cbiAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xudmFyIENScCQ4ID0ge307XG5cbkNScCQ4LmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZlci53aWR0aCA9IHc7XG4gIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xufTtcblxuQ1JwJDguYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpIHx8IG51bWJlcihvcHRpb25zLm1heEhlaWdodCk7XG4gIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBzY2FsZSA9IDE7XG5cbiAgaWYgKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICB9IGVsc2UgaWYgKHNwZWNkTWF4RGltcykge1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICBpZiAobnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpKSB7XG4gICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSkge1xuICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICB9XG5cbiAgICBzY2FsZSA9IE1hdGgubWluKG1heFNjYWxlVywgbWF4U2NhbGVIKTtcbiAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICBoZWlnaHQgKj0gc2NhbGU7XG4gIH1cblxuICBpZiAoIXNwZWNkTWF4RGltcykge1xuICAgIHdpZHRoICo9IHB4UmF0aW87XG4gICAgaGVpZ2h0ICo9IHB4UmF0aW87XG4gICAgc2NhbGUgKj0gcHhSYXRpbztcbiAgfVxuXG4gIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcblxuICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICBidWZmQ3h0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgaWYgKG9wdGlvbnMuZnVsbCkge1xuICAgICAgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZShiYi54MSAqIHNjYWxlLCBiYi55MSAqIHNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgIH07XG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICB9IC8vIG5lZWQgdG8gZmlsbCBiZyBhdCBlbmQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIGZpbGwgY2xlYXJlZCB0cmFuc3BhcmVudCBwaXhlbHMgaW4ganBnc1xuXG5cbiAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICBidWZmQ3h0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZkNhbnZhcztcbn07XG5cbmZ1bmN0aW9uIGI2NFRvQmxvYihiNjQsIG1pbWVUeXBlKSB7XG4gIHZhciBieXRlcyA9IGF0b2IoYjY0KTtcbiAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmVWludDhbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCbG9iKFtidWZmXSwge1xuICAgIHR5cGU6IG1pbWVUeXBlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiNjRVcmlUb0I2NChiNjR1cmkpIHtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuICByZXR1cm4gYjY0dXJpLnN1YnN0cihpICsgMSk7XG59XG5cbmZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gIHZhciBnZXRCNjRVcmkgPSBmdW5jdGlvbiBnZXRCNjRVcmkoKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gIH07XG5cbiAgc3dpdGNoIChvcHRpb25zLm91dHB1dCkge1xuICAgIGNhc2UgJ2Jsb2ItcHJvbWlzZSc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgaWYgKGJsb2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYGNhbnZhcy50b0Jsb2IoKWAgc2VudCBhIG51bGwgdmFsdWUgaW4gaXRzIGNhbGxiYWNrJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdibG9iJzpcbiAgICAgIHJldHVybiBiNjRUb0Jsb2IoYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpLCBtaW1lVHlwZSk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKTtcblxuICAgIGNhc2UgJ2Jhc2U2NHVyaSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRCNjRVcmkoKTtcbiAgfVxufVxuXG5DUnAkOC5wbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9wbmcnKTtcbn07XG5cbkNScCQ4LmpwZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL2pwZWcnKTtcbn07XG5cbnZhciBDUnAkOSA9IHt9O1xuXG5DUnAkOS5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICBjYXNlICdyb3VuZC1wb2x5Z29uJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFBvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAncm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdjdXRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ2N1dC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0N1dFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdib3R0b21yb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY2FzZSAnYmFycmVsJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG52YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbnZhciBDUnAkYSA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbkNScCRhLkNBTlZBU19MQVlFUlMgPSAzOyAvL1xuXG5DUnAkYS5TRUxFQ1RfQk9YID0gMDtcbkNScCRhLkRSQUcgPSAxO1xuQ1JwJGEuTk9ERSA9IDI7XG5DUnAkYS5CVUZGRVJfQ09VTlQgPSAzOyAvL1xuXG5DUnAkYS5URVhUVVJFX0JVRkZFUiA9IDA7XG5DUnAkYS5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbkNScCRhLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kYXRhID0ge1xuICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwJGEuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAkYS5DQU5WQVNfTEFZRVJTKSxcbiAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENScCRhLkNBTlZBU19MQVlFUlMpLFxuICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwJGEuQlVGRkVSX0NPVU5UKSxcbiAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScCRhLkNBTlZBU19MQVlFUlMpXG4gIH07XG4gIHZhciB0YXBIbE9mZkF0dHIgPSAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJztcbiAgdmFyIHRhcEhsT2ZmU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIHZhciBjb250YWluZXJTdHlsZSA9IHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5jYW52YXNDb250YWluZXIpO1xuICBjb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIHZhciBzdHlsZU1hcCA9IHtcbiAgICAnLXdlYmtpdC11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLW1vei11c2VyLXNlbGVjdCc6ICctbW96LW5vbmUnLFxuICAgICd1c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLFxuICAgICdvdXRsaW5lLXN0eWxlJzogJ25vbmUnXG4gIH07XG5cbiAgaWYgKG1zKCkpIHtcbiAgICBzdHlsZU1hcFsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgIHN0eWxlTWFwWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwJGEuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgdmFyIGNhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgY2FudmFzLnN0eWxlW2tdID0gc3R5bGVNYXBba107XG4gICAgfSk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwJGEuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgfVxuXG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAkYS5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwJGEuTk9ERSArICctbm9kZScpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwJGEuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScCRhLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwJGEuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScCRhLkRSQUcgKyAnLWRyYWcnKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScCRhLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdidWZmZXInICsgaSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICB9XG5cbiAgci5wYXRoc0VuYWJsZWQgPSB0cnVlO1xuICB2YXIgZW1wdHlCYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gIHZhciBnZXRCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3hDZW50ZXIoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKGJiLngxICsgYmIueDIpIC8gMixcbiAgICAgIHk6IChiYi55MSArIGJiLnkyKSAvIDJcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRDZW50ZXJPZmZzZXQoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWJiLncgLyAyLFxuICAgICAgeTogLWJiLmggLyAyXG4gICAgfTtcbiAgfTtcblxuICB2YXIgYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgdmFyIHNhbWUgPSBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID09PSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIHJldHVybiAhc2FtZTtcbiAgfTtcblxuICB2YXIgZ2V0U3R5bGVLZXkgPSBmdW5jdGlvbiBnZXRTdHlsZUtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLm5vZGVLZXk7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5O1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuc291cmNlTGFiZWxTdHlsZUtleTtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnRhcmdldExhYmVsU3R5bGVLZXk7XG4gIH07XG5cbiAgdmFyIGRyYXdFbGVtZW50ID0gZnVuY3Rpb24gZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIGZhbHNlLCBmYWxzZSwgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdMYWJlbCA9IGZ1bmN0aW9uIGRyYXdMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdtYWluJywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdTb3VyY2VMYWJlbCA9IGZ1bmN0aW9uIGRyYXdTb3VyY2VMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdzb3VyY2UnLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd1RhcmdldExhYmVsID0gZnVuY3Rpb24gZHJhd1RhcmdldExhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3RhcmdldCcsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBnZXRFbGVtZW50Qm94ID0gZnVuY3Rpb24gZ2V0RWxlbWVudEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmJvZHlCb3VuZHM7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5tYWluIHx8IGVtcHR5QmI7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsQm94ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5zb3VyY2UgfHwgZW1wdHlCYjtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnRhcmdldCB8fCBlbXB0eUJiO1xuICB9O1xuXG4gIHZhciBpc0xhYmVsVmlzaWJsZUF0U2NhbGUgPSBmdW5jdGlvbiBpc0xhYmVsVmlzaWJsZUF0U2NhbGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSB7XG4gICAgcmV0dXJuIHNjYWxlZExhYmVsU2hvd247XG4gIH07XG5cbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGdldEJveENlbnRlcihnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuXG4gIHZhciBhZGRUZXh0TWFyZ2luID0gZnVuY3Rpb24gYWRkVGV4dE1hcmdpbihwcmVmaXgsIHB0LCBlbGUpIHtcbiAgICB2YXIgcHJlID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHB0LnggKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZSxcbiAgICAgIHk6IHB0LnkgKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldFJzUHQgPSBmdW5jdGlvbiBnZXRSc1B0KGVsZSwgeCwgeSkge1xuICAgIHZhciBycyA9IGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcnNbeF0sXG4gICAgICB5OiByc1t5XVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignJywgZ2V0UnNQdChlbGUsICdsYWJlbFgnLCAnbGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignc291cmNlJywgZ2V0UnNQdChlbGUsICdzb3VyY2VMYWJlbFgnLCAnc291cmNlTGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbigndGFyZ2V0JywgZ2V0UnNQdChlbGUsICd0YXJnZXRMYWJlbFgnLCAndGFyZ2V0TGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0U291cmNlTGFiZWxCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHZhciBiYiA9IGdldExhYmVsQm94KGVsZSk7XG4gICAgdmFyIHAgPSBnZXRDZW50ZXJPZmZzZXQoZ2V0TGFiZWxCb3goZWxlKSk7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcC54ID0gLWJiLnc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHAueCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHAueSA9IC1iYi5oO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcC55ID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgZWxlVHhyQ2FjaGUgPSByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleSxcbiAgICBkb2VzRWxlSW52YWxpZGF0ZUtleTogYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQsXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdFbGVtZW50LFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRFbGVtZW50Qm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldEVsZW1lbnRSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQsXG4gICAgYWxsb3dFZGdlVHhyQ2FjaGluZzogZmFsc2UsXG4gICAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiBmYWxzZVxuICB9KTtcbiAgdmFyIGxibFR4ckNhY2hlID0gci5kYXRhLmxibFR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0TGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0TGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgc2xiVHhyQ2FjaGUgPSByLmRhdGEuc2xiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTb3VyY2VMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1NvdXJjZUxhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRTb3VyY2VMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciB0bGJUeHJDYWNoZSA9IHIuZGF0YS50bGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFRhcmdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3VGFyZ2V0TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldFRhcmdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIGx5clR4ckNhY2hlID0gci5kYXRhLmx5clR4ckNhY2hlID0gbmV3IExheWVyZWRUZXh0dXJlQ2FjaGUocik7XG4gIHIub25VcGRhdGVFbGVDYWxjcyhmdW5jdGlvbiBpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyh3aWxsRHJhdywgZWxlcykge1xuICAgIC8vIGVhY2ggY2FjaGUgc2hvdWxkIGNoZWNrIGZvciBzdWIta2V5IGRpZmYgdG8gc2VlIHRoYXQgdGhlIHVwZGF0ZSBhZmZlY3RzIHRoYXQgY2FjaGUgcGFydGljdWxhcmx5XG4gICAgZWxlVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIGxibFR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBzbGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgdGxiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpOyAvLyBhbnkgY2hhbmdlIGludmFsaWRhdGVzIHRoZSBsYXllcnNcblxuICAgIGx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTsgLy8gdXBkYXRlIHRoZSBvbGQgYmcgdGltZXN0YW1wIHNvIGRpZmZzIGNhbiBiZSBkb25lIGluIHRoZSBlbGUgdHhyIGNhY2hlc1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3AgPSBlbGVzW19pXS5fcHJpdmF0ZTtcbiAgICAgIF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlZmluZUluTGF5ZXJzID0gZnVuY3Rpb24gcmVmaW5lSW5MYXllcnMocmVxcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgbHlyVHhyQ2FjaGUuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50KHJlcXNbaV0uZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgZWxlVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgbGJsVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgc2xiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgdGxiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbn1cblxuQ1JwJGEucmVkcmF3SGludCA9IGZ1bmN0aW9uIChncm91cCwgYm9vbCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgc3dpdGNoIChncm91cCkge1xuICAgIGNhc2UgJ2VsZXMnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScCRhLk5PREVdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwJGEuRFJBR10gPSBib29sO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScCRhLlNFTEVDVF9CT1hdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59OyAvLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xuXG5cbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScCRhLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwJGEudXNlUGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xufTtcblxuQ1JwJGEuc2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQsIGJvb2wpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufTtcblxuQ1JwJGEuZ2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH1cbn07XG5cbkNScCRhLm1ha2VPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzO1xuXG4gIGlmICgodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKE9mZnNjcmVlbkNhbnZhcykpICE9PSAoIFwidW5kZWZpbmVkXCIgKSkge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufTtcblxuW0NScCwgQ1JwJDEsIENScCQyLCBDUnAkMywgQ1JwJDQsIENScCQ1LCBDUnAkNiwgQ1JwJDcsIENScCQ4LCBDUnAkOV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKENScCRhLCBwcm9wcyk7XG59KTtcblxudmFyIHJlbmRlcmVyID0gW3tcbiAgbmFtZTogJ251bGwnLFxuICBpbXBsOiBOdWxsUmVuZGVyZXJcbn0sIHtcbiAgbmFtZTogJ2Jhc2UnLFxuICBpbXBsOiBCUlxufSwge1xuICBuYW1lOiAnY2FudmFzJyxcbiAgaW1wbDogQ1Jcbn1dO1xuXG52YXIgaW5jRXh0cyA9IFt7XG4gIHR5cGU6ICdsYXlvdXQnLFxuICBleHRlbnNpb25zOiBsYXlvdXRcbn0sIHtcbiAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgZXh0ZW5zaW9uczogcmVuZGVyZXJcbn1dO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHt9OyAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiBvdmVycmlkZUVycihmaWVsZCkge1xuICAgIGVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyk7XG4gIH07XG5cbiAgaWYgKHR5cGUgPT09ICdjb3JlJykge1xuICAgIGlmIChDb3JlLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb3JlLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb2xsZWN0aW9uJykge1xuICAgIGlmIChDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsYXlvdXQnKSB7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG5cbiAgICAgIGlmICghcGxhaW5PYmplY3QodGhpcy5fcHJpdmF0ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocmVnaXN0cmFudC5wcm90b3R5cGUpO1xuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuXG4gICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcblxuXG4gICAgaWYgKGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByZWdTdG9wID0gcmVnaXN0cmFudC5wcm90b3R5cGUuc3RvcDtcblxuICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hbmltYXRlKSB7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdTdG9wKSB7XG4gICAgICAgIHJlZ1N0b3AuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGF5b3V0UHJvdG8uY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEN5ID0gZnVuY3Rpb24gZ2V0Q3kobGF5b3V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0Ll9wcml2YXRlLmN5O1xuICAgIH07XG5cbiAgICB2YXIgZW1pdHRlck9wdHMgPSB7XG4gICAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMobGF5b3V0LCBldnQpIHtcbiAgICAgICAgZXZ0LmxheW91dCA9IGxheW91dDtcbiAgICAgICAgZXZ0LmN5ID0gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgZXZ0LnRhcmdldCA9IGxheW91dDtcbiAgICAgIH0sXG4gICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgIHJldHVybiBnZXRDeShsYXlvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kKGxheW91dFByb3RvLCB7XG4gICAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0cywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uZTogZnVuY3Rpb24gb25lKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2dCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZ0LCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmUkMy5ldmVudEFsaWFzZXNPbihsYXlvdXRQcm90byk7XG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgIEJhc2VSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgUmVnaXN0cmFudFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcblxuICAgICAgaWYgKGV4aXN0c0luUikge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIocE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBwcm90b1twTmFtZV0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3BOYW1lIGluIHJQcm90bykge1xuICAgICAgcHJvdG9bX3BOYW1lXSA9IHJQcm90b1tfcE5hbWVdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHByb3RvW25hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZXh0ID0gUmVuZGVyZXI7XG4gIH1cblxuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KSB7XG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgfSk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbiBleHRlbnNpb24oKSB7XG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgICAgICB9XG59OyAvLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcblxuXG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247IC8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcblxuaW5jRXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIHNldEV4dGVuc2lvbihncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwpO1xuICB9KTtcbn0pO1xuXG4vLyAodXNlZnVsIGZvciBpbml0KVxuXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSkge1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICB2YXIgbWFwID0gbmFtZTtcbiAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcE5hbWVzW2pdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtrZXldO1xuXG4gICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1trZXldIHx8IFN0eWxlLnByb3BlcnRpZXNbZGFzaDJjYW1lbChrZXkpXTtcblxuICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzOyAvLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcblxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGN5KSB7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gIHJldHVybiB0aGlzLmFwcGVuZFRvU3R5bGUoc3R5bGUpO1xufTsgLy8gYXBwZW5kIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3Qgb24gYSByZWFsIHN0eWxlIG9iamVjdFxuXG5cbnNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIHN0eWxlLmNzcyhwcm9wLm5hbWUsIHByb3AudmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciB2ZXJzaW9uID0gXCIzLjEyLjFcIjtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uIGN5dG9zY2FwZShvcHRpb25zKSB7XG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGNyZWF0ZSBpbnN0YW5jZVxuXG5cbiAgaWYgKHBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb3JlKG9wdGlvbnMpO1xuICB9IC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmIChzdHJpbmcob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cbn07IC8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuXG5cbmN5dG9zY2FwZS51c2UgPSBmdW5jdGlvbiAoZXh0KSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJncyB0byBwYXNzIHRvIGV4dFxuXG4gIGFyZ3MudW5zaGlmdChjeXRvc2NhcGUpOyAvLyBjeXRvc2NhcGUgaXMgZmlyc3QgYXJnIHRvIGV4dFxuXG4gIGV4dC5hcHBseShudWxsLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jeXRvc2NhcGUud2FybmluZ3MgPSBmdW5jdGlvbiAoYm9vbCkge1xuICByZXR1cm4gd2FybmluZ3MoYm9vbCk7XG59OyAvLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cblxuXG5jeXRvc2NhcGUudmVyc2lvbiA9IHZlcnNpb247IC8vIGV4cG9zZSBwdWJsaWMgYXBpcyAobW9zdGx5IGZvciBleHRlbnNpb25zKVxuXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgUGV0dGl0dFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3JhcGhsaWI6IHJlcXVpcmUoXCIuL2xpYi9ncmFwaGxpYlwiKSxcblxuICBsYXlvdXQ6IHJlcXVpcmUoXCIuL2xpYi9sYXlvdXRcIiksXG4gIGRlYnVnOiByZXF1aXJlKFwiLi9saWIvZGVidWdcIiksXG4gIHV0aWw6IHtcbiAgICB0aW1lOiByZXF1aXJlKFwiLi9saWIvdXRpbFwiKS50aW1lLFxuICAgIG5vdGltZTogcmVxdWlyZShcIi4vbGliL3V0aWxcIikubm90aW1lXG4gIH0sXG4gIHZlcnNpb246IHJlcXVpcmUoXCIuL2xpYi92ZXJzaW9uXCIpXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIGdyZWVkeUZBUyA9IHJlcXVpcmUoXCIuL2dyZWVkeS1mYXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydW46IHJ1bixcbiAgdW5kbzogdW5kb1xufTtcblxuZnVuY3Rpb24gcnVuKGcpIHtcbiAgdmFyIGZhcyA9IChnLmdyYXBoKCkuYWN5Y2xpY2VyID09PSBcImdyZWVkeVwiXG4gICAgPyBncmVlZHlGQVMoZywgd2VpZ2h0Rm4oZykpXG4gICAgOiBkZnNGQVMoZykpO1xuICBfLmZvckVhY2goZmFzLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICBsYWJlbC5mb3J3YXJkTmFtZSA9IGUubmFtZTtcbiAgICBsYWJlbC5yZXZlcnNlZCA9IHRydWU7XG4gICAgZy5zZXRFZGdlKGUudywgZS52LCBsYWJlbCwgXy51bmlxdWVJZChcInJldlwiKSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdlaWdodEZuKGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZnNGQVMoZykge1xuICB2YXIgZmFzID0gW107XG4gIHZhciBzdGFjayA9IHt9O1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIHN0YWNrW3ZdID0gdHJ1ZTtcbiAgICBfLmZvckVhY2goZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKF8uaGFzKHN0YWNrLCBlLncpKSB7XG4gICAgICAgIGZhcy5wdXNoKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGZzKGUudyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVsZXRlIHN0YWNrW3ZdO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZGZzKTtcbiAgcmV0dXJuIGZhcztcbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbGFiZWwgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGxhYmVsLnJldmVyc2VkKSB7XG4gICAgICBnLnJlbW92ZUVkZ2UoZSk7XG5cbiAgICAgIHZhciBmb3J3YXJkTmFtZSA9IGxhYmVsLmZvcndhcmROYW1lO1xuICAgICAgZGVsZXRlIGxhYmVsLnJldmVyc2VkO1xuICAgICAgZGVsZXRlIGxhYmVsLmZvcndhcmROYW1lO1xuICAgICAgZy5zZXRFZGdlKGUudywgZS52LCBsYWJlbCwgZm9yd2FyZE5hbWUpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRCb3JkZXJTZWdtZW50cztcblxuZnVuY3Rpb24gYWRkQm9yZGVyU2VnbWVudHMoZykge1xuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBkZnMpO1xuICAgIH1cblxuICAgIGlmIChfLmhhcyhub2RlLCBcIm1pblJhbmtcIikpIHtcbiAgICAgIG5vZGUuYm9yZGVyTGVmdCA9IFtdO1xuICAgICAgbm9kZS5ib3JkZXJSaWdodCA9IFtdO1xuICAgICAgZm9yICh2YXIgcmFuayA9IG5vZGUubWluUmFuaywgbWF4UmFuayA9IG5vZGUubWF4UmFuayArIDE7XG4gICAgICAgIHJhbmsgPCBtYXhSYW5rO1xuICAgICAgICArK3JhbmspIHtcbiAgICAgICAgYWRkQm9yZGVyTm9kZShnLCBcImJvcmRlckxlZnRcIiwgXCJfYmxcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJSaWdodFwiLCBcIl9iclwiLCB2LCBub2RlLCByYW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByb3AsIHByZWZpeCwgc2csIHNnTm9kZSwgcmFuaykge1xuICB2YXIgbGFiZWwgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHJhbms6IHJhbmssIGJvcmRlclR5cGU6IHByb3AgfTtcbiAgdmFyIHByZXYgPSBzZ05vZGVbcHJvcF1bcmFuayAtIDFdO1xuICB2YXIgY3VyciA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIGxhYmVsLCBwcmVmaXgpO1xuICBzZ05vZGVbcHJvcF1bcmFua10gPSBjdXJyO1xuICBnLnNldFBhcmVudChjdXJyLCBzZyk7XG4gIGlmIChwcmV2KSB7XG4gICAgZy5zZXRFZGdlKHByZXYsIGN1cnIsIHsgd2VpZ2h0OiAxIH0pO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGp1c3Q6IGFkanVzdCxcbiAgdW5kbzogdW5kb1xufTtcblxuZnVuY3Rpb24gYWRqdXN0KGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJsclwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJidFwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHJldmVyc2VZKGcpO1xuICB9XG5cbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwWFkoZyk7XG4gICAgc3dhcFdpZHRoSGVpZ2h0KGcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodChnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFdpZHRoSGVpZ2h0T25lKGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLmVkZ2UoZSkpOyB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFdpZHRoSGVpZ2h0T25lKGF0dHJzKSB7XG4gIHZhciB3ID0gYXR0cnMud2lkdGg7XG4gIGF0dHJzLndpZHRoID0gYXR0cnMuaGVpZ2h0O1xuICBhdHRycy5oZWlnaHQgPSB3O1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV2ZXJzZVlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgcmV2ZXJzZVlPbmUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInlcIikpIHtcbiAgICAgIHJldmVyc2VZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VZT25lKGF0dHJzKSB7XG4gIGF0dHJzLnkgPSAtYXR0cnMueTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyBzd2FwWFlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgc3dhcFhZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBzd2FwWFlPbmUoZWRnZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZT25lKGF0dHJzKSB7XG4gIHZhciB4ID0gYXR0cnMueDtcbiAgYXR0cnMueCA9IGF0dHJzLnk7XG4gIGF0dHJzLnkgPSB4O1xufVxuIiwiLypcbiAqIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgaW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIENvcm1lbiwgZXQgYWwuLFxuICogXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdDtcblxuZnVuY3Rpb24gTGlzdCgpIHtcbiAgdmFyIHNlbnRpbmVsID0ge307XG4gIHNlbnRpbmVsLl9uZXh0ID0gc2VudGluZWwuX3ByZXYgPSBzZW50aW5lbDtcbiAgdGhpcy5fc2VudGluZWwgPSBzZW50aW5lbDtcbn1cblxuTGlzdC5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgdmFyIGVudHJ5ID0gc2VudGluZWwuX3ByZXY7XG4gIGlmIChlbnRyeSAhPT0gc2VudGluZWwpIHtcbiAgICB1bmxpbmsoZW50cnkpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxuTGlzdC5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gIHZhciBzZW50aW5lbCA9IHRoaXMuX3NlbnRpbmVsO1xuICBpZiAoZW50cnkuX3ByZXYgJiYgZW50cnkuX25leHQpIHtcbiAgICB1bmxpbmsoZW50cnkpO1xuICB9XG4gIGVudHJ5Ll9uZXh0ID0gc2VudGluZWwuX25leHQ7XG4gIHNlbnRpbmVsLl9uZXh0Ll9wcmV2ID0gZW50cnk7XG4gIHNlbnRpbmVsLl9uZXh0ID0gZW50cnk7XG4gIGVudHJ5Ll9wcmV2ID0gc2VudGluZWw7XG59O1xuXG5MaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RycyA9IFtdO1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgdmFyIGN1cnIgPSBzZW50aW5lbC5fcHJldjtcbiAgd2hpbGUgKGN1cnIgIT09IHNlbnRpbmVsKSB7XG4gICAgc3Rycy5wdXNoKEpTT04uc3RyaW5naWZ5KGN1cnIsIGZpbHRlck91dExpbmtzKSk7XG4gICAgY3VyciA9IGN1cnIuX3ByZXY7XG4gIH1cbiAgcmV0dXJuIFwiW1wiICsgc3Rycy5qb2luKFwiLCBcIikgKyBcIl1cIjtcbn07XG5cbmZ1bmN0aW9uIHVubGluayhlbnRyeSkge1xuICBlbnRyeS5fcHJldi5fbmV4dCA9IGVudHJ5Ll9uZXh0O1xuICBlbnRyeS5fbmV4dC5fcHJldiA9IGVudHJ5Ll9wcmV2O1xuICBkZWxldGUgZW50cnkuX25leHQ7XG4gIGRlbGV0ZSBlbnRyeS5fcHJldjtcbn1cblxuZnVuY3Rpb24gZmlsdGVyT3V0TGlua3Moaywgdikge1xuICBpZiAoayAhPT0gXCJfbmV4dFwiICYmIGsgIT09IFwiX3ByZXZcIikge1xuICAgIHJldHVybiB2O1xuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVidWdPcmRlcmluZzogZGVidWdPcmRlcmluZ1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGRlYnVnT3JkZXJpbmcoZykge1xuICB2YXIgbGF5ZXJNYXRyaXggPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG5cbiAgdmFyIGggPSBuZXcgR3JhcGgoeyBjb21wb3VuZDogdHJ1ZSwgbXVsdGlncmFwaDogdHJ1ZSB9KS5zZXRHcmFwaCh7fSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGguc2V0Tm9kZSh2LCB7IGxhYmVsOiB2IH0pO1xuICAgIGguc2V0UGFyZW50KHYsIFwibGF5ZXJcIiArIGcubm9kZSh2KS5yYW5rKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGguc2V0RWRnZShlLnYsIGUudywge30sIGUubmFtZSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChsYXllck1hdHJpeCwgZnVuY3Rpb24obGF5ZXIsIGkpIHtcbiAgICB2YXIgbGF5ZXJWID0gXCJsYXllclwiICsgaTtcbiAgICBoLnNldE5vZGUobGF5ZXJWLCB7IHJhbms6IFwic2FtZVwiIH0pO1xuICAgIF8ucmVkdWNlKGxheWVyLCBmdW5jdGlvbih1LCB2KSB7XG4gICAgICBoLnNldEVkZ2UodSwgdiwgeyBzdHlsZTogXCJpbnZpc1wiIH0pO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBoO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgZ3JhcGhsaWI7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgZ3JhcGhsaWIgPSByZXF1aXJlKFwiZ3JhcGhsaWJcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFncmFwaGxpYikge1xuICBncmFwaGxpYiA9IHdpbmRvdy5ncmFwaGxpYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBncmFwaGxpYjtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuL2RhdGEvbGlzdFwiKTtcblxuLypcbiAqIEEgZ3JlZWR5IGhldXJpc3RpYyBmb3IgZmluZGluZyBhIGZlZWRiYWNrIGFyYyBzZXQgZm9yIGEgZ3JhcGguIEEgZmVlZGJhY2tcbiAqIGFyYyBzZXQgaXMgYSBzZXQgb2YgZWRnZXMgdGhhdCBjYW4gYmUgcmVtb3ZlZCB0byBtYWtlIGEgZ3JhcGggYWN5Y2xpYy5cbiAqIFRoZSBhbGdvcml0aG0gY29tZXMgZnJvbTogUC4gRWFkZXMsIFguIExpbiwgYW5kIFcuIEYuIFNteXRoLCBcIkEgZmFzdCBhbmRcbiAqIGVmZmVjdGl2ZSBoZXVyaXN0aWMgZm9yIHRoZSBmZWVkYmFjayBhcmMgc2V0IHByb2JsZW0uXCIgVGhpcyBpbXBsZW1lbnRhdGlvblxuICogYWRqdXN0cyB0aGF0IGZyb20gdGhlIHBhcGVyIHRvIGFsbG93IGZvciB3ZWlnaHRlZCBlZGdlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBncmVlZHlGQVM7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GTiA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGdyZWVkeUZBUyhnLCB3ZWlnaHRGbikge1xuICBpZiAoZy5ub2RlQ291bnQoKSA8PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBzdGF0ZSA9IGJ1aWxkU3RhdGUoZywgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRk4pO1xuICB2YXIgcmVzdWx0cyA9IGRvR3JlZWR5RkFTKHN0YXRlLmdyYXBoLCBzdGF0ZS5idWNrZXRzLCBzdGF0ZS56ZXJvSWR4KTtcblxuICAvLyBFeHBhbmQgbXVsdGktZWRnZXNcbiAgcmV0dXJuIF8uZmxhdHRlbihfLm1hcChyZXN1bHRzLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGcub3V0RWRnZXMoZS52LCBlLncpO1xuICB9KSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRvR3JlZWR5RkFTKGcsIGJ1Y2tldHMsIHplcm9JZHgpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHNvdXJjZXMgPSBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV07XG4gIHZhciBzaW5rcyA9IGJ1Y2tldHNbMF07XG5cbiAgdmFyIGVudHJ5O1xuICB3aGlsZSAoZy5ub2RlQ291bnQoKSkge1xuICAgIHdoaWxlICgoZW50cnkgPSBzaW5rcy5kZXF1ZXVlKCkpKSAgIHsgcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSk7IH1cbiAgICB3aGlsZSAoKGVudHJ5ID0gc291cmNlcy5kZXF1ZXVlKCkpKSB7IHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpOyB9XG4gICAgaWYgKGcubm9kZUNvdW50KCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSBidWNrZXRzLmxlbmd0aCAtIDI7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgZW50cnkgPSBidWNrZXRzW2ldLmRlcXVldWUoKTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnksIHRydWUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5LCBjb2xsZWN0UHJlZGVjZXNzb3JzKSB7XG4gIHZhciByZXN1bHRzID0gY29sbGVjdFByZWRlY2Vzc29ycyA/IFtdIDogdW5kZWZpbmVkO1xuXG4gIF8uZm9yRWFjaChnLmluRWRnZXMoZW50cnkudiksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgd2VpZ2h0ID0gZy5lZGdlKGVkZ2UpO1xuICAgIHZhciB1RW50cnkgPSBnLm5vZGUoZWRnZS52KTtcblxuICAgIGlmIChjb2xsZWN0UHJlZGVjZXNzb3JzKSB7XG4gICAgICByZXN1bHRzLnB1c2goeyB2OiBlZGdlLnYsIHc6IGVkZ2UudyB9KTtcbiAgICB9XG5cbiAgICB1RW50cnkub3V0IC09IHdlaWdodDtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgdUVudHJ5KTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcub3V0RWRnZXMoZW50cnkudiksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgd2VpZ2h0ID0gZy5lZGdlKGVkZ2UpO1xuICAgIHZhciB3ID0gZWRnZS53O1xuICAgIHZhciB3RW50cnkgPSBnLm5vZGUodyk7XG4gICAgd0VudHJ5W1wiaW5cIl0gLT0gd2VpZ2h0O1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCB3RW50cnkpO1xuICB9KTtcblxuICBnLnJlbW92ZU5vZGUoZW50cnkudik7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RhdGUoZywgd2VpZ2h0Rm4pIHtcbiAgdmFyIGZhc0dyYXBoID0gbmV3IEdyYXBoKCk7XG4gIHZhciBtYXhJbiA9IDA7XG4gIHZhciBtYXhPdXQgPSAwO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBmYXNHcmFwaC5zZXROb2RlKHYsIHsgdjogdiwgXCJpblwiOiAwLCBvdXQ6IDAgfSk7XG4gIH0pO1xuXG4gIC8vIEFnZ3JlZ2F0ZSB3ZWlnaHRzIG9uIG5vZGVzLCBidXQgYWxzbyBzdW0gdGhlIHdlaWdodHMgYWNyb3NzIG11bHRpLWVkZ2VzXG4gIC8vIGludG8gYSBzaW5nbGUgZWRnZSBmb3IgdGhlIGZhc0dyYXBoLlxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHByZXZXZWlnaHQgPSBmYXNHcmFwaC5lZGdlKGUudiwgZS53KSB8fCAwO1xuICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbihlKTtcbiAgICB2YXIgZWRnZVdlaWdodCA9IHByZXZXZWlnaHQgKyB3ZWlnaHQ7XG4gICAgZmFzR3JhcGguc2V0RWRnZShlLnYsIGUudywgZWRnZVdlaWdodCk7XG4gICAgbWF4T3V0ID0gTWF0aC5tYXgobWF4T3V0LCBmYXNHcmFwaC5ub2RlKGUudikub3V0ICs9IHdlaWdodCk7XG4gICAgbWF4SW4gID0gTWF0aC5tYXgobWF4SW4sICBmYXNHcmFwaC5ub2RlKGUudylbXCJpblwiXSAgKz0gd2VpZ2h0KTtcbiAgfSk7XG5cbiAgdmFyIGJ1Y2tldHMgPSBfLnJhbmdlKG1heE91dCArIG1heEluICsgMykubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExpc3QoKTsgfSk7XG4gIHZhciB6ZXJvSWR4ID0gbWF4SW4gKyAxO1xuXG4gIF8uZm9yRWFjaChmYXNHcmFwaC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIGZhc0dyYXBoLm5vZGUodikpO1xuICB9KTtcblxuICByZXR1cm4geyBncmFwaDogZmFzR3JhcGgsIGJ1Y2tldHM6IGJ1Y2tldHMsIHplcm9JZHg6IHplcm9JZHggfTtcbn1cblxuZnVuY3Rpb24gYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KSB7XG4gIGlmICghZW50cnkub3V0KSB7XG4gICAgYnVja2V0c1swXS5lbnF1ZXVlKGVudHJ5KTtcbiAgfSBlbHNlIGlmICghZW50cnlbXCJpblwiXSkge1xuICAgIGJ1Y2tldHNbYnVja2V0cy5sZW5ndGggLSAxXS5lbnF1ZXVlKGVudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBidWNrZXRzW2VudHJ5Lm91dCAtIGVudHJ5W1wiaW5cIl0gKyB6ZXJvSWR4XS5lbnF1ZXVlKGVudHJ5KTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIGFjeWNsaWMgPSByZXF1aXJlKFwiLi9hY3ljbGljXCIpO1xudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZVwiKTtcbnZhciByYW5rID0gcmVxdWlyZShcIi4vcmFua1wiKTtcbnZhciBub3JtYWxpemVSYW5rcyA9IHJlcXVpcmUoXCIuL3V0aWxcIikubm9ybWFsaXplUmFua3M7XG52YXIgcGFyZW50RHVtbXlDaGFpbnMgPSByZXF1aXJlKFwiLi9wYXJlbnQtZHVtbXktY2hhaW5zXCIpO1xudmFyIHJlbW92ZUVtcHR5UmFua3MgPSByZXF1aXJlKFwiLi91dGlsXCIpLnJlbW92ZUVtcHR5UmFua3M7XG52YXIgbmVzdGluZ0dyYXBoID0gcmVxdWlyZShcIi4vbmVzdGluZy1ncmFwaFwiKTtcbnZhciBhZGRCb3JkZXJTZWdtZW50cyA9IHJlcXVpcmUoXCIuL2FkZC1ib3JkZXItc2VnbWVudHNcIik7XG52YXIgY29vcmRpbmF0ZVN5c3RlbSA9IHJlcXVpcmUoXCIuL2Nvb3JkaW5hdGUtc3lzdGVtXCIpO1xudmFyIG9yZGVyID0gcmVxdWlyZShcIi4vb3JkZXJcIik7XG52YXIgcG9zaXRpb24gPSByZXF1aXJlKFwiLi9wb3NpdGlvblwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dDtcblxuZnVuY3Rpb24gbGF5b3V0KGcsIG9wdHMpIHtcbiAgdmFyIHRpbWUgPSBvcHRzICYmIG9wdHMuZGVidWdUaW1pbmcgPyB1dGlsLnRpbWUgOiB1dGlsLm5vdGltZTtcbiAgdGltZShcImxheW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGF5b3V0R3JhcGggPSBcbiAgICAgIHRpbWUoXCIgIGJ1aWxkTGF5b3V0R3JhcGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBidWlsZExheW91dEdyYXBoKGcpOyB9KTtcbiAgICB0aW1lKFwiICBydW5MYXlvdXRcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyBydW5MYXlvdXQobGF5b3V0R3JhcGgsIHRpbWUpOyB9KTtcbiAgICB0aW1lKFwiICB1cGRhdGVJbnB1dEdyYXBoXCIsIGZ1bmN0aW9uKCkgeyB1cGRhdGVJbnB1dEdyYXBoKGcsIGxheW91dEdyYXBoKTsgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5MYXlvdXQoZywgdGltZSkge1xuICB0aW1lKFwiICAgIG1ha2VTcGFjZUZvckVkZ2VMYWJlbHNcIiwgZnVuY3Rpb24oKSB7IG1ha2VTcGFjZUZvckVkZ2VMYWJlbHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZVNlbGZFZGdlc1wiLCAgICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZVNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWN5Y2xpY1wiLCAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgYWN5Y2xpYy5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIG5lc3RpbmdHcmFwaC5ydW5cIiwgICAgICAgZnVuY3Rpb24oKSB7IG5lc3RpbmdHcmFwaC5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIHJhbmtcIiwgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJhbmsodXRpbC5hc05vbkNvbXBvdW5kR3JhcGgoZykpOyB9KTtcbiAgdGltZShcIiAgICBpbmplY3RFZGdlTGFiZWxQcm94aWVzXCIsIGZ1bmN0aW9uKCkgeyBpbmplY3RFZGdlTGFiZWxQcm94aWVzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVFbXB0eVJhbmtzXCIsICAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVFbXB0eVJhbmtzKGcpOyB9KTtcbiAgdGltZShcIiAgICBuZXN0aW5nR3JhcGguY2xlYW51cFwiLCAgIGZ1bmN0aW9uKCkgeyBuZXN0aW5nR3JhcGguY2xlYW51cChnKTsgfSk7XG4gIHRpbWUoXCIgICAgbm9ybWFsaXplUmFua3NcIiwgICAgICAgICBmdW5jdGlvbigpIHsgbm9ybWFsaXplUmFua3MoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFzc2lnblJhbmtNaW5NYXhcIiwgICAgICAgZnVuY3Rpb24oKSB7IGFzc2lnblJhbmtNaW5NYXgoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXNcIiwgZnVuY3Rpb24oKSB7IHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZS5ydW5cIiwgICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZS5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIHBhcmVudER1bW15Q2hhaW5zXCIsICAgICAgZnVuY3Rpb24oKSB7IHBhcmVudER1bW15Q2hhaW5zKGcpOyB9KTtcbiAgdGltZShcIiAgICBhZGRCb3JkZXJTZWdtZW50c1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBhZGRCb3JkZXJTZWdtZW50cyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgb3JkZXJcIiwgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgb3JkZXIoZyk7IH0pO1xuICB0aW1lKFwiICAgIGluc2VydFNlbGZFZGdlc1wiLCAgICAgICAgZnVuY3Rpb24oKSB7IGluc2VydFNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWRqdXN0Q29vcmRpbmF0ZVN5c3RlbVwiLCBmdW5jdGlvbigpIHsgY29vcmRpbmF0ZVN5c3RlbS5hZGp1c3QoZyk7IH0pO1xuICB0aW1lKFwiICAgIHBvc2l0aW9uXCIsICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHBvc2l0aW9uKGcpOyB9KTtcbiAgdGltZShcIiAgICBwb3NpdGlvblNlbGZFZGdlc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBwb3NpdGlvblNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlQm9yZGVyTm9kZXNcIiwgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlQm9yZGVyTm9kZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZS51bmRvXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZS51bmRvKGcpOyB9KTtcbiAgdGltZShcIiAgICBmaXh1cEVkZ2VMYWJlbENvb3Jkc1wiLCAgIGZ1bmN0aW9uKCkgeyBmaXh1cEVkZ2VMYWJlbENvb3JkcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgdW5kb0Nvb3JkaW5hdGVTeXN0ZW1cIiwgICBmdW5jdGlvbigpIHsgY29vcmRpbmF0ZVN5c3RlbS51bmRvKGcpOyB9KTtcbiAgdGltZShcIiAgICB0cmFuc2xhdGVHcmFwaFwiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyB0cmFuc2xhdGVHcmFwaChnKTsgfSk7XG4gIHRpbWUoXCIgICAgYXNzaWduTm9kZUludGVyc2VjdHNcIiwgICBmdW5jdGlvbigpIHsgYXNzaWduTm9kZUludGVyc2VjdHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJldmVyc2VQb2ludHNcIiwgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldmVyc2VQb2ludHNGb3JSZXZlcnNlZEVkZ2VzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhY3ljbGljLnVuZG9cIiwgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBhY3ljbGljLnVuZG8oZyk7IH0pO1xufVxuXG4vKlxuICogQ29waWVzIGZpbmFsIGxheW91dCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBsYXlvdXQgZ3JhcGggYmFjayB0byB0aGUgaW5wdXRcbiAqIGdyYXBoLiBUaGlzIHByb2Nlc3Mgb25seSBjb3BpZXMgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBsYXlvdXQgZ3JhcGhcbiAqIHRvIHRoZSBpbnB1dCBncmFwaCwgc28gaXQgc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlSW5wdXRHcmFwaChpbnB1dEdyYXBoLCBsYXlvdXRHcmFwaCkge1xuICBfLmZvckVhY2goaW5wdXRHcmFwaC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGlucHV0TGFiZWwgPSBpbnB1dEdyYXBoLm5vZGUodik7XG4gICAgdmFyIGxheW91dExhYmVsID0gbGF5b3V0R3JhcGgubm9kZSh2KTtcblxuICAgIGlmIChpbnB1dExhYmVsKSB7XG4gICAgICBpbnB1dExhYmVsLnggPSBsYXlvdXRMYWJlbC54O1xuICAgICAgaW5wdXRMYWJlbC55ID0gbGF5b3V0TGFiZWwueTtcblxuICAgICAgaWYgKGxheW91dEdyYXBoLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgICBpbnB1dExhYmVsLndpZHRoID0gbGF5b3V0TGFiZWwud2lkdGg7XG4gICAgICAgIGlucHV0TGFiZWwuaGVpZ2h0ID0gbGF5b3V0TGFiZWwuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGguZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBpbnB1dExhYmVsID0gaW5wdXRHcmFwaC5lZGdlKGUpO1xuICAgIHZhciBsYXlvdXRMYWJlbCA9IGxheW91dEdyYXBoLmVkZ2UoZSk7XG5cbiAgICBpbnB1dExhYmVsLnBvaW50cyA9IGxheW91dExhYmVsLnBvaW50cztcbiAgICBpZiAoXy5oYXMobGF5b3V0TGFiZWwsIFwieFwiKSkge1xuICAgICAgaW5wdXRMYWJlbC54ID0gbGF5b3V0TGFiZWwueDtcbiAgICAgIGlucHV0TGFiZWwueSA9IGxheW91dExhYmVsLnk7XG4gICAgfVxuICB9KTtcblxuICBpbnB1dEdyYXBoLmdyYXBoKCkud2lkdGggPSBsYXlvdXRHcmFwaC5ncmFwaCgpLndpZHRoO1xuICBpbnB1dEdyYXBoLmdyYXBoKCkuaGVpZ2h0ID0gbGF5b3V0R3JhcGguZ3JhcGgoKS5oZWlnaHQ7XG59XG5cbnZhciBncmFwaE51bUF0dHJzID0gW1wibm9kZXNlcFwiLCBcImVkZ2VzZXBcIiwgXCJyYW5rc2VwXCIsIFwibWFyZ2lueFwiLCBcIm1hcmdpbnlcIl07XG52YXIgZ3JhcGhEZWZhdWx0cyA9IHsgcmFua3NlcDogNTAsIGVkZ2VzZXA6IDIwLCBub2Rlc2VwOiA1MCwgcmFua2RpcjogXCJ0YlwiIH07XG52YXIgZ3JhcGhBdHRycyA9IFtcImFjeWNsaWNlclwiLCBcInJhbmtlclwiLCBcInJhbmtkaXJcIiwgXCJhbGlnblwiXTtcbnZhciBub2RlTnVtQXR0cnMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcbnZhciBub2RlRGVmYXVsdHMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbnZhciBlZGdlTnVtQXR0cnMgPSBbXCJtaW5sZW5cIiwgXCJ3ZWlnaHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImxhYmVsb2Zmc2V0XCJdO1xudmFyIGVkZ2VEZWZhdWx0cyA9IHtcbiAgbWlubGVuOiAxLCB3ZWlnaHQ6IDEsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gIGxhYmVsb2Zmc2V0OiAxMCwgbGFiZWxwb3M6IFwiclwiXG59O1xudmFyIGVkZ2VBdHRycyA9IFtcImxhYmVscG9zXCJdO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIG5ldyBncmFwaCBmcm9tIHRoZSBpbnB1dCBncmFwaCwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGxheW91dC5cbiAqIFRoaXMgcHJvY2VzcyBjb3BpZXMgb25seSB3aGl0ZWxpc3RlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIGlucHV0IGdyYXBoIHRvIHRoZVxuICogbGF5b3V0IGdyYXBoLiBUaHVzIHRoaXMgZnVuY3Rpb24gc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXlvdXRHcmFwaChpbnB1dEdyYXBoKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKHsgbXVsdGlncmFwaDogdHJ1ZSwgY29tcG91bmQ6IHRydWUgfSk7XG4gIHZhciBncmFwaCA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLmdyYXBoKCkpO1xuXG4gIGcuc2V0R3JhcGgoXy5tZXJnZSh7fSxcbiAgICBncmFwaERlZmF1bHRzLFxuICAgIHNlbGVjdE51bWJlckF0dHJzKGdyYXBoLCBncmFwaE51bUF0dHJzKSxcbiAgICBfLnBpY2soZ3JhcGgsIGdyYXBoQXR0cnMpKSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGgubm9kZSh2KSk7XG4gICAgZy5zZXROb2RlKHYsIF8uZGVmYXVsdHMoc2VsZWN0TnVtYmVyQXR0cnMobm9kZSwgbm9kZU51bUF0dHJzKSwgbm9kZURlZmF1bHRzKSk7XG4gICAgZy5zZXRQYXJlbnQodiwgaW5wdXRHcmFwaC5wYXJlbnQodikpO1xuICB9KTtcblxuICBfLmZvckVhY2goaW5wdXRHcmFwaC5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5lZGdlKGUpKTtcbiAgICBnLnNldEVkZ2UoZSwgXy5tZXJnZSh7fSxcbiAgICAgIGVkZ2VEZWZhdWx0cyxcbiAgICAgIHNlbGVjdE51bWJlckF0dHJzKGVkZ2UsIGVkZ2VOdW1BdHRycyksXG4gICAgICBfLnBpY2soZWRnZSwgZWRnZUF0dHJzKSkpO1xuICB9KTtcblxuICByZXR1cm4gZztcbn1cblxuLypcbiAqIFRoaXMgaWRlYSBjb21lcyBmcm9tIHRoZSBHYW5zbmVyIHBhcGVyOiB0byBhY2NvdW50IGZvciBlZGdlIGxhYmVscyBpbiBvdXJcbiAqIGxheW91dCB3ZSBzcGxpdCBlYWNoIHJhbmsgaW4gaGFsZiBieSBkb3VibGluZyBtaW5sZW4gYW5kIGhhbHZpbmcgcmFua3NlcC5cbiAqIFRoZW4gd2UgY2FuIHBsYWNlIGxhYmVscyBhdCB0aGVzZSBtaWQtcG9pbnRzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogV2UgYWxzbyBhZGQgc29tZSBtaW5pbWFsIHBhZGRpbmcgdG8gdGhlIHdpZHRoIHRvIHB1c2ggdGhlIGxhYmVsIGZvciB0aGUgZWRnZVxuICogYXdheSBmcm9tIHRoZSBlZGdlIGl0c2VsZiBhIGJpdC5cbiAqL1xuZnVuY3Rpb24gbWFrZVNwYWNlRm9yRWRnZUxhYmVscyhnKSB7XG4gIHZhciBncmFwaCA9IGcuZ3JhcGgoKTtcbiAgZ3JhcGgucmFua3NlcCAvPSAyO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgZWRnZS5taW5sZW4gKj0gMjtcbiAgICBpZiAoZWRnZS5sYWJlbHBvcy50b0xvd2VyQ2FzZSgpICE9PSBcImNcIikge1xuICAgICAgaWYgKGdyYXBoLnJhbmtkaXIgPT09IFwiVEJcIiB8fCBncmFwaC5yYW5rZGlyID09PSBcIkJUXCIpIHtcbiAgICAgICAgZWRnZS53aWR0aCArPSBlZGdlLmxhYmVsb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5oZWlnaHQgKz0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKlxuICogQ3JlYXRlcyB0ZW1wb3JhcnkgZHVtbXkgbm9kZXMgdGhhdCBjYXB0dXJlIHRoZSByYW5rIGluIHdoaWNoIGVhY2ggZWRnZSdzXG4gKiBsYWJlbCBpcyBnb2luZyB0bywgaWYgaXQgaGFzIG9uZSBvZiBub24temVybyB3aWR0aCBhbmQgaGVpZ2h0LiBXZSBkbyB0aGlzXG4gKiBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGVtcHR5IHJhbmtzIHdoaWxlIHByZXNlcnZpbmcgYmFsYW5jZSBmb3IgdGhlXG4gKiBsYWJlbCdzIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBpbmplY3RFZGdlTGFiZWxQcm94aWVzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChlZGdlLndpZHRoICYmIGVkZ2UuaGVpZ2h0KSB7XG4gICAgICB2YXIgdiA9IGcubm9kZShlLnYpO1xuICAgICAgdmFyIHcgPSBnLm5vZGUoZS53KTtcbiAgICAgIHZhciBsYWJlbCA9IHsgcmFuazogKHcucmFuayAtIHYucmFuaykgLyAyICsgdi5yYW5rLCBlOiBlIH07XG4gICAgICB1dGlsLmFkZER1bW15Tm9kZShnLCBcImVkZ2UtcHJveHlcIiwgbGFiZWwsIFwiX2VwXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblJhbmtNaW5NYXgoZykge1xuICB2YXIgbWF4UmFuayA9IDA7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5ib3JkZXJUb3ApIHtcbiAgICAgIG5vZGUubWluUmFuayA9IGcubm9kZShub2RlLmJvcmRlclRvcCkucmFuaztcbiAgICAgIG5vZGUubWF4UmFuayA9IGcubm9kZShub2RlLmJvcmRlckJvdHRvbSkucmFuaztcbiAgICAgIG1heFJhbmsgPSBfLm1heChtYXhSYW5rLCBub2RlLm1heFJhbmspO1xuICAgIH1cbiAgfSk7XG4gIGcuZ3JhcGgoKS5tYXhSYW5rID0gbWF4UmFuaztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWRnZUxhYmVsUHJveGllcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJlZGdlLXByb3h5XCIpIHtcbiAgICAgIGcuZWRnZShub2RlLmUpLmxhYmVsUmFuayA9IG5vZGUucmFuaztcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVHcmFwaChnKSB7XG4gIHZhciBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB2YXIgbWF4WCA9IDA7XG4gIHZhciBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB2YXIgbWF4WSA9IDA7XG4gIHZhciBncmFwaExhYmVsID0gZy5ncmFwaCgpO1xuICB2YXIgbWFyZ2luWCA9IGdyYXBoTGFiZWwubWFyZ2lueCB8fCAwO1xuICB2YXIgbWFyZ2luWSA9IGdyYXBoTGFiZWwubWFyZ2lueSB8fCAwO1xuXG4gIGZ1bmN0aW9uIGdldEV4dHJlbWVzKGF0dHJzKSB7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICAgIHZhciBoID0gYXR0cnMuaGVpZ2h0O1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4IC0gdyAvIDIpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4ICsgdyAvIDIpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5IC0gaCAvIDIpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5ICsgaCAvIDIpO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyBnZXRFeHRyZW1lcyhnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHtcbiAgICAgIGdldEV4dHJlbWVzKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWluWCAtPSBtYXJnaW5YO1xuICBtaW5ZIC09IG1hcmdpblk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIG5vZGUueCAtPSBtaW5YO1xuICAgIG5vZGUueSAtPSBtaW5ZO1xuICB9KTtcblxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgXy5mb3JFYWNoKGVkZ2UucG9pbnRzLCBmdW5jdGlvbihwKSB7XG4gICAgICBwLnggLT0gbWluWDtcbiAgICAgIHAueSAtPSBtaW5ZO1xuICAgIH0pO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHsgZWRnZS54IC09IG1pblg7IH1cbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ5XCIpKSB7IGVkZ2UueSAtPSBtaW5ZOyB9XG4gIH0pO1xuXG4gIGdyYXBoTGFiZWwud2lkdGggPSBtYXhYIC0gbWluWCArIG1hcmdpblg7XG4gIGdyYXBoTGFiZWwuaGVpZ2h0ID0gbWF4WSAtIG1pblkgKyBtYXJnaW5ZO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25Ob2RlSW50ZXJzZWN0cyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICB2YXIgbm9kZVYgPSBnLm5vZGUoZS52KTtcbiAgICB2YXIgbm9kZVcgPSBnLm5vZGUoZS53KTtcbiAgICB2YXIgcDEsIHAyO1xuICAgIGlmICghZWRnZS5wb2ludHMpIHtcbiAgICAgIGVkZ2UucG9pbnRzID0gW107XG4gICAgICBwMSA9IG5vZGVXO1xuICAgICAgcDIgPSBub2RlVjtcbiAgICB9IGVsc2Uge1xuICAgICAgcDEgPSBlZGdlLnBvaW50c1swXTtcbiAgICAgIHAyID0gZWRnZS5wb2ludHNbZWRnZS5wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGVkZ2UucG9pbnRzLnVuc2hpZnQodXRpbC5pbnRlcnNlY3RSZWN0KG5vZGVWLCBwMSkpO1xuICAgIGVkZ2UucG9pbnRzLnB1c2godXRpbC5pbnRlcnNlY3RSZWN0KG5vZGVXLCBwMikpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZml4dXBFZGdlTGFiZWxDb29yZHMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgaWYgKGVkZ2UubGFiZWxwb3MgPT09IFwibFwiIHx8IGVkZ2UubGFiZWxwb3MgPT09IFwiclwiKSB7XG4gICAgICAgIGVkZ2Uud2lkdGggLT0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZWRnZS5sYWJlbHBvcykge1xuICAgICAgY2FzZSBcImxcIjogZWRnZS54IC09IGVkZ2Uud2lkdGggLyAyICsgZWRnZS5sYWJlbG9mZnNldDsgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOiBlZGdlLnggKz0gZWRnZS53aWR0aCAvIDIgKyBlZGdlLmxhYmVsb2Zmc2V0OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS5yZXZlcnNlZCkge1xuICAgICAgZWRnZS5wb2ludHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJvcmRlck5vZGVzKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmIChnLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgICB2YXIgdCA9IGcubm9kZShub2RlLmJvcmRlclRvcCk7XG4gICAgICB2YXIgYiA9IGcubm9kZShub2RlLmJvcmRlckJvdHRvbSk7XG4gICAgICB2YXIgbCA9IGcubm9kZShfLmxhc3Qobm9kZS5ib3JkZXJMZWZ0KSk7XG4gICAgICB2YXIgciA9IGcubm9kZShfLmxhc3Qobm9kZS5ib3JkZXJSaWdodCkpO1xuXG4gICAgICBub2RlLndpZHRoID0gTWF0aC5hYnMoci54IC0gbC54KTtcbiAgICAgIG5vZGUuaGVpZ2h0ID0gTWF0aC5hYnMoYi55IC0gdC55KTtcbiAgICAgIG5vZGUueCA9IGwueCArIG5vZGUud2lkdGggLyAyO1xuICAgICAgbm9kZS55ID0gdC55ICsgbm9kZS5oZWlnaHQgLyAyO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmIChnLm5vZGUodikuZHVtbXkgPT09IFwiYm9yZGVyXCIpIHtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTZWxmRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUudiA9PT0gZS53KSB7XG4gICAgICB2YXIgbm9kZSA9IGcubm9kZShlLnYpO1xuICAgICAgaWYgKCFub2RlLnNlbGZFZGdlcykge1xuICAgICAgICBub2RlLnNlbGZFZGdlcyA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZS5zZWxmRWRnZXMucHVzaCh7IGU6IGUsIGxhYmVsOiBnLmVkZ2UoZSkgfSk7XG4gICAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U2VsZkVkZ2VzKGcpIHtcbiAgdmFyIGxheWVycyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgXy5mb3JFYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgb3JkZXJTaGlmdCA9IDA7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICAgIG5vZGUub3JkZXIgPSBpICsgb3JkZXJTaGlmdDtcbiAgICAgIF8uZm9yRWFjaChub2RlLnNlbGZFZGdlcywgZnVuY3Rpb24oc2VsZkVkZ2UpIHtcbiAgICAgICAgdXRpbC5hZGREdW1teU5vZGUoZywgXCJzZWxmZWRnZVwiLCB7XG4gICAgICAgICAgd2lkdGg6IHNlbGZFZGdlLmxhYmVsLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2VsZkVkZ2UubGFiZWwuaGVpZ2h0LFxuICAgICAgICAgIHJhbms6IG5vZGUucmFuayxcbiAgICAgICAgICBvcmRlcjogaSArICgrK29yZGVyU2hpZnQpLFxuICAgICAgICAgIGU6IHNlbGZFZGdlLmUsXG4gICAgICAgICAgbGFiZWw6IHNlbGZFZGdlLmxhYmVsXG4gICAgICAgIH0sIFwiX3NlXCIpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgbm9kZS5zZWxmRWRnZXM7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblNlbGZFZGdlcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJzZWxmZWRnZVwiKSB7XG4gICAgICB2YXIgc2VsZk5vZGUgPSBnLm5vZGUobm9kZS5lLnYpO1xuICAgICAgdmFyIHggPSBzZWxmTm9kZS54ICsgc2VsZk5vZGUud2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSBzZWxmTm9kZS55O1xuICAgICAgdmFyIGR4ID0gbm9kZS54IC0geDtcbiAgICAgIHZhciBkeSA9IHNlbGZOb2RlLmhlaWdodCAvIDI7XG4gICAgICBnLnNldEVkZ2Uobm9kZS5lLCBub2RlLmxhYmVsKTtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICAgIG5vZGUubGFiZWwucG9pbnRzID0gW1xuICAgICAgICB7IHg6IHggKyAyICogZHggLyAzLCB5OiB5IC0gZHkgfSxcbiAgICAgICAgeyB4OiB4ICsgNSAqIGR4IC8gNiwgeTogeSAtIGR5IH0sXG4gICAgICAgIHsgeDogeCArICAgICBkeCAgICAsIHk6IHkgfSxcbiAgICAgICAgeyB4OiB4ICsgNSAqIGR4IC8gNiwgeTogeSArIGR5IH0sXG4gICAgICAgIHsgeDogeCArIDIgKiBkeCAvIDMsIHk6IHkgKyBkeSB9XG4gICAgICBdO1xuICAgICAgbm9kZS5sYWJlbC54ID0gbm9kZS54O1xuICAgICAgbm9kZS5sYWJlbC55ID0gbm9kZS55O1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdE51bWJlckF0dHJzKG9iaiwgYXR0cnMpIHtcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKF8ucGljayhvYmosIGF0dHJzKSwgTnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplKGF0dHJzKSB7XG4gIHZhciBuZXdBdHRycyA9IHt9O1xuICBfLmZvckVhY2goYXR0cnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBuZXdBdHRyc1trLnRvTG93ZXJDYXNlKCldID0gdjtcbiAgfSk7XG4gIHJldHVybiBuZXdBdHRycztcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGxvZGFzaDtcblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgdHJ5IHtcbiAgICBsb2Rhc2ggPSB7XG4gICAgICBjbG9uZURlZXA6IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBkZWZhdWx0czogcmVxdWlyZShcImxvZGFzaC9kZWZhdWx0c1wiKSxcbiAgICAgIGVhY2g6IHJlcXVpcmUoXCJsb2Rhc2gvZWFjaFwiKSxcbiAgICAgIGZpbHRlcjogcmVxdWlyZShcImxvZGFzaC9maWx0ZXJcIiksXG4gICAgICBmaW5kOiByZXF1aXJlKFwibG9kYXNoL2ZpbmRcIiksXG4gICAgICBmbGF0dGVuOiByZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIiksXG4gICAgICBmb3JFYWNoOiByZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIiksXG4gICAgICBmb3JJbjogcmVxdWlyZShcImxvZGFzaC9mb3JJblwiKSxcbiAgICAgIGhhczogIHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpLFxuICAgICAgaXNVbmRlZmluZWQ6IHJlcXVpcmUoXCJsb2Rhc2gvaXNVbmRlZmluZWRcIiksXG4gICAgICBsYXN0OiByZXF1aXJlKFwibG9kYXNoL2xhc3RcIiksXG4gICAgICBtYXA6IHJlcXVpcmUoXCJsb2Rhc2gvbWFwXCIpLFxuICAgICAgbWFwVmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL21hcFZhbHVlc1wiKSxcbiAgICAgIG1heDogcmVxdWlyZShcImxvZGFzaC9tYXhcIiksXG4gICAgICBtZXJnZTogcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSxcbiAgICAgIG1pbjogcmVxdWlyZShcImxvZGFzaC9taW5cIiksXG4gICAgICBtaW5CeTogcmVxdWlyZShcImxvZGFzaC9taW5CeVwiKSxcbiAgICAgIG5vdzogcmVxdWlyZShcImxvZGFzaC9ub3dcIiksXG4gICAgICBwaWNrOiByZXF1aXJlKFwibG9kYXNoL3BpY2tcIiksXG4gICAgICByYW5nZTogcmVxdWlyZShcImxvZGFzaC9yYW5nZVwiKSxcbiAgICAgIHJlZHVjZTogcmVxdWlyZShcImxvZGFzaC9yZWR1Y2VcIiksXG4gICAgICBzb3J0Qnk6IHJlcXVpcmUoXCJsb2Rhc2gvc29ydEJ5XCIpLFxuICAgICAgdW5pcXVlSWQ6IHJlcXVpcmUoXCJsb2Rhc2gvdW5pcXVlSWRcIiksXG4gICAgICB2YWx1ZXM6IHJlcXVpcmUoXCJsb2Rhc2gvdmFsdWVzXCIpLFxuICAgICAgemlwT2JqZWN0OiByZXF1aXJlKFwibG9kYXNoL3ppcE9iamVjdFwiKSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIGNsZWFudXA6IGNsZWFudXBcbn07XG5cbi8qXG4gKiBBIG5lc3RpbmcgZ3JhcGggY3JlYXRlcyBkdW1teSBub2RlcyBmb3IgdGhlIHRvcHMgYW5kIGJvdHRvbXMgb2Ygc3ViZ3JhcGhzLFxuICogYWRkcyBhcHByb3ByaWF0ZSBlZGdlcyB0byBlbnN1cmUgdGhhdCBhbGwgY2x1c3RlciBub2RlcyBhcmUgcGxhY2VkIGJldHdlZW5cbiAqIHRoZXNlIGJvdW5kcmllcywgYW5kIGVuc3VyZXMgdGhhdCB0aGUgZ3JhcGggaXMgY29ubmVjdGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHdlIGVuc3VyZSwgdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBtaW5sZW4gcHJvcGVydHksIHRoYXQgbm9kZXNcbiAqIGFuZCBzdWJncmFwaCBib3JkZXIgbm9kZXMgdG8gbm90IGVuZCB1cCBvbiB0aGUgc2FtZSByYW5rLlxuICpcbiAqIFByZWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgYSBEQUdcbiAqICAgIDIuIE5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgYSBtaW5sZW4gYXR0cmlidXRlXG4gKlxuICogUG9zdGNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgY29ubmVjdGVkLlxuICogICAgMi4gRHVtbXkgbm9kZXMgYXJlIGFkZGVkIGZvciB0aGUgdG9wcyBhbmQgYm90dG9tcyBvZiBzdWJncmFwaHMuXG4gKiAgICAzLiBUaGUgbWlubGVuIGF0dHJpYnV0ZSBmb3Igbm9kZXMgaXMgYWRqdXN0ZWQgdG8gZW5zdXJlIG5vZGVzIGRvIG5vdFxuICogICAgICAgZ2V0IHBsYWNlZCBvbiB0aGUgc2FtZSByYW5rIGFzIHN1YmdyYXBoIGJvcmRlciBub2Rlcy5cbiAqXG4gKiBUaGUgbmVzdGluZyBncmFwaCBpZGVhIGNvbWVzIGZyb20gU2FuZGVyLCBcIkxheW91dCBvZiBDb21wb3VuZCBEaXJlY3RlZFxuICogR3JhcGhzLlwiXG4gKi9cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIHZhciByb290ID0gdXRpbC5hZGREdW1teU5vZGUoZywgXCJyb290XCIsIHt9LCBcIl9yb290XCIpO1xuICB2YXIgZGVwdGhzID0gdHJlZURlcHRocyhnKTtcbiAgdmFyIGhlaWdodCA9IF8ubWF4KF8udmFsdWVzKGRlcHRocykpIC0gMTsgLy8gTm90ZTogZGVwdGhzIGlzIGFuIE9iamVjdCBub3QgYW4gYXJyYXlcbiAgdmFyIG5vZGVTZXAgPSAyICogaGVpZ2h0ICsgMTtcblxuICBnLmdyYXBoKCkubmVzdGluZ1Jvb3QgPSByb290O1xuXG4gIC8vIE11bHRpcGx5IG1pbmxlbiBieSBub2RlU2VwIHRvIGFsaWduIG5vZGVzIG9uIG5vbi1ib3JkZXIgcmFua3MuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHsgZy5lZGdlKGUpLm1pbmxlbiAqPSBub2RlU2VwOyB9KTtcblxuICAvLyBDYWxjdWxhdGUgYSB3ZWlnaHQgdGhhdCBpcyBzdWZmaWNpZW50IHRvIGtlZXAgc3ViZ3JhcGhzIHZlcnRpY2FsbHkgY29tcGFjdFxuICB2YXIgd2VpZ2h0ID0gc3VtV2VpZ2h0cyhnKSArIDE7XG5cbiAgLy8gQ3JlYXRlIGJvcmRlciBub2RlcyBhbmQgbGluayB0aGVtIHVwXG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIGNoaWxkKTtcbiAgfSk7XG5cbiAgLy8gU2F2ZSB0aGUgbXVsdGlwbGllciBmb3Igbm9kZSBsYXllcnMgZm9yIGxhdGVyIHJlbW92YWwgb2YgZW1wdHkgYm9yZGVyXG4gIC8vIGxheWVycy5cbiAgZy5ncmFwaCgpLm5vZGVSYW5rRmFjdG9yID0gbm9kZVNlcDtcbn1cblxuZnVuY3Rpb24gZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gZy5jaGlsZHJlbih2KTtcbiAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpZiAodiAhPT0gcm9vdCkge1xuICAgICAgZy5zZXRFZGdlKHJvb3QsIHYsIHsgd2VpZ2h0OiAwLCBtaW5sZW46IG5vZGVTZXAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0b3AgPSB1dGlsLmFkZEJvcmRlck5vZGUoZywgXCJfYnRcIik7XG4gIHZhciBib3R0b20gPSB1dGlsLmFkZEJvcmRlck5vZGUoZywgXCJfYmJcIik7XG4gIHZhciBsYWJlbCA9IGcubm9kZSh2KTtcblxuICBnLnNldFBhcmVudCh0b3AsIHYpO1xuICBsYWJlbC5ib3JkZXJUb3AgPSB0b3A7XG4gIGcuc2V0UGFyZW50KGJvdHRvbSwgdik7XG4gIGxhYmVsLmJvcmRlckJvdHRvbSA9IGJvdHRvbTtcblxuICBfLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIGNoaWxkKTtcblxuICAgIHZhciBjaGlsZE5vZGUgPSBnLm5vZGUoY2hpbGQpO1xuICAgIHZhciBjaGlsZFRvcCA9IGNoaWxkTm9kZS5ib3JkZXJUb3AgPyBjaGlsZE5vZGUuYm9yZGVyVG9wIDogY2hpbGQ7XG4gICAgdmFyIGNoaWxkQm90dG9tID0gY2hpbGROb2RlLmJvcmRlckJvdHRvbSA/IGNoaWxkTm9kZS5ib3JkZXJCb3R0b20gOiBjaGlsZDtcbiAgICB2YXIgdGhpc1dlaWdodCA9IGNoaWxkTm9kZS5ib3JkZXJUb3AgPyB3ZWlnaHQgOiAyICogd2VpZ2h0O1xuICAgIHZhciBtaW5sZW4gPSBjaGlsZFRvcCAhPT0gY2hpbGRCb3R0b20gPyAxIDogaGVpZ2h0IC0gZGVwdGhzW3ZdICsgMTtcblxuICAgIGcuc2V0RWRnZSh0b3AsIGNoaWxkVG9wLCB7XG4gICAgICB3ZWlnaHQ6IHRoaXNXZWlnaHQsXG4gICAgICBtaW5sZW46IG1pbmxlbixcbiAgICAgIG5lc3RpbmdFZGdlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBnLnNldEVkZ2UoY2hpbGRCb3R0b20sIGJvdHRvbSwge1xuICAgICAgd2VpZ2h0OiB0aGlzV2VpZ2h0LFxuICAgICAgbWlubGVuOiBtaW5sZW4sXG4gICAgICBuZXN0aW5nRWRnZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoIWcucGFyZW50KHYpKSB7XG4gICAgZy5zZXRFZGdlKHJvb3QsIHRvcCwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogaGVpZ2h0ICsgZGVwdGhzW3ZdIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyZWVEZXB0aHMoZykge1xuICB2YXIgZGVwdGhzID0ge307XG4gIGZ1bmN0aW9uIGRmcyh2LCBkZXB0aCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBkZnMoY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVwdGhzW3ZdID0gZGVwdGg7XG4gIH1cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZnVuY3Rpb24odikgeyBkZnModiwgMSk7IH0pO1xuICByZXR1cm4gZGVwdGhzO1xufVxuXG5mdW5jdGlvbiBzdW1XZWlnaHRzKGcpIHtcbiAgcmV0dXJuIF8ucmVkdWNlKGcuZWRnZXMoKSwgZnVuY3Rpb24oYWNjLCBlKSB7XG4gICAgcmV0dXJuIGFjYyArIGcuZWRnZShlKS53ZWlnaHQ7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwKGcpIHtcbiAgdmFyIGdyYXBoTGFiZWwgPSBnLmdyYXBoKCk7XG4gIGcucmVtb3ZlTm9kZShncmFwaExhYmVsLm5lc3RpbmdSb290KTtcbiAgZGVsZXRlIGdyYXBoTGFiZWwubmVzdGluZ1Jvb3Q7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS5uZXN0aW5nRWRnZSkge1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydW46IHJ1bixcbiAgdW5kbzogdW5kb1xufTtcblxuLypcbiAqIEJyZWFrcyBhbnkgbG9uZyBlZGdlcyBpbiB0aGUgZ3JhcGggaW50byBzaG9ydCBzZWdtZW50cyB0aGF0IHNwYW4gMSBsYXllclxuICogZWFjaC4gVGhpcyBvcGVyYXRpb24gaXMgdW5kb2FibGUgd2l0aCB0aGUgZGVub3JtYWxpemUgZnVuY3Rpb24uXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gVGhlIGlucHV0IGdyYXBoIGlzIGEgREFHLlxuICogICAgMi4gRWFjaCBub2RlIGluIHRoZSBncmFwaCBoYXMgYSBcInJhbmtcIiBwcm9wZXJ0eS5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbjpcbiAqXG4gKiAgICAxLiBBbGwgZWRnZXMgaW4gdGhlIGdyYXBoIGhhdmUgYSBsZW5ndGggb2YgMS5cbiAqICAgIDIuIER1bW15IG5vZGVzIGFyZSBhZGRlZCB3aGVyZSBlZGdlcyBoYXZlIGJlZW4gc3BsaXQgaW50byBzZWdtZW50cy5cbiAqICAgIDMuIFRoZSBncmFwaCBpcyBhdWdtZW50ZWQgd2l0aCBhIFwiZHVtbXlDaGFpbnNcIiBhdHRyaWJ1dGUgd2hpY2ggY29udGFpbnNcbiAqICAgICAgIHRoZSBmaXJzdCBkdW1teSBpbiBlYWNoIGNoYWluIG9mIGR1bW15IG5vZGVzIHByb2R1Y2VkLlxuICovXG5mdW5jdGlvbiBydW4oZykge1xuICBnLmdyYXBoKCkuZHVtbXlDaGFpbnMgPSBbXTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZWRnZSkgeyBub3JtYWxpemVFZGdlKGcsIGVkZ2UpOyB9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRWRnZShnLCBlKSB7XG4gIHZhciB2ID0gZS52O1xuICB2YXIgdlJhbmsgPSBnLm5vZGUodikucmFuaztcbiAgdmFyIHcgPSBlLnc7XG4gIHZhciB3UmFuayA9IGcubm9kZSh3KS5yYW5rO1xuICB2YXIgbmFtZSA9IGUubmFtZTtcbiAgdmFyIGVkZ2VMYWJlbCA9IGcuZWRnZShlKTtcbiAgdmFyIGxhYmVsUmFuayA9IGVkZ2VMYWJlbC5sYWJlbFJhbms7XG5cbiAgaWYgKHdSYW5rID09PSB2UmFuayArIDEpIHJldHVybjtcblxuICBnLnJlbW92ZUVkZ2UoZSk7XG5cbiAgdmFyIGR1bW15LCBhdHRycywgaTtcbiAgZm9yIChpID0gMCwgKyt2UmFuazsgdlJhbmsgPCB3UmFuazsgKytpLCArK3ZSYW5rKSB7XG4gICAgZWRnZUxhYmVsLnBvaW50cyA9IFtdO1xuICAgIGF0dHJzID0ge1xuICAgICAgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIGVkZ2VMYWJlbDogZWRnZUxhYmVsLCBlZGdlT2JqOiBlLFxuICAgICAgcmFuazogdlJhbmtcbiAgICB9O1xuICAgIGR1bW15ID0gdXRpbC5hZGREdW1teU5vZGUoZywgXCJlZGdlXCIsIGF0dHJzLCBcIl9kXCIpO1xuICAgIGlmICh2UmFuayA9PT0gbGFiZWxSYW5rKSB7XG4gICAgICBhdHRycy53aWR0aCA9IGVkZ2VMYWJlbC53aWR0aDtcbiAgICAgIGF0dHJzLmhlaWdodCA9IGVkZ2VMYWJlbC5oZWlnaHQ7XG4gICAgICBhdHRycy5kdW1teSA9IFwiZWRnZS1sYWJlbFwiO1xuICAgICAgYXR0cnMubGFiZWxwb3MgPSBlZGdlTGFiZWwubGFiZWxwb3M7XG4gICAgfVxuICAgIGcuc2V0RWRnZSh2LCBkdW1teSwgeyB3ZWlnaHQ6IGVkZ2VMYWJlbC53ZWlnaHQgfSwgbmFtZSk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcuZ3JhcGgoKS5kdW1teUNoYWlucy5wdXNoKGR1bW15KTtcbiAgICB9XG4gICAgdiA9IGR1bW15O1xuICB9XG5cbiAgZy5zZXRFZGdlKHYsIHcsIHsgd2VpZ2h0OiBlZGdlTGFiZWwud2VpZ2h0IH0sIG5hbWUpO1xufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgXy5mb3JFYWNoKGcuZ3JhcGgoKS5kdW1teUNoYWlucywgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciBvcmlnTGFiZWwgPSBub2RlLmVkZ2VMYWJlbDtcbiAgICB2YXIgdztcbiAgICBnLnNldEVkZ2Uobm9kZS5lZGdlT2JqLCBvcmlnTGFiZWwpO1xuICAgIHdoaWxlIChub2RlLmR1bW15KSB7XG4gICAgICB3ID0gZy5zdWNjZXNzb3JzKHYpWzBdO1xuICAgICAgZy5yZW1vdmVOb2RlKHYpO1xuICAgICAgb3JpZ0xhYmVsLnBvaW50cy5wdXNoKHsgeDogbm9kZS54LCB5OiBub2RlLnkgfSk7XG4gICAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJlZGdlLWxhYmVsXCIpIHtcbiAgICAgICAgb3JpZ0xhYmVsLnggPSBub2RlLng7XG4gICAgICAgIG9yaWdMYWJlbC55ID0gbm9kZS55O1xuICAgICAgICBvcmlnTGFiZWwud2lkdGggPSBub2RlLndpZHRoO1xuICAgICAgICBvcmlnTGFiZWwuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB2ID0gdztcbiAgICAgIG5vZGUgPSBnLm5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTdWJncmFwaENvbnN0cmFpbnRzO1xuXG5mdW5jdGlvbiBhZGRTdWJncmFwaENvbnN0cmFpbnRzKGcsIGNnLCB2cykge1xuICB2YXIgcHJldiA9IHt9LFxuICAgIHJvb3RQcmV2O1xuXG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBjaGlsZCA9IGcucGFyZW50KHYpLFxuICAgICAgcGFyZW50LFxuICAgICAgcHJldkNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgcGFyZW50ID0gZy5wYXJlbnQoY2hpbGQpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2W3BhcmVudF07XG4gICAgICAgIHByZXZbcGFyZW50XSA9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkNoaWxkID0gcm9vdFByZXY7XG4gICAgICAgIHJvb3RQcmV2ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoaWxkICYmIHByZXZDaGlsZCAhPT0gY2hpbGQpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2Q2hpbGQsIGNoaWxkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKlxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYgPyBnLmNoaWxkcmVuKHYpIDogZy5jaGlsZHJlbigpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgc3ViZ3JhcGhzID0gW107XG4gICAgICBfLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZE1pbiA9IGRmcyhjaGlsZCk7XG4gICAgICAgIGlmIChnLmNoaWxkcmVuKGNoaWxkKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdWJncmFwaHMucHVzaCh7IHY6IGNoaWxkLCBvcmRlcjogY2hpbGRNaW4gfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBjaGlsZE1pbik7XG4gICAgICB9KTtcbiAgICAgIF8ucmVkdWNlKF8uc29ydEJ5KHN1YmdyYXBocywgXCJvcmRlclwiKSwgZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICBjZy5zZXRFZGdlKHByZXYudiwgY3Vyci52KTtcbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIHJldHVybiBnLm5vZGUodikub3JkZXI7XG4gIH1cbiAgZGZzKHVuZGVmaW5lZCk7XG4gICovXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFyeWNlbnRlcjtcblxuZnVuY3Rpb24gYmFyeWNlbnRlcihnLCBtb3ZhYmxlKSB7XG4gIHJldHVybiBfLm1hcChtb3ZhYmxlLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGluViA9IGcuaW5FZGdlcyh2KTtcbiAgICBpZiAoIWluVi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHY6IHYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IF8ucmVkdWNlKGluViwgZnVuY3Rpb24oYWNjLCBlKSB7XG4gICAgICAgIHZhciBlZGdlID0gZy5lZGdlKGUpLFxuICAgICAgICAgIG5vZGVVID0gZy5ub2RlKGUudik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VtOiBhY2Muc3VtICsgKGVkZ2Uud2VpZ2h0ICogbm9kZVUub3JkZXIpLFxuICAgICAgICAgIHdlaWdodDogYWNjLndlaWdodCArIGVkZ2Uud2VpZ2h0XG4gICAgICAgIH07XG4gICAgICB9LCB7IHN1bTogMCwgd2VpZ2h0OiAwIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiB2LFxuICAgICAgICBiYXJ5Y2VudGVyOiByZXN1bHQuc3VtIC8gcmVzdWx0LndlaWdodCxcbiAgICAgICAgd2VpZ2h0OiByZXN1bHQud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZExheWVyR3JhcGg7XG5cbi8qXG4gKiBDb25zdHJ1Y3RzIGEgZ3JhcGggdGhhdCBjYW4gYmUgdXNlZCB0byBzb3J0IGEgbGF5ZXIgb2Ygbm9kZXMuIFRoZSBncmFwaCB3aWxsXG4gKiBjb250YWluIGFsbCBiYXNlIGFuZCBzdWJncmFwaCBub2RlcyBmcm9tIHRoZSByZXF1ZXN0IGxheWVyIGluIHRoZWlyIG9yaWdpbmFsXG4gKiBoaWVyYXJjaHkgYW5kIGFueSBlZGdlcyB0aGF0IGFyZSBpbmNpZGVudCBvbiB0aGVzZSBub2RlcyBhbmQgYXJlIG9mIHRoZSB0eXBlXG4gKiByZXF1ZXN0ZWQgYnkgdGhlIFwicmVsYXRpb25zaGlwXCIgcGFyYW1ldGVyLlxuICpcbiAqIE5vZGVzIGZyb20gdGhlIHJlcXVlc3RlZCByYW5rIHRoYXQgZG8gbm90IGhhdmUgcGFyZW50cyBhcmUgYXNzaWduZWQgYSByb290XG4gKiBub2RlIGluIHRoZSBvdXRwdXQgZ3JhcGgsIHdoaWNoIGlzIHNldCBpbiB0aGUgcm9vdCBncmFwaCBhdHRyaWJ1dGUuIFRoaXNcbiAqIG1ha2VzIGl0IGVhc3kgdG8gd2FsayB0aGUgaGllcmFyY2h5IG9mIG1vdmFibGUgbm9kZXMgZHVyaW5nIG9yZGVyaW5nLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBCYXNlIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXZlIGEgcmFuayBhdHRyaWJ1dGVcbiAqICAgIDMuIFN1YmdyYXBoIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgbWluUmFuayBhbmQgbWF4UmFuayBhdHRyaWJ1dGVzXG4gKiAgICA0LiBFZGdlcyBoYXZlIGFuIGFzc2lnbmVkIHdlaWdodFxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBPdXRwdXQgZ3JhcGggaGFzIGFsbCBub2RlcyBpbiB0aGUgbW92YWJsZSByYW5rIHdpdGggcHJlc2VydmVkXG4gKiAgICAgICBoaWVyYXJjaHkuXG4gKiAgICAyLiBSb290IG5vZGVzIGluIHRoZSBtb3ZhYmxlIGxheWVyIGFyZSBtYWRlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gKiAgICAgICBpbmRpY2F0ZWQgYnkgdGhlIHJvb3QgYXR0cmlidXRlIG9mIHRoZSBncmFwaC5cbiAqICAgIDMuIE5vbi1tb3ZhYmxlIG5vZGVzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZVxuICogICAgICAgcmVsYXRpb25zaGlwIHBhcmFtZXRlciwgYXJlIGluY2x1ZGVkIGluIHRoZSBncmFwaCAod2l0aG91dCBoaWVyYXJjaHkpLlxuICogICAgNC4gRWRnZXMgaW5jaWRlbnQgb24gbW92YWJsZSBub2Rlcywgc2VsZWN0ZWQgYnkgdGhlIHJlbGF0aW9uc2hpcFxuICogICAgICAgcGFyYW1ldGVyLCBhcmUgYWRkZWQgdG8gdGhlIG91dHB1dCBncmFwaC5cbiAqICAgIDUuIFRoZSB3ZWlnaHRzIGZvciBjb3BpZWQgZWRnZXMgYXJlIGFnZ3JlZ2F0ZWQgYXMgbmVlZCwgc2luY2UgdGhlIG91dHB1dFxuICogICAgICAgZ3JhcGggaXMgbm90IGEgbXVsdGktZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5ZXJHcmFwaChnLCByYW5rLCByZWxhdGlvbnNoaXApIHtcbiAgdmFyIHJvb3QgPSBjcmVhdGVSb290Tm9kZShnKSxcbiAgICByZXN1bHQgPSBuZXcgR3JhcGgoeyBjb21wb3VuZDogdHJ1ZSB9KS5zZXRHcmFwaCh7IHJvb3Q6IHJvb3QgfSlcbiAgICAgIC5zZXREZWZhdWx0Tm9kZUxhYmVsKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpLFxuICAgICAgcGFyZW50ID0gZy5wYXJlbnQodik7XG5cbiAgICBpZiAobm9kZS5yYW5rID09PSByYW5rIHx8IG5vZGUubWluUmFuayA8PSByYW5rICYmIHJhbmsgPD0gbm9kZS5tYXhSYW5rKSB7XG4gICAgICByZXN1bHQuc2V0Tm9kZSh2KTtcbiAgICAgIHJlc3VsdC5zZXRQYXJlbnQodiwgcGFyZW50IHx8IHJvb3QpO1xuXG4gICAgICAvLyBUaGlzIGFzc3VtZXMgd2UgaGF2ZSBvbmx5IHNob3J0IGVkZ2VzIVxuICAgICAgXy5mb3JFYWNoKGdbcmVsYXRpb25zaGlwXSh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdSA9IGUudiA9PT0gdiA/IGUudyA6IGUudixcbiAgICAgICAgICBlZGdlID0gcmVzdWx0LmVkZ2UodSwgdiksXG4gICAgICAgICAgd2VpZ2h0ID0gIV8uaXNVbmRlZmluZWQoZWRnZSkgPyBlZGdlLndlaWdodCA6IDA7XG4gICAgICAgIHJlc3VsdC5zZXRFZGdlKHUsIHYsIHsgd2VpZ2h0OiBnLmVkZ2UoZSkud2VpZ2h0ICsgd2VpZ2h0IH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChfLmhhcyhub2RlLCBcIm1pblJhbmtcIikpIHtcbiAgICAgICAgcmVzdWx0LnNldE5vZGUodiwge1xuICAgICAgICAgIGJvcmRlckxlZnQ6IG5vZGUuYm9yZGVyTGVmdFtyYW5rXSxcbiAgICAgICAgICBib3JkZXJSaWdodDogbm9kZS5ib3JkZXJSaWdodFtyYW5rXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3ROb2RlKGcpIHtcbiAgdmFyIHY7XG4gIHdoaWxlIChnLmhhc05vZGUoKHYgPSBfLnVuaXF1ZUlkKFwiX3Jvb3RcIikpKSk7XG4gIHJldHVybiB2O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcm9zc0NvdW50O1xuXG4vKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgbGF5ZXJpbmcgKGFuIGFycmF5IG9mIGxheWVycywgZWFjaCB3aXRoIGFuIGFycmF5IG9mXG4gKiBvcmRlcmVyZCBub2RlcykgYW5kIGEgZ3JhcGggYW5kIHJldHVybnMgYSB3ZWlnaHRlZCBjcm9zc2luZyBjb3VudC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBtdXN0IGJlIHNpbXBsZSAobm90IGEgbXVsdGlncmFwaCksIGRpcmVjdGVkLCBhbmQgaW5jbHVkZVxuICogICAgICAgb25seSBzaW1wbGUgZWRnZXMuXG4gKiAgICAyLiBFZGdlcyBpbiB0aGUgaW5wdXQgZ3JhcGggbXVzdCBoYXZlIGFzc2lnbmVkIHdlaWdodHMuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBncmFwaCBhbmQgbGF5ZXJpbmcgbWF0cml4IGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBkZXJpdmVkIGZyb20gQmFydGgsIGV0IGFsLiwgXCJCaWxheWVyIENyb3NzIENvdW50aW5nLlwiXG4gKi9cbmZ1bmN0aW9uIGNyb3NzQ291bnQoZywgbGF5ZXJpbmcpIHtcbiAgdmFyIGNjID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYXllcmluZy5sZW5ndGg7ICsraSkge1xuICAgIGNjICs9IHR3b0xheWVyQ3Jvc3NDb3VudChnLCBsYXllcmluZ1tpLTFdLCBsYXllcmluZ1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNjO1xufVxuXG5mdW5jdGlvbiB0d29MYXllckNyb3NzQ291bnQoZywgbm9ydGhMYXllciwgc291dGhMYXllcikge1xuICAvLyBTb3J0IGFsbCBvZiB0aGUgZWRnZXMgYmV0d2VlbiB0aGUgbm9ydGggYW5kIHNvdXRoIGxheWVycyBieSB0aGVpciBwb3NpdGlvblxuICAvLyBpbiB0aGUgbm9ydGggbGF5ZXIgYW5kIHRoZW4gdGhlIHNvdXRoLiBNYXAgdGhlc2UgZWRnZXMgdG8gdGhlIHBvc2l0aW9uIG9mXG4gIC8vIHRoZWlyIGhlYWQgaW4gdGhlIHNvdXRoIGxheWVyLlxuICB2YXIgc291dGhQb3MgPSBfLnppcE9iamVjdChzb3V0aExheWVyLFxuICAgIF8ubWFwKHNvdXRoTGF5ZXIsIGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBpOyB9KSk7XG4gIHZhciBzb3V0aEVudHJpZXMgPSBfLmZsYXR0ZW4oXy5tYXAobm9ydGhMYXllciwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLnNvcnRCeShfLm1hcChnLm91dEVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4geyBwb3M6IHNvdXRoUG9zW2Uud10sIHdlaWdodDogZy5lZGdlKGUpLndlaWdodCB9O1xuICAgIH0pLCBcInBvc1wiKTtcbiAgfSksIHRydWUpO1xuXG4gIC8vIEJ1aWxkIHRoZSBhY2N1bXVsYXRvciB0cmVlXG4gIHZhciBmaXJzdEluZGV4ID0gMTtcbiAgd2hpbGUgKGZpcnN0SW5kZXggPCBzb3V0aExheWVyLmxlbmd0aCkgZmlyc3RJbmRleCA8PD0gMTtcbiAgdmFyIHRyZWVTaXplID0gMiAqIGZpcnN0SW5kZXggLSAxO1xuICBmaXJzdEluZGV4IC09IDE7XG4gIHZhciB0cmVlID0gXy5tYXAobmV3IEFycmF5KHRyZWVTaXplKSwgZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIHdlaWdodGVkIGNyb3NzaW5nc1xuICB2YXIgY2MgPSAwO1xuICBfLmZvckVhY2goc291dGhFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICB2YXIgaW5kZXggPSBlbnRyeS5wb3MgKyBmaXJzdEluZGV4O1xuICAgIHRyZWVbaW5kZXhdICs9IGVudHJ5LndlaWdodDtcbiAgICB2YXIgd2VpZ2h0U3VtID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgIHdlaWdodFN1bSArPSB0cmVlW2luZGV4ICsgMV07XG4gICAgICB9XG4gICAgICBpbmRleCA9IChpbmRleCAtIDEpID4+IDE7XG4gICAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgfVxuICAgIGNjICs9IGVudHJ5LndlaWdodCAqIHdlaWdodFN1bTtcbiAgfSkpO1xuXG4gIHJldHVybiBjYztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgaW5pdE9yZGVyID0gcmVxdWlyZShcIi4vaW5pdC1vcmRlclwiKTtcbnZhciBjcm9zc0NvdW50ID0gcmVxdWlyZShcIi4vY3Jvc3MtY291bnRcIik7XG52YXIgc29ydFN1YmdyYXBoID0gcmVxdWlyZShcIi4vc29ydC1zdWJncmFwaFwiKTtcbnZhciBidWlsZExheWVyR3JhcGggPSByZXF1aXJlKFwiLi9idWlsZC1sYXllci1ncmFwaFwiKTtcbnZhciBhZGRTdWJncmFwaENvbnN0cmFpbnRzID0gcmVxdWlyZShcIi4vYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlcjtcblxuLypcbiAqIEFwcGxpZXMgaGV1cmlzdGljcyB0byBtaW5pbWl6ZSBlZGdlIGNyb3NzaW5ncyBpbiB0aGUgZ3JhcGggYW5kIHNldHMgdGhlIGJlc3RcbiAqIG9yZGVyIHNvbHV0aW9uIGFzIGFuIG9yZGVyIGF0dHJpYnV0ZSBvbiBlYWNoIG5vZGUuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0cyB3aXRoIGEgXCJyYW5rXCIgYXR0cmlidXRlXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgdGhlIFwid2VpZ2h0XCIgYXR0cmlidXRlXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhbiBcIm9yZGVyXCIgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZVxuICogICAgICAgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBvcmRlcihnKSB7XG4gIHZhciBtYXhSYW5rID0gdXRpbC5tYXhSYW5rKGcpLFxuICAgIGRvd25MYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgXy5yYW5nZSgxLCBtYXhSYW5rICsgMSksIFwiaW5FZGdlc1wiKSxcbiAgICB1cExheWVyR3JhcGhzID0gYnVpbGRMYXllckdyYXBocyhnLCBfLnJhbmdlKG1heFJhbmsgLSAxLCAtMSwgLTEpLCBcIm91dEVkZ2VzXCIpO1xuXG4gIHZhciBsYXllcmluZyA9IGluaXRPcmRlcihnKTtcbiAgYXNzaWduT3JkZXIoZywgbGF5ZXJpbmcpO1xuXG4gIHZhciBiZXN0Q0MgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgYmVzdDtcblxuICBmb3IgKHZhciBpID0gMCwgbGFzdEJlc3QgPSAwOyBsYXN0QmVzdCA8IDQ7ICsraSwgKytsYXN0QmVzdCkge1xuICAgIHN3ZWVwTGF5ZXJHcmFwaHMoaSAlIDIgPyBkb3duTGF5ZXJHcmFwaHMgOiB1cExheWVyR3JhcGhzLCBpICUgNCA+PSAyKTtcblxuICAgIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICAgIHZhciBjYyA9IGNyb3NzQ291bnQoZywgbGF5ZXJpbmcpO1xuICAgIGlmIChjYyA8IGJlc3RDQykge1xuICAgICAgbGFzdEJlc3QgPSAwO1xuICAgICAgYmVzdCA9IF8uY2xvbmVEZWVwKGxheWVyaW5nKTtcbiAgICAgIGJlc3RDQyA9IGNjO1xuICAgIH1cbiAgfVxuXG4gIGFzc2lnbk9yZGVyKGcsIGJlc3QpO1xufVxuXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGhzKGcsIHJhbmtzLCByZWxhdGlvbnNoaXApIHtcbiAgcmV0dXJuIF8ubWFwKHJhbmtzLCBmdW5jdGlvbihyYW5rKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGF5ZXJHcmFwaChnLCByYW5rLCByZWxhdGlvbnNoaXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dlZXBMYXllckdyYXBocyhsYXllckdyYXBocywgYmlhc1JpZ2h0KSB7XG4gIHZhciBjZyA9IG5ldyBHcmFwaCgpO1xuICBfLmZvckVhY2gobGF5ZXJHcmFwaHMsIGZ1bmN0aW9uKGxnKSB7XG4gICAgdmFyIHJvb3QgPSBsZy5ncmFwaCgpLnJvb3Q7XG4gICAgdmFyIHNvcnRlZCA9IHNvcnRTdWJncmFwaChsZywgcm9vdCwgY2csIGJpYXNSaWdodCk7XG4gICAgXy5mb3JFYWNoKHNvcnRlZC52cywgZnVuY3Rpb24odiwgaSkge1xuICAgICAgbGcubm9kZSh2KS5vcmRlciA9IGk7XG4gICAgfSk7XG4gICAgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhsZywgY2csIHNvcnRlZC52cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25PcmRlcihnLCBsYXllcmluZykge1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICBnLm5vZGUodikub3JkZXIgPSBpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdE9yZGVyO1xuXG4vKlxuICogQXNzaWducyBhbiBpbml0aWFsIG9yZGVyIHZhbHVlIGZvciBlYWNoIG5vZGUgYnkgcGVyZm9ybWluZyBhIERGUyBzZWFyY2hcbiAqIHN0YXJ0aW5nIGZyb20gbm9kZXMgaW4gdGhlIGZpcnN0IHJhbmsuIE5vZGVzIGFyZSBhc3NpZ25lZCBhbiBvcmRlciBpbiB0aGVpclxuICogcmFuayBhcyB0aGV5IGFyZSBmaXJzdCB2aXNpdGVkLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggY29tZXMgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWUgZm9yIERyYXdpbmcgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICpcbiAqIFJldHVybnMgYSBsYXllcmluZyBtYXRyaXggd2l0aCBhbiBhcnJheSBwZXIgbGF5ZXIgYW5kIGVhY2ggbGF5ZXIgc29ydGVkIGJ5XG4gKiB0aGUgb3JkZXIgb2YgaXRzIG5vZGVzLlxuICovXG5mdW5jdGlvbiBpbml0T3JkZXIoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgc2ltcGxlTm9kZXMgPSBfLmZpbHRlcihnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gIWcuY2hpbGRyZW4odikubGVuZ3RoO1xuICB9KTtcbiAgdmFyIG1heFJhbmsgPSBfLm1heChfLm1hcChzaW1wbGVOb2RlcywgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcbiAgdmFyIGxheWVycyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGxheWVyc1tub2RlLnJhbmtdLnB1c2godik7XG4gICAgXy5mb3JFYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgfVxuXG4gIHZhciBvcmRlcmVkVnMgPSBfLnNvcnRCeShzaW1wbGVOb2RlcywgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pO1xuICBfLmZvckVhY2gob3JkZXJlZFZzLCBkZnMpO1xuXG4gIHJldHVybiBsYXllcnM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVDb25mbGljdHM7XG5cbi8qXG4gKiBHaXZlbiBhIGxpc3Qgb2YgZW50cmllcyBvZiB0aGUgZm9ybSB7diwgYmFyeWNlbnRlciwgd2VpZ2h0fSBhbmQgYVxuICogY29uc3RyYWludCBncmFwaCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVzb2x2ZSBhbnkgY29uZmxpY3RzIGJldHdlZW4gdGhlXG4gKiBjb25zdHJhaW50IGdyYXBoIGFuZCB0aGUgYmFyeWNlbnRlcnMgZm9yIHRoZSBlbnRyaWVzLiBJZiB0aGUgYmFyeWNlbnRlcnMgZm9yXG4gKiBhbiBlbnRyeSB3b3VsZCB2aW9sYXRlIGEgY29uc3RyYWludCBpbiB0aGUgY29uc3RyYWludCBncmFwaCB0aGVuIHdlIGNvYWxlc2NlXG4gKiB0aGUgbm9kZXMgaW4gdGhlIGNvbmZsaWN0IGludG8gYSBuZXcgbm9kZSB0aGF0IHJlc3BlY3RzIHRoZSBjb250cmFpbnQgYW5kXG4gKiBhZ2dyZWdhdGVzIGJhcnljZW50ZXIgYW5kIHdlaWdodCBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBkZXNjcmlwdGlvbiBpbiBGb3JzdGVyLCBcIkEgRmFzdCBhbmRcbiAqIFNpbXBsZSBIdWVyaXN0aWMgZm9yIENvbnN0cmFpbmVkIFR3by1MZXZlbCBDcm9zc2luZyBSZWR1Y3Rpb24sXCIgdGhvdWdodCBpdFxuICogZGlmZmVycyBpbiBzb21lIHNwZWNpZmljIGRldGFpbHMuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gRWFjaCBlbnRyeSBoYXMgdGhlIGZvcm0ge3YsIGJhcnljZW50ZXIsIHdlaWdodH0sIG9yIGlmIHRoZSBub2RlIGhhc1xuICogICAgICAgbm8gYmFyeWNlbnRlciwgdGhlbiB7dn0uXG4gKlxuICogUmV0dXJuczpcbiAqXG4gKiAgICBBIG5ldyBsaXN0IG9mIGVudHJpZXMgb2YgdGhlIGZvcm0ge3ZzLCBpLCBiYXJ5Y2VudGVyLCB3ZWlnaHR9LiBUaGUgbGlzdFxuICogICAgYHZzYCBtYXkgZWl0aGVyIGJlIGEgc2luZ2xldG9uIG9yIGl0IG1heSBiZSBhbiBhZ2dyZWdhdGlvbiBvZiBub2Rlc1xuICogICAgb3JkZXJlZCBzdWNoIHRoYXQgdGhleSBkbyBub3QgdmlvbGF0ZSBjb25zdHJhaW50cyBmcm9tIHRoZSBjb25zdHJhaW50XG4gKiAgICBncmFwaC4gVGhlIHByb3BlcnR5IGBpYCBpcyB0aGUgbG93ZXN0IG9yaWdpbmFsIGluZGV4IG9mIGFueSBvZiB0aGVcbiAqICAgIGVsZW1lbnRzIGluIGB2c2AuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb25mbGljdHMoZW50cmllcywgY2cpIHtcbiAgdmFyIG1hcHBlZEVudHJpZXMgPSB7fTtcbiAgXy5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgdmFyIHRtcCA9IG1hcHBlZEVudHJpZXNbZW50cnkudl0gPSB7XG4gICAgICBpbmRlZ3JlZTogMCxcbiAgICAgIFwiaW5cIjogW10sXG4gICAgICBvdXQ6IFtdLFxuICAgICAgdnM6IFtlbnRyeS52XSxcbiAgICAgIGk6IGlcbiAgICB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRyeS5iYXJ5Y2VudGVyKSkge1xuICAgICAgdG1wLmJhcnljZW50ZXIgPSBlbnRyeS5iYXJ5Y2VudGVyO1xuICAgICAgdG1wLndlaWdodCA9IGVudHJ5LndlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChjZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVudHJ5ViA9IG1hcHBlZEVudHJpZXNbZS52XTtcbiAgICB2YXIgZW50cnlXID0gbWFwcGVkRW50cmllc1tlLnddO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRyeVYpICYmICFfLmlzVW5kZWZpbmVkKGVudHJ5VykpIHtcbiAgICAgIGVudHJ5Vy5pbmRlZ3JlZSsrO1xuICAgICAgZW50cnlWLm91dC5wdXNoKG1hcHBlZEVudHJpZXNbZS53XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgc291cmNlU2V0ID0gXy5maWx0ZXIobWFwcGVkRW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gIWVudHJ5LmluZGVncmVlO1xuICB9KTtcblxuICByZXR1cm4gZG9SZXNvbHZlQ29uZmxpY3RzKHNvdXJjZVNldCk7XG59XG5cbmZ1bmN0aW9uIGRvUmVzb2x2ZUNvbmZsaWN0cyhzb3VyY2VTZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBoYW5kbGVJbih2RW50cnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odUVudHJ5KSB7XG4gICAgICBpZiAodUVudHJ5Lm1lcmdlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1RW50cnkuYmFyeWNlbnRlcikgfHxcbiAgICAgICAgICBfLmlzVW5kZWZpbmVkKHZFbnRyeS5iYXJ5Y2VudGVyKSB8fFxuICAgICAgICAgIHVFbnRyeS5iYXJ5Y2VudGVyID49IHZFbnRyeS5iYXJ5Y2VudGVyKSB7XG4gICAgICAgIG1lcmdlRW50cmllcyh2RW50cnksIHVFbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU91dCh2RW50cnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24od0VudHJ5KSB7XG4gICAgICB3RW50cnlbXCJpblwiXS5wdXNoKHZFbnRyeSk7XG4gICAgICBpZiAoLS13RW50cnkuaW5kZWdyZWUgPT09IDApIHtcbiAgICAgICAgc291cmNlU2V0LnB1c2god0VudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgd2hpbGUgKHNvdXJjZVNldC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBzb3VyY2VTZXQucG9wKCk7XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICBfLmZvckVhY2goZW50cnlbXCJpblwiXS5yZXZlcnNlKCksIGhhbmRsZUluKGVudHJ5KSk7XG4gICAgXy5mb3JFYWNoKGVudHJ5Lm91dCwgaGFuZGxlT3V0KGVudHJ5KSk7XG4gIH1cblxuICByZXR1cm4gXy5tYXAoXy5maWx0ZXIoZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICFlbnRyeS5tZXJnZWQ7IH0pLFxuICAgIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gXy5waWNrKGVudHJ5LCBbXCJ2c1wiLCBcImlcIiwgXCJiYXJ5Y2VudGVyXCIsIFwid2VpZ2h0XCJdKTtcbiAgICB9KTtcblxufVxuXG5mdW5jdGlvbiBtZXJnZUVudHJpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciB3ZWlnaHQgPSAwO1xuXG4gIGlmICh0YXJnZXQud2VpZ2h0KSB7XG4gICAgc3VtICs9IHRhcmdldC5iYXJ5Y2VudGVyICogdGFyZ2V0LndlaWdodDtcbiAgICB3ZWlnaHQgKz0gdGFyZ2V0LndlaWdodDtcbiAgfVxuXG4gIGlmIChzb3VyY2Uud2VpZ2h0KSB7XG4gICAgc3VtICs9IHNvdXJjZS5iYXJ5Y2VudGVyICogc291cmNlLndlaWdodDtcbiAgICB3ZWlnaHQgKz0gc291cmNlLndlaWdodDtcbiAgfVxuXG4gIHRhcmdldC52cyA9IHNvdXJjZS52cy5jb25jYXQodGFyZ2V0LnZzKTtcbiAgdGFyZ2V0LmJhcnljZW50ZXIgPSBzdW0gLyB3ZWlnaHQ7XG4gIHRhcmdldC53ZWlnaHQgPSB3ZWlnaHQ7XG4gIHRhcmdldC5pID0gTWF0aC5taW4oc291cmNlLmksIHRhcmdldC5pKTtcbiAgc291cmNlLm1lcmdlZCA9IHRydWU7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgYmFyeWNlbnRlciA9IHJlcXVpcmUoXCIuL2JhcnljZW50ZXJcIik7XG52YXIgcmVzb2x2ZUNvbmZsaWN0cyA9IHJlcXVpcmUoXCIuL3Jlc29sdmUtY29uZmxpY3RzXCIpO1xudmFyIHNvcnQgPSByZXF1aXJlKFwiLi9zb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRTdWJncmFwaDtcblxuZnVuY3Rpb24gc29ydFN1YmdyYXBoKGcsIHYsIGNnLCBiaWFzUmlnaHQpIHtcbiAgdmFyIG1vdmFibGUgPSBnLmNoaWxkcmVuKHYpO1xuICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgdmFyIGJsID0gbm9kZSA/IG5vZGUuYm9yZGVyTGVmdCA6IHVuZGVmaW5lZDtcbiAgdmFyIGJyID0gbm9kZSA/IG5vZGUuYm9yZGVyUmlnaHQ6IHVuZGVmaW5lZDtcbiAgdmFyIHN1YmdyYXBocyA9IHt9O1xuXG4gIGlmIChibCkge1xuICAgIG1vdmFibGUgPSBfLmZpbHRlcihtb3ZhYmxlLCBmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gdyAhPT0gYmwgJiYgdyAhPT0gYnI7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmFyeWNlbnRlcnMgPSBiYXJ5Y2VudGVyKGcsIG1vdmFibGUpO1xuICBfLmZvckVhY2goYmFyeWNlbnRlcnMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGcuY2hpbGRyZW4oZW50cnkudikubGVuZ3RoKSB7XG4gICAgICB2YXIgc3ViZ3JhcGhSZXN1bHQgPSBzb3J0U3ViZ3JhcGgoZywgZW50cnkudiwgY2csIGJpYXNSaWdodCk7XG4gICAgICBzdWJncmFwaHNbZW50cnkudl0gPSBzdWJncmFwaFJlc3VsdDtcbiAgICAgIGlmIChfLmhhcyhzdWJncmFwaFJlc3VsdCwgXCJiYXJ5Y2VudGVyXCIpKSB7XG4gICAgICAgIG1lcmdlQmFyeWNlbnRlcnMoZW50cnksIHN1YmdyYXBoUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyaWVzID0gcmVzb2x2ZUNvbmZsaWN0cyhiYXJ5Y2VudGVycywgY2cpO1xuICBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKTtcblxuICB2YXIgcmVzdWx0ID0gc29ydChlbnRyaWVzLCBiaWFzUmlnaHQpO1xuXG4gIGlmIChibCkge1xuICAgIHJlc3VsdC52cyA9IF8uZmxhdHRlbihbYmwsIHJlc3VsdC52cywgYnJdLCB0cnVlKTtcbiAgICBpZiAoZy5wcmVkZWNlc3NvcnMoYmwpLmxlbmd0aCkge1xuICAgICAgdmFyIGJsUHJlZCA9IGcubm9kZShnLnByZWRlY2Vzc29ycyhibClbMF0pLFxuICAgICAgICBiclByZWQgPSBnLm5vZGUoZy5wcmVkZWNlc3NvcnMoYnIpWzBdKTtcbiAgICAgIGlmICghXy5oYXMocmVzdWx0LCBcImJhcnljZW50ZXJcIikpIHtcbiAgICAgICAgcmVzdWx0LmJhcnljZW50ZXIgPSAwO1xuICAgICAgICByZXN1bHQud2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gKHJlc3VsdC5iYXJ5Y2VudGVyICogcmVzdWx0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBibFByZWQub3JkZXIgKyBiclByZWQub3JkZXIpIC8gKHJlc3VsdC53ZWlnaHQgKyAyKTtcbiAgICAgIHJlc3VsdC53ZWlnaHQgKz0gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKSB7XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGVudHJ5LnZzID0gXy5mbGF0dGVuKGVudHJ5LnZzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoc3ViZ3JhcGhzW3ZdKSB7XG4gICAgICAgIHJldHVybiBzdWJncmFwaHNbdl0udnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KSwgdHJ1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJhcnljZW50ZXJzKHRhcmdldCwgb3RoZXIpIHtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldC5iYXJ5Y2VudGVyKSkge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gKHRhcmdldC5iYXJ5Y2VudGVyICogdGFyZ2V0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuYmFyeWNlbnRlciAqIG90aGVyLndlaWdodCkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldC53ZWlnaHQgKyBvdGhlci53ZWlnaHQpO1xuICAgIHRhcmdldC53ZWlnaHQgKz0gb3RoZXIud2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gb3RoZXIuYmFyeWNlbnRlcjtcbiAgICB0YXJnZXQud2VpZ2h0ID0gb3RoZXIud2VpZ2h0O1xuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cbmZ1bmN0aW9uIHNvcnQoZW50cmllcywgYmlhc1JpZ2h0KSB7XG4gIHZhciBwYXJ0cyA9IHV0aWwucGFydGl0aW9uKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIF8uaGFzKGVudHJ5LCBcImJhcnljZW50ZXJcIik7XG4gIH0pO1xuICB2YXIgc29ydGFibGUgPSBwYXJ0cy5saHMsXG4gICAgdW5zb3J0YWJsZSA9IF8uc29ydEJ5KHBhcnRzLnJocywgZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuIC1lbnRyeS5pOyB9KSxcbiAgICB2cyA9IFtdLFxuICAgIHN1bSA9IDAsXG4gICAgd2VpZ2h0ID0gMCxcbiAgICB2c0luZGV4ID0gMDtcblxuICBzb3J0YWJsZS5zb3J0KGNvbXBhcmVXaXRoQmlhcyghIWJpYXNSaWdodCkpO1xuXG4gIHZzSW5kZXggPSBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgdnNJbmRleCk7XG5cbiAgXy5mb3JFYWNoKHNvcnRhYmxlLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2c0luZGV4ICs9IGVudHJ5LnZzLmxlbmd0aDtcbiAgICB2cy5wdXNoKGVudHJ5LnZzKTtcbiAgICBzdW0gKz0gZW50cnkuYmFyeWNlbnRlciAqIGVudHJ5LndlaWdodDtcbiAgICB3ZWlnaHQgKz0gZW50cnkud2VpZ2h0O1xuICAgIHZzSW5kZXggPSBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgdnNJbmRleCk7XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSB7IHZzOiBfLmZsYXR0ZW4odnMsIHRydWUpIH07XG4gIGlmICh3ZWlnaHQpIHtcbiAgICByZXN1bHQuYmFyeWNlbnRlciA9IHN1bSAvIHdlaWdodDtcbiAgICByZXN1bHQud2VpZ2h0ID0gd2VpZ2h0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVVbnNvcnRhYmxlKHZzLCB1bnNvcnRhYmxlLCBpbmRleCkge1xuICB2YXIgbGFzdDtcbiAgd2hpbGUgKHVuc29ydGFibGUubGVuZ3RoICYmIChsYXN0ID0gXy5sYXN0KHVuc29ydGFibGUpKS5pIDw9IGluZGV4KSB7XG4gICAgdW5zb3J0YWJsZS5wb3AoKTtcbiAgICB2cy5wdXNoKGxhc3QudnMpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlV2l0aEJpYXMoYmlhcykge1xuICByZXR1cm4gZnVuY3Rpb24oZW50cnlWLCBlbnRyeVcpIHtcbiAgICBpZiAoZW50cnlWLmJhcnljZW50ZXIgPCBlbnRyeVcuYmFyeWNlbnRlcikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoZW50cnlWLmJhcnljZW50ZXIgPiBlbnRyeVcuYmFyeWNlbnRlcikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuICFiaWFzID8gZW50cnlWLmkgLSBlbnRyeVcuaSA6IGVudHJ5Vy5pIC0gZW50cnlWLmk7XG4gIH07XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnREdW1teUNoYWlucztcblxuZnVuY3Rpb24gcGFyZW50RHVtbXlDaGFpbnMoZykge1xuICB2YXIgcG9zdG9yZGVyTnVtcyA9IHBvc3RvcmRlcihnKTtcblxuICBfLmZvckVhY2goZy5ncmFwaCgpLmR1bW15Q2hhaW5zLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIGVkZ2VPYmogPSBub2RlLmVkZ2VPYmo7XG4gICAgdmFyIHBhdGhEYXRhID0gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgZWRnZU9iai52LCBlZGdlT2JqLncpO1xuICAgIHZhciBwYXRoID0gcGF0aERhdGEucGF0aDtcbiAgICB2YXIgbGNhID0gcGF0aERhdGEubGNhO1xuICAgIHZhciBwYXRoSWR4ID0gMDtcbiAgICB2YXIgcGF0aFYgPSBwYXRoW3BhdGhJZHhdO1xuICAgIHZhciBhc2NlbmRpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKHYgIT09IGVkZ2VPYmoudykge1xuICAgICAgbm9kZSA9IGcubm9kZSh2KTtcblxuICAgICAgaWYgKGFzY2VuZGluZykge1xuICAgICAgICB3aGlsZSAoKHBhdGhWID0gcGF0aFtwYXRoSWR4XSkgIT09IGxjYSAmJlxuICAgICAgICAgICAgICAgZy5ub2RlKHBhdGhWKS5tYXhSYW5rIDwgbm9kZS5yYW5rKSB7XG4gICAgICAgICAgcGF0aElkeCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGhWID09PSBsY2EpIHtcbiAgICAgICAgICBhc2NlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWFzY2VuZGluZykge1xuICAgICAgICB3aGlsZSAocGF0aElkeCA8IHBhdGgubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgZy5ub2RlKHBhdGhWID0gcGF0aFtwYXRoSWR4ICsgMV0pLm1pblJhbmsgPD0gbm9kZS5yYW5rKSB7XG4gICAgICAgICAgcGF0aElkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICAgIH1cblxuICAgICAgZy5zZXRQYXJlbnQodiwgcGF0aFYpO1xuICAgICAgdiA9IGcuc3VjY2Vzc29ycyh2KVswXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBGaW5kIGEgcGF0aCBmcm9tIHYgdG8gdyB0aHJvdWdoIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIChMQ0EpLiBSZXR1cm4gdGhlXG4vLyBmdWxsIHBhdGggYW5kIHRoZSBMQ0EuXG5mdW5jdGlvbiBmaW5kUGF0aChnLCBwb3N0b3JkZXJOdW1zLCB2LCB3KSB7XG4gIHZhciB2UGF0aCA9IFtdO1xuICB2YXIgd1BhdGggPSBbXTtcbiAgdmFyIGxvdyA9IE1hdGgubWluKHBvc3RvcmRlck51bXNbdl0ubG93LCBwb3N0b3JkZXJOdW1zW3ddLmxvdyk7XG4gIHZhciBsaW0gPSBNYXRoLm1heChwb3N0b3JkZXJOdW1zW3ZdLmxpbSwgcG9zdG9yZGVyTnVtc1t3XS5saW0pO1xuICB2YXIgcGFyZW50O1xuICB2YXIgbGNhO1xuXG4gIC8vIFRyYXZlcnNlIHVwIGZyb20gdiB0byBmaW5kIHRoZSBMQ0FcbiAgcGFyZW50ID0gdjtcbiAgZG8ge1xuICAgIHBhcmVudCA9IGcucGFyZW50KHBhcmVudCk7XG4gICAgdlBhdGgucHVzaChwYXJlbnQpO1xuICB9IHdoaWxlIChwYXJlbnQgJiZcbiAgICAgICAgICAgKHBvc3RvcmRlck51bXNbcGFyZW50XS5sb3cgPiBsb3cgfHwgbGltID4gcG9zdG9yZGVyTnVtc1twYXJlbnRdLmxpbSkpO1xuICBsY2EgPSBwYXJlbnQ7XG5cbiAgLy8gVHJhdmVyc2UgZnJvbSB3IHRvIExDQVxuICBwYXJlbnQgPSB3O1xuICB3aGlsZSAoKHBhcmVudCA9IGcucGFyZW50KHBhcmVudCkpICE9PSBsY2EpIHtcbiAgICB3UGF0aC5wdXNoKHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4geyBwYXRoOiB2UGF0aC5jb25jYXQod1BhdGgucmV2ZXJzZSgpKSwgbGNhOiBsY2EgfTtcbn1cblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgbGltID0gMDtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBsb3cgPSBsaW07XG4gICAgXy5mb3JFYWNoKGcuY2hpbGRyZW4odiksIGRmcyk7XG4gICAgcmVzdWx0W3ZdID0geyBsb3c6IGxvdywgbGltOiBsaW0rKyB9O1xuICB9XG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGRmcyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG4vKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgY29vcmRpbmF0ZSBhc3NpZ25tZW50IGJhc2VkIG9uIEJyYW5kZXMgYW5kIEvDtnBmLCBcIkZhc3RcbiAqIGFuZCBTaW1wbGUgSG9yaXpvbnRhbCBDb29yZGluYXRlIEFzc2lnbm1lbnQuXCJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9zaXRpb25YOiBwb3NpdGlvblgsXG4gIGZpbmRUeXBlMUNvbmZsaWN0czogZmluZFR5cGUxQ29uZmxpY3RzLFxuICBmaW5kVHlwZTJDb25mbGljdHM6IGZpbmRUeXBlMkNvbmZsaWN0cyxcbiAgYWRkQ29uZmxpY3Q6IGFkZENvbmZsaWN0LFxuICBoYXNDb25mbGljdDogaGFzQ29uZmxpY3QsXG4gIHZlcnRpY2FsQWxpZ25tZW50OiB2ZXJ0aWNhbEFsaWdubWVudCxcbiAgaG9yaXpvbnRhbENvbXBhY3Rpb246IGhvcml6b250YWxDb21wYWN0aW9uLFxuICBhbGlnbkNvb3JkaW5hdGVzOiBhbGlnbkNvb3JkaW5hdGVzLFxuICBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudDogZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQsXG4gIGJhbGFuY2U6IGJhbGFuY2Vcbn07XG5cbi8qXG4gKiBNYXJrcyBhbGwgZWRnZXMgaW4gdGhlIGdyYXBoIHdpdGggYSB0eXBlLTEgY29uZmxpY3Qgd2l0aCB0aGUgXCJ0eXBlMUNvbmZsaWN0XCJcbiAqIHByb3BlcnR5LiBBIHR5cGUtMSBjb25mbGljdCBpcyBvbmUgd2hlcmUgYSBub24taW5uZXIgc2VnbWVudCBjcm9zc2VzIGFuXG4gKiBpbm5lciBzZWdtZW50LiBBbiBpbm5lciBzZWdtZW50IGlzIGFuIGVkZ2Ugd2l0aCBib3RoIGluY2lkZW50IG5vZGVzIG1hcmtlZFxuICogd2l0aCB0aGUgXCJkdW1teVwiIHByb3BlcnR5LlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIHNjYW5zIGxheWVyIGJ5IGxheWVyLCBzdGFydGluZyB3aXRoIHRoZSBzZWNvbmQsIGZvciB0eXBlLTFcbiAqIGNvbmZsaWN0cyBiZXR3ZWVuIHRoZSBjdXJyZW50IGxheWVyIGFuZCB0aGUgcHJldmlvdXMgbGF5ZXIuIEZvciBlYWNoIGxheWVyXG4gKiBpdCBzY2FucyB0aGUgbm9kZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0IHVudGlsIGl0IHJlYWNoZXMgb25lIHRoYXQgaXMgaW5jaWRlbnRcbiAqIG9uIGFuIGlubmVyIHNlZ21lbnQuIEl0IHRoZW4gc2NhbnMgcHJlZGVjZXNzb3JzIHRvIGRldGVybWluZSBpZiB0aGV5IGhhdmVcbiAqIGVkZ2VzIHRoYXQgY3Jvc3MgdGhhdCBpbm5lciBzZWdtZW50LiBBdCB0aGUgZW5kIGEgZmluYWwgc2NhbiBpcyBkb25lIGZvciBhbGxcbiAqIG5vZGVzIG9uIHRoZSBjdXJyZW50IHJhbmsgdG8gc2VlIGlmIHRoZXkgY3Jvc3MgdGhlIGxhc3QgdmlzaXRlZCBpbm5lclxuICogc2VnbWVudC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSAoc2FmZWx5KSBhc3N1bWVzIHRoYXQgYSBkdW1teSBub2RlIHdpbGwgb25seSBiZSBpbmNpZGVudCBvbiBhXG4gKiBzaW5nbGUgbm9kZSBpbiB0aGUgbGF5ZXJzIGJlaW5nIHNjYW5uZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihwcmV2TGF5ZXIsIGxheWVyKSB7XG4gICAgdmFyXG4gICAgICAvLyBsYXN0IHZpc2l0ZWQgbm9kZSBpbiB0aGUgcHJldmlvdXMgbGF5ZXIgdGhhdCBpcyBpbmNpZGVudCBvbiBhbiBpbm5lclxuICAgICAgLy8gc2VnbWVudC5cbiAgICAgIGswID0gMCxcbiAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub2RlIGluIHRoaXMgbGF5ZXIgc2Nhbm5lZCBmb3IgY3Jvc3NpbmdzIHdpdGggYSB0eXBlLTFcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBzY2FuUG9zID0gMCxcbiAgICAgIHByZXZMYXllckxlbmd0aCA9IHByZXZMYXllci5sZW5ndGgsXG4gICAgICBsYXN0Tm9kZSA9IF8ubGFzdChsYXllcik7XG5cbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHZhciB3ID0gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSxcbiAgICAgICAgazEgPSB3ID8gZy5ub2RlKHcpLm9yZGVyIDogcHJldkxheWVyTGVuZ3RoO1xuXG4gICAgICBpZiAodyB8fCB2ID09PSBsYXN0Tm9kZSkge1xuICAgICAgICBfLmZvckVhY2gobGF5ZXIuc2xpY2Uoc2NhblBvcywgaSArMSksIGZ1bmN0aW9uKHNjYW5Ob2RlKSB7XG4gICAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHNjYW5Ob2RlKSwgZnVuY3Rpb24odSkge1xuICAgICAgICAgICAgdmFyIHVMYWJlbCA9IGcubm9kZSh1KSxcbiAgICAgICAgICAgICAgdVBvcyA9IHVMYWJlbC5vcmRlcjtcbiAgICAgICAgICAgIGlmICgodVBvcyA8IGswIHx8IGsxIDwgdVBvcykgJiZcbiAgICAgICAgICAgICAgICAhKHVMYWJlbC5kdW1teSAmJiBnLm5vZGUoc2Nhbk5vZGUpLmR1bW15KSkge1xuICAgICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHNjYW5Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYW5Qb3MgPSBpICsgMTtcbiAgICAgICAgazAgPSBrMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXllcjtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSB7XG4gIHZhciBjb25mbGljdHMgPSB7fTtcblxuICBmdW5jdGlvbiBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhFbmQsIHByZXZOb3J0aEJvcmRlciwgbmV4dE5vcnRoQm9yZGVyKSB7XG4gICAgdmFyIHY7XG4gICAgXy5mb3JFYWNoKF8ucmFuZ2Uoc291dGhQb3MsIHNvdXRoRW5kKSwgZnVuY3Rpb24oaSkge1xuICAgICAgdiA9IHNvdXRoW2ldO1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgICAgICBfLmZvckVhY2goZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICB2YXIgdU5vZGUgPSBnLm5vZGUodSk7XG4gICAgICAgICAgaWYgKHVOb2RlLmR1bW15ICYmXG4gICAgICAgICAgICAgICh1Tm9kZS5vcmRlciA8IHByZXZOb3J0aEJvcmRlciB8fCB1Tm9kZS5vcmRlciA+IG5leHROb3J0aEJvcmRlcikpIHtcbiAgICAgICAgICAgIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihub3J0aCwgc291dGgpIHtcbiAgICB2YXIgcHJldk5vcnRoUG9zID0gLTEsXG4gICAgICBuZXh0Tm9ydGhQb3MsXG4gICAgICBzb3V0aFBvcyA9IDA7XG5cbiAgICBfLmZvckVhY2goc291dGgsIGZ1bmN0aW9uKHYsIHNvdXRoTG9va2FoZWFkKSB7XG4gICAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSBnLnByZWRlY2Vzc29ycyh2KTtcbiAgICAgICAgaWYgKHByZWRlY2Vzc29ycy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9ydGhQb3MgPSBnLm5vZGUocHJlZGVjZXNzb3JzWzBdKS5vcmRlcjtcbiAgICAgICAgICBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhMb29rYWhlYWQsIHByZXZOb3J0aFBvcywgbmV4dE5vcnRoUG9zKTtcbiAgICAgICAgICBzb3V0aFBvcyA9IHNvdXRoTG9va2FoZWFkO1xuICAgICAgICAgIHByZXZOb3J0aFBvcyA9IG5leHROb3J0aFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoLmxlbmd0aCwgbmV4dE5vcnRoUG9zLCBub3J0aC5sZW5ndGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvdXRoO1xuICB9XG5cbiAgXy5yZWR1Y2UobGF5ZXJpbmcsIHZpc2l0TGF5ZXIpO1xuICByZXR1cm4gY29uZmxpY3RzO1xufVxuXG5mdW5jdGlvbiBmaW5kT3RoZXJJbm5lclNlZ21lbnROb2RlKGcsIHYpIHtcbiAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgIHJldHVybiBfLmZpbmQoZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiBnLm5vZGUodSkuZHVtbXk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cblxuICB2YXIgY29uZmxpY3RzViA9IGNvbmZsaWN0c1t2XTtcbiAgaWYgKCFjb25mbGljdHNWKSB7XG4gICAgY29uZmxpY3RzW3ZdID0gY29uZmxpY3RzViA9IHt9O1xuICB9XG4gIGNvbmZsaWN0c1Zbd10gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpIHtcbiAgaWYgKHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gXy5oYXMoY29uZmxpY3RzW3ZdLCB3KTtcbn1cblxuLypcbiAqIFRyeSB0byBhbGlnbiBub2RlcyBpbnRvIHZlcnRpY2FsIFwiYmxvY2tzXCIgd2hlcmUgcG9zc2libGUuIFRoaXMgYWxnb3JpdGhtXG4gKiBhdHRlbXB0cyB0byBhbGlnbiBhIG5vZGUgd2l0aCBvbmUgb2YgaXRzIG1lZGlhbiBuZWlnaGJvcnMuIElmIHRoZSBlZGdlXG4gKiBjb25uZWN0aW5nIGEgbmVpZ2hib3IgaXMgYSB0eXBlLTEgY29uZmxpY3QgdGhlbiB3ZSBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eS5cbiAqIElmIGEgcHJldmlvdXMgbm9kZSBoYXMgYWxyZWFkeSBmb3JtZWQgYSBibG9jayB3aXRoIGEgbm9kZSBhZnRlciB0aGUgbm9kZVxuICogd2UncmUgdHJ5aW5nIHRvIGZvcm0gYSBibG9jayB3aXRoLCB3ZSBhbHNvIGlnbm9yZSB0aGF0IHBvc3NpYmlsaXR5IC0gb3VyXG4gKiBibG9ja3Mgd291bGQgYmUgc3BsaXQgaW4gdGhhdCBzY2VuYXJpby5cbiAqL1xuZnVuY3Rpb24gdmVydGljYWxBbGlnbm1lbnQoZywgbGF5ZXJpbmcsIGNvbmZsaWN0cywgbmVpZ2hib3JGbikge1xuICB2YXIgcm9vdCA9IHt9LFxuICAgIGFsaWduID0ge30sXG4gICAgcG9zID0ge307XG5cbiAgLy8gV2UgY2FjaGUgdGhlIHBvc2l0aW9uIGhlcmUgYmFzZWQgb24gdGhlIGxheWVyaW5nIGJlY2F1c2UgdGhlIGdyYXBoIGFuZFxuICAvLyBsYXllcmluZyBtYXkgYmUgb3V0IG9mIHN5bmMuIFRoZSBsYXllcmluZyBtYXRyaXggaXMgbWFuaXB1bGF0ZWQgdG9cbiAgLy8gZ2VuZXJhdGUgZGlmZmVyZW50IGV4dHJlbWUgYWxpZ25tZW50cy5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgb3JkZXIpIHtcbiAgICAgIHJvb3Rbdl0gPSB2O1xuICAgICAgYWxpZ25bdl0gPSB2O1xuICAgICAgcG9zW3ZdID0gb3JkZXI7XG4gICAgfSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgcHJldklkeCA9IC0xO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHdzID0gbmVpZ2hib3JGbih2KTtcbiAgICAgIGlmICh3cy5sZW5ndGgpIHtcbiAgICAgICAgd3MgPSBfLnNvcnRCeSh3cywgZnVuY3Rpb24odykgeyByZXR1cm4gcG9zW3ddOyB9KTtcbiAgICAgICAgdmFyIG1wID0gKHdzLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IobXApLCBpbCA9IE1hdGguY2VpbChtcCk7IGkgPD0gaWw7ICsraSkge1xuICAgICAgICAgIHZhciB3ID0gd3NbaV07XG4gICAgICAgICAgaWYgKGFsaWduW3ZdID09PSB2ICYmXG4gICAgICAgICAgICAgIHByZXZJZHggPCBwb3Nbd10gJiZcbiAgICAgICAgICAgICAgIWhhc0NvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykpIHtcbiAgICAgICAgICAgIGFsaWduW3ddID0gdjtcbiAgICAgICAgICAgIGFsaWduW3ZdID0gcm9vdFt2XSA9IHJvb3Rbd107XG4gICAgICAgICAgICBwcmV2SWR4ID0gcG9zW3ddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4geyByb290OiByb290LCBhbGlnbjogYWxpZ24gfTtcbn1cblxuZnVuY3Rpb24gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgbGF5ZXJpbmcsIHJvb3QsIGFsaWduLCByZXZlcnNlU2VwKSB7XG4gIC8vIFRoaXMgcG9ydGlvbiBvZiB0aGUgYWxnb3JpdGhtIGRpZmZlcnMgZnJvbSBCSyBkdWUgdG8gYSBudW1iZXIgb2YgcHJvYmxlbXMuXG4gIC8vIEluc3RlYWQgb2YgdGhlaXIgYWxnb3JpdGhtIHdlIGNvbnN0cnVjdCBhIG5ldyBibG9jayBncmFwaCBhbmQgZG8gdHdvXG4gIC8vIHN3ZWVwcy4gVGhlIGZpcnN0IHN3ZWVwIHBsYWNlcyBibG9ja3Mgd2l0aCB0aGUgc21hbGxlc3QgcG9zc2libGVcbiAgLy8gY29vcmRpbmF0ZXMuIFRoZSBzZWNvbmQgc3dlZXAgcmVtb3ZlcyB1bnVzZWQgc3BhY2UgYnkgbW92aW5nIGJsb2NrcyB0byB0aGVcbiAgLy8gZ3JlYXRlc3QgY29vcmRpbmF0ZXMgd2l0aG91dCB2aW9sYXRpbmcgc2VwYXJhdGlvbi5cbiAgdmFyIHhzID0ge30sXG4gICAgYmxvY2tHID0gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSxcbiAgICBib3JkZXJUeXBlID0gcmV2ZXJzZVNlcCA/IFwiYm9yZGVyTGVmdFwiIDogXCJib3JkZXJSaWdodFwiO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoc2V0WHNGdW5jLCBuZXh0Tm9kZXNGdW5jKSB7XG4gICAgdmFyIHN0YWNrID0gYmxvY2tHLm5vZGVzKCk7XG4gICAgdmFyIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICBpZiAodmlzaXRlZFtlbGVtXSkge1xuICAgICAgICBzZXRYc0Z1bmMoZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdGVkW2VsZW1dID0gdHJ1ZTtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5jb25jYXQobmV4dE5vZGVzRnVuYyhlbGVtKSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBwYXNzLCBhc3NpZ24gc21hbGxlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczEoZWxlbSkge1xuICAgIHhzW2VsZW1dID0gYmxvY2tHLmluRWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGFjYywgeHNbZS52XSArIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzLCBhc3NpZ24gZ3JlYXRlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczIoZWxlbSkge1xuICAgIHZhciBtaW4gPSBibG9ja0cub3V0RWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGFjYywgeHNbZS53XSAtIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgdmFyIG5vZGUgPSBnLm5vZGUoZWxlbSk7XG4gICAgaWYgKG1pbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIG5vZGUuYm9yZGVyVHlwZSAhPT0gYm9yZGVyVHlwZSkge1xuICAgICAgeHNbZWxlbV0gPSBNYXRoLm1heCh4c1tlbGVtXSwgbWluKTtcbiAgICB9XG4gIH1cblxuICBpdGVyYXRlKHBhc3MxLCBibG9ja0cucHJlZGVjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG4gIGl0ZXJhdGUocGFzczIsIGJsb2NrRy5zdWNjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG5cbiAgLy8gQXNzaWduIHggY29vcmRpbmF0ZXMgdG8gYWxsIG5vZGVzXG4gIF8uZm9yRWFjaChhbGlnbiwgZnVuY3Rpb24odikge1xuICAgIHhzW3ZdID0geHNbcm9vdFt2XV07XG4gIH0pO1xuXG4gIHJldHVybiB4cztcbn1cblxuXG5mdW5jdGlvbiBidWlsZEJsb2NrR3JhcGgoZywgbGF5ZXJpbmcsIHJvb3QsIHJldmVyc2VTZXApIHtcbiAgdmFyIGJsb2NrR3JhcGggPSBuZXcgR3JhcGgoKSxcbiAgICBncmFwaExhYmVsID0gZy5ncmFwaCgpLFxuICAgIHNlcEZuID0gc2VwKGdyYXBoTGFiZWwubm9kZXNlcCwgZ3JhcGhMYWJlbC5lZGdlc2VwLCByZXZlcnNlU2VwKTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHU7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgdlJvb3QgPSByb290W3ZdO1xuICAgICAgYmxvY2tHcmFwaC5zZXROb2RlKHZSb290KTtcbiAgICAgIGlmICh1KSB7XG4gICAgICAgIHZhciB1Um9vdCA9IHJvb3RbdV0sXG4gICAgICAgICAgcHJldk1heCA9IGJsb2NrR3JhcGguZWRnZSh1Um9vdCwgdlJvb3QpO1xuICAgICAgICBibG9ja0dyYXBoLnNldEVkZ2UodVJvb3QsIHZSb290LCBNYXRoLm1heChzZXBGbihnLCB2LCB1KSwgcHJldk1heCB8fCAwKSk7XG4gICAgICB9XG4gICAgICB1ID0gdjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJsb2NrR3JhcGg7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBhbGlnbm1lbnQgdGhhdCBoYXMgdGhlIHNtYWxsZXN0IHdpZHRoIG9mIHRoZSBnaXZlbiBhbGlnbm1lbnRzLlxuICovXG5mdW5jdGlvbiBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudChnLCB4c3MpIHtcbiAgcmV0dXJuIF8ubWluQnkoXy52YWx1ZXMoeHNzKSwgZnVuY3Rpb24gKHhzKSB7XG4gICAgdmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgXy5mb3JJbih4cywgZnVuY3Rpb24gKHgsIHYpIHtcbiAgICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aChnLCB2KSAvIDI7XG5cbiAgICAgIG1heCA9IE1hdGgubWF4KHggKyBoYWxmV2lkdGgsIG1heCk7XG4gICAgICBtaW4gPSBNYXRoLm1pbih4IC0gaGFsZldpZHRoLCBtaW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1heCAtIG1pbjtcbiAgfSk7XG59XG5cbi8qXG4gKiBBbGlnbiB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBvZiB0aGUgbGF5b3V0IGFsaWdubWVudHMgc3VjaCB0aGF0XG4gKiBsZWZ0LWJpYXNlZCBhbGlnbm1lbnRzIGhhdmUgdGhlaXIgbWluaW11bSBjb29yZGluYXRlIGF0IHRoZSBzYW1lIHBvaW50IGFzXG4gKiB0aGUgbWluaW11bSBjb29yZGluYXRlIG9mIHRoZSBzbWFsbGVzdCB3aWR0aCBhbGlnbm1lbnQgYW5kIHJpZ2h0LWJpYXNlZFxuICogYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1heGltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhcyB0aGUgbWF4aW11bVxuICogY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbkNvb3JkaW5hdGVzKHhzcywgYWxpZ25Ubykge1xuICB2YXIgYWxpZ25Ub1ZhbHMgPSBfLnZhbHVlcyhhbGlnblRvKSxcbiAgICBhbGlnblRvTWluID0gXy5taW4oYWxpZ25Ub1ZhbHMpLFxuICAgIGFsaWduVG9NYXggPSBfLm1heChhbGlnblRvVmFscyk7XG5cbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgdmFyIGFsaWdubWVudCA9IHZlcnQgKyBob3JpeixcbiAgICAgICAgeHMgPSB4c3NbYWxpZ25tZW50XSxcbiAgICAgICAgZGVsdGE7XG4gICAgICBpZiAoeHMgPT09IGFsaWduVG8pIHJldHVybjtcblxuICAgICAgdmFyIHhzVmFscyA9IF8udmFsdWVzKHhzKTtcbiAgICAgIGRlbHRhID0gaG9yaXogPT09IFwibFwiID8gYWxpZ25Ub01pbiAtIF8ubWluKHhzVmFscykgOiBhbGlnblRvTWF4IC0gXy5tYXgoeHNWYWxzKTtcblxuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIHhzc1thbGlnbm1lbnRdID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBkZWx0YTsgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiYWxhbmNlKHhzcywgYWxpZ24pIHtcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKHhzcy51bCwgZnVuY3Rpb24oaWdub3JlLCB2KSB7XG4gICAgaWYgKGFsaWduKSB7XG4gICAgICByZXR1cm4geHNzW2FsaWduLnRvTG93ZXJDYXNlKCldW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeHMgPSBfLnNvcnRCeShfLm1hcCh4c3MsIHYpKTtcbiAgICAgIHJldHVybiAoeHNbMV0gKyB4c1syXSkgLyAyO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uWChnKSB7XG4gIHZhciBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgdmFyIGNvbmZsaWN0cyA9IF8ubWVyZ2UoXG4gICAgZmluZFR5cGUxQ29uZmxpY3RzKGcsIGxheWVyaW5nKSxcbiAgICBmaW5kVHlwZTJDb25mbGljdHMoZywgbGF5ZXJpbmcpKTtcblxuICB2YXIgeHNzID0ge307XG4gIHZhciBhZGp1c3RlZExheWVyaW5nO1xuICBfLmZvckVhY2goW1widVwiLCBcImRcIl0sIGZ1bmN0aW9uKHZlcnQpIHtcbiAgICBhZGp1c3RlZExheWVyaW5nID0gdmVydCA9PT0gXCJ1XCIgPyBsYXllcmluZyA6IF8udmFsdWVzKGxheWVyaW5nKS5yZXZlcnNlKCk7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICBhZGp1c3RlZExheWVyaW5nID0gXy5tYXAoYWRqdXN0ZWRMYXllcmluZywgZnVuY3Rpb24oaW5uZXIpIHtcbiAgICAgICAgICByZXR1cm4gXy52YWx1ZXMoaW5uZXIpLnJldmVyc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvckZuID0gKHZlcnQgPT09IFwidVwiID8gZy5wcmVkZWNlc3NvcnMgOiBnLnN1Y2Nlc3NvcnMpLmJpbmQoZyk7XG4gICAgICB2YXIgYWxpZ24gPSB2ZXJ0aWNhbEFsaWdubWVudChnLCBhZGp1c3RlZExheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pO1xuICAgICAgdmFyIHhzID0gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgYWRqdXN0ZWRMYXllcmluZyxcbiAgICAgICAgYWxpZ24ucm9vdCwgYWxpZ24uYWxpZ24sIGhvcml6ID09PSBcInJcIik7XG4gICAgICBpZiAoaG9yaXogPT09IFwiclwiKSB7XG4gICAgICAgIHhzID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIC14OyB9KTtcbiAgICAgIH1cbiAgICAgIHhzc1t2ZXJ0ICsgaG9yaXpdID0geHM7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBzbWFsbGVzdFdpZHRoID0gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKTtcbiAgYWxpZ25Db29yZGluYXRlcyh4c3MsIHNtYWxsZXN0V2lkdGgpO1xuICByZXR1cm4gYmFsYW5jZSh4c3MsIGcuZ3JhcGgoKS5hbGlnbik7XG59XG5cbmZ1bmN0aW9uIHNlcChub2RlU2VwLCBlZGdlU2VwLCByZXZlcnNlU2VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCB2LCB3KSB7XG4gICAgdmFyIHZMYWJlbCA9IGcubm9kZSh2KTtcbiAgICB2YXIgd0xhYmVsID0gZy5ub2RlKHcpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBkZWx0YTtcblxuICAgIHN1bSArPSB2TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh2TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAodkxhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gLXZMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZGVsdGEgPSB2TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICBzdW0gKz0gKHZMYWJlbC5kdW1teSA/IGVkZ2VTZXAgOiBub2RlU2VwKSAvIDI7XG4gICAgc3VtICs9ICh3TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuXG4gICAgc3VtICs9IHdMYWJlbC53aWR0aCAvIDI7XG4gICAgaWYgKF8uaGFzKHdMYWJlbCwgXCJsYWJlbHBvc1wiKSkge1xuICAgICAgc3dpdGNoICh3TGFiZWwubGFiZWxwb3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcImxcIjogZGVsdGEgPSB3TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gLXdMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHN1bSArPSByZXZlcnNlU2VwID8gZGVsdGEgOiAtZGVsdGE7XG4gICAgfVxuICAgIGRlbHRhID0gMDtcblxuICAgIHJldHVybiBzdW07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpZHRoKGcsIHYpIHtcbiAgcmV0dXJuIGcubm9kZSh2KS53aWR0aDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHBvc2l0aW9uWCA9IHJlcXVpcmUoXCIuL2JrXCIpLnBvc2l0aW9uWDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpdGlvbjtcblxuZnVuY3Rpb24gcG9zaXRpb24oZykge1xuICBnID0gdXRpbC5hc05vbkNvbXBvdW5kR3JhcGgoZyk7XG5cbiAgcG9zaXRpb25ZKGcpO1xuICBfLmZvckVhY2gocG9zaXRpb25YKGcpLCBmdW5jdGlvbih4LCB2KSB7XG4gICAgZy5ub2RlKHYpLnggPSB4O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25ZKGcpIHtcbiAgdmFyIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICB2YXIgcmFua1NlcCA9IGcuZ3JhcGgoKS5yYW5rc2VwO1xuICB2YXIgcHJldlkgPSAwO1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG1heEhlaWdodCA9IF8ubWF4KF8ubWFwKGxheWVyLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikuaGVpZ2h0OyB9KSk7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICBnLm5vZGUodikueSA9IHByZXZZICsgbWF4SGVpZ2h0IC8gMjtcbiAgICB9KTtcbiAgICBwcmV2WSArPSBtYXhIZWlnaHQgKyByYW5rU2VwO1xuICB9KTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcbnZhciBzbGFjayA9IHJlcXVpcmUoXCIuL3V0aWxcIikuc2xhY2s7XG5cbm1vZHVsZS5leHBvcnRzID0gZmVhc2libGVUcmVlO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIHNwYW5uaW5nIHRyZWUgd2l0aCB0aWdodCBlZGdlcyBhbmQgYWRqdXN0ZWQgdGhlIGlucHV0IG5vZGUnc1xuICogcmFua3MgdG8gYWNoaWV2ZSB0aGlzLiBBIHRpZ2h0IGVkZ2UgaXMgb25lIHRoYXQgaXMgaGFzIGEgbGVuZ3RoIHRoYXQgbWF0Y2hlc1xuICogaXRzIFwibWlubGVuXCIgYXR0cmlidXRlLlxuICpcbiAqIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgZm9yIHRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBXG4gKiBUZWNobmlxdWUgZm9yIERyYXdpbmcgRGlyZWN0ZWQgR3JhcGhzLlwiXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEdyYXBoIG11c3QgYmUgY29ubmVjdGVkLlxuICogICAgMy4gR3JhcGggbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub2RlLlxuICogICAgNS4gR3JhcGggbm9kZXMgbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSBhc3NpZ25lZCBhIFwicmFua1wiIHByb3BlcnR5IHRoYXRcbiAqICAgICAgIHJlc3BlY3RzIHRoZSBcIm1pbmxlblwiIHByb3BlcnR5IG9mIGluY2lkZW50IGVkZ2VzLlxuICogICAgNi4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIGEgXCJtaW5sZW5cIiBwcm9wZXJ0eS5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgLSBHcmFwaCBub2RlcyB3aWxsIGhhdmUgdGhlaXIgcmFuayBhZGp1c3RlZCB0byBlbnN1cmUgdGhhdCBhbGwgZWRnZXMgYXJlXG4gKiAgICAgIHRpZ2h0LlxuICpcbiAqIFJldHVybnMgYSB0cmVlICh1bmRpcmVjdGVkIGdyYXBoKSB0aGF0IGlzIGNvbnN0cnVjdGVkIHVzaW5nIG9ubHkgXCJ0aWdodFwiXG4gKiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gZmVhc2libGVUcmVlKGcpIHtcbiAgdmFyIHQgPSBuZXcgR3JhcGgoeyBkaXJlY3RlZDogZmFsc2UgfSk7XG5cbiAgLy8gQ2hvb3NlIGFyYml0cmFyeSBub2RlIGZyb20gd2hpY2ggdG8gc3RhcnQgb3VyIHRyZWVcbiAgdmFyIHN0YXJ0ID0gZy5ub2RlcygpWzBdO1xuICB2YXIgc2l6ZSA9IGcubm9kZUNvdW50KCk7XG4gIHQuc2V0Tm9kZShzdGFydCwge30pO1xuXG4gIHZhciBlZGdlLCBkZWx0YTtcbiAgd2hpbGUgKHRpZ2h0VHJlZSh0LCBnKSA8IHNpemUpIHtcbiAgICBlZGdlID0gZmluZE1pblNsYWNrRWRnZSh0LCBnKTtcbiAgICBkZWx0YSA9IHQuaGFzTm9kZShlZGdlLnYpID8gc2xhY2soZywgZWRnZSkgOiAtc2xhY2soZywgZWRnZSk7XG4gICAgc2hpZnRSYW5rcyh0LCBnLCBkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gdDtcbn1cblxuLypcbiAqIEZpbmRzIGEgbWF4aW1hbCB0cmVlIG9mIHRpZ2h0IGVkZ2VzIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlXG4gKiB0cmVlLlxuICovXG5mdW5jdGlvbiB0aWdodFRyZWUodCwgZykge1xuICBmdW5jdGlvbiBkZnModikge1xuICAgIF8uZm9yRWFjaChnLm5vZGVFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGVkZ2VWID0gZS52LFxuICAgICAgICB3ID0gKHYgPT09IGVkZ2VWKSA/IGUudyA6IGVkZ2VWO1xuICAgICAgaWYgKCF0Lmhhc05vZGUodykgJiYgIXNsYWNrKGcsIGUpKSB7XG4gICAgICAgIHQuc2V0Tm9kZSh3LCB7fSk7XG4gICAgICAgIHQuc2V0RWRnZSh2LCB3LCB7fSk7XG4gICAgICAgIGRmcyh3KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF8uZm9yRWFjaCh0Lm5vZGVzKCksIGRmcyk7XG4gIHJldHVybiB0Lm5vZGVDb3VudCgpO1xufVxuXG4vKlxuICogRmluZHMgdGhlIGVkZ2Ugd2l0aCB0aGUgc21hbGxlc3Qgc2xhY2sgdGhhdCBpcyBpbmNpZGVudCBvbiB0cmVlIGFuZCByZXR1cm5zXG4gKiBpdC5cbiAqL1xuZnVuY3Rpb24gZmluZE1pblNsYWNrRWRnZSh0LCBnKSB7XG4gIHJldHVybiBfLm1pbkJ5KGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGlmICh0Lmhhc05vZGUoZS52KSAhPT0gdC5oYXNOb2RlKGUudykpIHtcbiAgICAgIHJldHVybiBzbGFjayhnLCBlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaGlmdFJhbmtzKHQsIGcsIGRlbHRhKSB7XG4gIF8uZm9yRWFjaCh0Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBnLm5vZGUodikucmFuayArPSBkZWx0YTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHJhbmtVdGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBsb25nZXN0UGF0aCA9IHJhbmtVdGlsLmxvbmdlc3RQYXRoO1xudmFyIGZlYXNpYmxlVHJlZSA9IHJlcXVpcmUoXCIuL2ZlYXNpYmxlLXRyZWVcIik7XG52YXIgbmV0d29ya1NpbXBsZXggPSByZXF1aXJlKFwiLi9uZXR3b3JrLXNpbXBsZXhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuaztcblxuLypcbiAqIEFzc2lnbnMgYSByYW5rIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGggdGhhdCByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIlxuICogY29uc3RyYWludCBzcGVjaWZpZWQgb24gZWRnZXMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBUaGlzIGJhc2ljIHN0cnVjdHVyZSBpcyBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvclxuICogRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCJcbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIGEgY29ubmVjdGVkIERBR1xuICogICAgMi4gR3JhcGggbm9kZXMgbXVzdCBiZSBvYmplY3RzXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgXCJ3ZWlnaHRcIiBhbmQgXCJtaW5sZW5cIiBhdHRyaWJ1dGVzXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhIFwicmFua1wiIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGVcbiAqICAgICAgIGFsZ29yaXRobS4gUmFua3MgY2FuIHN0YXJ0IGF0IGFueSBpbmRleCAoaW5jbHVkaW5nIG5lZ2F0aXZlKSwgd2UnbGxcbiAqICAgICAgIGZpeCB0aGVtIHVwIGxhdGVyLlxuICovXG5mdW5jdGlvbiByYW5rKGcpIHtcbiAgc3dpdGNoKGcuZ3JhcGgoKS5yYW5rZXIpIHtcbiAgY2FzZSBcIm5ldHdvcmstc2ltcGxleFwiOiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKTsgYnJlYWs7XG4gIGNhc2UgXCJ0aWdodC10cmVlXCI6IHRpZ2h0VHJlZVJhbmtlcihnKTsgYnJlYWs7XG4gIGNhc2UgXCJsb25nZXN0LXBhdGhcIjogbG9uZ2VzdFBhdGhSYW5rZXIoZyk7IGJyZWFrO1xuICBkZWZhdWx0OiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKTtcbiAgfVxufVxuXG4vLyBBIGZhc3QgYW5kIHNpbXBsZSByYW5rZXIsIGJ1dCByZXN1bHRzIGFyZSBmYXIgZnJvbSBvcHRpbWFsLlxudmFyIGxvbmdlc3RQYXRoUmFua2VyID0gbG9uZ2VzdFBhdGg7XG5cbmZ1bmN0aW9uIHRpZ2h0VHJlZVJhbmtlcihnKSB7XG4gIGxvbmdlc3RQYXRoKGcpO1xuICBmZWFzaWJsZVRyZWUoZyk7XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtTaW1wbGV4UmFua2VyKGcpIHtcbiAgbmV0d29ya1NpbXBsZXgoZyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGZlYXNpYmxlVHJlZSA9IHJlcXVpcmUoXCIuL2ZlYXNpYmxlLXRyZWVcIik7XG52YXIgc2xhY2sgPSByZXF1aXJlKFwiLi91dGlsXCIpLnNsYWNrO1xudmFyIGluaXRSYW5rID0gcmVxdWlyZShcIi4vdXRpbFwiKS5sb25nZXN0UGF0aDtcbnZhciBwcmVvcmRlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5hbGcucHJlb3JkZXI7XG52YXIgcG9zdG9yZGVyID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLmFsZy5wb3N0b3JkZXI7XG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKFwiLi4vdXRpbFwiKS5zaW1wbGlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXR3b3JrU2ltcGxleDtcblxuLy8gRXhwb3NlIHNvbWUgaW50ZXJuYWxzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5uZXR3b3JrU2ltcGxleC5pbml0TG93TGltVmFsdWVzID0gaW5pdExvd0xpbVZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmluaXRDdXRWYWx1ZXMgPSBpbml0Q3V0VmFsdWVzO1xubmV0d29ya1NpbXBsZXguY2FsY0N1dFZhbHVlID0gY2FsY0N1dFZhbHVlO1xubmV0d29ya1NpbXBsZXgubGVhdmVFZGdlID0gbGVhdmVFZGdlO1xubmV0d29ya1NpbXBsZXguZW50ZXJFZGdlID0gZW50ZXJFZGdlO1xubmV0d29ya1NpbXBsZXguZXhjaGFuZ2VFZGdlcyA9IGV4Y2hhbmdlRWRnZXM7XG5cbi8qXG4gKiBUaGUgbmV0d29yayBzaW1wbGV4IGFsZ29yaXRobSBhc3NpZ25zIHJhbmtzIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGhcbiAqIGFuZCBpdGVyYXRpdmVseSBpbXByb3ZlcyB0aGUgcmFua2luZyB0byByZWR1Y2UgdGhlIGxlbmd0aCBvZiBlZGdlcy5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBtdXN0IGJlIGEgREFHLlxuICogICAgMi4gQWxsIG5vZGVzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgYW4gb2JqZWN0IHZhbHVlLlxuICogICAgMy4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgXCJtaW5sZW5cIiBhbmQgXCJ3ZWlnaHRcIiBhdHRyaWJ1dGVzLlxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggd2lsbCBoYXZlIGFuIGFzc2lnbmVkIFwicmFua1wiIGF0dHJpYnV0ZSB0aGF0IGhhc1xuICogICAgICAgYmVlbiBvcHRpbWl6ZWQgYnkgdGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0uIFJhbmtzIHN0YXJ0IGF0IDAuXG4gKlxuICpcbiAqIEEgcm91Z2ggc2tldGNoIG9mIHRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAqXG4gKiAgICAxLiBBc3NpZ24gaW5pdGlhbCByYW5rcyB0byBlYWNoIG5vZGUuIFdlIHVzZSB0aGUgbG9uZ2VzdCBwYXRoIGFsZ29yaXRobSxcbiAqICAgICAgIHdoaWNoIGFzc2lnbnMgcmFua3MgdG8gdGhlIGxvd2VzdCBwb3NpdGlvbiBwb3NzaWJsZS4gSW4gZ2VuZXJhbCB0aGlzXG4gKiAgICAgICBsZWFkcyB0byB2ZXJ5IHdpZGUgYm90dG9tIHJhbmtzIGFuZCB1bm5lY2Vzc2FyaWx5IGxvbmcgZWRnZXMuXG4gKiAgICAyLiBDb25zdHJ1Y3QgYSBmZWFzaWJsZSB0aWdodCB0cmVlLiBBIHRpZ2h0IHRyZWUgaXMgb25lIHN1Y2ggdGhhdCBhbGxcbiAqICAgICAgIGVkZ2VzIGluIHRoZSB0cmVlIGhhdmUgbm8gc2xhY2sgKGRpZmZlcmVuY2UgYmV0d2VlbiBsZW5ndGggb2YgZWRnZVxuICogICAgICAgYW5kIG1pbmxlbiBmb3IgdGhlIGVkZ2UpLiBUaGlzIGJ5IGl0c2VsZiBncmVhdGx5IGltcHJvdmVzIHRoZSBhc3NpZ25lZFxuICogICAgICAgcmFua2luZ3MgYnkgc2hvcnRpbmcgZWRnZXMuXG4gKiAgICAzLiBJdGVyYXRpdmVseSBmaW5kIGVkZ2VzIHRoYXQgaGF2ZSBuZWdhdGl2ZSBjdXQgdmFsdWVzLiBHZW5lcmFsbHkgYVxuICogICAgICAgbmVnYXRpdmUgY3V0IHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBlZGdlIGNvdWxkIGJlIHJlbW92ZWQgYW5kIGEgbmV3XG4gKiAgICAgICB0cmVlIGVkZ2UgY291bGQgYmUgYWRkZWQgdG8gcHJvZHVjZSBhIG1vcmUgY29tcGFjdCBncmFwaC5cbiAqXG4gKiBNdWNoIG9mIHRoZSBhbGdvcml0aG1zIGhlcmUgYXJlIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWVcbiAqIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIiBUaGUgc3RydWN0dXJlIG9mIHRoZSBmaWxlIHJvdWdobHkgZm9sbG93cyB0aGVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgb3ZlcmFsbCBhbGdvcml0aG0uXG4gKi9cbmZ1bmN0aW9uIG5ldHdvcmtTaW1wbGV4KGcpIHtcbiAgZyA9IHNpbXBsaWZ5KGcpO1xuICBpbml0UmFuayhnKTtcbiAgdmFyIHQgPSBmZWFzaWJsZVRyZWUoZyk7XG4gIGluaXRMb3dMaW1WYWx1ZXModCk7XG4gIGluaXRDdXRWYWx1ZXModCwgZyk7XG5cbiAgdmFyIGUsIGY7XG4gIHdoaWxlICgoZSA9IGxlYXZlRWRnZSh0KSkpIHtcbiAgICBmID0gZW50ZXJFZGdlKHQsIGcsIGUpO1xuICAgIGV4Y2hhbmdlRWRnZXModCwgZywgZSwgZik7XG4gIH1cbn1cblxuLypcbiAqIEluaXRpYWxpemVzIGN1dCB2YWx1ZXMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaW5pdEN1dFZhbHVlcyh0LCBnKSB7XG4gIHZhciB2cyA9IHBvc3RvcmRlcih0LCB0Lm5vZGVzKCkpO1xuICB2cyA9IHZzLnNsaWNlKDAsIHZzLmxlbmd0aCAtIDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBhc3NpZ25DdXRWYWx1ZSh0LCBnLCB2KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkN1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIHQuZWRnZShjaGlsZCwgcGFyZW50KS5jdXR2YWx1ZSA9IGNhbGNDdXRWYWx1ZSh0LCBnLCBjaGlsZCk7XG59XG5cbi8qXG4gKiBHaXZlbiB0aGUgdGlnaHQgdHJlZSwgaXRzIGdyYXBoLCBhbmQgYSBjaGlsZCBpbiB0aGUgZ3JhcGggY2FsY3VsYXRlIGFuZFxuICogcmV0dXJuIHRoZSBjdXQgdmFsdWUgZm9yIHRoZSBlZGdlIGJldHdlZW4gdGhlIGNoaWxkIGFuZCBpdHMgcGFyZW50LlxuICovXG5mdW5jdGlvbiBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpIHtcbiAgdmFyIGNoaWxkTGFiID0gdC5ub2RlKGNoaWxkKTtcbiAgdmFyIHBhcmVudCA9IGNoaWxkTGFiLnBhcmVudDtcbiAgLy8gVHJ1ZSBpZiB0aGUgY2hpbGQgaXMgb24gdGhlIHRhaWwgZW5kIG9mIHRoZSBlZGdlIGluIHRoZSBkaXJlY3RlZCBncmFwaFxuICB2YXIgY2hpbGRJc1RhaWwgPSB0cnVlO1xuICAvLyBUaGUgZ3JhcGgncyB2aWV3IG9mIHRoZSB0cmVlIGVkZ2Ugd2UncmUgaW5zcGVjdGluZ1xuICB2YXIgZ3JhcGhFZGdlID0gZy5lZGdlKGNoaWxkLCBwYXJlbnQpO1xuICAvLyBUaGUgYWNjdW11bGF0ZWQgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgaXRzIHBhcmVudFxuICB2YXIgY3V0VmFsdWUgPSAwO1xuXG4gIGlmICghZ3JhcGhFZGdlKSB7XG4gICAgY2hpbGRJc1RhaWwgPSBmYWxzZTtcbiAgICBncmFwaEVkZ2UgPSBnLmVkZ2UocGFyZW50LCBjaGlsZCk7XG4gIH1cblxuICBjdXRWYWx1ZSA9IGdyYXBoRWRnZS53ZWlnaHQ7XG5cbiAgXy5mb3JFYWNoKGcubm9kZUVkZ2VzKGNoaWxkKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBpc091dEVkZ2UgPSBlLnYgPT09IGNoaWxkLFxuICAgICAgb3RoZXIgPSBpc091dEVkZ2UgPyBlLncgOiBlLnY7XG5cbiAgICBpZiAob3RoZXIgIT09IHBhcmVudCkge1xuICAgICAgdmFyIHBvaW50c1RvSGVhZCA9IGlzT3V0RWRnZSA9PT0gY2hpbGRJc1RhaWwsXG4gICAgICAgIG90aGVyV2VpZ2h0ID0gZy5lZGdlKGUpLndlaWdodDtcblxuICAgICAgY3V0VmFsdWUgKz0gcG9pbnRzVG9IZWFkID8gb3RoZXJXZWlnaHQgOiAtb3RoZXJXZWlnaHQ7XG4gICAgICBpZiAoaXNUcmVlRWRnZSh0LCBjaGlsZCwgb3RoZXIpKSB7XG4gICAgICAgIHZhciBvdGhlckN1dFZhbHVlID0gdC5lZGdlKGNoaWxkLCBvdGhlcikuY3V0dmFsdWU7XG4gICAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IC1vdGhlckN1dFZhbHVlIDogb3RoZXJDdXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdExvd0xpbVZhbHVlcyh0cmVlLCByb290KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJvb3QgPSB0cmVlLm5vZGVzKClbMF07XG4gIH1cbiAgZGZzQXNzaWduTG93TGltKHRyZWUsIHt9LCAxLCByb290KTtcbn1cblxuZnVuY3Rpb24gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHYsIHBhcmVudCkge1xuICB2YXIgbG93ID0gbmV4dExpbTtcbiAgdmFyIGxhYmVsID0gdHJlZS5ub2RlKHYpO1xuXG4gIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICBfLmZvckVhY2godHJlZS5uZWlnaGJvcnModiksIGZ1bmN0aW9uKHcpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHcpKSB7XG4gICAgICBuZXh0TGltID0gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHcsIHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGFiZWwubG93ID0gbG93O1xuICBsYWJlbC5saW0gPSBuZXh0TGltKys7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBsYWJlbC5wYXJlbnQgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyB3aGVuIHdlIGluY3JlbWVudGFsbHkgdXBkYXRlIGxvdyBsaW1cbiAgICBkZWxldGUgbGFiZWwucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG5leHRMaW07XG59XG5cbmZ1bmN0aW9uIGxlYXZlRWRnZSh0cmVlKSB7XG4gIHJldHVybiBfLmZpbmQodHJlZS5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRyZWUuZWRnZShlKS5jdXR2YWx1ZSA8IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbnRlckVkZ2UodCwgZywgZWRnZSkge1xuICB2YXIgdiA9IGVkZ2UudjtcbiAgdmFyIHcgPSBlZGdlLnc7XG5cbiAgLy8gRm9yIHRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gd2UgYXNzdW1lIHRoYXQgdiBpcyB0aGUgdGFpbCBhbmQgdyBpcyB0aGVcbiAgLy8gaGVhZCwgc28gaWYgd2UgZG9uJ3QgaGF2ZSB0aGlzIGVkZ2UgaW4gdGhlIGdyYXBoIHdlIHNob3VsZCBmbGlwIGl0IHRvXG4gIC8vIG1hdGNoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxuICBpZiAoIWcuaGFzRWRnZSh2LCB3KSkge1xuICAgIHYgPSBlZGdlLnc7XG4gICAgdyA9IGVkZ2UudjtcbiAgfVxuXG4gIHZhciB2TGFiZWwgPSB0Lm5vZGUodik7XG4gIHZhciB3TGFiZWwgPSB0Lm5vZGUodyk7XG4gIHZhciB0YWlsTGFiZWwgPSB2TGFiZWw7XG4gIHZhciBmbGlwID0gZmFsc2U7XG5cbiAgLy8gSWYgdGhlIHJvb3QgaXMgaW4gdGhlIHRhaWwgb2YgdGhlIGVkZ2UgdGhlbiB3ZSBuZWVkIHRvIGZsaXAgdGhlIGxvZ2ljIHRoYXRcbiAgLy8gY2hlY2tzIGZvciB0aGUgaGVhZCBhbmQgdGFpbCBub2RlcyBpbiB0aGUgY2FuZGlkYXRlcyBmdW5jdGlvbiBiZWxvdy5cbiAgaWYgKHZMYWJlbC5saW0gPiB3TGFiZWwubGltKSB7XG4gICAgdGFpbExhYmVsID0gd0xhYmVsO1xuICAgIGZsaXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBfLmZpbHRlcihnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICByZXR1cm4gZmxpcCA9PT0gaXNEZXNjZW5kYW50KHQsIHQubm9kZShlZGdlLnYpLCB0YWlsTGFiZWwpICYmXG4gICAgICAgICAgIGZsaXAgIT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS53KSwgdGFpbExhYmVsKTtcbiAgfSk7XG5cbiAgcmV0dXJuIF8ubWluQnkoY2FuZGlkYXRlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gc2xhY2soZywgZWRnZSk7IH0pO1xufVxuXG5mdW5jdGlvbiBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpIHtcbiAgdmFyIHYgPSBlLnY7XG4gIHZhciB3ID0gZS53O1xuICB0LnJlbW92ZUVkZ2Uodiwgdyk7XG4gIHQuc2V0RWRnZShmLnYsIGYudywge30pO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuICB1cGRhdGVSYW5rcyh0LCBnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmFua3ModCwgZykge1xuICB2YXIgcm9vdCA9IF8uZmluZCh0Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICFnLm5vZGUodikucGFyZW50OyB9KTtcbiAgdmFyIHZzID0gcHJlb3JkZXIodCwgcm9vdCk7XG4gIHZzID0gdnMuc2xpY2UoMSk7XG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBwYXJlbnQgPSB0Lm5vZGUodikucGFyZW50LFxuICAgICAgZWRnZSA9IGcuZWRnZSh2LCBwYXJlbnQpLFxuICAgICAgZmxpcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFlZGdlKSB7XG4gICAgICBlZGdlID0gZy5lZGdlKHBhcmVudCwgdik7XG4gICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnLm5vZGUodikucmFuayA9IGcubm9kZShwYXJlbnQpLnJhbmsgKyAoZmxpcHBlZCA/IGVkZ2UubWlubGVuIDogLWVkZ2UubWlubGVuKTtcbiAgfSk7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkZ2UgaXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzVHJlZUVkZ2UodHJlZSwgdSwgdikge1xuICByZXR1cm4gdHJlZS5oYXNFZGdlKHUsIHYpO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgbm9kZSBpcyBkZXNjZW5kYW50IG9mIHRoZSByb290IG5vZGUgcGVyIHRoZVxuICogYXNzaWduZWQgbG93IGFuZCBsaW0gYXR0cmlidXRlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaXNEZXNjZW5kYW50KHRyZWUsIHZMYWJlbCwgcm9vdExhYmVsKSB7XG4gIHJldHVybiByb290TGFiZWwubG93IDw9IHZMYWJlbC5saW0gJiYgdkxhYmVsLmxpbSA8PSByb290TGFiZWwubGltO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvbmdlc3RQYXRoOiBsb25nZXN0UGF0aCxcbiAgc2xhY2s6IHNsYWNrXG59O1xuXG4vKlxuICogSW5pdGlhbGl6ZXMgcmFua3MgZm9yIHRoZSBpbnB1dCBncmFwaCB1c2luZyB0aGUgbG9uZ2VzdCBwYXRoIGFsZ29yaXRobS4gVGhpc1xuICogYWxnb3JpdGhtIHNjYWxlcyB3ZWxsIGFuZCBpcyBmYXN0IGluIHByYWN0aWNlLCBpdCB5aWVsZHMgcmF0aGVyIHBvb3JcbiAqIHNvbHV0aW9ucy4gTm9kZXMgYXJlIHB1c2hlZCB0byB0aGUgbG93ZXN0IGxheWVyIHBvc3NpYmxlLCBsZWF2aW5nIHRoZSBib3R0b21cbiAqIHJhbmtzIHdpZGUgYW5kIGxlYXZpbmcgZWRnZXMgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5LiBIb3dldmVyLCBkdWUgdG8gaXRzXG4gKiBzcGVlZCwgdGhpcyBhbGdvcml0aG0gaXMgZ29vZCBmb3IgZ2V0dGluZyBhbiBpbml0aWFsIHJhbmtpbmcgdGhhdCBjYW4gYmUgZmVkXG4gKiBpbnRvIG90aGVyIGFsZ29yaXRobXMuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gZG9lcyBub3Qgbm9ybWFsaXplIGxheWVycyBiZWNhdXNlIGl0IHdpbGwgYmUgdXNlZCBieSBvdGhlclxuICogYWxnb3JpdGhtcyBpbiBtb3N0IGNhc2VzLiBJZiB1c2luZyB0aGlzIGFsZ29yaXRobSBkaXJlY3RseSwgYmUgc3VyZSB0b1xuICogcnVuIG5vcm1hbGl6ZSBhdCB0aGUgZW5kLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHLlxuICogICAgMi4gSW5wdXQgZ3JhcGggbm9kZSBsYWJlbHMgY2FuIGJlIGFzc2lnbmVkIHByb3BlcnRpZXMuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEVhY2ggbm9kZSB3aWxsIGJlIGFzc2lnbiBhbiAodW5ub3JtYWxpemVkKSBcInJhbmtcIiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdFBhdGgoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGxhYmVsID0gZy5ub2RlKHYpO1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgcmV0dXJuIGxhYmVsLnJhbms7XG4gICAgfVxuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgdmFyIHJhbmsgPSBfLm1pbihfLm1hcChnLm91dEVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gZGZzKGUudykgLSBnLmVkZ2UoZSkubWlubGVuO1xuICAgIH0pKTtcblxuICAgIGlmIChyYW5rID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgLy8gcmV0dXJuIHZhbHVlIG9mIF8ubWFwKFtdKSBmb3IgTG9kYXNoIDNcbiAgICAgICAgcmFuayA9PT0gdW5kZWZpbmVkIHx8IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbXSkgZm9yIExvZGFzaCA0XG4gICAgICAgIHJhbmsgPT09IG51bGwpIHsgLy8gcmV0dXJuIHZhbHVlIG9mIF8ubWFwKFtudWxsXSlcbiAgICAgIHJhbmsgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiAobGFiZWwucmFuayA9IHJhbmspO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcuc291cmNlcygpLCBkZnMpO1xufVxuXG4vKlxuICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNsYWNrIGZvciB0aGUgZ2l2ZW4gZWRnZS4gVGhlIHNsYWNrIGlzIGRlZmluZWQgYXMgdGhlXG4gKiBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxlbmd0aCBvZiB0aGUgZWRnZSBhbmQgaXRzIG1pbmltdW0gbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbGFjayhnLCBlKSB7XG4gIHJldHVybiBnLm5vZGUoZS53KS5yYW5rIC0gZy5ub2RlKGUudikucmFuayAtIGcuZWRnZShlKS5taW5sZW47XG59XG4iLCIvKiBlc2xpbnQgXCJuby1jb25zb2xlXCI6IG9mZiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZER1bW15Tm9kZTogYWRkRHVtbXlOb2RlLFxuICBzaW1wbGlmeTogc2ltcGxpZnksXG4gIGFzTm9uQ29tcG91bmRHcmFwaDogYXNOb25Db21wb3VuZEdyYXBoLFxuICBzdWNjZXNzb3JXZWlnaHRzOiBzdWNjZXNzb3JXZWlnaHRzLFxuICBwcmVkZWNlc3NvcldlaWdodHM6IHByZWRlY2Vzc29yV2VpZ2h0cyxcbiAgaW50ZXJzZWN0UmVjdDogaW50ZXJzZWN0UmVjdCxcbiAgYnVpbGRMYXllck1hdHJpeDogYnVpbGRMYXllck1hdHJpeCxcbiAgbm9ybWFsaXplUmFua3M6IG5vcm1hbGl6ZVJhbmtzLFxuICByZW1vdmVFbXB0eVJhbmtzOiByZW1vdmVFbXB0eVJhbmtzLFxuICBhZGRCb3JkZXJOb2RlOiBhZGRCb3JkZXJOb2RlLFxuICBtYXhSYW5rOiBtYXhSYW5rLFxuICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgdGltZTogdGltZSxcbiAgbm90aW1lOiBub3RpbWVcbn07XG5cbi8qXG4gKiBBZGRzIGEgZHVtbXkgbm9kZSB0byB0aGUgZ3JhcGggYW5kIHJldHVybiB2LlxuICovXG5mdW5jdGlvbiBhZGREdW1teU5vZGUoZywgdHlwZSwgYXR0cnMsIG5hbWUpIHtcbiAgdmFyIHY7XG4gIGRvIHtcbiAgICB2ID0gXy51bmlxdWVJZChuYW1lKTtcbiAgfSB3aGlsZSAoZy5oYXNOb2RlKHYpKTtcblxuICBhdHRycy5kdW1teSA9IHR5cGU7XG4gIGcuc2V0Tm9kZSh2LCBhdHRycyk7XG4gIHJldHVybiB2O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBncmFwaCB3aXRoIG9ubHkgc2ltcGxlIGVkZ2VzLiBIYW5kbGVzIGFnZ3JlZ2F0aW9uIG9mIGRhdGFcbiAqIGFzc29jaWF0ZWQgd2l0aCBtdWx0aS1lZGdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnkoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCgpLnNldEdyYXBoKGcuZ3JhcGgoKSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHNpbXBsZUxhYmVsID0gc2ltcGxpZmllZC5lZGdlKGUudiwgZS53KSB8fCB7IHdlaWdodDogMCwgbWlubGVuOiAxIH07XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLnYsIGUudywge1xuICAgICAgd2VpZ2h0OiBzaW1wbGVMYWJlbC53ZWlnaHQgKyBsYWJlbC53ZWlnaHQsXG4gICAgICBtaW5sZW46IE1hdGgubWF4KHNpbXBsZUxhYmVsLm1pbmxlbiwgbGFiZWwubWlubGVuKVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIGFzTm9uQ29tcG91bmRHcmFwaChnKSB7XG4gIHZhciBzaW1wbGlmaWVkID0gbmV3IEdyYXBoKHsgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSB9KS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFnLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7XG4gICAgfVxuICB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLCBnLmVkZ2UoZSkpO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHN1Y3MgPSB7fTtcbiAgICBfLmZvckVhY2goZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgc3Vjc1tlLnddID0gKHN1Y3NbZS53XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Y3M7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG5mdW5jdGlvbiBwcmVkZWNlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHByZWRzID0ge307XG4gICAgXy5mb3JFYWNoKGcuaW5FZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcHJlZHNbZS52XSA9IChwcmVkc1tlLnZdIHx8IDApICsgZy5lZGdlKGUpLndlaWdodDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJlZHM7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG4vKlxuICogRmluZHMgd2hlcmUgYSBsaW5lIHN0YXJ0aW5nIGF0IHBvaW50ICh7eCwgeX0pIHdvdWxkIGludGVyc2VjdCBhIHJlY3RhbmdsZVxuICogKHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSkgaWYgaXQgd2VyZSBwb2ludGluZyBhdCB0aGUgcmVjdGFuZ2xlJ3MgY2VudGVyLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0KHJlY3QsIHBvaW50KSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcblxuICAvLyBSZWN0YW5nbGUgaW50ZXJzZWN0aW9uIGFsZ29yaXRobSBmcm9tOlxuICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTA4MTEzL2ZpbmQtZWRnZS1iZXR3ZWVuLXR3by1ib3hlc1xuICB2YXIgZHggPSBwb2ludC54IC0geDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHk7XG4gIHZhciB3ID0gcmVjdC53aWR0aCAvIDI7XG4gIHZhciBoID0gcmVjdC5oZWlnaHQgLyAyO1xuXG4gIGlmICghZHggJiYgIWR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHBvc3NpYmxlIHRvIGZpbmQgaW50ZXJzZWN0aW9uIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlXCIpO1xuICB9XG5cbiAgdmFyIHN4LCBzeTtcbiAgaWYgKE1hdGguYWJzKGR5KSAqIHcgPiBNYXRoLmFicyhkeCkgKiBoKSB7XG4gICAgLy8gSW50ZXJzZWN0aW9uIGlzIHRvcCBvciBib3R0b20gb2YgcmVjdC5cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICBoID0gLWg7XG4gICAgfVxuICAgIHN4ID0gaCAqIGR4IC8gZHk7XG4gICAgc3kgPSBoO1xuICB9IGVsc2Uge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyBsZWZ0IG9yIHJpZ2h0IG9mIHJlY3QuXG4gICAgaWYgKGR4IDwgMCkge1xuICAgICAgdyA9IC13O1xuICAgIH1cbiAgICBzeCA9IHc7XG4gICAgc3kgPSB3ICogZHkgLyBkeDtcbiAgfVxuXG4gIHJldHVybiB7IHg6IHggKyBzeCwgeTogeSArIHN5IH07XG59XG5cbi8qXG4gKiBHaXZlbiBhIERBRyB3aXRoIGVhY2ggbm9kZSBhc3NpZ25lZCBcInJhbmtcIiBhbmQgXCJvcmRlclwiIHByb3BlcnRpZXMsIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgcHJvZHVjZSBhIG1hdHJpeCB3aXRoIHRoZSBpZHMgb2YgZWFjaCBub2RlLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyTWF0cml4KGcpIHtcbiAgdmFyIGxheWVyaW5nID0gXy5tYXAoXy5yYW5nZShtYXhSYW5rKGcpICsgMSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIHJhbmsgPSBub2RlLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICBsYXllcmluZ1tyYW5rXVtub2RlLm9yZGVyXSA9IHY7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxheWVyaW5nO1xufVxuXG4vKlxuICogQWRqdXN0cyB0aGUgcmFua3MgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggc3VjaCB0aGF0IGFsbCBub2RlcyB2IGhhdmVcbiAqIHJhbmsodikgPj0gMCBhbmQgYXQgbGVhc3Qgb25lIG5vZGUgdyBoYXMgcmFuayh3KSA9IDAuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmtzKGcpIHtcbiAgdmFyIG1pbiA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChfLmhhcyhub2RlLCBcInJhbmtcIikpIHtcbiAgICAgIG5vZGUucmFuayAtPSBtaW47XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlSYW5rcyhnKSB7XG4gIC8vIFJhbmtzIG1heSBub3Qgc3RhcnQgYXQgMCwgc28gd2UgbmVlZCB0byBvZmZzZXQgdGhlbVxuICB2YXIgb2Zmc2V0ID0gXy5taW4oXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikucmFuazsgfSkpO1xuXG4gIHZhciBsYXllcnMgPSBbXTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbmsgLSBvZmZzZXQ7XG4gICAgaWYgKCFsYXllcnNbcmFua10pIHtcbiAgICAgIGxheWVyc1tyYW5rXSA9IFtdO1xuICAgIH1cbiAgICBsYXllcnNbcmFua10ucHVzaCh2KTtcbiAgfSk7XG5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIG5vZGVSYW5rRmFjdG9yID0gZy5ncmFwaCgpLm5vZGVSYW5rRmFjdG9yO1xuICBfLmZvckVhY2gobGF5ZXJzLCBmdW5jdGlvbih2cywgaSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHZzKSAmJiBpICUgbm9kZVJhbmtGYWN0b3IgIT09IDApIHtcbiAgICAgIC0tZGVsdGE7XG4gICAgfSBlbHNlIGlmIChkZWx0YSkge1xuICAgICAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7IGcubm9kZSh2KS5yYW5rICs9IGRlbHRhOyB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByZWZpeCwgcmFuaywgb3JkZXIpIHtcbiAgdmFyIG5vZGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICBub2RlLnJhbmsgPSByYW5rO1xuICAgIG5vZGUub3JkZXIgPSBvcmRlcjtcbiAgfVxuICByZXR1cm4gYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIG5vZGUsIHByZWZpeCk7XG59XG5cbmZ1bmN0aW9uIG1heFJhbmsoZykge1xuICByZXR1cm4gXy5tYXgoXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHJhbmsgPSBnLm5vZGUodikucmFuaztcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocmFuaykpIHtcbiAgICAgIHJldHVybiByYW5rO1xuICAgIH1cbiAgfSkpO1xufVxuXG4vKlxuICogUGFydGl0aW9uIGEgY29sbGVjdGlvbiBpbnRvIHR3byBncm91cHM6IGBsaHNgIGFuZCBgcmhzYC4gSWYgdGhlIHN1cHBsaWVkXG4gKiBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFuIGVudHJ5IGl0IGdvZXMgaW50byBgbGhzYC4gT3RoZXJ3aXNlIGl0IGdvZXNcbiAqIGludG8gYHJocy5cbiAqL1xuZnVuY3Rpb24gcGFydGl0aW9uKGNvbGxlY3Rpb24sIGZuKSB7XG4gIHZhciByZXN1bHQgPSB7IGxoczogW10sIHJoczogW10gfTtcbiAgXy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgcmVzdWx0Lmxocy5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnJocy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmbmAgd2l0aCBhIHRpbWVyLiBUaGUgd3JhcHBlciBsb2dzIHRoZVxuICogdGltZSBpdCB0YWtlcyB0byBleGVjdXRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGltZShuYW1lLCBmbikge1xuICB2YXIgc3RhcnQgPSBfLm5vdygpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGNvbnNvbGUubG9nKG5hbWUgKyBcIiB0aW1lOiBcIiArIChfLm5vdygpIC0gc3RhcnQpICsgXCJtc1wiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpbWUobmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZuKCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiMC44LjVcIjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBDaHJpcyBQZXR0aXR0XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuICogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXG4gKiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxuICogT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGxpYiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiBsaWIuR3JhcGgsXG4gIGpzb246IHJlcXVpcmUoXCIuL2xpYi9qc29uXCIpLFxuICBhbGc6IHJlcXVpcmUoXCIuL2xpYi9hbGdcIiksXG4gIHZlcnNpb246IGxpYi52ZXJzaW9uXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHM7XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHMoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgY21wdHMgPSBbXTtcbiAgdmFyIGNtcHQ7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBjbXB0LnB1c2godik7XG4gICAgXy5lYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgY21wdCA9IFtdO1xuICAgIGRmcyh2KTtcbiAgICBpZiAoY21wdC5sZW5ndGgpIHtcbiAgICAgIGNtcHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY21wdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGZzO1xuXG4vKlxuICogQSBoZWxwZXIgdGhhdCBwcmVmb3JtcyBhIHByZS0gb3IgcG9zdC1vcmRlciB0cmF2ZXJzYWwgb24gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgcmV0dXJucyB0aGUgbm9kZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSB2aXNpdGVkLiBJZiB0aGUgZ3JhcGggaXNcbiAqIHVuZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIG5laWdoYm9ycy4gSWYgdGhlIGdyYXBoXG4gKiBpcyBkaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgc3VjY2Vzc29ycy5cbiAqXG4gKiBPcmRlciBtdXN0IGJlIG9uZSBvZiBcInByZVwiIG9yIFwicG9zdFwiLlxuICovXG5mdW5jdGlvbiBkZnMoZywgdnMsIG9yZGVyKSB7XG4gIGlmICghXy5pc0FycmF5KHZzKSkge1xuICAgIHZzID0gW3ZzXTtcbiAgfVxuXG4gIHZhciBuYXZpZ2F0aW9uID0gKGcuaXNEaXJlY3RlZCgpID8gZy5zdWNjZXNzb3JzIDogZy5uZWlnaGJvcnMpLmJpbmQoZyk7XG5cbiAgdmFyIGFjYyA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIWcuaGFzTm9kZSh2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggZG9lcyBub3QgaGF2ZSBub2RlOiBcIiArIHYpO1xuICAgIH1cblxuICAgIGRvRGZzKGcsIHYsIG9yZGVyID09PSBcInBvc3RcIiwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIGRvRGZzKGcsIHYsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKSB7XG4gIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIGlmICghcG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gICAgXy5lYWNoKG5hdmlnYXRpb24odiksIGZ1bmN0aW9uKHcpIHtcbiAgICAgIGRvRGZzKGcsIHcsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgICB9KTtcbiAgICBpZiAocG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gIH1cbn1cbiIsInZhciBkaWprc3RyYSA9IHJlcXVpcmUoXCIuL2RpamtzdHJhXCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhQWxsO1xuXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBlZGdlRnVuYykge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZy5ub2RlcygpLCBmdW5jdGlvbihhY2MsIHYpIHtcbiAgICBhY2Nbdl0gPSBkaWprc3RyYShnLCB2LCB3ZWlnaHRGdW5jLCBlZGdlRnVuYyk7XG4gIH0sIHt9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5EaWprc3RyYShnLCBTdHJpbmcoc291cmNlKSxcbiAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgIGVkZ2VGbiB8fCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm91dEVkZ2VzKHYpOyB9KTtcbn1cblxuZnVuY3Rpb24gcnVuRGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHZhciByZXN1bHRzID0ge307XG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIHZhciB2LCB2RW50cnk7XG5cbiAgdmFyIHVwZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiAhPT0gdiA/IGVkZ2UudiA6IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gcmVzdWx0c1t3XTtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgdmFyIGRpc3RhbmNlID0gdkVudHJ5LmRpc3RhbmNlICsgd2VpZ2h0O1xuXG4gICAgaWYgKHdlaWdodCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpamtzdHJhIGRvZXMgbm90IGFsbG93IG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0cy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiQmFkIGVkZ2U6IFwiICsgZWRnZSArIFwiIFdlaWdodDogXCIgKyB3ZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChkaXN0YW5jZSA8IHdFbnRyeS5kaXN0YW5jZSkge1xuICAgICAgd0VudHJ5LmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB3RW50cnkucHJlZGVjZXNzb3IgPSB2O1xuICAgICAgcHEuZGVjcmVhc2UodywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfTtcblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgdmFyIGRpc3RhbmNlID0gdiA9PT0gc291cmNlID8gMCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICByZXN1bHRzW3ZdID0geyBkaXN0YW5jZTogZGlzdGFuY2UgfTtcbiAgICBwcS5hZGQodiwgZGlzdGFuY2UpO1xuICB9KTtcblxuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICB2RW50cnkgPSByZXN1bHRzW3ZdO1xuICAgIGlmICh2RW50cnkuZGlzdGFuY2UgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZWRnZUZuKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHRhcmphbiA9IHJlcXVpcmUoXCIuL3RhcmphblwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQ3ljbGVzO1xuXG5mdW5jdGlvbiBmaW5kQ3ljbGVzKGcpIHtcbiAgcmV0dXJuIF8uZmlsdGVyKHRhcmphbihnKSwgZnVuY3Rpb24oY21wdCkge1xuICAgIHJldHVybiBjbXB0Lmxlbmd0aCA+IDEgfHwgKGNtcHQubGVuZ3RoID09PSAxICYmIGcuaGFzRWRnZShjbXB0WzBdLCBjbXB0WzBdKSk7XG4gIH0pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZsb3lkV2Fyc2hhbGw7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZmxveWRXYXJzaGFsbChnLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5GbG95ZFdhcnNoYWxsKGcsXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgbm9kZXMgPSBnLm5vZGVzKCk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgcmVzdWx0c1t2XSA9IHt9O1xuICAgIHJlc3VsdHNbdl1bdl0gPSB7IGRpc3RhbmNlOiAwIH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAodiAhPT0gdykge1xuICAgICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWRnZUZuKHYpLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnY7XG4gICAgICB2YXIgZCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IGQsIHByZWRlY2Vzc29yOiB2IH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciByb3dLID0gcmVzdWx0c1trXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciByb3dJID0gcmVzdWx0c1tpXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICB2YXIgaWsgPSByb3dJW2tdO1xuICAgICAgICB2YXIga2ogPSByb3dLW2pdO1xuICAgICAgICB2YXIgaWogPSByb3dJW2pdO1xuICAgICAgICB2YXIgYWx0RGlzdGFuY2UgPSBpay5kaXN0YW5jZSArIGtqLmRpc3RhbmNlO1xuICAgICAgICBpZiAoYWx0RGlzdGFuY2UgPCBpai5kaXN0YW5jZSkge1xuICAgICAgICAgIGlqLmRpc3RhbmNlID0gYWx0RGlzdGFuY2U7XG4gICAgICAgICAgaWoucHJlZGVjZXNzb3IgPSBrai5wcmVkZWNlc3NvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvbmVudHM6IHJlcXVpcmUoXCIuL2NvbXBvbmVudHNcIiksXG4gIGRpamtzdHJhOiByZXF1aXJlKFwiLi9kaWprc3RyYVwiKSxcbiAgZGlqa3N0cmFBbGw6IHJlcXVpcmUoXCIuL2RpamtzdHJhLWFsbFwiKSxcbiAgZmluZEN5Y2xlczogcmVxdWlyZShcIi4vZmluZC1jeWNsZXNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IHJlcXVpcmUoXCIuL2Zsb3lkLXdhcnNoYWxsXCIpLFxuICBpc0FjeWNsaWM6IHJlcXVpcmUoXCIuL2lzLWFjeWNsaWNcIiksXG4gIHBvc3RvcmRlcjogcmVxdWlyZShcIi4vcG9zdG9yZGVyXCIpLFxuICBwcmVvcmRlcjogcmVxdWlyZShcIi4vcHJlb3JkZXJcIiksXG4gIHByaW06IHJlcXVpcmUoXCIuL3ByaW1cIiksXG4gIHRhcmphbjogcmVxdWlyZShcIi4vdGFyamFuXCIpLFxuICB0b3Bzb3J0OiByZXF1aXJlKFwiLi90b3Bzb3J0XCIpXG59O1xuIiwidmFyIHRvcHNvcnQgPSByZXF1aXJlKFwiLi90b3Bzb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuZnVuY3Rpb24gaXNBY3ljbGljKGcpIHtcbiAgdHJ5IHtcbiAgICB0b3Bzb3J0KGcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiB0b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RvcmRlcjtcblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicG9zdFwiKTtcbn1cbiIsInZhciBkZnMgPSByZXF1aXJlKFwiLi9kZnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlb3JkZXI7XG5cbmZ1bmN0aW9uIHByZW9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicHJlXCIpO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSByZXF1aXJlKFwiLi4vZGF0YS9wcmlvcml0eS1xdWV1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmltO1xuXG5mdW5jdGlvbiBwcmltKGcsIHdlaWdodEZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgcGFyZW50cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdjtcblxuICBmdW5jdGlvbiB1cGRhdGVOZWlnaGJvcnMoZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgIHZhciBwcmkgPSBwcS5wcmlvcml0eSh3KTtcbiAgICBpZiAocHJpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0RnVuYyhlZGdlKTtcbiAgICAgIGlmIChlZGdlV2VpZ2h0IDwgcHJpKSB7XG4gICAgICAgIHBhcmVudHNbd10gPSB2O1xuICAgICAgICBwcS5kZWNyZWFzZSh3LCBlZGdlV2VpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZy5ub2RlQ291bnQoKSA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcHEuYWRkKHYsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgcmVzdWx0LnNldE5vZGUodik7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGZyb20gYW4gYXJiaXRyYXJ5IG5vZGVcbiAgcHEuZGVjcmVhc2UoZy5ub2RlcygpWzBdLCAwKTtcblxuICB2YXIgaW5pdCA9IGZhbHNlO1xuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICBpZiAoXy5oYXMocGFyZW50cywgdikpIHtcbiAgICAgIHJlc3VsdC5zZXRFZGdlKHYsIHBhcmVudHNbdl0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ3JhcGggaXMgbm90IGNvbm5lY3RlZDogXCIgKyBnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlRWRnZXModikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0YXJqYW47XG5cbmZ1bmN0aW9uIHRhcmphbihnKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9OyAvLyBub2RlIGlkIC0+IHsgb25TdGFjaywgbG93bGluaywgaW5kZXggfVxuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGVudHJ5ID0gdmlzaXRlZFt2XSA9IHtcbiAgICAgIG9uU3RhY2s6IHRydWUsXG4gICAgICBsb3dsaW5rOiBpbmRleCxcbiAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgfTtcbiAgICBzdGFjay5wdXNoKHYpO1xuXG4gICAgZy5zdWNjZXNzb3JzKHYpLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgICBkZnModyk7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmxvd2xpbmspO1xuICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddLm9uU3RhY2spIHtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10uaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVudHJ5Lmxvd2xpbmsgPT09IGVudHJ5LmluZGV4KSB7XG4gICAgICB2YXIgY21wdCA9IFtdO1xuICAgICAgdmFyIHc7XG4gICAgICBkbyB7XG4gICAgICAgIHcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmlzaXRlZFt3XS5vblN0YWNrID0gZmFsc2U7XG4gICAgICAgIGNtcHQucHVzaCh3KTtcbiAgICAgIH0gd2hpbGUgKHYgIT09IHcpO1xuICAgICAgcmVzdWx0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfVxuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICBkZnModik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b3Bzb3J0O1xudG9wc29ydC5DeWNsZUV4Y2VwdGlvbiA9IEN5Y2xlRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHN0YWNrID0ge307XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChfLmhhcyhzdGFjaywgbm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghXy5oYXModmlzaXRlZCwgbm9kZSkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKG5vZGUpLCB2aXNpdCk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgXy5lYWNoKGcuc2lua3MoKSwgdmlzaXQpO1xuXG4gIGlmIChfLnNpemUodmlzaXRlZCkgIT09IGcubm9kZUNvdW50KCkpIHtcbiAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBDeWNsZUV4Y2VwdGlvbigpIHt9XG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsgLy8gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB0byBwYXNzIHRlc3RpbmciLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpb3JpdHlRdWV1ZTtcblxuLyoqXG4gKiBBIG1pbi1wcmlvcml0eSBxdWV1ZSBkYXRhIHN0cnVjdHVyZS4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIENvcm1lbixcbiAqIGV0IGFsLiwgXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLiBUaGUgYmFzaWMgaWRlYSBvZiBhIG1pbi1wcmlvcml0eVxuICogcXVldWUgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IChpbiBPKDEpIHRpbWUpIGdldCB0aGUgc21hbGxlc3Qga2V5IGluXG4gKiB0aGUgcXVldWUuIEFkZGluZyBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgdGFrZXMgTyhsb2cgbikgdGltZS4gQSBrZXkgY2FuXG4gKiBoYXZlIGl0cyBwcmlvcml0eSBkZWNyZWFzZWQgaW4gTyhsb2cgbikgdGltZS5cbiAqL1xuZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgdGhpcy5fYXJyID0gW107XG4gIHRoaXMuX2tleUluZGljZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyB0aGF0IGFyZSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgua2V5OyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgKiprZXkqKiBpcyBpbiB0aGUgcXVldWUgYW5kIGBmYWxzZWAgaWYgbm90LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2tleUluZGljZXMsIGtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqLiBJZiAqKmtleSoqIGlzIG5vdCBwcmVzZW50IGluIHRoZSBxdWV1ZVxuICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuIFRha2VzIGBPKDEpYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHJpb3JpdHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5O1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGlzIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXNcbiAqIGVtcHR5IHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIHVuZGVyZmxvd1wiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyWzBdLmtleTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBrZXkgaW50byB0aGUgcHJpb3JpdHkgcXVldWUuIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgaW5cbiAqIHRoZSBxdWV1ZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYDsgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAqIFRha2VzIGBPKG4pYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgaW5pdGlhbCBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAga2V5ID0gU3RyaW5nKGtleSk7XG4gIGlmICghXy5oYXMoa2V5SW5kaWNlcywga2V5KSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gICAgdmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcbiAgICBrZXlJbmRpY2VzW2tleV0gPSBpbmRleDtcbiAgICBhcnIucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IGtleSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKGxvZyBuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N3YXAoMCwgdGhpcy5fYXJyLmxlbmd0aCAtIDEpO1xuICB2YXIgbWluID0gdGhpcy5fYXJyLnBvcCgpO1xuICBkZWxldGUgdGhpcy5fa2V5SW5kaWNlc1ttaW4ua2V5XTtcbiAgdGhpcy5faGVhcGlmeSgwKTtcbiAgcmV0dXJuIG1pbi5rZXk7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiogdG8gKipwcmlvcml0eSoqLiBJZiB0aGUgbmV3IHByaW9yaXR5IGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIHByaW9yaXR5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byByYWlzZSBwcmlvcml0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBuZXcgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVjcmVhc2UgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKHByaW9yaXR5ID4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBwcmlvcml0eSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBwcmlvcml0eS4gXCIgK1xuICAgICAgICBcIktleTogXCIgKyBrZXkgKyBcIiBPbGQ6IFwiICsgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSArIFwiIE5ldzogXCIgKyBwcmlvcml0eSk7XG4gIH1cbiAgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5faGVhcGlmeSA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGwgPSAyICogaTtcbiAgdmFyIHIgPSBsICsgMTtcbiAgdmFyIGxhcmdlc3QgPSBpO1xuICBpZiAobCA8IGFyci5sZW5ndGgpIHtcbiAgICBsYXJnZXN0ID0gYXJyW2xdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gbCA6IGxhcmdlc3Q7XG4gICAgaWYgKHIgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBsYXJnZXN0ID0gYXJyW3JdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gciA6IGxhcmdlc3Q7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0ICE9PSBpKSB7XG4gICAgICB0aGlzLl9zd2FwKGksIGxhcmdlc3QpO1xuICAgICAgdGhpcy5faGVhcGlmeShsYXJnZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9kZWNyZWFzZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBwcmlvcml0eSA9IGFycltpbmRleF0ucHJpb3JpdHk7XG4gIHZhciBwYXJlbnQ7XG4gIHdoaWxlIChpbmRleCAhPT0gMCkge1xuICAgIHBhcmVudCA9IGluZGV4ID4+IDE7XG4gICAgaWYgKGFycltwYXJlbnRdLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zd2FwKGluZGV4LCBwYXJlbnQpO1xuICAgIGluZGV4ID0gcGFyZW50O1xuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICB2YXIgb3JpZ0FyckkgPSBhcnJbaV07XG4gIHZhciBvcmlnQXJySiA9IGFycltqXTtcbiAgYXJyW2ldID0gb3JpZ0Fycko7XG4gIGFycltqXSA9IG9yaWdBcnJJO1xuICBrZXlJbmRpY2VzW29yaWdBcnJKLmtleV0gPSBpO1xuICBrZXlJbmRpY2VzW29yaWdBcnJJLmtleV0gPSBqO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxudmFyIERFRkFVTFRfRURHRV9OQU1FID0gXCJcXHgwMFwiO1xudmFyIEdSQVBIX05PREUgPSBcIlxceDAwXCI7XG52YXIgRURHRV9LRVlfREVMSU0gPSBcIlxceDAxXCI7XG5cbi8vIEltcGxlbWVudGF0aW9uIG5vdGVzOlxuLy9cbi8vICAqIE5vZGUgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gc3RyaW5nIGlkcyBmb3IgdGhlIG5vZGVzXG4vLyAgKiBFZGdlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIFwiZWRnZU9ialwiLCBlZGdlIG9iamVjdCwgdGhhdCBpc1xuLy8gICAgY29tcG9zZWQgb2YgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFuIGVkZ2U6IHt2LCB3LCBuYW1lfS5cbi8vICAqIEludGVybmFsbHkgd2UgdXNlIGFuIFwiZWRnZUlkXCIsIGEgc3RyaW5naWZpZWQgZm9ybSBvZiB0aGUgZWRnZU9iaiwgdG9cbi8vICAgIHJlZmVyZW5jZSBlZGdlcy4gVGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgYSBwZXJmb3JtYW50IHdheSB0byBsb29rIHRoZXNlXG4vLyAgICBlZGdlcyB1cCBhbmQsIG9iamVjdCBwcm9wZXJ0aWVzLCB3aGljaCBoYXZlIHN0cmluZyBrZXlzLCBhcmUgdGhlIGNsb3Nlc3Rcbi8vICAgIHdlJ3JlIGdvaW5nIHRvIGdldCB0byBhIHBlcmZvcm1hbnQgaGFzaHRhYmxlIGluIEphdmFTY3JpcHQuXG5cbmZ1bmN0aW9uIEdyYXBoKG9wdHMpIHtcbiAgdGhpcy5faXNEaXJlY3RlZCA9IF8uaGFzKG9wdHMsIFwiZGlyZWN0ZWRcIikgPyBvcHRzLmRpcmVjdGVkIDogdHJ1ZTtcbiAgdGhpcy5faXNNdWx0aWdyYXBoID0gXy5oYXMob3B0cywgXCJtdWx0aWdyYXBoXCIpID8gb3B0cy5tdWx0aWdyYXBoIDogZmFsc2U7XG4gIHRoaXMuX2lzQ29tcG91bmQgPSBfLmhhcyhvcHRzLCBcImNvbXBvdW5kXCIpID8gb3B0cy5jb21wb3VuZCA6IGZhbHNlO1xuXG4gIC8vIExhYmVsIGZvciB0aGUgZ3JhcGggaXRzZWxmXG4gIHRoaXMuX2xhYmVsID0gdW5kZWZpbmVkO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IG5vZGVcbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGVkZ2VcbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIHYgLT4gbGFiZWxcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIC8vIHYgLT4gcGFyZW50XG4gICAgdGhpcy5fcGFyZW50ID0ge307XG5cbiAgICAvLyB2IC0+IGNoaWxkcmVuXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXSA9IHt9O1xuICB9XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX2luID0ge307XG5cbiAgLy8gdSAtPiB2IC0+IE51bWJlclxuICB0aGlzLl9wcmVkcyA9IHt9O1xuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9vdXQgPSB7fTtcblxuICAvLyB2IC0+IHcgLT4gTnVtYmVyXG4gIHRoaXMuX3N1Y3MgPSB7fTtcblxuICAvLyBlIC0+IGVkZ2VPYmpcbiAgdGhpcy5fZWRnZU9ianMgPSB7fTtcblxuICAvLyBlIC0+IGxhYmVsXG4gIHRoaXMuX2VkZ2VMYWJlbHMgPSB7fTtcbn1cblxuLyogTnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX25vZGVDb3VudCA9IDA7XG5cbi8qIE51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9lZGdlQ291bnQgPSAwO1xuXG5cbi8qID09PSBHcmFwaCBmdW5jdGlvbnMgPT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RpcmVjdGVkO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTXVsdGlncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNNdWx0aWdyYXBoO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzQ29tcG91bmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ29tcG91bmQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0R3JhcGggPSBmdW5jdGlvbihsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWw7XG59O1xuXG5cbi8qID09PSBOb2RlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0Tm9kZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmtleXModGhpcy5fbm9kZXMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNvdXJjZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9pblt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNpbmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5fb3V0W3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXROb2RlKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbih2LCB2YWx1ZSkge1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9ub2Rlc1t2XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX25vZGVzW3ZdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbih2KTtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aGlzLl9wYXJlbnRbdl0gPSBHUkFQSF9OT0RFO1xuICAgIHRoaXMuX2NoaWxkcmVuW3ZdID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV1bdl0gPSB0cnVlO1xuICB9XG4gIHRoaXMuX2luW3ZdID0ge307XG4gIHRoaXMuX3ByZWRzW3ZdID0ge307XG4gIHRoaXMuX291dFt2XSA9IHt9O1xuICB0aGlzLl9zdWNzW3ZdID0ge307XG4gICsrdGhpcy5fbm9kZUNvdW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX25vZGVzLCB2KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gIGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgdmFyIHJlbW92ZUVkZ2UgPSBmdW5jdGlvbihlKSB7IHNlbGYucmVtb3ZlRWRnZShzZWxmLl9lZGdlT2Jqc1tlXSk7IH07XG4gICAgZGVsZXRlIHRoaXMuX25vZGVzW3ZdO1xuICAgIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdl07XG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbih2KSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgc2VsZi5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgfVxuICAgIF8uZWFjaChfLmtleXModGhpcy5faW5bdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5faW5bdl07XG4gICAgZGVsZXRlIHRoaXMuX3ByZWRzW3ZdO1xuICAgIF8uZWFjaChfLmtleXModGhpcy5fb3V0W3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XTtcbiAgICBkZWxldGUgdGhpcy5fc3Vjc1t2XTtcbiAgICAtLXRoaXMuX25vZGVDb3VudDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbih2LCBwYXJlbnQpIHtcbiAgaWYgKCF0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQgaW4gYSBub24tY29tcG91bmQgZ3JhcGhcIik7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gR1JBUEhfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2UgcGFyZW50IHRvIHN0cmluZ1xuICAgIHBhcmVudCArPSBcIlwiO1xuICAgIGZvciAodmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgIV8uaXNVbmRlZmluZWQoYW5jZXN0b3IpO1xuICAgICAgYW5jZXN0b3IgPSB0aGlzLnBhcmVudChhbmNlc3RvcikpIHtcbiAgICAgIGlmIChhbmNlc3RvciA9PT0gdikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIFwiICsgcGFyZW50KyBcIiBhcyBwYXJlbnQgb2YgXCIgKyB2ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdvdWxkIGNyZWF0ZSBhIGN5Y2xlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Tm9kZShwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgdGhpcy5fcGFyZW50W3ZdID0gcGFyZW50O1xuICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdW3ZdID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0ID0gZnVuY3Rpb24odikge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdGhpcy5fcGFyZW50W3ZdXVt2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudFt2XTtcbiAgICBpZiAocGFyZW50ICE9PSBHUkFQSF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24odikge1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2KSkge1xuICAgIHYgPSBHUkFQSF9OT0RFO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBfLmtleXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSBHUkFQSF9OT0RFKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc05vZGUodikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkc1YgPSB0aGlzLl9wcmVkc1t2XTtcbiAgaWYgKHByZWRzVikge1xuICAgIHJldHVybiBfLmtleXMocHJlZHNWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBzdWNzViA9IHRoaXMuX3N1Y3Nbdl07XG4gIGlmIChzdWNzVikge1xuICAgIHJldHVybiBfLmtleXMoc3Vjc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHMgPSB0aGlzLnByZWRlY2Vzc29ycyh2KTtcbiAgaWYgKHByZWRzKSB7XG4gICAgcmV0dXJuIF8udW5pb24ocHJlZHMsIHRoaXMuc3VjY2Vzc29ycyh2KSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAodikge1xuICB2YXIgbmVpZ2hib3JzO1xuICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLnN1Y2Nlc3NvcnModik7XG4gIH0gZWxzZSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnModik7XG4gIH1cbiAgcmV0dXJuIG5laWdoYm9ycy5sZW5ndGggPT09IDA7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgZGlyZWN0ZWQ6IHRoaXMuX2lzRGlyZWN0ZWQsXG4gICAgbXVsdGlncmFwaDogdGhpcy5faXNNdWx0aWdyYXBoLFxuICAgIGNvbXBvdW5kOiB0aGlzLl9pc0NvbXBvdW5kXG4gIH0pO1xuXG4gIGNvcHkuc2V0R3JhcGgodGhpcy5ncmFwaCgpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24odmFsdWUsIHYpIHtcbiAgICBpZiAoZmlsdGVyKHYpKSB7XG4gICAgICBjb3B5LnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5lYWNoKHRoaXMuX2VkZ2VPYmpzLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvcHkuaGFzTm9kZShlLnYpICYmIGNvcHkuaGFzTm9kZShlLncpKSB7XG4gICAgICBjb3B5LnNldEVkZ2UoZSwgc2VsZi5lZGdlKGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXJlbnRzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnQodikge1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudCh2KTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgY29weS5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudHNbdl0gPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluIHBhcmVudHMpIHtcbiAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICBfLmVhY2goY29weS5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgICBjb3B5LnNldFBhcmVudCh2LCBmaW5kUGFyZW50KHYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxuLyogPT09IEVkZ2UgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRFZGdlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX2VkZ2VPYmpzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8ucmVkdWNlKHZzLCBmdW5jdGlvbih2LCB3KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHNldEVkZ2UodiwgdywgW3ZhbHVlLCBbbmFtZV1dKVxuICogc2V0RWRnZSh7IHYsIHcsIFtuYW1lXSB9LCBbdmFsdWVdKVxuICovXG5HcmFwaC5wcm90b3R5cGUuc2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiwgdywgbmFtZSwgdmFsdWU7XG4gIHZhciB2YWx1ZVNwZWNpZmllZCA9IGZhbHNlO1xuICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAodHlwZW9mIGFyZzAgPT09IFwib2JqZWN0XCIgJiYgYXJnMCAhPT0gbnVsbCAmJiBcInZcIiBpbiBhcmcwKSB7XG4gICAgdiA9IGFyZzAudjtcbiAgICB3ID0gYXJnMC53O1xuICAgIG5hbWUgPSBhcmcwLm5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gYXJnMDtcbiAgICB3ID0gYXJndW1lbnRzWzFdO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2ID0gXCJcIiArIHY7XG4gIHcgPSBcIlwiICsgdztcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiXCIgKyBuYW1lO1xuICB9XG5cbiAgdmFyIGUgPSBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIGlmIChfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKSkge1xuICAgIGlmICh2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSAmJiAhdGhpcy5faXNNdWx0aWdyYXBoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBhIG5hbWVkIGVkZ2Ugd2hlbiBpc011bHRpZ3JhcGggPSBmYWxzZVwiKTtcbiAgfVxuXG4gIC8vIEl0IGRpZG4ndCBleGlzdCwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQuXG4gIC8vIEZpcnN0IGVuc3VyZSB0aGUgbm9kZXMgZXhpc3QuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5zZXROb2RlKHcpO1xuXG4gIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZVNwZWNpZmllZCA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuKHYsIHcsIG5hbWUpO1xuXG4gIHZhciBlZGdlT2JqID0gZWRnZUFyZ3NUb09iaih0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgLy8gRW5zdXJlIHdlIGFkZCB1bmRpcmVjdGVkIGVkZ2VzIGluIGEgY29uc2lzdGVudCB3YXkuXG4gIHYgPSBlZGdlT2JqLnY7XG4gIHcgPSBlZGdlT2JqLnc7XG5cbiAgT2JqZWN0LmZyZWV6ZShlZGdlT2JqKTtcbiAgdGhpcy5fZWRnZU9ianNbZV0gPSBlZGdlT2JqO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICB0aGlzLl9pblt3XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX291dFt2XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX2VkZ2VDb3VudCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gdGhpcy5fZWRnZUxhYmVsc1tlXTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgaWYgKGVkZ2UpIHtcbiAgICB2ID0gZWRnZS52O1xuICAgIHcgPSBlZGdlLnc7XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VPYmpzW2VdO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ddW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl1bZV07XG4gICAgdGhpcy5fZWRnZUNvdW50LS07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaW5FZGdlcyA9IGZ1bmN0aW9uKHYsIHUpIHtcbiAgdmFyIGluViA9IHRoaXMuX2luW3ZdO1xuICBpZiAoaW5WKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMoaW5WKTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLnYgPT09IHU7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBvdXRWID0gdGhpcy5fb3V0W3ZdO1xuICBpZiAob3V0Vikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKG91dFYpO1xuICAgIGlmICghdykge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudyA9PT0gdzsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlRWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBpbkVkZ2VzID0gdGhpcy5pbkVkZ2VzKHYsIHcpO1xuICBpZiAoaW5FZGdlcykge1xuICAgIHJldHVybiBpbkVkZ2VzLmNvbmNhdCh0aGlzLm91dEVkZ2VzKHYsIHcpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5jcmVtZW50T3JJbml0RW50cnkobWFwLCBrKSB7XG4gIGlmIChtYXBba10pIHtcbiAgICBtYXBba10rKztcbiAgfSBlbHNlIHtcbiAgICBtYXBba10gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkobWFwLCBrKSB7XG4gIGlmICghLS1tYXBba10pIHsgZGVsZXRlIG1hcFtrXTsgfVxufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gdiArIEVER0VfS0VZX0RFTElNICsgdyArIEVER0VfS0VZX0RFTElNICtcbiAgICAgICAgICAgICAoXy5pc1VuZGVmaW5lZChuYW1lKSA/IERFRkFVTFRfRURHRV9OQU1FIDogbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9PYmooaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICB2YXIgZWRnZU9iaiA9ICB7IHY6IHYsIHc6IHcgfTtcbiAgaWYgKG5hbWUpIHtcbiAgICBlZGdlT2JqLm5hbWUgPSBuYW1lO1xuICB9XG4gIHJldHVybiBlZGdlT2JqO1xufVxuXG5mdW5jdGlvbiBlZGdlT2JqVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqKSB7XG4gIHJldHVybiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgZWRnZU9iai52LCBlZGdlT2JqLncsIGVkZ2VPYmoubmFtZSk7XG59XG4iLCIvLyBJbmNsdWRlcyBvbmx5IHRoZSBcImNvcmVcIiBvZiBncmFwaGxpYlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiByZXF1aXJlKFwiLi9ncmFwaFwiKSxcbiAgdmVyc2lvbjogcmVxdWlyZShcIi4vdmVyc2lvblwiKVxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cml0ZTogd3JpdGUsXG4gIHJlYWQ6IHJlYWRcbn07XG5cbmZ1bmN0aW9uIHdyaXRlKGcpIHtcbiAgdmFyIGpzb24gPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgZGlyZWN0ZWQ6IGcuaXNEaXJlY3RlZCgpLFxuICAgICAgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSxcbiAgICAgIGNvbXBvdW5kOiBnLmlzQ29tcG91bmQoKVxuICAgIH0sXG4gICAgbm9kZXM6IHdyaXRlTm9kZXMoZyksXG4gICAgZWRnZXM6IHdyaXRlRWRnZXMoZylcbiAgfTtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKGcuZ3JhcGgoKSkpIHtcbiAgICBqc29uLnZhbHVlID0gXy5jbG9uZShnLmdyYXBoKCkpO1xuICB9XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB3cml0ZU5vZGVzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlVmFsdWUgPSBnLm5vZGUodik7XG4gICAgdmFyIHBhcmVudCA9IGcucGFyZW50KHYpO1xuICAgIHZhciBub2RlID0geyB2OiB2IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVkZ2VzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlVmFsdWUgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIGVkZ2UgPSB7IHY6IGUudiwgdzogZS53IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGUubmFtZSkpIHtcbiAgICAgIGVkZ2UubmFtZSA9IGUubmFtZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVkZ2VWYWx1ZSkpIHtcbiAgICAgIGVkZ2UudmFsdWUgPSBlZGdlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZChqc29uKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKGpzb24ub3B0aW9ucykuc2V0R3JhcGgoanNvbi52YWx1ZSk7XG4gIF8uZWFjaChqc29uLm5vZGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0Tm9kZShlbnRyeS52LCBlbnRyeS52YWx1ZSk7XG4gICAgaWYgKGVudHJ5LnBhcmVudCkge1xuICAgICAgZy5zZXRQYXJlbnQoZW50cnkudiwgZW50cnkucGFyZW50KTtcbiAgICB9XG4gIH0pO1xuICBfLmVhY2goanNvbi5lZGdlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldEVkZ2UoeyB2OiBlbnRyeS52LCB3OiBlbnRyeS53LCBuYW1lOiBlbnRyeS5uYW1lIH0sIGVudHJ5LnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgaGFzOiAgcmVxdWlyZShcImxvZGFzaC9oYXNcIiksXG4gICAgICBpc0FycmF5OiByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksXG4gICAgICBpc0VtcHR5OiByZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIiksXG4gICAgICBpc0Z1bmN0aW9uOiByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksXG4gICAgICBpc1VuZGVmaW5lZDogcmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSxcbiAgICAgIGtleXM6IHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSxcbiAgICAgIG1hcDogcmVxdWlyZShcImxvZGFzaC9tYXBcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc2l6ZTogcmVxdWlyZShcImxvZGFzaC9zaXplXCIpLFxuICAgICAgdHJhbnNmb3JtOiByZXF1aXJlKFwibG9kYXNoL3RyYW5zZm9ybVwiKSxcbiAgICAgIHVuaW9uOiByZXF1aXJlKFwibG9kYXNoL3VuaW9uXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFsb2Rhc2gpIHtcbiAgbG9kYXNoID0gd2luZG93Ll87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9kYXNoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMi4xLjgnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cblxuICAvKlxuICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICovXG5cbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3QuSGVhcCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIZWFwO1xuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFeHRyZW11bTtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUd0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUx0O1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBiYXNlU29ydEJ5ID0gcmVxdWlyZSgnLi9fYmFzZVNvcnRCeScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNvbXBhcmVNdWx0aXBsZSA9IHJlcXVpcmUoJy4vX2NvbXBhcmVNdWx0aXBsZScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlT3JkZXJCeTtcbiIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0Qnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlWmlwT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQXNjZW5kaW5nO1xuIiwidmFyIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL19jb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBiYXNlUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlUmFuZ2UnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSYW5nZTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBhc2NpaVNpemUgPSByZXF1aXJlKCcuL19hc2NpaVNpemUnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVTaXplID0gcmVxdWlyZSgnLi9fdW5pY29kZVNpemUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nU2l6ZTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlU2l6ZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvckVhY2gnKTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9fYmFzZUZpbHRlcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyO1xuIiwidmFyIGNyZWF0ZUZpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVGaW5kJyksXG4gICAgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmZvckluUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlRm9yKG9iamVjdCwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JJbjtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXMob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob3RoZXIsICdhJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAqIEBzZWUgXy5tYXBLZXlzXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gKiB9O1xuICpcbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuIiwidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VHdCA9IHJlcXVpcmUoJy4vX2Jhc2VHdCcpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDhcbiAqXG4gKiBfLm1heChbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1heDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgYmFzZUV4dHJlbXVtID0gcmVxdWlyZSgnLi9fYmFzZUV4dHJlbXVtJyksXG4gICAgYmFzZUx0ID0gcmVxdWlyZSgnLi9fYmFzZUx0JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8ubWluKFtdKTtcbiAqIC8vID0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluO1xuIiwidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VMdCA9IHJlcXVpcmUoJy4vX2Jhc2VMdCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICpcbiAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAqIC8vID0+IHsgJ24nOiAxIH1cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAqIC8vID0+IHsgJ24nOiAxIH1cbiAqL1xuZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluQnk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgY3JlYXRlUmFuZ2UgPSByZXF1aXJlKCcuL19jcmVhdGVSYW5nZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gKlxuICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yYW5nZSg0KTtcbiAqIC8vID0+IFswLCAxLCAyLCAzXVxuICpcbiAqIF8ucmFuZ2UoLTQpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAqXG4gKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDQsIDApO1xuICogLy8gPT4gWzEsIDEsIDFdXG4gKlxuICogXy5yYW5nZSgwKTtcbiAqIC8vID0+IFtdXG4gKi9cbnZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG4iLCJ2YXIgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlUmVkdWNlID0gcmVxdWlyZSgnLi9fYmFzZVJlZHVjZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICogYW5kIGBzb3J0QnlgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gKiAgIHJldHVybiBzdW0gKyBuO1xuICogfSwgMCk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG4iLCJ2YXIgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9pc1N0cmluZycpLFxuICAgIHN0cmluZ1NpemUgPSByZXF1aXJlKCcuL19zdHJpbmdTaXplJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAqIC8vID0+IDdcbiAqL1xuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gIH1cbiAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaXplO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlT3JkZXJCeSA9IHJlcXVpcmUoJy4vX2Jhc2VPcmRlckJ5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0sIFtdKTtcbiAqIC8vID0+IFs0LCA5XVxuICpcbiAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgIH1cbiAgfVxuICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbnZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG52YXIgaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICpcbiAqIF8udW5pcXVlSWQoKTtcbiAqIC8vID0+ICcxMDUnXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVJZDtcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi9fYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi9fYmFzZVppcE9iamVjdCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xuZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHppcE9iamVjdDtcbiIsInZhciBuLGwsdSx0LGksbyxyLGY9e30sZT1bXSxjPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7ZnVuY3Rpb24gcyhuLGwpe2Zvcih2YXIgdSBpbiBsKW5bdV09bFt1XTtyZXR1cm4gbn1mdW5jdGlvbiBhKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pfWZ1bmN0aW9uIGgobixsLHUpe3ZhciB0LGksbyxyLGY9YXJndW1lbnRzO2lmKGw9cyh7fSxsKSxhcmd1bWVudHMubGVuZ3RoPjMpZm9yKHU9W3VdLHQ9Mzt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXUucHVzaChmW3RdKTtpZihudWxsIT11JiYobC5jaGlsZHJlbj11KSxudWxsIT1uJiZudWxsIT1uLmRlZmF1bHRQcm9wcylmb3IoaSBpbiBuLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1sW2ldJiYobFtpXT1uLmRlZmF1bHRQcm9wc1tpXSk7cmV0dXJuIHI9bC5rZXksbnVsbCE9KG89bC5yZWYpJiZkZWxldGUgbC5yZWYsbnVsbCE9ciYmZGVsZXRlIGwua2V5LHYobixsLHIsbyl9ZnVuY3Rpb24gdihsLHUsdCxpKXt2YXIgbz17dHlwZTpsLHByb3BzOnUsa2V5OnQscmVmOmksX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6bnVsbCxfX2M6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDB9O3JldHVybiBuLnZub2RlJiZuLnZub2RlKG8pLG99ZnVuY3Rpb24gcCgpe3JldHVybnt9fWZ1bmN0aW9uIGQobil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24geShuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bH1mdW5jdGlvbiBtKG4sbCl7aWYobnVsbD09bClyZXR1cm4gbi5fXz9tKG4uX18sbi5fXy5fX2suaW5kZXhPZihuKSsxKTpudWxsO2Zvcih2YXIgdTtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSlyZXR1cm4gdS5fX2U7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50eXBlP20obik6bnVsbH1mdW5jdGlvbiB3KG4pe3ZhciBsLHU7aWYobnVsbCE9KG49bi5fXykmJm51bGwhPW4uX19jKXtmb3Iobi5fX2U9bi5fX2MuYmFzZT1udWxsLGw9MDtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSl7bi5fX2U9bi5fX2MuYmFzZT11Ll9fZTticmVha31yZXR1cm4gdyhuKX19ZnVuY3Rpb24gZyhsKXsoIWwuX19kJiYobC5fX2Q9ITApJiYxPT09dS5wdXNoKGwpfHxpIT09bi5kZWJvdW5jZVJlbmRlcmluZykmJigoaT1uLmRlYm91bmNlUmVuZGVyaW5nKXx8dCkoayl9ZnVuY3Rpb24gaygpe3ZhciBuLGwsdCxpLG8scixmO2Zvcih1LnNvcnQoZnVuY3Rpb24obixsKXtyZXR1cm4gbC5fX3YuX19iLW4uX192Ll9fYn0pO249dS5wb3AoKTspbi5fX2QmJih0PXZvaWQgMCxpPXZvaWQgMCxyPShvPShsPW4pLl9fdikuX19lLChmPWwuX19QKSYmKHQ9W10saT1UKGYsbyxzKHt9LG8pLGwuX19uLHZvaWQgMCE9PWYub3duZXJTVkdFbGVtZW50LG51bGwsdCxudWxsPT1yP20obyk6ciksJCh0LG8pLGkhPXImJncobykpKX1mdW5jdGlvbiBfKG4sbCx1LHQsaSxvLHIsYyxzKXt2YXIgaCx2LHAsZCx5LHcsZyxrPXUmJnUuX19rfHxlLF89ay5sZW5ndGg7aWYoYz09ZiYmKGM9bnVsbCE9bz9vWzBdOl8/bSh1LDApOm51bGwpLGg9MCxsLl9faz1iKGwuX19rLGZ1bmN0aW9uKHUpe2lmKG51bGwhPXUpe2lmKHUuX189bCx1Ll9fYj1sLl9fYisxLG51bGw9PT0ocD1rW2hdKXx8cCYmdS5rZXk9PXAua2V5JiZ1LnR5cGU9PT1wLnR5cGUpa1toXT12b2lkIDA7ZWxzZSBmb3Iodj0wO3Y8Xzt2Kyspe2lmKChwPWtbdl0pJiZ1LmtleT09cC5rZXkmJnUudHlwZT09PXAudHlwZSl7a1t2XT12b2lkIDA7YnJlYWt9cD1udWxsfWlmKGQ9VChuLHUscD1wfHxmLHQsaSxvLHIsYyxzKSwodj11LnJlZikmJnAucmVmIT12JiYoZ3x8KGc9W10pLHAucmVmJiZnLnB1c2gocC5yZWYsbnVsbCx1KSxnLnB1c2godix1Ll9fY3x8ZCx1KSksbnVsbCE9ZCl7aWYobnVsbD09dyYmKHc9ZCksbnVsbCE9dS5fX2QpZD11Ll9fZCx1Ll9fZD1udWxsO2Vsc2UgaWYobz09cHx8ZCE9Y3x8bnVsbD09ZC5wYXJlbnROb2RlKXtuOmlmKG51bGw9PWN8fGMucGFyZW50Tm9kZSE9PW4pbi5hcHBlbmRDaGlsZChkKTtlbHNle2Zvcih5PWMsdj0wOyh5PXkubmV4dFNpYmxpbmcpJiZ2PF87dis9MilpZih5PT1kKWJyZWFrIG47bi5pbnNlcnRCZWZvcmUoZCxjKX1cIm9wdGlvblwiPT1sLnR5cGUmJihuLnZhbHVlPVwiXCIpfWM9ZC5uZXh0U2libGluZyxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnR5cGUmJihsLl9fZD1kKX19cmV0dXJuIGgrKyx1fSksbC5fX2U9dyxudWxsIT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsLnR5cGUpZm9yKGg9by5sZW5ndGg7aC0tOyludWxsIT1vW2hdJiZhKG9baF0pO2ZvcihoPV87aC0tOyludWxsIT1rW2hdJiZBKGtbaF0sa1toXSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKXooZ1toXSxnWysraF0sZ1srK2hdKX1mdW5jdGlvbiBiKG4sbCx1KXtpZihudWxsPT11JiYodT1bXSksbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBuKWwmJnUucHVzaChsKG51bGwpKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpZm9yKHZhciB0PTA7dDxuLmxlbmd0aDt0KyspYihuW3RdLGwsdSk7ZWxzZSB1LnB1c2gobD9sKFwic3RyaW5nXCI9PXR5cGVvZiBufHxcIm51bWJlclwiPT10eXBlb2Ygbj92KG51bGwsbixudWxsLG51bGwpOm51bGwhPW4uX19lfHxudWxsIT1uLl9fYz92KG4udHlwZSxuLnByb3BzLG4ua2V5LG51bGwpOm4pOm4pO3JldHVybiB1fWZ1bmN0aW9uIHgobixsLHUsdCxpKXt2YXIgbztmb3IobyBpbiB1KW8gaW4gbHx8UChuLG8sbnVsbCx1W29dLHQpO2ZvcihvIGluIGwpaSYmXCJmdW5jdGlvblwiIT10eXBlb2YgbFtvXXx8XCJ2YWx1ZVwiPT09b3x8XCJjaGVja2VkXCI9PT1vfHx1W29dPT09bFtvXXx8UChuLG8sbFtvXSx1W29dLHQpfWZ1bmN0aW9uIEMobixsLHUpe1wiLVwiPT09bFswXT9uLnNldFByb3BlcnR5KGwsdSk6bltsXT1cIm51bWJlclwiPT10eXBlb2YgdSYmITE9PT1jLnRlc3QobCk/dStcInB4XCI6bnVsbD09dT9cIlwiOnV9ZnVuY3Rpb24gUChuLGwsdSx0LGkpe3ZhciBvLHIsZixlLGM7aWYoaT9cImNsYXNzTmFtZVwiPT09bCYmKGw9XCJjbGFzc1wiKTpcImNsYXNzXCI9PT1sJiYobD1cImNsYXNzTmFtZVwiKSxcImtleVwiPT09bHx8XCJjaGlsZHJlblwiPT09bCk7ZWxzZSBpZihcInN0eWxlXCI9PT1sKWlmKG89bi5zdHlsZSxcInN0cmluZ1wiPT10eXBlb2YgdSlvLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYoby5jc3NUZXh0PVwiXCIsdD1udWxsKSx0KWZvcihyIGluIHQpdSYmciBpbiB1fHxDKG8scixcIlwiKTtpZih1KWZvcihmIGluIHUpdCYmdVtmXT09PXRbZl18fEMobyxmLHVbZl0pfWVsc2VcIm9cIj09PWxbMF0mJlwiblwiPT09bFsxXT8oZT1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGM9bC50b0xvd2VyQ2FzZSgpLGw9KGMgaW4gbj9jOmwpLnNsaWNlKDIpLHU/KHR8fG4uYWRkRXZlbnRMaXN0ZW5lcihsLE4sZSksKG4ubHx8KG4ubD17fSkpW2xdPXUpOm4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLE4sZSkpOlwibGlzdFwiIT09bCYmXCJ0YWdOYW1lXCIhPT1sJiZcImZvcm1cIiE9PWwmJiFpJiZsIGluIG4/bltsXT1udWxsPT11P1wiXCI6dTpcImZ1bmN0aW9uXCIhPXR5cGVvZiB1JiZcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiYobCE9PShsPWwucmVwbGFjZSgvXnhsaW5rOj8vLFwiXCIpKT9udWxsPT11fHwhMT09PXU/bi5yZW1vdmVBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixsLnRvTG93ZXJDYXNlKCkpOm4uc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsbC50b0xvd2VyQ2FzZSgpLHUpOm51bGw9PXV8fCExPT09dT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuLnNldEF0dHJpYnV0ZShsLHUpKX1mdW5jdGlvbiBOKGwpe3RoaXMubFtsLnR5cGVdKG4uZXZlbnQ/bi5ldmVudChsKTpsKX1mdW5jdGlvbiBUKGwsdSx0LGksbyxyLGYsZSxjKXt2YXIgYSxoLHYscCxtLHcsZyxrLHgsQyxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsOyhhPW4uX19iKSYmYSh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihrPXUucHJvcHMseD0oYT1QLmNvbnRleHRUeXBlKSYmaVthLl9fY10sQz1hP3g/eC5wcm9wcy52YWx1ZTphLl9fOmksdC5fX2M/Zz0oaD11Ll9fYz10Ll9fYykuX189aC5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9aD1uZXcgUChrLEMpOih1Ll9fYz1oPW5ldyB5KGssQyksaC5jb25zdHJ1Y3Rvcj1QLGgucmVuZGVyPUQpLHgmJnguc3ViKGgpLGgucHJvcHM9ayxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PUMsaC5fX249aSx2PWguX19kPSEwLGguX19oPVtdKSxudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1zKHt9LGguX19zKSkscyhoLl9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhrLGguX19zKSkpLHA9aC5wcm9wcyxtPWguc3RhdGUsdiludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9aC5jb21wb25lbnRXaWxsTW91bnQmJmguY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9aC5jb21wb25lbnREaWRNb3VudCYmaC5fX2gucHVzaChoLmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsPT1oLl9fZSYmbnVsbCE9aC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZoLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoayxDKSwhaC5fX2UmJm51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKGssaC5fX3MsQykpe2ZvcihoLnByb3BzPWssaC5zdGF0ZT1oLl9fcyxoLl9fZD0hMSxoLl9fdj11LHUuX19lPXQuX19lLHUuX19rPXQuX19rLGguX19oLmxlbmd0aCYmZi5wdXNoKGgpLGE9MDthPHUuX19rLmxlbmd0aDthKyspdS5fX2tbYV0mJih1Ll9fa1thXS5fXz11KTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKGssaC5fX3MsQyksbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZShwLG0sdyl9KX1oLmNvbnRleHQ9QyxoLnByb3BzPWssaC5zdGF0ZT1oLl9fcywoYT1uLl9fcikmJmEodSksaC5fX2Q9ITEsaC5fX3Y9dSxoLl9fUD1sLGE9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksdS5fX2s9YihudWxsIT1hJiZhLnR5cGU9PWQmJm51bGw9PWEua2V5P2EucHJvcHMuY2hpbGRyZW46YSksbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJihpPXMocyh7fSxpKSxoLmdldENoaWxkQ29udGV4dCgpKSksdnx8bnVsbD09aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KHc9aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwLG0pKSxfKGwsdSx0LGksbyxyLGYsZSxjKSxoLmJhc2U9dS5fX2UsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksZyYmKGguX19FPWguX189bnVsbCksaC5fX2U9bnVsbH1lbHNlIHUuX19lPWoodC5fX2UsdSx0LGksbyxyLGYsYyk7KGE9bi5kaWZmZWQpJiZhKHUpfWNhdGNoKGwpe24uX19lKGwsdSx0KX1yZXR1cm4gdS5fX2V9ZnVuY3Rpb24gJChsLHUpe24uX19jJiZuLl9fYyh1LGwpLGwuc29tZShmdW5jdGlvbih1KXt0cnl7bD11Ll9faCx1Ll9faD1bXSxsLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobCl7bi5fX2UobCx1Ll9fdil9fSl9ZnVuY3Rpb24gaihuLGwsdSx0LGksbyxyLGMpe3ZhciBzLGEsaCx2LHAsZD11LnByb3BzLHk9bC5wcm9wcztpZihpPVwic3ZnXCI9PT1sLnR5cGV8fGksbnVsbD09biYmbnVsbCE9bylmb3Iocz0wO3M8by5sZW5ndGg7cysrKWlmKG51bGwhPShhPW9bc10pJiYobnVsbD09PWwudHlwZT8zPT09YS5ub2RlVHlwZTphLmxvY2FsTmFtZT09PWwudHlwZSkpe249YSxvW3NdPW51bGw7YnJlYWt9aWYobnVsbD09bil7aWYobnVsbD09PWwudHlwZSlyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoeSk7bj1pP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsbC50eXBlKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KGwudHlwZSksbz1udWxsfWlmKG51bGw9PT1sLnR5cGUpbnVsbCE9byYmKG9bby5pbmRleE9mKG4pXT1udWxsKSxkIT09eSYmKG4uZGF0YT15KTtlbHNlIGlmKGwhPT11KXtpZihudWxsIT1vJiYobz1lLnNsaWNlLmNhbGwobi5jaGlsZE5vZGVzKSksaD0oZD11LnByb3BzfHxmKS5kYW5nZXJvdXNseVNldElubmVySFRNTCx2PXkuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWMpe2lmKGQ9PT1mKWZvcihkPXt9LHA9MDtwPG4uYXR0cmlidXRlcy5sZW5ndGg7cCsrKWRbbi5hdHRyaWJ1dGVzW3BdLm5hbWVdPW4uYXR0cmlidXRlc1twXS52YWx1ZTsodnx8aCkmJih2JiZoJiZ2Ll9faHRtbD09aC5fX2h0bWx8fChuLmlubmVySFRNTD12JiZ2Ll9faHRtbHx8XCJcIikpfXgobix5LGQsaSxjKSxsLl9faz1sLnByb3BzLmNoaWxkcmVuLHZ8fF8obixsLHUsdCxcImZvcmVpZ25PYmplY3RcIiE9PWwudHlwZSYmaSxvLHIsZixjKSxjfHwoXCJ2YWx1ZVwiaW4geSYmdm9pZCAwIT09eS52YWx1ZSYmeS52YWx1ZSE9PW4udmFsdWUmJihuLnZhbHVlPW51bGw9PXkudmFsdWU/XCJcIjp5LnZhbHVlKSxcImNoZWNrZWRcImluIHkmJnZvaWQgMCE9PXkuY2hlY2tlZCYmeS5jaGVja2VkIT09bi5jaGVja2VkJiYobi5jaGVja2VkPXkuY2hlY2tlZCkpfXJldHVybiBufWZ1bmN0aW9uIHoobCx1LHQpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2wodSk6bC5jdXJyZW50PXV9Y2F0Y2gobCl7bi5fX2UobCx0KX19ZnVuY3Rpb24gQShsLHUsdCl7dmFyIGksbyxyO2lmKG4udW5tb3VudCYmbi51bm1vdW50KGwpLChpPWwucmVmKSYmeihpLG51bGwsdSksdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgbC50eXBlfHwodD1udWxsIT0obz1sLl9fZSkpLGwuX19lPWwuX19kPW51bGwsbnVsbCE9KGk9bC5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtpLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobCl7bi5fX2UobCx1KX1pLmJhc2U9aS5fX1A9bnVsbH1pZihpPWwuX19rKWZvcihyPTA7cjxpLmxlbmd0aDtyKyspaVtyXSYmQShpW3JdLHUsdCk7bnVsbCE9byYmYShvKX1mdW5jdGlvbiBEKG4sbCx1KXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihuLHUpfWZ1bmN0aW9uIEUobCx1LHQpe3ZhciBpLHIsYztuLl9fJiZuLl9fKGwsdSkscj0oaT10PT09byk/bnVsbDp0JiZ0Ll9fa3x8dS5fX2ssbD1oKGQsbnVsbCxbbF0pLGM9W10sVCh1LChpP3U6dHx8dSkuX19rPWwscnx8ZixmLHZvaWQgMCE9PXUub3duZXJTVkdFbGVtZW50LHQmJiFpP1t0XTpyP251bGw6ZS5zbGljZS5jYWxsKHUuY2hpbGROb2RlcyksYyx0fHxmLGkpLCQoYyxsKX1mdW5jdGlvbiBIKG4sbCl7RShuLGwsbyl9ZnVuY3Rpb24gSShuLGwpe3JldHVybiBsPXMocyh7fSxuLnByb3BzKSxsKSxhcmd1bWVudHMubGVuZ3RoPjImJihsLmNoaWxkcmVuPWUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpLHYobi50eXBlLGwsbC5rZXl8fG4ua2V5LGwucmVmfHxuLnJlZil9ZnVuY3Rpb24gTChuKXt2YXIgbD17fSx1PXtfX2M6XCJfX2NDXCIrcisrLF9fOm4sQ29uc3VtZXI6ZnVuY3Rpb24obixsKXtyZXR1cm4gbi5jaGlsZHJlbihsKX0sUHJvdmlkZXI6ZnVuY3Rpb24obil7dmFyIHQsaT10aGlzO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHQ9W10sdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbFt1Ll9fY109aSxsfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihsKXtuLnZhbHVlIT09bC52YWx1ZSYmdC5zb21lKGZ1bmN0aW9uKG4pe24uY29udGV4dD1sLnZhbHVlLGcobil9KX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dC5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Quc3BsaWNlKHQuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LkNvbnN1bWVyLmNvbnRleHRUeXBlPXUsdX1uPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHU7bD1sLl9fOylpZigodT1sLl9fYykmJiF1Ll9fKXRyeXtpZih1LmNvbnN0cnVjdG9yJiZudWxsIT11LmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcil1LnNldFN0YXRlKHUuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKG4pKTtlbHNle2lmKG51bGw9PXUuY29tcG9uZW50RGlkQ2F0Y2gpY29udGludWU7dS5jb21wb25lbnREaWRDYXRjaChuKX1yZXR1cm4gZyh1Ll9fRT11KX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJnZvaWQgMD09PW4uY29uc3RydWN0b3J9LHkucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKG4sbCl7dmFyIHU7dT10aGlzLl9fcyE9PXRoaXMuc3RhdGU/dGhpcy5fX3M6dGhpcy5fX3M9cyh7fSx0aGlzLnN0YXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKHUsdGhpcy5wcm9wcykpLG4mJnModSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKHRoaXMuX19lPSExLGwmJnRoaXMuX19oLnB1c2gobCksZyh0aGlzKSl9LHkucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMuX192JiYodGhpcy5fX2U9ITAsbiYmdGhpcy5fX2gucHVzaChuKSxnKHRoaXMpKX0seS5wcm90b3R5cGUucmVuZGVyPWQsdT1bXSx0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/UHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKTpzZXRUaW1lb3V0LG89ZixyPTA7ZXhwb3J0e0UgYXMgcmVuZGVyLEggYXMgaHlkcmF0ZSxoIGFzIGNyZWF0ZUVsZW1lbnQsaCxkIGFzIEZyYWdtZW50LHAgYXMgY3JlYXRlUmVmLGwgYXMgaXNWYWxpZEVsZW1lbnQseSBhcyBDb21wb25lbnQsSSBhcyBjbG9uZUVsZW1lbnQsTCBhcyBjcmVhdGVDb250ZXh0LGIgYXMgdG9DaGlsZEFycmF5LEEgYXMgX3VubW91bnQsbiBhcyBvcHRpb25zfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJy4uL2NvbnRyb2xsZXInO1xuaW1wb3J0IEN5dG9zY2FwZSBmcm9tICdjeXRvc2NhcGUnO1xuaW1wb3J0IHsgc3R5bGUgfSBmcm9tICcuLi9jeS1jb25mJztcbmltcG9ydCBDeXRvc2NhcGVDb21wb25lbnQgZnJvbSAnLi9jeXRvc2NhcGUnO1xuaW1wb3J0IHsgaXNEZXYgfSBmcm9tICcuLi9lbnYnO1xuaW1wb3J0IHsgTm9kZUluZm8gfSBmcm9tICcuL25vZGUtaW5mbyc7XG5pbXBvcnQgeyBNZW51IH0gZnJvbSAnLi9tZW51JztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCAqIGFzIGRhdGEgZnJvbSAnLi4vY3ktY29uZi9kYXRhLmpzb24nO1xuaW1wb3J0IGRhZ3JlIGZyb20gJ2N5dG9zY2FwZS1kYWdyZSc7XG5pbXBvcnQgZXVsZXIgZnJvbSAnY3l0b3NjYXBlLWV1bGVyJztcbmNsYXNzIEFwcENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCBsYXlvdXRzID0ge1xuICAgICAgREFHOiB7XG4gICAgICAgIG5hbWU6ICdkYWdyZScsXG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgcmFua0RpcjogJ1RCJyxcbiAgICAgICAgbm9kZVNlcDogMTIwLFxuICAgICAgICBlZGdlU2VwOiAyMDAsXG4gICAgICAgIHJhbmtTZXA6IDE1MCxcbiAgICAgICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgICAgICBmaXQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgRkRHOiB7XG4gICAgICAgIG5hbWU6ICdldWxlcicsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMzAwLFxuICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgZml0OiBmYWxzZSxcbiAgICAgICAgcGFkZGluZzogMTAsIFxuICAgICAgICBjZW50ZXJHcmFwaDogdHJ1ZSxcbiAgICAgICAgc3ByaW5nQ29lZmY6IDAuMDAwOCxcbiAgICAgICAgbWFzczogMTUsXG4gICAgICAgIGdyYXZpdHk6IC0xMCxcbiAgICAgICAgcHVsbDogMC4wMDAxLFxuICAgICAgICB0aGV0YTogMC4zMzMsXG4gICAgICAgIGRyYWdDb2VmZjogMC4wMixcbiAgICAgICAgbW92ZW1lbnRUaHJlc2hvbGQ6IDEsXG4gICAgICAgIHRpbWVTdGVwOiAyMCxcbiAgICAgICAgcmVmcmVzaDogMTAsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgICAgICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCxcbiAgICAgICAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSxcbiAgICAgICAgcmFuZG9taXplOiB0cnVlXG4gICAgICB9XG4gICAgfTtcblxuICAgIEN5dG9zY2FwZS51c2UoZGFncmUpO1xuICAgIEN5dG9zY2FwZS51c2UoZXVsZXIpO1xuXG4gICAgZnVuY3Rpb24gR2V0TmFtZShub2RlKSB7XG4gICAgICBsZXQgamZUeXBlcyA9IFtcImltcHJvdmVtZW50XCIsIFwicGF0dGVyblwiLCBcInNhZ2FcIiwgXCJ1c2VyXCJdO1xuICAgICAgaWYgKGpmVHlwZXMuaW5jbHVkZXMobm9kZS5ncm91cCkpXG4gICAgICB7XG4gICAgICAgIHJldHVybiAoKG5vZGUubmFtZSA9PT0gbnVsbCkgPyBub2RlLmlkIDogKG5vZGUubmFtZSkuc3Vic3RyaW5nKDAsIDEwMCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBjeSA9IG5ldyBDeXRvc2NhcGUoe1xuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbm9kZXM6XG4gICAgICAgICAgZGF0YS5ub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBHZXROYW1lKG5vZGUpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgTm9kZVR5cGU6IG5vZGUuZ3JvdXAsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdlaWdodDogbm9kZS53ZWlnaHQgKyAxMDAsXG4gICAgICAgICAgICAgICAgbGluazogbm9kZS5MaW5rLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBcImZhbHNlXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICBlZGdlczpcbiAgICAgICAgICBkYXRhLmxpbmtzLm1hcChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlkOiAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyksXG4gICAgICAgICAgICAgICAgc291cmNlOiBsaW5rLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGxpbmsudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHdlaWdodDogKGxpbmsud2VpZ2h0ICsgMjApLFxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IGxpbmsuc291cmNlVHlwZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRUeXBlOiBsaW5rLnRhcmdldFR5cGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgICBzdHlsZSxcbiAgICAgIHNlbGVjdGlvblR5cGU6ICdzaW5nbGUnLFxuICAgICAgYm94U2VsZWN0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHdoZWVsU2Vuc2l0aXZpdHk6IDAuMjVcbiAgICB9KTtcblxuICAgIGN5Lm5vZGVzKCkucGFuaWZ5KCkudW5ncmFiaWZ5KCk7XG5cbiAgICAvL1RPRE8gLSByZW1vdmUgdGhpcyBoYWNrIHdoZW4gSkYgZ2l2ZXMgaW1wcm92ZW1lbnRzIGEgd2VpZ2h0aW5nIGdlbmVyYXRlZFxuICAgIC8vZnJvbSB0aGUgY29tcG9zaXRlIHdlaWdodHMgb2YgdGhlaXIgbGlua2VkIHBhdHRlcm5zXG4gICAgY3kuZWxlbWVudHMoXCJub2RlW05vZGVUeXBlID0gJ2ltcHJvdmVtZW50J11cIikuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmRhdGEoKS53ZWlnaHQgPT0gMTAwKSB7XG4gICAgICAgIGxldCBjb21wb3NpdGVXZWlnaHQgPSAwO1xuICAgICAgICBlbGVtZW50Lm91dGdvZXJzKFwibm9kZVtOb2RlVHlwZSA9ICdwYXR0ZXJuJ11cIikuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICAgICAgICBjb21wb3NpdGVXZWlnaHQgPSBjb21wb3NpdGVXZWlnaHQgKyBwYXR0ZXJuLmRhdGEoKS53ZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmluY29tZXJzKFwibm9kZVtOb2RlVHlwZSA9ICdzYWdhJ11cIikuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICAgICAgICBjb21wb3NpdGVXZWlnaHQgPSBjb21wb3NpdGVXZWlnaHQgKyBwYXR0ZXJuLmRhdGEoKS53ZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmRhdGEoKS53ZWlnaHQgPSAoMTAwICsgKGNvbXBvc2l0ZVdlaWdodC84KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoeyBjeSwgbGF5b3V0cyB9KTtcbiAgICBjb25zdCBidXMgPSBjb250cm9sbGVyLmJ1cztcblxuICAgIGlmKCBpc0RldiApe1xuICAgICAgd2luZG93LmN5ID0gY3k7XG4gICAgICB3aW5kb3cuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICBcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0geyBjb250cm9sbGVyLCBjeSB9O1xuICAgIGNvbnRyb2xsZXIucnVuTGF5b3V0KCk7XG5cbiAgICBidXMub24oJ3Nob3dJbmZvJywgdGhpcy5vblNob3dJbmZvID0gKG5vZGUgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluZm9Ob2RlOiBub2RlIH0pO1xuICAgIH0pKTtcblxuICAgIGJ1cy5vbignaGlkZUluZm8nLCB0aGlzLm9uSGlkZUluZm8gPSAoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluZm9Ob2RlOiBudWxsIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgY29uc3QgYnVzID0gdGhpcy5zdGF0ZS5jb250cm9sbGVyLmJ1cztcblxuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignc2hvd0luZm8nLCB0aGlzLm9uU2hvd0luZm8pO1xuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignaGlkZUluZm8nLCB0aGlzLm9uSGlkZUluZm8pO1xuICB9XG5cbiAgdHJ1bmNhdGVTdHJpbmcoc3RyLCBudW0pIHtcbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiBzdHIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG51bVxuICAvLyBqdXN0IHJldHVybiBzdHItLWRvbid0IHRydW5jYXRlIGl0LlxuICBpZiAoc3RyLmxlbmd0aCA8PSBudW0pIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIC8vIFJldHVybiBzdHIgdHJ1bmNhdGVkIHdpdGggJy4uLicgY29uY2F0ZW5hdGVkIHRvIHRoZSBlbmQgb2Ygc3RyLlxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbnVtKSArICcuLi4nO1xufVxuXG4gIHJlbmRlcigpe1xuICAgIGNvbnN0IHsgY3ksIGNvbnRyb2xsZXIsIGluZm9Ob2RlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIGgoJ2RpdicsIHsgY2xhc3M6ICdhcHAnIH0sIFtcbiAgICAgIGgoQ3l0b3NjYXBlQ29tcG9uZW50LCB7IGN5LCBjb250cm9sbGVyIH0pLFxuXG4gICAgICBpbmZvTm9kZSA/IChcbiAgICAgICAgaCgnZGl2JywgeyBjbGFzczogJ2FwcC1ub2RlLWluZm8nIH0sIFtcbiAgICAgICAgICBoKE5vZGVJbmZvLCB7IG5vZGU6IGluZm9Ob2RlIH0pXG4gICAgICAgIF0pXG4gICAgICApIDogbnVsbCxcblxuICAgICAgaChNZW51LCB7IGNvbnRyb2xsZXIgfSksXG4gICAgICBoKEZpbHRlciwgeyBjb250cm9sbGVyIH0pXG4gICAgXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwQ29tcG9uZW50O1xuZXhwb3J0IHsgQXBwQ29tcG9uZW50IH07IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuY2xhc3MgQ3l0b3NjYXBlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiBoKCdkaXYnLCB7IGlkOiAnY3knIH0pOyAgICBcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgY29uc3QgeyBjeSwgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3knKTtcblxuICAgIGN5Lm1vdW50KGNvbnRhaW5lcik7XG4gICAgY3kuZml0KDEwKTtcblxuICAgIGN5Lm9uKCd0YXAnLCB0aGlzLm9uVGFwID0gZSA9PiB7XG4gICAgICBpZiggZS50YXJnZXQgPT09IGN5ICl7XG4gICAgICAgIGNvbnRyb2xsZXIudW5oaWdobGlnaHQoKTtcbiAgICAgICAgY29udHJvbGxlci5oaWRlSW5mbygpO1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlTWVudSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5oaWdobGlnaHQoZS50YXJnZXQpO1xuICAgICAgICBjb250cm9sbGVyLnNob3dJbmZvKGUudGFyZ2V0KTtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZU1lbnUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgY29uc3QgeyBjeSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGN5LnJlbW92ZUxpc3RlbmVyKCd0YXAnLCB0aGlzLm9uVGFwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDeXRvc2NhcGVDb21wb25lbnQ7XG5leHBvcnQgeyBDeXRvc2NhcGVDb21wb25lbnQgfTsiLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmNsYXNzIEZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgYnVzIH0gPSBjb250cm9sbGVyO1xuXG4gICAgICAgIGJ1cy5vbignY2hhbmdlVHlwZScsIHRoaXMuY2hhbmdlQ2hhcnRUeXBlID0gKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHNldENoYXJ0VHlwZUxhYmVsKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRvZ2dsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydC10eXBlLWxhYmVsJyk7XG4gICAgICAgIHRvZ2dsZS52YWx1ZSA9IFwiQ2hhcnQgVHlwZTogXCIgKyBjb250cm9sbGVyLmNoYXJ0VHlwZTtcbiAgICB9XG5cbiAgICB0b2dnbGVQYXR0ZXJucygpIHtcbiAgICAgICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb250cm9sbGVyLnRvZ2dsZVBhdHRlcm5zKCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlSW1wcm92ZW1lbnRzKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlSW1wcm92ZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlU2FnYXMoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29udHJvbGxlci50b2dnbGVTYWdhcygpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFzc3VtcHRpb25zKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlQXNzdW1wdGlvbnMoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVBcHByb2FjaGVzKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlQXBwcm9hY2hlcygpO1xuICAgIH1cblxuICAgIHRvZ2dsZUdvYWxzKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlR29hbHMoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVPcnBoYW5zKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlT3JwaGFucygpO1xuICAgIH1cblxuICAgIHRvZ2dsZVByaW9yaXR5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnRyb2xsZXIudG9nZ2xlUHJpb3JpdHkoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVVc2VycygpIHtcbiAgICAgICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb250cm9sbGVyLnRvZ2dsZVVzZXJzKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVzIH0gPSB0aGlzLnByb3BzLmNvbnRyb2xsZXI7XG4gICAgICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlVHlwZScsIHRoaXMuY2hhbmdlQ2hhcnRUeXBlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzczogJ2ZpbHRlcicgfSwgW1xuICAgICAgICAgICAgaCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc05hbWVzKHsgJ2NoYXJ0LXR5cGUtdG9nZ2xlJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBjb250cm9sbGVyLnRvZ2dsZUNoYXJ0VHlwZSgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyBjaGFydC10eXBlJywgaWQ6ICdjaGFydC10eXBlLWxhYmVsJyB9LCBcIkNoYXJ0IFR5cGU6IFwiICsgY29udHJvbGxlci5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIuYXNzdW1wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnRvZ2dsZUFzc3VtcHRpb25zKClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3NsaWRlciByb3VuZCBhc3N1bXB0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyBhc3N1bXB0aW9ucycgfSwgJ2Fzc3VtcHRpb25zJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIuZ29hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnRvZ2dsZUdvYWxzKClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3NsaWRlciByb3VuZCBnb2FsJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyBnb2FscycgfSwgJ2dvYWxzJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIuYXBwcm9hY2hlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMudG9nZ2xlQXBwcm9hY2hlcygpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoKCdzcGFuJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdzbGlkZXIgcm91bmQgYXBwcm9hY2gnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgaCgnc3BhbicsIHsgY2xhc3M6ICdzbGlkZXItbGFiZWxzIGFwcHJvYWNoZXMnIH0sICdhcHByb2FjaGVzJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIuc2FnYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnRvZ2dsZVNhZ2FzKClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3NsaWRlciByb3VuZCBzYWdhJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyBzYWdhcycgfSwgJ3NhZ2FzJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIuaW1wcm92ZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gdGhpcy50b2dnbGVJbXByb3ZlbWVudHMoKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnc2xpZGVyIHJvdW5kIGltcHJvdmVtZW50J1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyBpbXByb3ZlbWVudHMnIH0sICdpbXByb3ZlbWVudHMnKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBoKCdkaXYnLCB7IGNsYXNzOiBjbGFzc05hbWVzKHsgJ2ZpbHRlci1wb3NpdGlvbic6IHRydWUgfSkgfSwgW1xuICAgICAgICAgICAgICAgIGgoJ2xhYmVsJywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdzd2l0Y2gnOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogY29udHJvbGxlci5wYXR0ZXJucyxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gdGhpcy50b2dnbGVQYXR0ZXJucygpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnc2xpZGVyIHJvdW5kIHBhdHRlcm4nXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBoKCdzcGFuJywge2NsYXNzOiAnc2xpZGVyLWxhYmVscyBwYXR0ZXJucyd9LCAncGF0dGVybnMnKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBoKCdkaXYnLCB7IGNsYXNzOiBjbGFzc05hbWVzKHsgJ2ZpbHRlci1wb3NpdGlvbic6IHRydWUgfSkgfSwgW1xuICAgICAgICAgICAgICAgIGgoJ2xhYmVsJywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdzd2l0Y2gnOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgaCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogY29udHJvbGxlci51c2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMudG9nZ2xlVXNlcnMoKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnc2xpZGVyIHJvdW5kIHVzZXJzJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7IGNsYXNzOiAnc2xpZGVyLWxhYmVscyB1c2VycycgfSwgJ3VzZXJzJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIub3JwaGFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMudG9nZ2xlT3JwaGFucygpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoKCdzcGFuJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdzbGlkZXIgcm91bmQnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgaCgnc3BhbicsIHsgY2xhc3M6ICdzbGlkZXItbGFiZWxzIG9ycGhhbnMnIH0sICdvcnBoYW5zJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdmaWx0ZXItcG9zaXRpb24nOiB0cnVlIH0pIH0sIFtcbiAgICAgICAgICAgICAgICBoKCdsYWJlbCcsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnc3dpdGNoJzogdHJ1ZSB9KSB9LCBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbnRyb2xsZXIucHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnRvZ2dsZVByaW9yaXR5KClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3NsaWRlciByb3VuZCBwcmlvcml0eSdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBoKCdzcGFuJywgeyBjbGFzczogJ3NsaWRlci1sYWJlbHMgcHJpb3JpdHknIH0sICdwcmlvcml0aXNhdGlvbicpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdKTtcbiAgICAgICAgXG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlcjtcbmV4cG9ydCB7IEZpbHRlciB9OyIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2guZGVib3VuY2UnO1xuaW1wb3J0IHsgTm9kZUluZm8gfSBmcm9tICcuL25vZGUtaW5mbyc7XG5cbmNsYXNzIE1lbnUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGJ1cyB9ID0gY29udHJvbGxlcjtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBvcGVuOiBjb250cm9sbGVyLmlzTWVudU9wZW4oKVxuICAgIH07XG5cbiAgICBidXMub24oJ29wZW5NZW51JywgdGhpcy5vbk9wZW5NZW51ID0gKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiB0cnVlIH0pO1xuXG4gICAgICB0aGlzLmZvY3VzVGV4dEJveCgpO1xuICAgIH0pKTtcblxuICAgIGJ1cy5vbignY2xvc2VNZW51JywgdGhpcy5vbk9wZW5NZW51ID0gKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiBmYWxzZSB9KTtcbiAgICB9KSk7XG5cbiAgICBidXMub24oJ3VwZGF0ZVNlYXJjaCcsIHRoaXMub25VcGRhdGVTZWFyY2ggPSAoc2VhcmNoTWF0Y2hOb2RlcyA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoTWF0Y2hOb2RlcyB9KTtcbiAgICB9KSk7XG5cbiAgICB0aGlzLmRlYm91bmNlZFVwZGF0ZVNlYXJjaCA9IGRlYm91bmNlKCgpID0+IHRoaXMudXBkYXRlU2VhcmNoKCksIDI1MCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpe1xuICAgIGNvbnN0IHsgYnVzIH0gPSB0aGlzLnByb3BzLmNvbnRyb2xsZXI7XG5cbiAgICBidXMucmVtb3ZlTGlzdGVuZXIoJ29wZW5NZW51JywgdGhpcy5vbk9wZW5NZW51KTtcbiAgICBidXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlTWVudScsIHRoaXMub25DbG9zZU1lbnUpO1xuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlU2VhcmNoJywgdGhpcy5vblVwZGF0ZVNlYXJjaCk7XG4gIH1cblxuICBvcGVuKCl7XG4gICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29udHJvbGxlci5vcGVuTWVudSgpO1xuICB9XG5cbiAgdXBkYXRlU2VhcmNoKCl7XG4gICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnUtc2VhcmNoJyk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51LXNlYXJjaC1yZXN1bHRzJyk7XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBpbnB1dC52YWx1ZTtcblxuICAgIHJlc3VsdHMuc2Nyb2xsVG8oMCwgMCk7XG5cbiAgICBjb250cm9sbGVyLnVwZGF0ZVNlYXJjaChxdWVyeVN0cmluZyk7XG4gIH1cblxuICBmb2N1c1RleHRCb3goKXtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51LXNlYXJjaCcpO1xuXG4gICAgaWYoIGlucHV0ICl7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIHNlbGVjdE5vZGUobm9kZSl7XG4gICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29udHJvbGxlci5jbG9zZU1lbnUoKTtcbiAgICBjb250cm9sbGVyLmhpZ2hsaWdodChub2RlKTtcbiAgICBjb250cm9sbGVyLnNob3dJbmZvKG5vZGUpO1xuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgY29uc3QgeyBjb250cm9sbGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgb3Blbiwgc2VhcmNoTWF0Y2hOb2RlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjbG9zZWQgPSAhb3BlbjtcblxuICAgIGxldCBzZWFyY2hSZXN1bHRzID0gW107XG5cbiAgICBpZiggc2VhcmNoTWF0Y2hOb2RlcyApe1xuICAgICAgc2VhcmNoUmVzdWx0cyA9IHNlYXJjaE1hdGNoTm9kZXMubWFwKG5vZGUgPT4gaCgnZGl2Lm1lbnUtbm9kZS1pbmZvJywge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnNlbGVjdE5vZGUobm9kZSlcbiAgICAgIH0sIFtcbiAgICAgICAgaChOb2RlSW5mbywgeyBub2RlIH0pXG4gICAgICBdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgoJ2RpdicsIHsgY2xhc3M6ICdtZW51LXBhcmVudCcgfSwgW1xuICAgICAgaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogY2xhc3NOYW1lcyh7ICdtZW51LXRvZ2dsZSc6IHRydWUsICdtZW51LW9wZW4nOiBvcGVuIH0pLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBjb250cm9sbGVyLnRvZ2dsZU1lbnUoKVxuICAgICAgfSksXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiBjbGFzc05hbWVzKHsgJ21lbnUnOiB0cnVlLCAnbWVudS1jbG9zZWQnOiBjbG9zZWQgfSkgfSwgW1xuICAgICAgICBoKCdpbnB1dCcsIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgY2xhc3M6ICdtZW51LXNlYXJjaCcsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWFyY2gnLFxuICAgICAgICAgIGlkOiAnbWVudS1zZWFyY2gnLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMub3BlbigpLFxuICAgICAgICAgIG9uS2V5RG93bjogKCkgPT4gdGhpcy5kZWJvdW5jZWRVcGRhdGVTZWFyY2goKVxuICAgICAgICB9KSxcbiAgICAgICAgaCgnZGl2JywgeyBjbGFzczogJ21lbnUtc2VhcmNoLXJlc3VsdHMnLCBpZDogJ21lbnUtc2VhcmNoLXJlc3VsdHMnIH0sIHNlYXJjaFJlc3VsdHMpXG4gICAgICBdKVxuICAgIF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lbnU7XG5leHBvcnQgeyBNZW51IH07IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuY2xhc3MgTm9kZUluZm8gZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgY29uc3QgeyBub2RlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGEoKTtcbiAgICBjb25zdCBuYW1lID0gZGF0YS5uYW1lO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uICA9IGRhdGEuZGVzY3JpcHRpb247XG4gICAgY29uc3QgdHlwZSA9IGRhdGEuTm9kZVR5cGU7XG4gICAgY29uc3QgcSA9IGRhdGEubGluaztcblxuICAgIHJldHVybiBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvJyB9LCBbXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvLW5hbWUnIH0sIG5hbWUpLFxuICAgICAgaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mby1kZXNjcmlwdGlvbicgfSwgZGVzY3JpcHRpb24pLFxuICAgICAgaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mby10eXBlJyB9LCB0eXBlKSxcbiAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdub2RlLWluZm8tbW9yZScgfSwgW1xuICAgICAgICBoKCdhJywgeyB0YXJnZXQ6ICdfYmxhbmsnLCBocmVmOiBgJHtxfWAgfSwgJ1ZpZXcgSmVsbHlmaXNoIGNhcmQnKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlSW5mbztcbmV4cG9ydCB7IE5vZGVJbmZvIH07IiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcblxuLy8gc2VhcmNoIHBhcmFtZXRlcnNcbmNvbnN0IG1pbk1ldHJpY1ZhbHVlID0gMC4yNTsgLy8gZmlsdGVyIG91dCBub2RlcyBmcm9tIHNlYXJjaCByZXN1bHRzIGlmIHRoZXkgaGF2ZSB0b3RhbCBzY29yZXMgbG93ZXIgdGhhbiB0aGlzXG5jb25zdCBtaW5TaW1pbGFyaXR5VmFsdWUgPSAwOyAvLyBvbmx5IGluY2x1ZGUgaW4gdG90YWwgbWV0cmljIGlmIHRoZSBpbmRpdmlkdWFsIHNpbSB2YWwgaXMgb24gWzAuNSwgMV1cblxuLy9jaGFydCB0eXBlIGVudW1cbmNvbnN0IENoYXJ0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgRkRHOiAnRkRHJyxcbiAgREFHOiAnREFHJ1xufSk7XG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7IGN5LCBsYXlvdXRzIH0pIHtcbiAgICB0aGlzLmNoYXJ0VHlwZSA9IENoYXJ0VHlwZXMuREFHO1xuICAgIHRoaXMub3JwaGFucyA9IGZhbHNlO1xuICAgIHRoaXMucGF0dGVybnMgPSBmYWxzZTtcbiAgICB0aGlzLmltcHJvdmVtZW50cyA9IGZhbHNlO1xuICAgIHRoaXMuc2FnYXMgPSB0cnVlO1xuICAgIHRoaXMuYXBwcm9hY2hlcyA9IHRydWU7XG4gICAgdGhpcy5hc3N1bXB0aW9ucyA9IHRydWU7XG4gICAgdGhpcy5nb2FscyA9IHRydWU7XG4gICAgdGhpcy51c2VycyA9IGZhbHNlO1xuICAgIHRoaXMuY3kgPSBjeTtcbiAgICB0aGlzLmxheW91dHMgPSBsYXlvdXRzO1xuICAgIHRoaXMuYnVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMubWVudSA9IGZhbHNlO1xuICAgIHRoaXMubm9kZXMgPSBjeS5ub2RlcygpO1xuICAgIHRoaXMuc2VhcmNoTWF0Y2hOb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gZmFsc2U7XG4gIH1cblxuICBpc01lbnVPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm1lbnU7XG4gIH1cblxuICBvcGVuTWVudSgpIHtcbiAgICB0aGlzLm1lbnUgPSB0cnVlO1xuXG4gICAgdGhpcy5idXMuZW1pdCgnb3Blbk1lbnUnKTtcbiAgICB0aGlzLmJ1cy5lbWl0KCd0b2dnbGVNZW51JywgdHJ1ZSk7XG4gIH1cblxuICBjbG9zZU1lbnUoKSB7XG4gICAgdGhpcy5tZW51ID0gZmFsc2U7XG5cbiAgICB0aGlzLmJ1cy5lbWl0KCdjbG9zZU1lbnUnKTtcbiAgICB0aGlzLmJ1cy5lbWl0KCd0b2dnbGVNZW51JywgZmFsc2UpO1xuICB9XG5cbiAgdG9nZ2xlTWVudSgpIHtcbiAgICBpZiAodGhpcy5pc01lbnVPcGVuKCkpIHtcbiAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Blbk1lbnUoKTtcbiAgICB9XG4gIH1cblxuICBpc0luZm9TaG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5pbmZvTm9kZSAhPSBudWxsO1xuICB9XG5cbiAgc2hvd0luZm8obm9kZSkge1xuICAgIHRoaXMuaW5mb05vZGUgPSBub2RlO1xuXG4gICAgdGhpcy5idXMuZW1pdCgnc2hvd0luZm8nLCBub2RlKTtcbiAgfVxuXG4gIGhpZGVJbmZvKCkge1xuICAgIHRoaXMuYnVzLmVtaXQoJ2hpZGVJbmZvJywgdGhpcy5pbmZvTm9kZSk7XG5cbiAgICB0aGlzLmluZm9Ob2RlID0gbnVsbDtcbiAgfVxuXG4gIGhhc0hpZ2hsaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0SGlnaGxpZ2h0ZWQgIT0gbnVsbDtcbiAgfVxuXG4gIHRvZ2dsZUNoYXJ0VHlwZSgpIHtcbiAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09IENoYXJ0VHlwZXMuRkRHKSB7XG4gICAgICB0aGlzLmNoYXJ0VHlwZSA9IENoYXJ0VHlwZXMuREFHO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcnRUeXBlID0gQ2hhcnRUeXBlcy5GREc7XG4gICAgfVxuXG4gICAgdGhpcy5idXMuZW1pdCgnY2hhbmdlVHlwZScpO1xuICAgIHRoaXMucnVuTGF5b3V0KCk7XG4gICAgXG4gIH1cblxuICBydW5MYXlvdXQocmFuZG9taXNlKSB7XG4gICAgdGhpcy5kcmF3TGF5b3V0KHJhbmRvbWlzZSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmFuaW1hdGVWaWV3KCk7XG4gICAgfSk7XG4gIH1cblxuICBhbmltYXRlVmlldygpIHtcbiAgICB0aGlzLmN5LmFuaW1hdGUoe1xuICAgICAgZml0OiB7XG4gICAgICAgIGVsZXM6IHRoaXMuY3ksXG4gICAgICAgIHBhZGRpbmc6IDEwXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZHVyYXRpb246IDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXdMYXlvdXQoKSB7XG4gICAgdGhpcy5yZW1vdmVkTm9kZXMucmVzdG9yZSgpO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gdGhpcy5jeS5jb2xsZWN0aW9uKCk7XG4gIFxuICAgIGlmICghdGhpcy51c2Vycykge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlVHlwZShcInVzZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdHRlcm5zKVxuICAgIHtcbiAgICAgIHRoaXMucmVtb3ZlTm9kZVR5cGUoXCJwYXR0ZXJuXCIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nb2Fscykge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlVHlwZShcImdvYWxcIik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmltcHJvdmVtZW50cykge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlVHlwZShcImltcHJvdmVtZW50XCIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hcHByb2FjaGVzKSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGVUeXBlKFwiYXBwcm9hY2hcIik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFzc3VtcHRpb25zKSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGVUeXBlKFwiYXNzdW1wdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2FnYXMpIHtcbiAgICAgIHRoaXMucmVtb3ZlTm9kZVR5cGUoXCJzYWdhXCIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vcnBoYW5zKVxuICAgIHtcbiAgICAgIHRoaXMucmVtb3ZlT3JwaGFucygpO1xuICAgIH1cblxuIFxuICAgIFxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmN5LnByb21pc2VPbignbGF5b3V0c3RvcCcpO1xuXG4gICAgdGhpcy5jeS5sYXlvdXQoXG5cbiAgICAgIHRoaXMubGF5b3V0c1t0aGlzLmNoYXJ0VHlwZV1cblxuICAgICkucnVuKCk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHJlbW92ZU5vZGVUeXBlKHR5cGUpXG4gIHtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IHRoaXMucmVtb3ZlZE5vZGVzLnVuaW9uKHRoaXMuY3kucmVtb3ZlKCdub2RlW05vZGVUeXBlID0gXCInKyB0eXBlICsgJ1wiXScpKTtcbiAgfVxuXG4gIHJlbW92ZU9ycGhhbnMoKVxuICB7XG4gICAgbGV0IHJlbW92ZWQgPSB0aGlzLmN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHRoaXMuY3kubm9kZXMoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQuZGVncmVlKCkgPCAxKSB7XG4gICAgICAgIHJlbW92ZWQgPSByZW1vdmVkLnVuaW9uKGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgICAgfSk7XG4gICAgXG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSB0aGlzLnJlbW92ZWROb2Rlcy51bmlvbihyZW1vdmVkKTtcbiAgfVxuXG4gIHRvZ2dsZVByaW9yaXR5KCkge1xuICAgIHRoaXMucHJpb3JpdHkgPSAhdGhpcy5wcmlvcml0eTtcbiAgICB0aGlzLnVuaGlnaGxpZ2h0KCk7XG4gICAgdGhpcy5yZW5kZXJQcmlvcml0eSgpO1xuICB9XG5cbiAgcmVuZGVyUHJpb3JpdHkoKVxuICAgIHtcbiAgICBjb25zdCBwcmlvcml0aXNlZFR5cGVzID0gWydpbXByb3ZlbWVudCcsICdzYWdhJ107XG4gICAgcHJpb3JpdGlzZWRUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgdGhpcy50b2dnbGVQcmlvcml0eUZvclR5cGUodHlwZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJ1bkxheW91dCgpO1xuICB9XG5cbiAgdG9nZ2xlUHJpb3JpdHlGb3JUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBpbXByb3ZlbWVudHMgPSB0aGlzLmN5LmVsZW1lbnRzKFwibm9kZVtOb2RlVHlwZSA9ICdcIisgdHlwZSArXCInXVwiKTtcbiAgICBjb25zdCBhbGxFbGxlcyA9IHRoaXMuY3kuZWxlbWVudHMoKTtcbiAgICBcbiAgICBpZiAodGhpcy5wcmlvcml0eSkge1xuICAgICAgdGhpcy5jeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGltcHJvdmVtZW50cy5hZGRDbGFzcygncHJpb3JpdGlzZWQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgdGhpcy5jeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFsbEVsbGVzLnJlbW92ZUNsYXNzKCdwcmlvcml0aXNlZCcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICB9XG5cbiAgcmVzZXRWaWV3KCkge1xuICAgIHRoaXMudW5oaWdobGlnaHQoKTtcbiAgICB0aGlzLmhpZGVJbmZvKCk7XG4gICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICB0aGlzLnJ1bkxheW91dCgpO1xuICAgIHRoaXMucmVuZGVyUHJpb3JpdHkoKTtcbiAgICBcbiAgfVxuXG4gIHRvZ2dsZVBhdHRlcm5zKCkge1xuICAgIHRoaXMucGF0dGVybnMgPSAhdGhpcy5wYXR0ZXJucztcbiAgICB0aGlzLnJlc2V0VmlldygpO1xuICB9XG5cbiAgdG9nZ2xlVXNlcnMoKSB7XG4gICAgdGhpcy51c2VycyA9ICF0aGlzLnVzZXJzO1xuICAgIHRoaXMucmVzZXRWaWV3KCk7XG4gIH1cbiAgXG4gIHRvZ2dsZVNhZ2FzKCkge1xuICAgIHRoaXMuc2FnYXMgPSAhdGhpcy5zYWdhcztcbiAgICB0aGlzLnJlc2V0VmlldygpO1xuICB9XG5cbiAgdG9nZ2xlR29hbHMoKSB7XG4gICAgdGhpcy5nb2FscyA9ICF0aGlzLmdvYWxzO1xuICAgIHRoaXMucmVzZXRWaWV3KCk7XG4gIH1cblxuICB0b2dnbGVBc3N1bXB0aW9ucygpIHtcbiAgICB0aGlzLmFzc3VtcHRpb25zID0gIXRoaXMuYXNzdW1wdGlvbnM7XG4gICAgdGhpcy5yZXNldFZpZXcoKTtcbiAgfVxuXG4gIHRvZ2dsZUFwcHJvYWNoZXMoKSB7XG4gICAgdGhpcy5hcHByb2FjaGVzID0gIXRoaXMuYXBwcm9hY2hlcztcbiAgICB0aGlzLnJlc2V0VmlldygpO1xuICB9XG5cbiAgdG9nZ2xlSW1wcm92ZW1lbnRzKCkge1xuICAgIHRoaXMuaW1wcm92ZW1lbnRzID0gIXRoaXMuaW1wcm92ZW1lbnRzO1xuICAgIHRoaXMucmVzZXRWaWV3KCk7XG4gIH1cblxuICB0b2dnbGVPcnBoYW5zKCkge1xuICAgIHRoaXMub3JwaGFucyA9ICF0aGlzLm9ycGhhbnM7XG4gICAgdGhpcy5yZXNldFZpZXcoKTtcbiAgfVxuXG5oaWdobGlnaHQobm9kZSl7XG4gIGNvbnN0IHsgY3kgfSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuaGlnaGxpZ2h0SW5Qcm9ncmVzcykgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cblxuICB0aGlzLmhpZ2hsaWdodEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gIGNvbnN0IGFsbEVsZXMgPSBjeS5lbGVtZW50cygpO1xuICBjb25zdCBuaG9vZCA9IHRoaXMubGFzdEhpZ2hsaWdodGVkID0gbm9kZS5jbG9zZWROZWlnaGJvcmhvb2QoKTtcbiAgY29uc3QgcHJlZGVjZXNzb3JzID0gbm9kZS5wcmVkZWNlc3NvcnMoKTtcbiAgbGV0IGhpZ2hsaWdodGVkID0gbmhvb2QudW5pb24ocHJlZGVjZXNzb3JzKTtcbiAgY29uc3Qgb3RoZXJzID0gdGhpcy5sYXN0VW5oaWdobGlnaHRlZCA9IGFsbEVsZXMubm90KGhpZ2hsaWdodGVkKTtcblxuICBjb25zdCBydW5MYXlvdXQgPSAoKSA9PiB7XG5cbiAgICAgIGNvbnN0IGxheW91dCA9IGhpZ2hsaWdodGVkLmxheW91dChcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IHRoaXMubGF5b3V0c1t0aGlzLmNoYXJ0VHlwZV0ubmFtZSxcbiAgICAgICAgICByYW5rRGlyOiAnVEInLFxuICAgICAgICAgIGZpdDogdHJ1ZSxcbiAgICAgICAgICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gICAgICAgICAgbGV2ZWxXaWR0aDogKCkgPT4geyByZXR1cm4gMTsgfSxcbiAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgICBzcHJpbmdMZW5ndGg6IDMwMCxcbiAgICAgICAgICBhbmltYXRlOiAnZW5kJyxcbiAgICAgICAgICBjZW50ZXJHcmFwaDogdHJ1ZSxcbiAgICAgICAgICBzcHJpbmdDb2VmZjogMC4wMDA4LFxuICAgICAgICAgIG1hc3M6IDIwLFxuICAgICAgICAgIGdyYXZpdHk6IC0xMCxcbiAgICAgICAgICBwdWxsOiAwLjAwMDEsXG4gICAgICAgICAgdGhldGE6IDAuMzMzLFxuICAgICAgICAgIGRyYWdDb2VmZjogMC4wMixcbiAgICAgICAgICBtb3ZlbWVudFRocmVzaG9sZDogMSxcbiAgICAgICAgICB0aW1lU3RlcDogMjAsXG4gICAgICAgICAgcmVmcmVzaDogMTAsXG4gICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICAgIG1heFNpbXVsYXRpb25UaW1lOiA0MDAwLFxuICAgICAgICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsXG4gICAgICAgICAgcmFuZG9taXplOiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByb21pc2UgPSBsYXlvdXQucHJvbWlzZU9uKCdsYXlvdXRzdG9wJyk7XG5cbiAgICAgIGxheW91dC5ydW4oKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgY29uc3QgYW5pbWF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3kuYW5pbWF0ZSh7XG4gICAgICBmaXQ6IHtcbiAgICAgICAgZWxlczogaGlnaGxpZ2h0ZWQsXG4gICAgICAgIHBhZGRpbmc6IDEwXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZHVyYXRpb246IDEwMDBcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCByZXNldENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgYWxsRWxlcy5yZW1vdmVDbGFzcygnaGlkZGVuJykucmVtb3ZlQ2xhc3MoJ2ZhZGVkJykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodGVkJyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgY29uc3Qgc2hvd090aGVyc0ZhZGVkID0gKCkgPT4ge1xuICAgIGN5LmJhdGNoKCgpID0+IHtcbiAgICAgIG90aGVycy5yZW1vdmVDbGFzcygnaGlkZGVuJykuYWRkQ2xhc3MoJ2ZhZGVkJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5idXMuZW1pdCgnaGlnaGxpZ2h0Jywgbm9kZSk7XG5cbiAgcmV0dXJuIChcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4ocmVzZXRDbGFzc2VzKVxuICAgICAgLnRoZW4ocnVuTGF5b3V0KVxuICAgICAgLnRoZW4oc2hvd090aGVyc0ZhZGVkKVxuICAgICAgLnRoZW4oYW5pbWF0ZVZpZXcpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1cy5lbWl0KCdoaWdobGlnaHRlbmQnLCBub2RlKTtcbiAgICAgIH0pXG4gICk7XG59XG5cbnVuaGlnaGxpZ2h0KCl7XG4gIGlmICghdGhpcy5oYXNIaWdobGlnaHQoKSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cblxuICBjb25zdCB7IGN5IH0gPSB0aGlzO1xuICBjb25zdCBhbGxFbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgY29uc3QgYWxsTm9kZXMgPSBjeS5ub2RlcygpO1xuXG4gIGN5LnN0b3AoKTtcbiAgYWxsTm9kZXMuc3RvcCgpO1xuXG4gIGNvbnN0IG90aGVycyA9IHRoaXMubGFzdFVuaGlnaGxpZ2h0ZWQ7XG5cbiAgdGhpcy5sYXN0SGlnaGxpZ2h0ZWQgPSB0aGlzLmxhc3RVbmhpZ2hsaWdodGVkID0gbnVsbDtcblxuICBjb25zdCBoaWRlT3RoZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIG90aGVycy5hZGRDbGFzcygnaGlkZGVuJyk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgY29uc3QgcmVzZXRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGN5LmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFsbEVsZXMucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLnJlbW92ZUNsYXNzKCdmYWRlZCcpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHRlZCcpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIGNvbnN0IGFuaW1hdGVWaWV3ID0gKCkgPT4ge1xuICAgIGN5LmFuaW1hdGUoe1xuICAgICAgZml0OiB7XG4gICAgICAgIGVsZXM6IHRoaXMuY3ksXG4gICAgICAgIHBhZGRpbmc6IDEwXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZHVyYXRpb246IDEwMDBcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBydW5MYXlvdXQgPSAoKSA9PiB7XG4gICAgdGhpcy5idXMuZW1pdCgndW5oaWdobGlnaHQnKTtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5jeS5sYXlvdXQodGhpcy5sYXlvdXRzW3RoaXMuY2hhcnRUeXBlXSk7XG4gICAgbGF5b3V0LnJ1bigpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKGhpZGVPdGhlcnMpXG4gICAgICAudGhlbihyZXNldENsYXNzZXMpXG4gICAgICAudGhlbihydW5MYXlvdXQpXG4gICAgLnRoZW4oYW5pbWF0ZVZpZXcpXG4gICk7XG59XG5cbnVwZGF0ZVNlYXJjaChxdWVyeVN0cmluZyl7XG4gIGNvbnN0IG5vcm1hbGl6ZSA9IHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgZ2V0V29yZHMgPSBzdHIgPT4gc3RyLnNwbGl0KC9cXHMrLyk7XG4gIGNvbnN0IHF1ZXJ5V29yZHMgPSBnZXRXb3Jkcyhub3JtYWxpemUocXVlcnlTdHJpbmcpKTtcblxuICBjb25zdCBhZGRXb3JkcyA9ICh3b3JkTGlzdCwgd29yZHNTdHIpID0+IHtcbiAgICBpZiAod29yZHNTdHIpIHtcbiAgICAgIHdvcmRMaXN0LnB1c2goLi4uZ2V0V29yZHMobm9ybWFsaXplKHdvcmRzU3RyKSkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBjYWNoZU5vZGVXb3JkcyA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGEoKTtcbiAgICBjb25zdCB3b3JkTGlzdCA9IFtdO1xuXG4gICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEubmFtZSk7XG4gICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEuU3lub255bSk7XG4gICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEuTm9kZVR5cGVGb3JtYXR0ZWQpO1xuXG4gICAgbm9kZS5kYXRhKCd3b3JkcycsIHdvcmRMaXN0KTtcbiAgfTtcblxuICBjb25zdCBnZXRTdHJpbmdTaW1pbGFyaXR5ID0gKHF1ZXJ5V29yZCwgbm9kZVdvcmQpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IG5vZGVXb3JkLmluZGV4T2YocXVlcnlXb3JkKTtcblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKG5vZGVXb3JkLmxlbmd0aCAtIHF1ZXJ5V29yZC5sZW5ndGgpO1xuICAgICAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5tYXgobm9kZVdvcmQubGVuZ3RoLCBxdWVyeVdvcmQubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIDEgLSAoZGlmZiAvIG1heExlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRNZXRyaWMgPSAobm9kZSwgcXVlcnlXb3JkcykgPT4ge1xuICAgIGNvbnN0IG5vZGVXb3JkcyA9IG5vZGUuZGF0YSgnd29yZHMnKTtcbiAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBub2RlV29yZCA9IG5vZGVXb3Jkc1tpXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBxdWVyeVdvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBxdWVyeVdvcmQgPSBxdWVyeVdvcmRzW2pdO1xuICAgICAgICBsZXQgc2ltaWxhcml0eSA9IGdldFN0cmluZ1NpbWlsYXJpdHkocXVlcnlXb3JkLCBub2RlV29yZCk7XG5cbiAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiBtaW5TaW1pbGFyaXR5VmFsdWUpIHtcbiAgICAgICAgICBzY29yZSArPSBzaW1pbGFyaXR5O1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xuICB9O1xuXG4gIGNvbnN0IGdldE5vZGVNZXRyaWMgPSBtZW1vaXplKG5vZGUgPT4gZ2V0TWV0cmljKG5vZGUsIHF1ZXJ5V29yZHMpLCBub2RlID0+IG5vZGUuaWQoKSk7XG5cbiAgaWYgKCF0aGlzLmNhY2hlZE5vZGVXb3Jkcykge1xuICAgIHRoaXMuY3kuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNhY2hlTm9kZVdvcmRzKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FjaGVkTm9kZVdvcmRzID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuc2VhcmNoTWF0Y2hOb2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHJldHVybiBnZXROb2RlTWV0cmljKG5vZGUpID4gbWluTWV0cmljVmFsdWU7XG4gIH0pLnNvcnQoKG5vZGVBLCBub2RlQikgPT4ge1xuICAgIHJldHVybiBnZXROb2RlTWV0cmljKG5vZGVCKSAtIGdldE5vZGVNZXRyaWMobm9kZUEpO1xuICB9KTtcblxuICB0aGlzLmJ1cy5lbWl0KCd1cGRhdGVTZWFyY2gnLCB0aGlzLnNlYXJjaE1hdGNoTm9kZXMpO1xuXG4gIHJldHVybiB0aGlzLnNlYXJjaE1hdGNoTm9kZXM7XG59XG5cbmdldFNlYXJjaE1hdGNoTm9kZXMoKXtcbiAgcmV0dXJuIHRoaXMuc2VhcmNoTWF0Y2hOb2Rlcztcbn1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbGxlcjtcbmV4cG9ydCB7IENvbnRyb2xsZXIgfTsiLCJpbXBvcnQgc3R5bGUgZnJvbSAnLi9zdHlsZSc7XG5cbmV4cG9ydCB7IHN0eWxlIH07XG5leHBvcnQgZGVmYXVsdCB7IHN0eWxlIH07XG4iLCJleHBvcnQgZGVmYXVsdCBgXG5jb3JlIHtcblx0YWN0aXZlLWJnLWNvbG9yOiByZ2IoNTIsIDU4LCA2NCk7XG5cdGFjdGl2ZS1iZy1vcGFjaXR5OiAwLjMzMztcbn1cblxuZWRnZSB7XG5cdGN1cnZlLXN0eWxlOiBzdHJhaWdodDtcblx0b3BhY2l0eTogMC4zMzM7XG5cdHdpZHRoOiA1cHg7XG5cdHotaW5kZXg6IDA7XG5cdG92ZXJsYXktb3BhY2l0eTogMDtcbiAgZXZlbnRzOiBubztcbn1cblxubm9kZSB7XG5cdHdpZHRoOiAxMDA7XG5cdGhlaWdodDogMTAwO1xuXHRmb250LXNpemU6IDk7XG5cdGZvbnQtd2VpZ2h0OiBib2xkO1xuXHRtaW4tem9vbWVkLWZvbnQtc2l6ZTogNDtcblx0bGFiZWw6IGRhdGEobmFtZSk7XG5cdHRleHQtd3JhcDogd3JhcDtcblx0dGV4dC1tYXgtd2lkdGg6IDcwO1xuXHR0ZXh0LXZhbGlnbjogY2VudGVyO1xuXHR0ZXh0LWhhbGlnbjogY2VudGVyO1xuXHR0ZXh0LWV2ZW50czogeWVzO1xuXHRjb2xvcjogIzAwMDtcblx0dGV4dC1vdXRsaW5lLXdpZHRoOiAxO1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6ICNmZmY7XG5cdHRleHQtb3V0bGluZS1vcGFjaXR5OiAxO1xuXHRvdmVybGF5LWNvbG9yOiAjZmZmO1xufVxuXG5lZGdlW2ludGVyYWN0aW9uID0gXCJjY1wiXSB7XG5cdGxpbmUtY29sb3I6ICNGQUNEMzc7XG5cdG9wYWNpdHk6IDAuNjY2O1xuXHR6LWluZGV4OiA5O1xuXHR3aWR0aDogNDtcbn1cblxubm9kZVtOb2RlVHlwZSA9IFwic2FnYVwiXSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICM5ZTc5ZGI7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIm1pc3Npb25cIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjYjUzNzM3O1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6IHdoaXRlO1xuXHRoZWlnaHQ6IDE1MDtcblx0d2lkdGg6IDE1MDtcbn1cblxubm9kZVtOb2RlVHlwZSA9IFwiYXNzdW1wdGlvblwiXSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICM4NmNiZmY7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcImdvYWxcIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjYzJlNWEwO1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6IHdoaXRlO1xufVxuXG5ub2RlW05vZGVUeXBlID0gXCJhcHByb2FjaFwiXSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNmZmY2ODY7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcImltcHJvdmVtZW50XCJdIHtcblx0YmFja2dyb3VuZC1jb2xvcjogI2ZmOWU2ZDtcblx0dGV4dC1vdXRsaW5lLWNvbG9yOiB3aGl0ZTtcbn1cblxuXG5ub2RlW05vZGVUeXBlID0gXCJwYXR0ZXJuXCJdIHtcblx0YmFja2dyb3VuZC1jb2xvcjogI0U5MUU2Mztcblx0dGV4dC1vdXRsaW5lLWNvbG9yOiB3aGl0ZTtcbn1cblxubm9kZVtOb2RlVHlwZSA9IFwidXNlclwiXSB7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbmVkZ2VbdGFyZ2V0VHlwZSA9IFwicGF0dGVyblwiXSB7XG5cdGxpbmUtY29sb3I6IHJlZDtcblx0d2lkdGg6IGRhdGEod2VpZ2h0KTtcbn1cblxubm9kZS5oaWdobGlnaHRlZCB7XG5cdG1pbi16b29tZWQtZm9udC1zaXplOiAwO1xuICB6LWluZGV4OiA5OTk5O1xufVxuXG5lZGdlLmhpZ2hsaWdodGVkIHtcblx0Y3VydmUtc3R5bGU6IHRheGk7XG5cdG9wYWNpdHk6IDAuODtcblx0d2lkdGg6IDQ7XG5cdHotaW5kZXg6IDk5OTk7XG59XG5cbi5wcmlvcml0aXNlZCB7XG5cdGhlaWdodDogZGF0YSh3ZWlnaHQpO1xuXHR3aWR0aDogZGF0YSh3ZWlnaHQpO1xufVxuXG4uZmFkZWQge1xuICBldmVudHM6IG5vO1xufVxuXG5ub2RlLmZhZGVkIHtcbiAgb3BhY2l0eTogMC4wODtcbn1cblxuZWRnZS5mYWRlZCB7XG4gIG9wYWNpdHk6IDAuMDY7XG59XG5cbi5oaWRkZW4ge1xuXHRkaXNwbGF5OiBub25lO1xufVxuXG4ub3JwaGFucy1maWx0ZXJlZCB7XG5cdGRpc3BsYXk6IG5vbmU7XG59XG5cbi5wYXR0ZXJucy1maWx0ZXJlZCB7XG5cdGRpc3BsYXk6IG5vbmU7XG59XG5cbmA7XG4iLCJleHBvcnQgY29uc3QgTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbmV4cG9ydCBjb25zdCBpc1Byb2QgPSBOT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzRGV2ID0gIWlzUHJvZDsiLCJpbXBvcnQgeyBpc1Byb2QgfSBmcm9tICcuL2Vudic7XG5pbXBvcnQgeyBoLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2FwcCc7XG5cbmlmKCAhaXNQcm9kICl7IC8vIHNldCB1cCBsaXZlcmVsb2FkIGZvciBkZXZcbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgc2NyaXB0LnNyYyA9ICdodHRwOi8vJyArIGxvY2F0aW9uLmhvc3RuYW1lICsgJzozNTcyOS9saXZlcmVsb2FkLmpzP3NuaXB2ZXI9MSc7XG5cbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICk7XG59XG5cbmNvbnN0IHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxucm9vdC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Jvb3QnKTtcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XG5cbnJlbmRlcihoKEFwcENvbXBvbmVudCksIHJvb3QpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==